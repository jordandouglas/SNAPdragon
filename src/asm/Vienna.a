!<arch>
//                                              302       `
SimPol_vRNA_interface.c/
data_structures.c/
plex_functions.c/
perturbation_fold.c/
structure_utils.c/
exterior_loops.c/
interior_loops.c/
multibranch_loops.c/
boltzmann_sampling.c/
constraints_SHAPE.c/
constraints_hard.c/
constraints_soft.c/
equilibrium_probs.c/
file_formats_msa.c/
plot_structure.c/

/0              0           0     0     644     6772      `
﻿/* 
	--------------------------------------------------------------------
	--------------------------------------------------------------------
	This file is part of SimPol.

    SimPol is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    SimPol is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with SimPol.  If not, see <http://www.gnu.org/licenses/>. 
    --------------------------------------------------------------------
    --------------------------------------------------------------------
-*/


//#include "SimPol_vRNA_interface.h"
#include "ViennaRNA/mfe.h"
#include "ViennaRNA/utils.h"
#include "ViennaRNA/plot_structure.h"
#include "ViennaRNA/structure_utils.h"
#include "ViennaRNA/gquad.h"
#include "ViennaRNA/plot_layouts.h"
#include "ViennaRNA/naview.h"
#include "ViennaRNA/eval.h"

#include <string.h>
#include <limits.h>
#include <stdlib.h>


const double vRNA_RT = 0.6156;
float vRNA_MFE_value = 0;
vrna_md_t md; // Model details
vrna_fold_compound_t* vc; // Contains information on the sequence and the DP matrices


// Initialise the ViennaRNA suite for RNA folding
void vRNA_init(const char* nascentSequence){



	// Initialise the model details
	vrna_md_defaults_gquad(1);
	set_model_details(&md);

	// Clean up
    if (vc) vrna_fold_compound_free(vc);

	// Allocate memory to fold the entire sequence (unless inserts have taken place)
	vc = vrna_fold_compound(nascentSequence, &md, 1);


	// Default all entries in the DP matrices to infinity so that we know they have not yet been set
	// Modified from the code in dp_matrices.c -> mfe_matrices_alloc_default()
	int i;
	int n, m;
	n = m = vc->length;
	int size          = ((n + 1) * (m + 2)) / 2;
 	int lin_size      = n + 2;

 	if (vc->matrices->evaluated) for (i = 0; i < size; i ++) vc->matrices->evaluated[i] = 0;
	if (vc->matrices->f5) for (i = 0; i < lin_size; i ++) vc->matrices->f5[i] = INF;
	if (vc->matrices->f3) for (i = 0; i < lin_size; i ++) vc->matrices->f3[i] = INF;
	if (vc->matrices->fc) for (i = 0; i < lin_size; i ++) vc->matrices->fc[i] = INF;
	if (vc->matrices->c) for (i = 0; i < size; i ++) vc->matrices->c[i] = INF;
	if (vc->matrices->fML) for (i = 0; i < size; i ++) vc->matrices->fML[i] = INF;
	if (vc->matrices->fM1) for (i = 0; i < size; i ++) vc->matrices->fM1[i] = INF;
	if (vc->matrices->fM2) for (i = 0; i < lin_size; i ++) vc->matrices->fM2[i] = INF;



}

// Calls the ViennaRNA suite written in C and returns the MFE structure
// External variable vRNA_MFE_value will contain the free energy
// Dynamic programming data structures in vRNA will persist between subsequent calls of this function
float vRNA_compute_MFE(char* sequence, char* structure, int length){


	// Convert the string sequence into a vrna_fold_compound_t object
	//vrna_fold_compound_t *vc = vrna_fold_compound(sequence, &md, 1);


	// Set the length and sequence of vc to the current sequence
	vc->length    = length;
  	vc->sequence  = strdup(sequence);



	//if (structureGlobal) free(structureGlobal);
	//char* structure = (char *) vrna_alloc(sizeof(char) * (length+1));


	// Compute MFE structure
	vRNA_MFE_value = (double) vrna_mfe(vc, structure) / vRNA_RT;


	//free(sequence);


	return vRNA_MFE_value;
	
}


// Calls the ViennaRNA suite written in C and returns the MFE structure
// Will not make use of any cached DP structures
float vRNA_compute_MFE_no_cache(char* sequence, char* structure, int length){




	// Allocate memory to fold the current sequence
	vrna_fold_compound_t*  vc_temp = vrna_fold_compound(sequence, &md, 1);

	// Set the length and sequence of vc to the current sequence
	vc_temp->length    = length;
  	vc_temp->sequence  = strdup(sequence);


	// Default all entries in the DP matrices to infinity so that we know they have not yet been set
	// Modified from the code in dp_matrices.c -> mfe_matrices_alloc_default()
	int i;
	int n, m;
	n = m = vc_temp->length;
	int size          = ((n + 1) * (m + 2)) / 2;
 	int lin_size      = n + 2;


 	if (vc->matrices->evaluated) for (i = 0; i < size; i ++) vc->matrices->evaluated[i] = 0;
	if (vc_temp->matrices->f5) for (i = 0; i < lin_size; i ++) vc_temp->matrices->f5[i] = INF;
	if (vc_temp->matrices->f3) for (i = 0; i < lin_size; i ++) vc_temp->matrices->f3[i] = INF;
	if (vc_temp->matrices->fc) for (i = 0; i < lin_size; i ++) vc_temp->matrices->fc[i] = INF;
	if (vc_temp->matrices->c) for (i = 0; i < size; i ++) vc_temp->matrices->c[i] = INF;
	if (vc_temp->matrices->fML) for (i = 0; i < size; i ++) vc_temp->matrices->fML[i] = INF;
	if (vc_temp->matrices->fM1) for (i = 0; i < size; i ++) vc_temp->matrices->fM1[i] = INF;
	if (vc_temp->matrices->fM2) for (i = 0; i < lin_size; i ++) vc_temp->matrices->fM2[i] = INF;


	// Compute MFE structure
	vRNA_MFE_value = (double) vrna_mfe(vc_temp, structure) / vRNA_RT;


	//free(sequence);


	// Clean up
    vrna_fold_compound_free(vc_temp);


	return vRNA_MFE_value;
	
}






// Returns coordinates to position each RNA base on a plot. Modified from code in plot_structure.c -> vrna_file_PS_rnaplot_a()
// Returns a float array XY where the first (length+1) are the X coordinates and the second (length+1) are the Y coordinates
void vRNA_get_coordinates(char* structure, float* XY, int length){


	
	//float  xmin, xmax, ymin, ymax;
	int    i;
	int    ee, gb, ge, Lg, l[3];
	float *X, *Y;


	short* pair_table_g = vrna_ptable(structure);


	ge=0;
	while ((ee = parse_gquad(structure + ge, &Lg, l)) > 0) {
		ge += ee;
		gb = ge - Lg*4 - l[0] - l[1] - l[2] + 1;

		// Add pseudo-base pair encoding gquad
		for (i=0; i < Lg; i++) {
			pair_table_g[ge-i] = gb+i;
			pair_table_g[gb+i] = ge-i;
		}
	} 


	X = (float *) vrna_alloc((length+1)*sizeof(float));
	Y = (float *) vrna_alloc((length+1)*sizeof(float));


	i = naview_xy_coordinates(pair_table_g, X, Y);

	for (i = 0; i < length; i++) {
		XY[i] = X[i];
		XY[i+length] = Y[i];
	}

	// Clean-up
	free(l);
	free(pair_table_g);
	free(X); 
	free(Y);

}



// Returns the Gibbs energy of the specified structure and sequence (equivalent to RNAeval)
float vRNA_eval(char* sequence, char* structure){


	// Allocate memory to fold the current sequence
	vrna_fold_compound_t*  vc = vrna_fold_compound(sequence, &md, 1);
	float energy = vrna_eval_structure_v(vc, structure, 0, NULL);

	// Clean up
    vrna_fold_compound_free(vc);

	return energy / vRNA_RT;
}	emptymain.c/    0           0     0     644     1145      `
﻿
/* 
	--------------------------------------------------------------------
	--------------------------------------------------------------------
	This file is part of SimPol.
    SimPol is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    SimPol is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    You should have received a copy of the GNU General Public License
    along with SimPol.  If not, see <http://www.gnu.org/licenses/>. 
    --------------------------------------------------------------------
    --------------------------------------------------------------------
-*/


// #include <stdio.h>



// This class is a placeholder for compiling libraries which do not have a main()
int main(int argc, const char* argv[])
{
	//printf( "\nNull main\n\n" );
}

dist_vars.c/    0           0     0     644     275       `
/*             Global variables for Distance-Package */

int  edit_backtrack = 0;  /* calculate aligned representation */

char *aligned_line[4];    /* containes the aligned string representations */

int  cost_matrix = 0;     /* 0 for usual costs, 1 for Shapiro's costs */


/25             0           0     0     644     26063     `
/** \file data_structures.c **/

/*
                  Data structure creation/destruction

                  This file contains everything which is necessary to
                  obtain and destroy datastructures used in the folding
                  recurrences throughout the VienneRNA paclage

                  c Ronny Lorenx

                  Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>

#include "utils.h"
#include "structure_utils.h"
#include "energy_par.h"
#include "data_structures.h"
#include "fold_vars.h"
#include "params.h"
#include "gquad.h"
#include "aln_util.h"
#include "ribo.h"
#include "constraints.h"
#include "part_func.h"
#include "cofold.h"
#include "mm.h"

#ifdef _OPENMP
#include <omp.h>
#endif

/*
#################################
# PRIVATE MACROS                #
#################################
*/

#define WITH_PTYPE          1L    /* passed to set_fold_compound() to indicate that we need to set vc->ptype */
#define WITH_PTYPE_COMPAT   2L    /* passed to set_fold_compound() to indicate that we need to set vc->ptype_compat */

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/
PRIVATE void            set_fold_compound(vrna_fold_compound_t *vc, vrna_md_t *md_p, unsigned int options, unsigned int aux);
PRIVATE void            make_pscores(vrna_fold_compound_t *vc);
PRIVATE void            add_params(vrna_fold_compound_t *vc, vrna_md_t *md_p, unsigned int options);


/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PUBLIC  void
vrna_fold_compound_free(vrna_fold_compound_t *vc){

  int s;

  if(vc){

    /* first destroy common attributes */
    vrna_mx_mfe_free(vc);
    vrna_mx_pf_free(vc);
    free(vc->iindx);
    free(vc->jindx);
    free(vc->params);
    free(vc->exp_params);
    vrna_hc_free(vc->hc);

    /* now distinguish the vc type */
    switch(vc->type){
      case VRNA_VC_TYPE_SINGLE:     free(vc->sequence);
                                    free(vc->sequence_encoding);
                                    free(vc->sequence_encoding2);
                                    free(vc->ptype);
                                    free(vc->ptype_pf_compat);
                                    vrna_sc_free(vc->sc);
                                    break;
      case VRNA_VC_TYPE_ALIGNMENT:  for(s=0;s<vc->n_seq;s++){
                                      free(vc->sequences[s]);
                                      free(vc->S[s]);
                                      free(vc->S5[s]);
                                      free(vc->S3[s]);
                                      free(vc->Ss[s]);
                                      free(vc->a2s[s]);
                                    }
                                    free(vc->sequences);
                                    free(vc->cons_seq);
                                    free(vc->S_cons);
                                    free(vc->S);
                                    free(vc->S5);
                                    free(vc->S3);
                                    free(vc->Ss);
                                    free(vc->a2s);
                                    free(vc->pscore);
                                    free(vc->pscore_pf_compat);
                                    if(vc->scs){
                                      for(s=0;s<vc->n_seq;s++)
                                        vrna_sc_free(vc->scs[s]);
                                      free(vc->scs);
                                    }
                                    break;
      default:                      /* do nothing */
                                    break;
    }

    /* free Distance Class Partitioning stuff (should be NULL if not used) */
    free(vc->reference_pt1);
    free(vc->reference_pt2);
    free(vc->referenceBPs1);
    free(vc->referenceBPs2);
    free(vc->bpdist);
    free(vc->mm1);
    free(vc->mm2);

    /* free local folding related stuff (should be NULL if not used) */
    if(vc->ptype_local){
      for (s=0; (s < vc->window_size + 5) && (s <= vc->length); s++){
        free(vc->ptype_local[s]);
      }
      free(vc->ptype_local);
    }

    if(vc->free_auxdata)
      vc->free_auxdata(vc->auxdata);

    free(vc);
  }
}


PUBLIC vrna_fold_compound_t *
vrna_fold_compound( const char *sequence,
                    vrna_md_t *md_p,
                    unsigned int options){

  int i;
  unsigned int        length, aux_options;
  vrna_fold_compound_t  *vc;
  vrna_md_t           md;

  if(sequence == NULL) return NULL;

  /* sanity check */
  length = strlen(sequence);
  if(length == 0)
    vrna_message_error("vrna_fold_compound: sequence length must be greater 0");

  vc            = vrna_alloc(sizeof(vrna_fold_compound_t));
  vc->type      = VRNA_VC_TYPE_SINGLE;
  vc->length    = length;
  vc->sequence  = strdup(sequence);
  aux_options   = 0L;


  /* get a copy of the model details */
  if(md_p)
    md = *md_p;
  else
    vrna_md_set_default(&md);

  if(options & VRNA_OPTION_WINDOW){ /* sliding window structure prediction */
    if(md.window_size <= 0)
      md.window_size = (int)vc->length;
    else if(md.window_size > (int)vc->length)
      md.window_size = (int)vc->length;

    vc->window_size = md.window_size;

    if((md.max_bp_span <= 0) || (md.max_bp_span > md.window_size))
      md.max_bp_span = md.window_size;

    set_fold_compound(vc, &md, options, aux_options);

    vc->ptype_local = vrna_alloc(sizeof(char *)*(vc->length+1));
    for (i = (int)vc->length; ( i > (int)vc->length - vc->window_size - 5) && (i >= 0); i--){
      vc->ptype_local[i] = vrna_alloc(sizeof(char)*(vc->window_size+5));
    }

    if(!(options & VRNA_OPTION_EVAL_ONLY)){
      /* add default hard constraints */
      /* vrna_hc_init(vc); */ /* no hard constraints in Lfold, yet! */

      /* add DP matrices */
      vrna_mx_add(vc, VRNA_MX_WINDOW, options);
    }
  } else { /* regular global structure prediction */

    /* set window size to entire sequence */
    md.window_size = (int)vc->length;

    aux_options |= WITH_PTYPE;

    if(options & VRNA_OPTION_PF)
      aux_options |= WITH_PTYPE_COMPAT;

    set_fold_compound(vc, &md, options, aux_options);

    if(!(options & VRNA_OPTION_EVAL_ONLY)){
      /* add default hard constraints */
      vrna_hc_init(vc);

      /* add DP matrices (if required) */
      vrna_mx_add(vc, VRNA_MX_DEFAULT, options);
    }
  }

  return vc;
}

PUBLIC vrna_fold_compound_t *
vrna_fold_compound_comparative( const char **sequences,
                                vrna_md_t *md_p,
                                unsigned int options){

  int s, n_seq, length;
  vrna_fold_compound_t *vc;
  vrna_md_t           md;
  unsigned int        aux_options;

  aux_options = 0L;
 
  if(sequences == NULL) return NULL;

  for(s=0;sequences[s];s++); /* count the sequences */

  n_seq = s;

  length = strlen(sequences[0]);
  /* sanity check */
  if(length == 0)
    vrna_message_error("vrna_fold_compound_comparative: sequence length must be greater 0");
  for(s = 0; s < n_seq; s++)
    if(strlen(sequences[s]) != length)
      vrna_message_error("vrna_fold_compound_comparative: uneqal sequence lengths in alignment");

  vc            = vrna_alloc(sizeof(vrna_fold_compound_t));
  vc->type      = VRNA_VC_TYPE_ALIGNMENT;

  vc->n_seq     = n_seq;
  vc->length    = length;
  vc->sequences = vrna_alloc(sizeof(char *) * (vc->n_seq + 1));
  for(s = 0; sequences[s]; s++)
    vc->sequences[s] = strdup(sequences[s]);

  /* get a copy of the model details */
  if(md_p)
    md = *md_p;
  else /* this fallback relies on global parameters and thus is not threadsafe */
    vrna_md_set_default(&md);


  aux_options |= WITH_PTYPE;

  if(options & VRNA_OPTION_PF)
    aux_options |= WITH_PTYPE_COMPAT;

  set_fold_compound(vc, &md, options, aux_options);

  make_pscores(vc);

  if(!(options & VRNA_OPTION_EVAL_ONLY)){
    /* add default hard constraints */
    vrna_hc_init(vc);

    /* add DP matrices (if required) */
    vrna_mx_add(vc, VRNA_MX_DEFAULT, options);
  }

  return vc;
}

PUBLIC vrna_fold_compound_t *
vrna_fold_compound_TwoD(const char *sequence,
                      const char *s1,
                      const char *s2,
                      vrna_md_t *md_p,
                      unsigned int options){

  int                 length, l, turn;
  vrna_fold_compound_t  *vc;
  vrna_md_t           md;


  if(sequence == NULL) return NULL;

  /* sanity check */
  length = strlen(sequence);
  if(length == 0)
    vrna_message_error("vrna_fold_compound_TwoD: sequence length must be greater 0");

  l = strlen(s1);
  if(l != length)
    vrna_message_error("vrna_fold_compound_TwoD: sequence and s1 differ in length");

  l = strlen(s2);
  if(l != length)
    vrna_message_error("vrna_fold_compound_TwoD: sequence and s2 differ in length");

  vc                = vrna_alloc(sizeof(vrna_fold_compound_t));
  vc->type          = VRNA_VC_TYPE_SINGLE;
  vc->length        = length;
  vc->sequence      = strdup(sequence);

  /* get a copy of the model details */
  if(md_p)
    md = *md_p;
  else /* this fallback relies on global parameters and thus is not threadsafe */
    vrna_md_set_default(&md);

  /* always make uniq ML decomposition ! */
  md.uniq_ML      = 1;
  md.compute_bpp  = 0;

  set_fold_compound(vc, &md, options, WITH_PTYPE | WITH_PTYPE_COMPAT);

  if(!(options & VRNA_OPTION_EVAL_ONLY)){
    vrna_hc_init(vc); /* add default hard constraints */

    /* add DP matrices */
    vrna_mx_add(vc, VRNA_MX_2DFOLD, options);
  }

  /* set all fields that are unique to Distance class partitioning... */
  turn  = vc->params->model_details.min_loop_size;
  vc->reference_pt1 = vrna_ptable(s1);
  vc->reference_pt2 = vrna_ptable(s2);
  vc->referenceBPs1 = vrna_refBPcnt_matrix(vc->reference_pt1, turn);
  vc->referenceBPs2 = vrna_refBPcnt_matrix(vc->reference_pt2, turn);
  vc->bpdist        = vrna_refBPdist_matrix(vc->reference_pt1, vc->reference_pt2, turn);
  /* compute maximum matching with reference structure 1 disallowed */
  vc->mm1           = maximumMatchingConstraint(vc->sequence, vc->reference_pt1);
  /* compute maximum matching with reference structure 2 disallowed */
  vc->mm2           = maximumMatchingConstraint(vc->sequence, vc->reference_pt2);

  vc->maxD1         = vc->mm1[vc->iindx[1]-length] + vc->referenceBPs1[vc->iindx[1]-length];
  vc->maxD2         = vc->mm2[vc->iindx[1]-length] + vc->referenceBPs2[vc->iindx[1]-length];

  return vc;
}

PUBLIC void
vrna_fold_compound_add_auxdata( vrna_fold_compound_t *vc,
                                void *data,
                                vrna_callback_free_auxdata *f){

  if(vc && data){

    if(vc->free_auxdata) /* free pre-existing auxdata */
      vc->free_auxdata(vc->auxdata);

    vc->auxdata       = data;
    vc->free_auxdata  = f;
  }
}

PUBLIC void
vrna_fold_compound_add_callback(vrna_fold_compound_t *vc,
                                vrna_callback_recursion_status *f){

  if(vc && f){
    vc->stat_cb       = f;
  }
}

PUBLIC int
vrna_fold_compound_prepare( vrna_fold_compound_t *vc,
                            unsigned int options){
  int ret = 1; /* success */

  if(options & VRNA_OPTION_MFE){   /* prepare for MFE computation */
    switch(vc->type){
      case VRNA_VC_TYPE_SINGLE:     if(!vc->ptype)
                                      if(!(options & VRNA_OPTION_WINDOW))
                                        vc->ptype = vrna_ptypes(vc->sequence_encoding2,
                                                                &(vc->params->model_details));
                                    break;
      case VRNA_VC_TYPE_ALIGNMENT:  break;
      default:                      break;
    }

    if(options & VRNA_OPTION_WINDOW){ /* Windowing approach, a.k.a. locally optimal */
      /*  check whether we have the correct DP matrices attached, and if there is
          enough memory allocated
      */
      if(!vc->matrices || (vc->matrices->type != VRNA_MX_WINDOW) || (vc->matrices->length < vc->length)){
        /* here we simply pass '0' as options, since we call mx_mfe_add() explicitely */
        vrna_mx_mfe_add(vc, VRNA_MX_WINDOW, options);
      }
    } else { /* default is regular MFE */
      /*  check whether we have the correct DP matrices attached, and if there is
          enough memory allocated
      */
      if(!vc->matrices || (vc->matrices->type != VRNA_MX_DEFAULT) || (vc->matrices->length < vc->length)){
        vrna_mx_mfe_add(vc, VRNA_MX_DEFAULT, options);
      }
    }
  }

  if(options & VRNA_OPTION_PF){   /* prepare for partition function computation */

    switch(vc->type){
      case VRNA_VC_TYPE_SINGLE:     /* get pre-computed Boltzmann factors if not present*/
                                    if(!vc->exp_params)
                                      vc->exp_params      = vrna_exp_params(&(vc->params->model_details));

                                    if(!vc->ptype)
                                      vc->ptype           = vrna_ptypes(vc->sequence_encoding2, &(vc->exp_params->model_details));
#ifdef VRNA_BACKWARD_COMPAT
                                    /* backward compatibility ptypes */
                                    if(!vc->ptype_pf_compat)
                                      vc->ptype_pf_compat = get_ptypes(vc->sequence_encoding2, &(vc->exp_params->model_details), 1);
#endif
                                    /* get precomputed Boltzmann factors for soft-constraints (if any) */
                                    if(vc->sc){
                                      if(!vc->sc->exp_energy_up)
                                        vrna_sc_add_up(vc, NULL, VRNA_OPTION_PF);
                                      if(!vc->sc->exp_energy_bp)
                                        vrna_sc_add_bp(vc, NULL, VRNA_OPTION_PF);
                                      if(!vc->sc->exp_energy_stack)
                                        vrna_sc_add_SHAPE_deigan(vc, NULL, 0, 0, VRNA_OPTION_PF);
                                    }

                                    break;

      case VRNA_VC_TYPE_ALIGNMENT:  /* get pre-computed Boltzmann factors if not present*/
                                    if(!vc->exp_params)
                                      vc->exp_params  = vrna_exp_params_comparative(vc->n_seq, &(vc->params->model_details));
                                    break;

      default:                      break;
    }

    /*  Add DP matrices, if not they are not present */
    if(!vc->exp_matrices || (vc->exp_matrices->type != VRNA_MX_DEFAULT) || (vc->exp_matrices->length < vc->length)){
      vrna_mx_pf_add(vc, VRNA_MX_DEFAULT, options);
    }
  }

  return ret;
}


#ifndef VRNA_DISABLE_C11_FEATURES
PUBLIC void
vrna_C11_features(void){

  __asm("nop");
}
#endif

/*
#####################################
# BEGIN OF STATIC HELPER FUNCTIONS  #
#####################################
*/

PRIVATE void
add_params( vrna_fold_compound_t *vc,
            vrna_md_t *md_p,
            unsigned int options){

  /* ALWAYS add regular energy parameters */
  vc->params = vrna_params(md_p);

  if(options & VRNA_OPTION_PF){
    vc->exp_params  = (vc->type == VRNA_VC_TYPE_SINGLE) ? \
                        vrna_exp_params(md_p) : \
                        vrna_exp_params_comparative(vc->n_seq, md_p);
  }

}

PRIVATE void
set_fold_compound(vrna_fold_compound_t *vc,
                  vrna_md_t *md_p,
                  unsigned int options,
                  unsigned int aux){


  char *sequence, **sequences;
  unsigned int        length, s;
  int                 cp;                     /* cut point for cofold */
  char                *seq, *seq2;

  sequence          = NULL;
  sequences         = NULL;
  cp                = -1;

  /* some default init values */
  vc->params        = NULL;
  vc->exp_params    = NULL;
  vc->matrices      = NULL;
  vc->exp_matrices  = NULL;
  vc->hc            = NULL;
  vc->auxdata       = NULL;
  vc->free_auxdata  = NULL;

  switch(vc->type){
    case VRNA_VC_TYPE_SINGLE:     sequence  = vc->sequence;

                                  seq2 = strdup(sequence);
                                  seq = vrna_cut_point_remove(seq2, &cp); /*  splice out the '&' if concatenated sequences and
                                                                        reset cp... this should also be safe for
                                                                        single sequences */
                                  vc->cutpoint            = cp;

                                  if((cp > 0) && (md_p->min_loop_size == TURN))
                                    md_p->min_loop_size = 0;  /* is it safe to set this here? */

                                  free(vc->sequence);
                                  vc->sequence            = seq;
                                  vc->length              = length = strlen(seq);
                                  vc->sequence_encoding   = vrna_seq_encode(seq, md_p);
                                  vc->sequence_encoding2  = vrna_seq_encode_simple(seq, md_p);
                                  if(!(options & VRNA_OPTION_EVAL_ONLY)){
                                    vc->ptype               = (aux & WITH_PTYPE) ? vrna_ptypes(vc->sequence_encoding2, md_p) : NULL;
                                    /* backward compatibility ptypes */
                                    vc->ptype_pf_compat     = (aux & WITH_PTYPE_COMPAT) ? get_ptypes(vc->sequence_encoding2, md_p, 1) : NULL;
                                  } else {
                                    vc->ptype           = NULL;
                                    vc->ptype_pf_compat = NULL;
                                  }
                                  vc->sc                  = NULL;
                                  free(seq2);
                                  break;

    case VRNA_VC_TYPE_ALIGNMENT:  sequences     = vc->sequences;

                                  vc->length    = length = vc->length;

                                  vc->cons_seq  = consensus((const char **)sequences);
                                  vc->S_cons    = vrna_seq_encode_simple(vc->cons_seq, md_p);

                                  vc->pscore    = vrna_alloc(sizeof(int)*((length*(length+1))/2+2));
                                  /* backward compatibility ptypes */
                                  vc->pscore_pf_compat = (aux & WITH_PTYPE_COMPAT) ? vrna_alloc(sizeof(int)*((length*(length+1))/2+2)) : NULL;

                                  oldAliEn = vc->oldAliEn  = md_p->oldAliEn;

                                  vc->S   = vrna_alloc((vc->n_seq+1) * sizeof(short *));
                                  vc->S5  = vrna_alloc((vc->n_seq+1) * sizeof(short *));
                                  vc->S3  = vrna_alloc((vc->n_seq+1) * sizeof(short *));
                                  vc->a2s = vrna_alloc((vc->n_seq+1) * sizeof(unsigned short *));
                                  vc->Ss  = vrna_alloc((vc->n_seq+1) * sizeof(char *));

                                  for (s = 0; s < vc->n_seq; s++) {
                                    vrna_aln_encode(vc->sequences[s],
                                                    &(vc->S[s]),
                                                    &(vc->S5[s]),
                                                    &(vc->S3[s]),
                                                    &(vc->Ss[s]),
                                                    &(vc->a2s[s]),
                                                    md_p);
                                  }
                                  vc->S5[vc->n_seq]  = NULL;
                                  vc->S3[vc->n_seq]  = NULL;
                                  vc->a2s[vc->n_seq] = NULL;
                                  vc->Ss[vc->n_seq]  = NULL;
                                  vc->S[vc->n_seq]   = NULL;

                                  vc->scs       = NULL;
                                  break;

    default:                      /* do nothing ? */
                                  break;
  }

  vc->iindx = vrna_idx_row_wise(vc->length);
  vc->jindx = vrna_idx_col_wise(vc->length);

  /* now come the energy parameters */
  add_params(vc, md_p, options);

}

PRIVATE void
make_pscores(vrna_fold_compound_t *vc){

  /* calculate co-variance bonus for each pair depending on  */
  /* compensatory/consistent mutations and incompatible seqs */
  /* should be 0 for conserved pairs, >0 for good pairs      */

#define NONE -10000 /* score for forbidden pairs */

  char *structure = NULL;
  int i,j,k,l,s, max_span, turn;
  float **dm;
  int olddm[7][7]={{0,0,0,0,0,0,0}, /* hamming distance between pairs */
                  {0,0,2,2,1,2,2} /* CG */,
                  {0,2,0,1,2,2,2} /* GC */,
                  {0,2,1,0,2,1,2} /* GU */,
                  {0,1,2,2,0,2,1} /* UG */,
                  {0,2,2,1,2,0,2} /* AU */,
                  {0,2,2,2,1,2,0} /* UA */};

  short           **S         = vc->S;
  char            **AS        = vc->sequences;
  int             n_seq       = vc->n_seq;
  vrna_md_t       *md         = (vc->params) ? &(vc->params->model_details) : &(vc->exp_params->model_details);
  int             *pscore     = vc->pscore;     /* precomputed array of pair types */             
  int             *indx       = vc->jindx;                                             
  int             *my_iindx   = vc->iindx;                                             
  int             n           = vc->length;                                            

  turn    = md->min_loop_size;

  if (md->ribo) {
    if (RibosumFile !=NULL) dm=readribosum(RibosumFile);
    else dm=get_ribosum((const char **)AS, n_seq, n);
  }
  else { /*use usual matrix*/
    dm = vrna_alloc(7*sizeof(float*));
    for (i=0; i<7;i++) {
      dm[i] = vrna_alloc(7*sizeof(float));
      for (j=0; j<7; j++)
        dm[i][j] = (float) olddm[i][j];
    }
  }

  max_span = md->max_bp_span;
  if((max_span < turn+2) || (max_span > n))
    max_span = n;
  for (i=1; i<n; i++) {
    for (j=i+1; (j<i+turn+1) && (j<=n); j++)
      pscore[indx[j]+i] = NONE;
    for (j=i+turn+1; j<=n; j++) {
      int pfreq[8]={0,0,0,0,0,0,0,0};
      double score;
      for (s=0; s<n_seq; s++) {
        int type;
        if (S[s][i]==0 && S[s][j]==0) type = 7; /* gap-gap  */
        else {
          if ((AS[s][i] == '~')||(AS[s][j] == '~')) type = 7;
          else type = md->pair[S[s][i]][S[s][j]];
        }
        pfreq[type]++;
      }
      if (pfreq[0]*2+pfreq[7]>n_seq) { pscore[indx[j]+i] = NONE; continue;}
      for (k=1,score=0; k<=6; k++) /* ignore pairtype 7 (gap-gap) */
        for (l=k; l<=6; l++)
          score += pfreq[k]*pfreq[l]*dm[k][l];
      /* counter examples score -1, gap-gap scores -0.25   */
      pscore[indx[j]+i] = md->cv_fact *
        ((UNIT*score)/n_seq - md->nc_fact*UNIT*(pfreq[0] + pfreq[7]*0.25));

      if((j - i + 1) > max_span){
        pscore[indx[j]+i] = NONE;
      }
    }
  }

  if (md->noLP) /* remove unwanted pairs */
    for (k=1; k<n-turn-1; k++)
      for (l=1; l<=2; l++) {
        int type,ntype=0,otype=0;
        i=k; j = i+turn+l;
        type = pscore[indx[j]+i];
        while ((i>=1)&&(j<=n)) {
          if ((i>1)&&(j<n)) ntype = pscore[indx[j+1]+i-1];
          if ((otype<md->cv_fact*MINPSCORE)&&(ntype<md->cv_fact*MINPSCORE))  /* too many counterexamples */
            pscore[indx[j]+i] = NONE; /* i.j can only form isolated pairs */
          otype =  type;
          type  = ntype;
          i--; j++;
        }
      }


  if (fold_constrained&&(structure!=NULL)) {
    int psij, hx, hx2, *stack, *stack2;
    stack = vrna_alloc(sizeof(int)*(n+1));
    stack2 = vrna_alloc(sizeof(int)*(n+1));

    for(hx=hx2=0, j=1; j<=n; j++) {
      switch (structure[j-1]) {
      case 'x': /* can't pair */
        for (l=1; l<j-turn; l++) pscore[indx[j]+l] = NONE;
        for (l=j+turn+1; l<=n; l++) pscore[indx[l]+j] = NONE;
        break;
      case '(':
        stack[hx++]=j;
        /* fallthrough */
      case '[':
        stack2[hx2++]=j;
        /* fallthrough */
      case '<': /* pairs upstream */
        for (l=1; l<j-turn; l++) pscore[indx[j]+l] = NONE;
        break;
      case ']':
        if (hx2<=0) {
          fprintf(stderr, "%s\n", structure);
          vrna_message_error("unbalanced brackets in constraints");
        }
        i = stack2[--hx2];
        pscore[indx[j]+i]=NONE;
        break;
      case ')':
        if (hx<=0) {
          fprintf(stderr, "%s\n", structure);
          vrna_message_error("unbalanced brackets in constraints");
        }
        i = stack[--hx];
        psij = pscore[indx[j]+i]; /* store for later */
        for (k=j; k<=n; k++)
          for (l=i; l<=j; l++)
            pscore[indx[k]+l] = NONE;
        for (l=i; l<=j; l++)
          for (k=1; k<=i; k++)
            pscore[indx[l]+k] = NONE;
        for (k=i+1; k<j; k++)
          pscore[indx[k]+i] = pscore[indx[j]+k] = NONE;
        pscore[indx[j]+i] = (psij>0) ? psij : 0;
        /* fallthrough */
      case '>': /* pairs downstream */
        for (l=j+turn+1; l<=n; l++) pscore[indx[l]+j] = NONE;
        break;
      }
    }
    if (hx!=0) {
      fprintf(stderr, "%s\n", structure);
      vrna_message_error("unbalanced brackets in constraint string");
    }
    free(stack); free(stack2);
  }
  /*free dm */
  for (i=0; i<7;i++) {
    free(dm[i]);
  }
  free(dm);

  /* copy over pscores for backward compatibility */
  if(vc->pscore_pf_compat){
    for(i = 1; i < n; i++)
      for(j = i; j <= n; j++){
        vc->pscore_pf_compat[my_iindx[i] - j] = (short)pscore[indx[j] + i];
      }
  }

}

part_func.c/    0           0     0     644     44053     `
/*
                  partiton function for RNA secondary structures

                  Ivo L Hofacker + Ronny Lorenz
                  Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <float.h>    /* #defines FLT_MAX ... */
#include <limits.h>

#include "utils.h"
#include "energy_par.h"
#include "fold_vars.h"
#include "loop_energies.h"
#include "gquad.h"
#include "constraints.h"
#include "mfe.h"
#include "part_func.h"

#ifdef _OPENMP
#include <omp.h>
#endif

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/
PUBLIC  int         st_back = 0;

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/

#ifdef  VRNA_BACKWARD_COMPAT

/* some backward compatibility stuff */
PRIVATE vrna_fold_compound_t  *backward_compat_compound = NULL;
PRIVATE int                 backward_compat           = 0;

#ifdef _OPENMP

#pragma omp threadprivate(backward_compat_compound, backward_compat)

#endif

#endif

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/
PRIVATE void  pf_circ(vrna_fold_compound_t *vc);
PRIVATE void  pf_linear(vrna_fold_compound_t *vc);
PRIVATE void  alipf_linear(vrna_fold_compound_t *vc);
PRIVATE void  wrap_alipf_circ(vrna_fold_compound_t *vc, char *structure);

#ifdef  VRNA_BACKWARD_COMPAT

PRIVATE float
wrap_pf_fold( const char *sequence,
              char *structure,
              vrna_exp_param_t *parameters,
              int calculate_bppm,
              int is_constrained,
              int is_circular);

#endif

PRIVATE double
wrap_mean_bp_distance(FLT_OR_DBL *p,
                      int length,
                      int *index,
                      int turn);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PUBLIC float
vrna_pf_fold( const char *seq,
              char *structure,
              vrna_plist_t **pl){

  float                 free_energy;
  double                mfe;
  vrna_fold_compound_t  *vc;
  vrna_md_t             md;

  vrna_md_set_default(&md);

  /* no need to backtrack MFE structure */
  md.backtrack = 0;

  if(!pl){ /* no need for pair probability computations if we do not store them somewhere */
    md.compute_bpp = 0;
  }

  vc  = vrna_fold_compound(seq, &md, 0);
  mfe = (double)vrna_pf(vc, NULL);
  vrna_exp_params_rescale(vc, &mfe);
  free_energy = vrna_pf(vc, structure);

  /* fill plist */
  if(pl){
    *pl = vrna_plist_from_probs(vc, /*cut_off:*/ 1e-6);
  }

  vrna_fold_compound_free(vc);

  return free_energy;
}

PUBLIC float
vrna_pf_circfold( const char *seq,
                  char *structure,
                  vrna_plist_t **pl){

  float                 free_energy;
  double                mfe;
  vrna_fold_compound_t  *vc;
  vrna_md_t             md;

  vrna_md_set_default(&md);
  md.circ = 1;

  /* no need to backtrack MFE structure */
  md.backtrack = 0;

  if(!pl){ /* no need for pair probability computations if we do not store them somewhere */
    md.compute_bpp = 0;
  }

  vc  = vrna_fold_compound(seq, &md, 0);
  mfe = (double)vrna_mfe(vc, NULL);
  vrna_exp_params_rescale(vc, &mfe);
  free_energy = vrna_pf(vc, structure);

  /* fill plist */
  if(pl){
    *pl = vrna_plist_from_probs(vc, /*cut_off:*/ 1e-6);
  }

  vrna_fold_compound_free(vc);

  return free_energy;
}

PUBLIC float
vrna_pf( vrna_fold_compound_t *vc,
              char *structure){

  FLT_OR_DBL        Q;
  double            free_energy;
  int               n;
  vrna_md_t         *md;
  vrna_exp_param_t  *params;
  vrna_mx_pf_t      *matrices;

  free_energy = (float)(INF/100.);

  if(vc){
    /* make sure, that we have the DP matrices */
    vrna_fold_compound_prepare(vc, VRNA_OPTION_PF);

    n         = vc->length;
    params    = vc->exp_params;
    matrices  = vc->exp_matrices;
    md        = &(params->model_details);

#ifdef _OPENMP
/* Explicitly turn off dynamic threads */
    omp_set_dynamic(0);
#endif

#ifdef SUN4
    nonstandard_arithmetic();
#else
#ifdef HP9
    fpsetfastmode(1);
#endif
#endif

    /* call user-defined recursion status callback function */
    if(vc->stat_cb)
      vc->stat_cb(VRNA_STATUS_PF_PRE, vc->auxdata);

    switch(vc->type){
      case VRNA_VC_TYPE_SINGLE:     /* do the linear pf fold and fill all matrices  */
                                    pf_linear(vc);

                                    if(md->circ)
                                      pf_circ(vc); /* do post processing step for circular RNAs */

                                    break;

      case VRNA_VC_TYPE_ALIGNMENT:  /* do the linear pf fold and fill all matrices  */
                                    alipf_linear(vc);

                                    /* calculate post processing step for circular  */
                                    /* RNAs                                         */
                                    if(md->circ)
                                      wrap_alipf_circ(vc, structure);

                                    break;

      default:                      vrna_message_warning("vrna_pf@part_func.c: Unrecognized fold compound type");
                                    return free_energy;
                                    break;
    }

    
    /* call user-defined recursion status callback function */
    if(vc->stat_cb)
      vc->stat_cb(VRNA_STATUS_PF_POST, vc->auxdata);

    /* calculate base pairing probability matrix (bppm)  */
    if(md->compute_bpp){
      vrna_pairing_probs(vc, structure);

#ifdef  VRNA_BACKWARD_COMPAT

      /*
      *  Backward compatibility:
      *  This block may be removed if deprecated functions
      *  relying on the global variable "pr" vanish from within the package!
      */
      pr = matrices->probs;
      /*
       {
        if(pr) free(pr);
        pr = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL) * ((n+1)*(n+2)/2));
        memcpy(pr, probs, sizeof(FLT_OR_DBL) * ((n+1)*(n+2)/2));
      }
      */

#endif

    }

    if (md->backtrack_type=='C')
      Q = matrices->qb[vc->iindx[1]-n];
    else if (md->backtrack_type=='M')
      Q = matrices->qm[vc->iindx[1]-n];
    else Q = (md->circ) ? matrices->qo : matrices->q[vc->iindx[1]-n];

    /* ensemble free energy in Kcal/mol              */
    if (Q<=FLT_MIN)
      fprintf(stderr, "pf_scale too large\n");

    switch(vc->type){
      case VRNA_VC_TYPE_ALIGNMENT:  free_energy = (-log(Q)-n*log(params->pf_scale))*params->kT/(1000.0 * vc->n_seq);
                                    break;

      case VRNA_VC_TYPE_SINGLE:     /* fall through */

      default:                      free_energy = (-log(Q)-n*log(params->pf_scale))*params->kT/1000.0;
                                    break;
    }

#ifdef SUN4
    standard_arithmetic();
#else
#ifdef HP9
    fpsetfastmode(0);
#endif
#endif
  }

  return free_energy;
}

PRIVATE void
pf_linear(vrna_fold_compound_t *vc){

  int n, i,j, k, ij, kl, d, ii, maxk;
  unsigned char type;

  FLT_OR_DBL  expMLstem = 0.;

  FLT_OR_DBL  temp, Qmax=0;
  FLT_OR_DBL  qbt1, *tmp, q_temp;
  FLT_OR_DBL  *qqm = NULL, *qqm1 = NULL, *qq = NULL, *qq1 = NULL;
  FLT_OR_DBL  *q, *qb, *qm, *qm1, *G, *q1k, *qln;
  FLT_OR_DBL  *scale;
  FLT_OR_DBL  *expMLbase;
  short       *S1;
  int         *my_iindx, *jindx;
  char        *ptype;

  vrna_exp_param_t  *pf_params;
  vrna_mx_pf_t      *matrices = vc->exp_matrices;

  pf_params             = vc->exp_params;
  vrna_md_t       *md = &(pf_params->model_details);
  vrna_hc_t       *hc = vc->hc;
  vrna_sc_t       *sc = vc->sc;

  double      max_real;
  int         with_gquad  = md->gquad;
  int         circular    = md->circ;
  int         turn        = md->min_loop_size;

  n         = vc->length;
  my_iindx  = vc->iindx;
  jindx     = vc->jindx;
  ptype     = vc->ptype;

  q         = matrices->q;
  qb        = matrices->qb;
  qm        = matrices->qm;
  qm1       = matrices->qm1;
  G         = matrices->G;
  q1k       = matrices->q1k;
  qln       = matrices->qln;
  scale     = matrices->scale;
  expMLbase = matrices->expMLbase;

  S1        = vc->sequence_encoding;

  int         hc_decompose;
  char        *hard_constraints = hc->matrix;
  int         *hc_up_ext        = hc->up_ext;
  int         *hc_up_ml         = hc->up_ml;

  max_real = (sizeof(FLT_OR_DBL) == sizeof(float)) ? FLT_MAX : DBL_MAX;

  /* allocate memory for helper arrays */
  qq        = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));
  qq1       = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));
  qqm       = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));
  qqm1      = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));

  /*array initialization ; qb,qm,q
    qb,qm,q (i,j) are stored as ((n+1-i)*(n-i) div 2 + n+1-j */

  if(with_gquad){
    expMLstem = exp_E_MLstem(0, -1, -1, pf_params);
    free(vc->exp_matrices->G);
    vc->exp_matrices->G = get_gquad_pf_matrix(vc->sequence_encoding2, vc->exp_matrices->scale, vc->exp_params);
    G = vc->exp_matrices->G;
  }

  for (d=0; d<=turn; d++)
    for (i=1; i<=n-d; i++) {
      j=i+d;
      ij = my_iindx[i]-j;
      if(hc_up_ext[i] > d){
        q[ij]=1.0*scale[d+1]; 

        if(sc){
          if(sc->exp_energy_up)
            q[ij] *= sc->exp_energy_up[i][d+1];
          if(sc->exp_f)
            q[ij] *= sc->exp_f(i, j, i, j, VRNA_DECOMP_EXT_UP, sc->data);
        }
      } else {
        q[ij] = 0.;
      }

      qb[ij]  = qm[ij] = 0.0;
    }

  for (i=0; i<=n; i++)
    qq[i] = qq1[i] = qqm[i] = qqm1[i] = 0;

  for (j = turn + 2; j <= n; j++) {
    for (i = j - turn - 1; i >= 1; i--) {
      /* construction of partition function of segment i,j */
      /* firstly that given i binds j : qb(i,j) */
      ij            = my_iindx[i] - j;
      type          = (unsigned char)ptype[jindx[j] + i];
      hc_decompose  = hard_constraints[jindx[j] + i];
      qbt1          = 0;
      q_temp        = 0.;

      if(type == 0)
        type = 7;

      if(hc_decompose){
        /* process hairpin loop(s) */
        qbt1 += vrna_exp_E_hp_loop(vc, i, j);
        /* process interior loop(s) */
        qbt1 += vrna_exp_E_int_loop(vc, i, j);
        /* process multibranch loop(s) */
        qbt1 += vrna_exp_E_mb_loop_fast(vc, i, j, qqm1);
      }
      qb[ij] = qbt1;

      /* construction of qqm matrix containing final stem
         contributions to multiple loop partition function
         from segment i,j */
      qqm[i] = 0.;

      if(hc_up_ml[j]){
        q_temp  =  qqm1[i] * expMLbase[1];

        if(sc){
          if(sc->exp_energy_up)
            q_temp *= sc->exp_energy_up[j][1];

          if(sc->exp_f)
            q_temp *= sc->exp_f(i, j, i, j-1, VRNA_DECOMP_ML_ML, sc->data);
        }

        qqm[i] = q_temp;

      }

      if(hc_decompose & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC){
        qbt1 = qb[ij] * exp_E_MLstem(type, ((i>1) || circular) ? S1[i-1] : -1, ((j<n) || circular) ? S1[j+1] : -1, pf_params);
        if(sc){

          if(sc->exp_f)
            qbt1 *= sc->exp_f(i, j, i, j, VRNA_DECOMP_ML_STEM, sc->data);
        }


        qqm[i] += qbt1;
      }

      if(with_gquad){
        /*include gquads into qqm*/
        qqm[i] += G[my_iindx[i]-j] * expMLstem;
      }

      if (qm1) qm1[jindx[j]+i] = qqm[i]; /* for stochastic backtracking and circfold */

      /*construction of qm matrix containing multiple loop
        partition function contributions from segment i,j */
      temp = 0.0;
      kl = my_iindx[i] - j + 1; /* ii-k=[i,k-1] */
      if(sc && sc->exp_f){
        for (k=j; k>i; k--, kl++){
          q_temp = qm[kl] * qqm[k];
          q_temp *= sc->exp_f(i, j, k-1, k, VRNA_DECOMP_ML_ML_ML, sc->data);
          temp += q_temp;
        }
      } else {
        for (k=j; k>i; k--, kl++){
          temp += qm[kl] * qqm[k];
        }
      }

      maxk  = MIN2(i+hc_up_ml[i], j);
      ii    = maxk - i; /* length of unpaired stretch */
      if(sc){
        for (k=maxk; k>i; k--, ii--){
          q_temp = expMLbase[ii] * qqm[k];
          if(sc->exp_energy_up)
            q_temp *= sc->exp_energy_up[i][ii];

          if(sc->exp_f)
            q_temp *= sc->exp_f(i, j, k, j, VRNA_DECOMP_ML_ML, sc->data);

          temp += q_temp;
        }
      } else {
        for (k=maxk; k>i; k--, ii--){
          temp += expMLbase[ii] * qqm[k];
        }
      }

      qm[ij] = (temp + qqm[i]);

      /*auxiliary matrix qq for cubic order q calculation below */
      qbt1 = 0.;

      if(hc_up_ext[j]){ /* all exterior loop parts [i, j] with exactly one stem (i, u) i < u < j */
        q_temp = qq1[i] * scale[1];

        if(sc){
          if(sc->exp_energy_up)
            q_temp *= sc->exp_energy_up[j][1];

          if(sc->exp_f)
            q_temp *= sc->exp_f(i, j, i, j-1, VRNA_DECOMP_EXT_EXT, sc->data);
        }

        qbt1 += q_temp;
      }

      if(hc_decompose & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){ /* exterior loop part with stem (i, j) */
        q_temp  = qb[ij]
                  * exp_E_ExtLoop(type, ((i>1) || circular) ? S1[i-1] : -1, ((j<n) || circular) ? S1[j+1] : -1, pf_params);
        if(sc){
          if(sc->exp_f)
            q_temp *= sc->exp_f(i, j, i, j, VRNA_DECOMP_EXT_STEM, sc->data);
        }
        qbt1 += q_temp;
      }

      if(with_gquad){
        qbt1 += G[ij];
      }

      qq[i] = qbt1;
      /*construction of partition function for segment i,j */
      temp = qq[i];

      /* the entire stretch [i,j] is unpaired */
      if(hc_up_ext[i] >= (j-i+1)){
        q_temp = 1.0 * scale[j-i+1];

        if(sc){
          if(sc->exp_energy_up)
            q_temp *= sc->exp_energy_up[i][j-i+1];

          if(sc->exp_f)
            q_temp *= sc->exp_f(i, j, i, j, VRNA_DECOMP_EXT_UP, sc->data);
        }

        temp += q_temp;
      }

      kl = my_iindx[i] - i;
      if(sc && sc->exp_f){
        for (k=i; k<j; k++, kl--){
          q_temp = q[kl] * qq[k+1];
          q_temp *= sc->exp_f(i, j, k, k+1, VRNA_DECOMP_EXT_EXT_EXT, sc->data);
          temp += q_temp;
        }
      } else {
        for (k=i; k<j; k++, kl--){
          temp += q[kl] * qq[k+1];
        }
      }

      q[ij] = temp;
      if (temp>Qmax) {
        Qmax = temp;
        if (Qmax>max_real/10.)
          fprintf(stderr, "Q close to overflow: %d %d %g\n", i,j,temp);
      }
      if (temp>=max_real) {
        PRIVATE char msg[128];
        snprintf(msg, 127, "overflow in pf_fold while calculating q[%d,%d]\n"
                     "use larger pf_scale", i,j);
        vrna_message_error(msg);
      }
    }
    tmp = qq1;  qq1 =qq;  qq =tmp;
    tmp = qqm1; qqm1=qqm; qqm=tmp;

  }

  /* prefill linear qln, q1k arrays */
  if(q1k && qln){
    for (k=1; k<=n; k++) {
      q1k[k] = q[my_iindx[1] - k];
      qln[k] = q[my_iindx[k] - n];
    }
    q1k[0] = 1.0;
    qln[n+1] = 1.0;
  }

  /* clean up */
  free(qq);
  free(qq1);
  free(qqm);
  free(qqm1);

}

/* calculate partition function for circular case */
/* NOTE: this is the postprocessing step ONLY     */
/* You have to call pf_linear first to calculate  */
/* complete circular case!!!                      */
PRIVATE void
pf_circ(vrna_fold_compound_t *vc){

  int u, p, q, k, l;
  int turn;
  int n;
  int   *my_iindx;
  int   *jindx;
  char  *ptype;
  FLT_OR_DBL  *scale;
  short       *S1;

  vrna_exp_param_t     *pf_params = vc->exp_params;
  FLT_OR_DBL    *qb, *qm, *qm1, *qm2, qo, qho, qio, qmo, qbt1;
  vrna_mx_pf_t  *matrices;

  n         = vc->length;

  matrices = vc->exp_matrices;
  qb  = matrices->qb;
  qm  = matrices->qm;
  qm1 = matrices->qm1;
  qm2 = matrices->qm2;

  my_iindx  = vc->iindx;
  jindx     = vc->jindx;

  ptype     = vc->ptype;
  scale     = matrices->scale;
  S1                = vc->sequence_encoding;


  FLT_OR_DBL  qot;
  FLT_OR_DBL  expMLclosing  = pf_params->expMLclosing;
  int         *rtype;

  turn        = pf_params->model_details.min_loop_size;
  rtype       = &(pf_params->model_details.rtype[0]);

  qo = qho = qio = qmo = 0.;

  /* construct qm2 matrix from qm1 entries  */
  for(k=1; k<n-turn-1; k++){
    qot = 0.;
    for (u=k+turn+1; u<n-turn-1; u++)
      qot += qm1[jindx[u]+k]*qm1[jindx[n]+(u+1)];
    qm2[k] = qot;
   }

  for(p = 1; p < n; p++){
    for(q = p + turn + 1; q <= n; q++){
      int type;
      /* 1. get exterior hairpin contribution  */
      qbt1 = qb[my_iindx[p]-q] * vrna_exp_E_hp_loop(vc, q, p);
      qho += qbt1;

      u = n-q + p-1;
      if (u<turn) continue;
      type = ptype[jindx[q] + p];
      if (!type) continue;
       /* cause we want to calc the exterior loops, we need the reversed pair type from now on  */
      type=rtype[type];


      /* 2. exterior interior loops, i "define" the (k,l) pair as "outer pair"  */
      /* so "outer type" is rtype[type[k,l]] and inner type is type[p,q]        */
      qot = 0.;
      for(k=q+1; k < n; k++){
        int ln1, lstart;
        ln1 = k - q - 1;
        if(ln1+p-1>MAXLOOP) break;
        lstart = ln1+p-1+n-MAXLOOP;
        if(lstart<k+turn+1) lstart = k + turn + 1;
        for(l=lstart;l <= n; l++){
          int ln2, type2;
          ln2 = (p - 1) + (n - l);

          if((ln1+ln2) > MAXLOOP) continue;

          type2 = ptype[jindx[l] + k];
          if(!type2) continue;
          qio += qb[my_iindx[p]-q] * qb[my_iindx[k]-l] * exp_E_IntLoop(ln2, ln1, rtype[type2], type, S1[l+1], S1[k-1], S1[p-1], S1[q+1], pf_params) * scale[ln1+ln2];
        }
      } /* end of kl double loop */
    }
  } /* end of pq double loop */

  /* 3. Multiloops  */
  for(k=turn+2; k<n-2*turn-3; k++)
    qmo += qm[my_iindx[1]-k] * qm2[k+1] * expMLclosing;

  /* add an additional pf of 1.0 to take the open chain into account too */
  qo = qho + qio + qmo + 1.0*scale[n];

  matrices->qo    = qo;
  matrices->qho   = qho;
  matrices->qio   = qio;
  matrices->qmo   = qmo;

}


PUBLIC int
vrna_pf_float_precision(void){

  return (sizeof(FLT_OR_DBL) == sizeof(float));
}


PRIVATE void
alipf_linear( vrna_fold_compound_t *vc){

  int         s, i,j,k, ij, jij, d, ii, *type, turn;
  FLT_OR_DBL  temp, temp2, Qmax=0.;
  FLT_OR_DBL  qbt1, *tmp;
  FLT_OR_DBL  *qqm = NULL, *qqm1 = NULL, *qq = NULL, *qq1 = NULL;
  double      kTn;
  double      max_real;

  int               n_seq             = vc->n_seq;
  int               n                 = vc->length;
  short             **S               = vc->S;                                                               
  short             **S5              = vc->S5;     /*S5[s][i] holds next base 5' of i in sequence s*/        
  short             **S3              = vc->S3;     /*Sl[s][i] holds next base 3' of i in sequence s*/        
  unsigned short    **a2s             = vc->a2s;                                                               
  vrna_exp_param_t  *pf_params        = vc->exp_params;
  vrna_mx_pf_t      *matrices         = vc->exp_matrices;
  vrna_md_t         *md               = &(pf_params->model_details);
  vrna_hc_t         *hc               = vc->hc;
  vrna_sc_t         **sc              = vc->scs;
  int               *my_iindx         = vc->iindx;
  int               *jindx            = vc->jindx;
  FLT_OR_DBL        *q                = matrices->q;
  FLT_OR_DBL        *qb               = matrices->qb;
  FLT_OR_DBL        *qm               = matrices->qm;
  FLT_OR_DBL        *qm1              = matrices->qm1;
  int               *pscore           = vc->pscore;     /* precomputed array of pair types */                  
  int               circular          = md->circ;
  FLT_OR_DBL        *scale            = matrices->scale;
  FLT_OR_DBL        *expMLbase        = matrices->expMLbase;
  char              *hard_constraints = hc->matrix;

  turn  = md->min_loop_size;
  kTn   = pf_params->kT/10.;   /* kT in cal/mol  */
  type  = (int *)vrna_alloc(sizeof(int) * n_seq);

  max_real  = (sizeof(FLT_OR_DBL) == sizeof(float)) ? FLT_MAX : DBL_MAX;

  /* allocate memory for helper arrays */
  qq        = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));
  qq1       = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));
  qqm       = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));
  qqm1      = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));


  /* array initialization ; qb,qm,q
     qb,qm,q (i,j) are stored as ((n+1-i)*(n-i) div 2 + n+1-j */

  for (d=0; d<=turn; d++)
    for (i=1; i<=n-d; i++) {
      j=i+d;
      ij = my_iindx[i]-j;
      if(hc->up_ext[i] > d){
        q[ij]=1.0*scale[d+1];
        if(sc)
          for(s = 0; s < n_seq; s++)
            if(sc[s]){
              int u = d + 1 /* a2s[s][j] - a2s[s][i] + 1 */;
              if(sc[s]->exp_energy_up)
                q[ij] *= sc[s]->exp_energy_up[a2s[s][i]][u];
            }
      }
      qb[ij]=qm[ij]=0.0;
    }

  for (i=1; i<=n; i++)
    qq[i]=qq1[i]=qqm[i]=qqm1[i]=0;

  for (j=turn+2;j<=n; j++) {
    for (i=j-turn-1; i>=1; i--) {
      int psc;
      /* construction of partition function for segment i,j */
      /* calculate pf given that i and j pair: qb(i,j)      */
      ij  = my_iindx[i] - j;
      jij = jindx[j] + i;

      for (s=0; s<n_seq; s++) {
        type[s] = md->pair[S[s][i]][S[s][j]];
        if (type[s]==0) type[s]=7;
      }

      psc   = pscore[jij];
      qbt1  = 0.;

      if(hard_constraints[jij]){
        /* process hairpin loop(s) */
        qbt1 += vrna_exp_E_hp_loop(vc, i, j);
        /* process interior loop(s) */
        qbt1 += vrna_exp_E_int_loop(vc, i, j);
        /* process multibranch loop(s) */
        qbt1 += vrna_exp_E_mb_loop_fast(vc, i, j, qqm1);

        qbt1 *= exp(psc/kTn);
      }

      qb[ij] = qbt1;

      /* construction of qqm matrix containing final stem
         contributions to multiple loop partition function
         from segment i,j */
      qqm[i] = 0.;
      if(hc->up_ml[i]){
        temp = qqm1[i] * expMLbase[1]; /* expMLbase[1]^n_seq */
        if(sc)
          for(s = 0; s < n_seq; s++){
            if(sc[s]){
              if(sc[s]->exp_energy_up)
                temp *= sc[s]->exp_energy_up[a2s[s][i]][1];
            }
          }
        qqm[i] += temp;
      }
      if(hard_constraints[jij] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC){
        for (qbt1=1, s=0; s<n_seq; s++) {
          qbt1 *= exp_E_MLstem(type[s], (i>1) || circular ? S5[s][i] : -1, (j<n) || circular ? S3[s][j] : -1, pf_params);
        }
        qqm[i] += qb[ij]*qbt1;
      }

      if(qm1)
        qm1[jij] = qqm[i]; /* for circ folding and stochBT */

      /* construction of qm matrix containing multiple loop
         partition function contributions from segment i,j */
      temp = 0.0;
      ii = my_iindx[i];  /* ii-k=[i,k-1] */
      for (k=i+1; k<=j; k++)
        temp += qm[ii-(k-1)] * qqm[k];

      for (k=i+1; k<=j; k++){
        if(hc->up_ml[i] < k - i)
          break;
        temp2 = expMLbase[k-i] * qqm[k];
        if(sc)
          for(s = 0; s < n_seq; s++){
            if(sc[s]){
              if(sc[s]->exp_energy_up)
                temp2 *= sc[s]->exp_energy_up[a2s[s][i]][a2s[s][k] - a2s[s][i]];
            }
          }
        temp += temp2;
      }
      qm[ij] = (temp + qqm[i]);

      /* auxiliary matrix qq for cubic order q calculation below */
      qbt1 = 0.;
      if((qb[ij] > 0) && (hard_constraints[jij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP)){
        qbt1 = qb[ij];
        for (s=0; s<n_seq; s++) {
          qbt1 *= exp_E_ExtLoop(type[s], (i>1) || circular ? S5[s][i] : -1, (j<n) || circular ? S3[s][j] : -1, pf_params);
        }
      }
      if(hc->up_ext[i]){
        temp = qq1[i]*scale[1];
        if(sc)
          for(s = 0; s < n_seq; s++){
            if(sc[s]){
              if(sc[s]->exp_energy_up)
                temp *= sc[s]->exp_energy_up[a2s[s][i]][1];
            }
          }
        qbt1 += temp;
      }
      qq[i] = qbt1;

      /* construction of partition function for segment i,j */
      temp = qq[i];
      if(hc->up_ext[i] >= j - i + 1){
        temp2 = 1.0 * scale[j - i + 1];
        if(sc)
          for(s = 0; s < n_seq; s++){
            if(sc[s]){
              if(sc[s]->exp_energy_up)
                temp2 *= sc[s]->exp_energy_up[a2s[s][i]][a2s[s][j] - a2s[s][i] + 1];
            }
          }
        temp += temp2;
      }

      for(k = i; k <= j - 1; k++)
        temp += q[ii - k] * qq[k + 1];

      q[ij] = temp;

      if (temp>Qmax) {
        Qmax = temp;
        if (Qmax>max_real/10.)
          fprintf(stderr, "Q close to overflow: %d %d %g\n", i,j,temp);
      }
      if (temp>=max_real) {
        PRIVATE char msg[128];
        snprintf(msg, 127, "overflow in pf_fold while calculating q[%d,%d]\n"
                     "use larger pf_scale", i,j);
        vrna_message_error(msg);
      }
    }
    tmp = qq1;  qq1 =qq;  qq =tmp;
    tmp = qqm1; qqm1=qqm; qqm=tmp;
  }

  /* clean up */
  free(type);
  free(qq);
  free(qq1);
  free(qqm);
  free(qqm1);
}

/* calculate partition function for circular case   */
/* NOTE: this is the postprocessing step ONLY        */
/* You have to call alipf_linear first to calculate  */
/* circular case!!!                                  */

PRIVATE void
wrap_alipf_circ(vrna_fold_compound_t *vc,
                char *structure){

  int u, p, q, pq, k, l, s, *type;
  FLT_OR_DBL qbt1, qot, qo, qho, qio, qmo;

  int               n_seq       = vc->n_seq;
  int               n           = vc->length;
  short             **S         = vc->S;                                                                   
  short             **S5        = vc->S5;     /*S5[s][i] holds next base 5' of i in sequence s*/            
  short             **S3        = vc->S3;     /*Sl[s][i] holds next base 3' of i in sequence s*/            
  char              **Ss        = vc->Ss;                                                                   
  unsigned short    **a2s       = vc->a2s;                                                                   
  vrna_exp_param_t  *pf_params  = vc->exp_params;
  vrna_mx_pf_t      *matrices   = vc->exp_matrices;
  vrna_md_t         *md         = &(pf_params->model_details);
  int               *my_iindx   = vc->iindx;
  int               *jindx      = vc->jindx;
  vrna_hc_t         *hc         = vc->hc;
  vrna_sc_t         **sc        = vc->scs;
  FLT_OR_DBL        *qb         = matrices->qb;
  FLT_OR_DBL        *qm         = matrices->qm;
  FLT_OR_DBL        *qm1        = matrices->qm1;
  FLT_OR_DBL        *qm2        = matrices->qm2;
  FLT_OR_DBL        *scale      = matrices->scale;
  FLT_OR_DBL        expMLclosing      = pf_params->expMLclosing;
  char              *hard_constraints = hc->matrix;
  int               *rtype            = &(md->rtype[0]);

  type  = (int *)vrna_alloc(sizeof(int) * n_seq);

  qo = qho = qio = qmo = 0.;
  /* calculate the qm2 matrix  */
  for(k=1; k<n-TURN; k++){
    qot = 0.;
    for (u=k+TURN+1; u<n-TURN-1; u++)
      qot += qm1[jindx[u]+k]*qm1[jindx[n]+(u+1)];
    qm2[k] = qot;
  }

  for(p=1;p<n;p++){
    for(q=p+TURN+1;q<=n;q++){
      u = n-q + p-1;
      if (u<TURN) continue;
      pq  = jindx[q] + p;

      if(!hard_constraints[pq]) continue;

      for(s = 0; s < n_seq; s++){
        type[s] = md->pair[S[s][p]][S[s][q]];
        if (type[s]==0) type[s]=7;
      }

      /* 1. exterior hairpin contribution  */
      /* Note, that we do not scale Hairpin Energy by u+2 but by u cause the scale  */
      /* for the closing pair was already done in the forward recursion              */
      if(hard_constraints[pq] & VRNA_CONSTRAINT_CONTEXT_HP_LOOP){
        if(hc->up_hp[q+1] > u){
          for (qbt1=1,s=0; s<n_seq; s++) {
            int rt;
            char loopseq[10];
            u   = a2s[s][n] - a2s[s][q] + a2s[s][p] - 1;
            rt  = rtype[type[s]];

            if (u<9){
              strcpy(loopseq , Ss[s] + a2s[s][q] - 1);
              strncat(loopseq, Ss[s], a2s[s][p]);
            }
            qbt1 *= exp_E_Hairpin(u, rt, S3[s][q], S5[s][p], loopseq, pf_params);
          }
          if(sc)
            for(s = 0; s < n_seq; s++){
              if(sc[s]){
                if(sc[s]->exp_energy_up){
                  qbt1 *=   ((p > 1) ? sc[s]->exp_energy_up[1][a2s[s][p]-1] : 1.)
                          * ((q < n) ? sc[s]->exp_energy_up[a2s[s][q]+1][a2s[s][n] - a2s[s][q]] : 1.);
                }
              }
            }
          qho += qb[my_iindx[p]-q] * qbt1 * scale[u];
        }
      }
      /* 2. exterior interior loop contribution*/

      if(hard_constraints[pq] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP){
        for(k=q+1; k < n; k++){
          int ln1, lstart;
          ln1 = k - q - 1;
          if(ln1 + p - 1 > MAXLOOP)
            break;
          if(hc->up_int[q+1] < ln1)
            break;

          lstart = ln1+p-1+n-MAXLOOP;
          if(lstart<k+TURN+1) lstart = k + TURN + 1;
          for(l=lstart;l <= n; l++){
            int ln2, type_2;

            ln2 = (p - 1) + (n - l);

            if(!(hard_constraints[jindx[l]+k] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP))
              continue;
            if((ln1+ln2) > MAXLOOP)
              continue;
            if(hc->up_int[l+1] < ln2)
              continue;

            FLT_OR_DBL qloop=1.;
            if (qb[my_iindx[k]-l]==0.){ qloop=0.; continue;}

            for (s=0; s<n_seq; s++){
              int ln1a = a2s[s][k] - 1 - a2s[s][q];
              int ln2a = a2s[s][n] - a2s[s][l] + a2s[s][p] - 1;
              int rt = rtype[type[s]];
              type_2 = md->pair[S[s][l]][S[s][k]];
              if (type_2 == 0) type_2 = 7;
              qloop *= exp_E_IntLoop(ln1a, ln2a, rt, type_2, S3[s][q], S5[s][p], S5[s][k], S3[s][l], pf_params);
            }
            if(sc)
              for(s = 0; s < n_seq; s++){
                int ln1a = a2s[s][k] - 1 - a2s[s][q];
                int ln2a = a2s[s][n] - a2s[s][l] + a2s[s][p] - 1;
                if(sc[s]){
                  if((ln1a+ln2a == 0) && (sc[s]->exp_energy_stack)){
                    if(S[s][p] && S[s][q] && S[s][k] && S[s][l]){ /* don't allow gaps in stack */
                      qloop *=    sc[s]->exp_energy_stack[a2s[s][p]]
                                * sc[s]->exp_energy_stack[a2s[s][q]]
                                * sc[s]->exp_energy_stack[a2s[s][k]]
                                * sc[s]->exp_energy_stack[a2s[s][l]];
                    }
                  }
                  if(sc[s]->exp_energy_up)
                    qloop *=    sc[s]->exp_energy_up[a2s[s][q] + 1][ln1a]
                              * ((l < n) ? sc[s]->exp_energy_up[a2s[s][l]+1][a2s[s][n] - a2s[s][l]] : 1.)
                              * ((p > 1) ? sc[s]->exp_energy_up[1][a2s[s][p]-1] : 1.);
                }
              }

            qio += qb[my_iindx[p]-q] * qb[my_iindx[k]-l] * qloop * scale[ln1+ln2];
          }
        } /* end of kl double loop */
      }
    }
  } /* end of pq double loop */

  /* 3. exterior multiloop contribution  */
  for(k=TURN+2; k<n-2*TURN-3; k++)
    qmo += qm[my_iindx[1]-k] * qm2[k+1] * pow(expMLclosing,n_seq);

  /* add additional pf of 1.0 to take open chain into account */
  qo = qho + qio + qmo;
  if(hc->up_ext[1] >= n)
     qo += 1.0 * scale[n];

  matrices->qo    = qo;
  matrices->qho   = qho;
  matrices->qio   = qio;
  matrices->qmo   = qmo;

  free(type);
}


/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/

#ifdef  VRNA_BACKWARD_COMPAT

PRIVATE double
wrap_mean_bp_distance(FLT_OR_DBL *p,
                      int length,
                      int *index,
                      int turn){

  int         i,j;
  double      d = 0.;

  /* compute the mean base pair distance in the thermodynamic ensemble */
  /* <d> = \sum_{a,b} p_a p_b d(S_a,S_b)
     this can be computed from the pair probs p_ij as
     <d> = \sum_{ij} p_{ij}(1-p_{ij}) */

  for (i=1; i<=length; i++)
    for (j=i+turn+1; j<=length; j++)
      d += p[index[i]-j] * (1-p[index[i]-j]);

  return 2*d;
}

PRIVATE float
wrap_pf_fold( const char *sequence,
              char *structure,
              vrna_exp_param_t *parameters,
              int calculate_bppm,
              int is_constrained,
              int is_circular){

  vrna_fold_compound_t  *vc;
  vrna_md_t           md;
  vc                  = NULL;

  /* we need vrna_exp_param_t datastructure to correctly init default hard constraints */
  if(parameters)
    md = parameters->model_details;
  else{
    set_model_details(&md); /* get global default parameters */
  }
  md.circ         = is_circular;
  md.compute_bpp  = calculate_bppm;

  vc = vrna_fold_compound(sequence, &md, VRNA_OPTION_DEFAULT);

  /* prepare exp_params and set global pf_scale */
  vc->exp_params = vrna_exp_params(&md);
  vc->exp_params->pf_scale = pf_scale;

  if(is_constrained && structure){
    unsigned int constraint_options = 0;
    constraint_options |= VRNA_CONSTRAINT_DB
                          | VRNA_CONSTRAINT_DB_PIPE
                          | VRNA_CONSTRAINT_DB_DOT
                          | VRNA_CONSTRAINT_DB_X
                          | VRNA_CONSTRAINT_DB_ANG_BRACK
                          | VRNA_CONSTRAINT_DB_RND_BRACK;

    vrna_constraints_add(vc, (const char *)structure, constraint_options);
  }

  if(backward_compat_compound && backward_compat)
    vrna_fold_compound_free(backward_compat_compound);

  backward_compat_compound  = vc;
  backward_compat           = 1;
  iindx = backward_compat_compound->iindx;

  return vrna_pf(vc, structure);
}

PUBLIC vrna_plist_t *
stackProb(double cutoff){

  if(!(backward_compat_compound && backward_compat)){
    vrna_message_error("stackProb: run pf_fold() first!");
  } else if( !backward_compat_compound->exp_matrices->probs){
    vrna_message_error("stackProb: probs==NULL!");
  } 

  return vrna_stack_prob(backward_compat_compound, cutoff);
}

PUBLIC char *
centroid( int length,
          double *dist) {

  if (pr==NULL)
    vrna_message_error("pr==NULL. You need to call pf_fold() before centroid()");

  return vrna_centroid_from_probs(length, dist, pr);
}


PUBLIC double
mean_bp_dist(int length) {

  /* compute the mean base pair distance in the thermodynamic ensemble */
  /* <d> = \sum_{a,b} p_a p_b d(S_a,S_b)
     this can be computed from the pair probs p_ij as
     <d> = \sum_{ij} p_{ij}(1-p_{ij}) */
  int i,j;
  double d=0;

  if (pr==NULL)
    vrna_message_error("pr==NULL. You need to call pf_fold() before mean_bp_dist()");

  int *my_iindx = vrna_idx_row_wise(length);

  for (i=1; i<=length; i++)
    for (j=i+TURN+1; j<=length; j++)
      d += pr[my_iindx[i]-j] * (1-pr[my_iindx[i]-j]);

  free(my_iindx);
  return 2*d;
}

/* get the free energy of a subsequence from the q[] array */
PUBLIC double
get_subseq_F( int i,
              int j){

  if(backward_compat_compound)
    if(backward_compat_compound->exp_matrices)
      if(backward_compat_compound->exp_matrices->q){
        int       *my_iindx   = backward_compat_compound->iindx;
        vrna_exp_param_t *pf_params  = backward_compat_compound->exp_params;
        FLT_OR_DBL  *q        = backward_compat_compound->exp_matrices->q;
        return ((-log(q[my_iindx[i]-j])-(j-i+1)*log(pf_params->pf_scale))*pf_params->kT/1000.0);
      }

  vrna_message_error("call pf_fold() to fill q[] array before calling get_subseq_F()");
  return 0.; /* we will never get to this point */
}



/*----------------------------------------------------------------------*/
PUBLIC double
expHairpinEnergy( int u,
                  int type,
                  short si1,
                  short sj1,
                  const char *string) {

/* compute Boltzmann weight of a hairpin loop, multiply by scale[u+2] */

  vrna_exp_param_t *pf_params = backward_compat_compound->exp_params;

  double q, kT;
  kT = pf_params->kT;   /* kT in cal/mol  */
  if(u <= 30)
    q = pf_params->exphairpin[u];
  else
    q = pf_params->exphairpin[30] * exp( -(pf_params->lxc*log( u/30.))*10./kT);
  if ((tetra_loop)&&(u==4)) {
    char tl[7]={0}, *ts;
    strncpy(tl, string, 6);
    if ((ts=strstr(pf_params->Tetraloops, tl)))
      return (pf_params->exptetra[(ts-pf_params->Tetraloops)/7]);
  }
  if ((tetra_loop)&&(u==6)) {
    char tl[9]={0}, *ts;
    strncpy(tl, string, 6);
    if ((ts=strstr(pf_params->Hexaloops, tl)))
      return  (pf_params->exphex[(ts-pf_params->Hexaloops)/9]);
  }
  if (u==3) {
    char tl[6]={0}, *ts;
    strncpy(tl, string, 5);
    if ((ts=strstr(pf_params->Triloops, tl)))
      return (pf_params->exptri[(ts-pf_params->Triloops)/6]);
    if (type>2)
      q *= pf_params->expTermAU;
  }
  else /* no mismatches for tri-loops */
    q *= pf_params->expmismatchH[type][si1][sj1];

  return q;
}

PUBLIC double
expLoopEnergy(int u1,
              int u2,
              int type,
              int type2,
              short si1,
              short sj1,
              short sp1,
              short sq1) {

/* compute Boltzmann weight of interior loop,
   multiply by scale[u1+u2+2] for scaling */
  double z=0;
  int no_close = 0;
  vrna_exp_param_t *pf_params = backward_compat_compound->exp_params;


  if ((no_closingGU) && ((type2==3)||(type2==4)||(type==2)||(type==4)))
    no_close = 1;

  if ((u1==0) && (u2==0)) /* stack */
    z = pf_params->expstack[type][type2];
  else if (no_close==0) {
    if ((u1==0)||(u2==0)) { /* bulge */
      int u;
      u = (u1==0)?u2:u1;
      z = pf_params->expbulge[u];
      if (u2+u1==1) z *= pf_params->expstack[type][type2];
      else {
        if (type>2) z *= pf_params->expTermAU;
        if (type2>2) z *= pf_params->expTermAU;
      }
    }
    else {     /* interior loop */
      if (u1+u2==2) /* size 2 is special */
        z = pf_params->expint11[type][type2][si1][sj1];
      else if ((u1==1) && (u2==2))
        z = pf_params->expint21[type][type2][si1][sq1][sj1];
      else if ((u1==2) && (u2==1))
        z = pf_params->expint21[type2][type][sq1][si1][sp1];
      else if ((u1==2) && (u2==2))
        z = pf_params->expint22[type][type2][si1][sp1][sq1][sj1];
      else if (((u1==2)&&(u2==3))||((u1==3)&&(u2==2))){ /*2-3 is special*/
        z = pf_params->expinternal[5]*
          pf_params->expmismatch23I[type][si1][sj1]*
          pf_params->expmismatch23I[type2][sq1][sp1];
        z *= pf_params->expninio[2][1];
      }
      else if ((u1==1)||(u2==1)) {  /*1-n is special*/
        z = pf_params->expinternal[u1+u2]*
          pf_params->expmismatch1nI[type][si1][sj1]*
          pf_params->expmismatch1nI[type2][sq1][sp1];
        z *= pf_params->expninio[2][abs(u1-u2)];
      }
      else {
        z = pf_params->expinternal[u1+u2]*
          pf_params->expmismatchI[type][si1][sj1]*
          pf_params->expmismatchI[type2][sq1][sp1];
        z *= pf_params->expninio[2][abs(u1-u2)];
      }
    }
  }
  return z;
}

PUBLIC void
init_pf_circ_fold(int length){
/* DO NOTHING */
}

PUBLIC void
init_pf_fold(int length){
/* DO NOTHING */
}

/**
*** Allocate memory for all matrices and other stuff
**/
PUBLIC void
free_pf_arrays(void){

  if(backward_compat_compound && backward_compat){
    vrna_fold_compound_free(backward_compat_compound);
    backward_compat_compound  = NULL;
    backward_compat           = 0;
    iindx = NULL;
  }
}

PUBLIC FLT_OR_DBL *
export_bppm(void){

  if(backward_compat_compound)
    if(backward_compat_compound->exp_matrices)
      if(backward_compat_compound->exp_matrices->probs)
        return backward_compat_compound->exp_matrices->probs;

  return NULL;
}

/*-------------------------------------------------------------------------*/
/* make arrays used for pf_fold available to other routines */
PUBLIC int
get_pf_arrays(short **S_p,
              short **S1_p,
              char **ptype_p,
              FLT_OR_DBL **qb_p,
              FLT_OR_DBL **qm_p,
              FLT_OR_DBL **q1k_p,
              FLT_OR_DBL **qln_p){

  if(backward_compat_compound){
    if(backward_compat_compound->exp_matrices)
      if(backward_compat_compound->exp_matrices->qb){
        *S_p      = backward_compat_compound->sequence_encoding2;
        *S1_p     = backward_compat_compound->sequence_encoding;
        *ptype_p  = backward_compat_compound->ptype_pf_compat;
        *qb_p     = backward_compat_compound->exp_matrices->qb;
        *qm_p     = backward_compat_compound->exp_matrices->qm;
        *q1k_p    = backward_compat_compound->exp_matrices->q1k;
        *qln_p    = backward_compat_compound->exp_matrices->qln;
        return 1;
      }
  }
  return 0;
}

/*-----------------------------------------------------------------*/
PUBLIC float
pf_fold(const char *sequence,
        char *structure){

  return wrap_pf_fold(sequence, structure, NULL, do_backtrack, fold_constrained, 0);
}

PUBLIC float
pf_circ_fold( const char *sequence,
              char *structure){

  return wrap_pf_fold(sequence, structure, NULL, do_backtrack, fold_constrained, 1);
}

PUBLIC float
pf_fold_par(const char *sequence,
            char *structure,
            vrna_exp_param_t *parameters,
            int calculate_bppm,
            int is_constrained,
            int is_circular){

  return wrap_pf_fold(sequence, structure, parameters, calculate_bppm, is_constrained, is_circular);
}

PUBLIC char *
pbacktrack(char *seq){

  int n = (int)strlen(seq);
  return vrna_pbacktrack5(backward_compat_compound, n);
}

PUBLIC char *
pbacktrack5(char *seq,
            int length){

  /* the seq parameter must no differ to the one stored globally anyway, so we just ignore it */
  return vrna_pbacktrack5(backward_compat_compound, length);
}

PUBLIC char *
pbacktrack_circ(char *seq){

  char      *structure;
  vrna_md_t *md;

  structure = NULL;

  if(backward_compat_compound){
    md = &(backward_compat_compound->exp_params->model_details);
    if(md->circ && backward_compat_compound->exp_matrices->qm2){
      structure = vrna_pbacktrack(backward_compat_compound);
    }
  }

  return structure;
}

PUBLIC void
update_pf_params(int length){

  if(backward_compat_compound && backward_compat){
    vrna_md_t         md;
    set_model_details(&md);
    vrna_exp_params_reset(backward_compat_compound, &md);

    /* compatibility with RNAup, may be removed sometime */
    pf_scale = backward_compat_compound->exp_params->pf_scale;
  }
}

PUBLIC void
update_pf_params_par( int length,
                      vrna_exp_param_t *parameters){

  if(backward_compat_compound && backward_compat){
    vrna_md_t         md;
    if(parameters){
      vrna_exp_params_subst(backward_compat_compound, parameters);
    } else {
      set_model_details(&md);
      vrna_exp_params_reset(backward_compat_compound, &md);
    }

    /* compatibility with RNAup, may be removed sometime */
    pf_scale = backward_compat_compound->exp_params->pf_scale;
  }
}

PUBLIC char *
get_centroid_struct_gquad_pr( int length,
                              double *dist){

  return vrna_centroid(backward_compat_compound, dist);
}

PUBLIC void
assign_plist_gquad_from_pr( vrna_plist_t **pl,
                            int length, /* ignored */
                            double cut_off){

  if(!backward_compat_compound){
    *pl = NULL;
  } else if( !backward_compat_compound->exp_matrices->probs){
    *pl = NULL;
  } else {
    *pl = vrna_plist_from_probs(backward_compat_compound, cut_off);
  }
}

PUBLIC double
mean_bp_distance(int length){

  if(backward_compat_compound)
    if(backward_compat_compound->exp_matrices)
      if(backward_compat_compound->exp_matrices->probs)
        return vrna_mean_bp_distance(backward_compat_compound);

  vrna_message_error("mean_bp_distance: you need to call vrna_pf_fold first");
  return 0.; /* we will never get to this point */
}

PUBLIC double
mean_bp_distance_pr(int length,
                    FLT_OR_DBL *p){

  double d=0;
  int *index = vrna_idx_row_wise((unsigned int) length);

  if (p==NULL)
    vrna_message_error("p==NULL. You need to supply a valid probability matrix for mean_bp_distance_pr()");

  d = wrap_mean_bp_distance(p, length, index, TURN);

  free(index);
  return d;
}

#endif

read_epars.c/   0           0     0     644     37210     `
/*
                  read energy parameters from a file

                      Stephan Kopp, Ivo Hofacker
                          Vienna RNA Package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <stdarg.h>
#include "utils.h"
#include "energy_const.h"
#include "energy_par.h"
#include "read_epars.h"

#define PUBLIC
#define PRIVATE   static
#define PARSET 20

#define DEF -50
#define NST 0

PRIVATE FILE *fp;

PRIVATE void  display_array(int *p, int size, int line, FILE *fp);
PRIVATE char  *get_array1(int *arr, int size);
PRIVATE void  ignore_comment(char *line);
PRIVATE void  check_symmetry(void);
PRIVATE void  update_nst(int array[NBPAIRS+1][NBPAIRS+1][5][5][5][5]);

/**
*** read a 1dimensional array from file
*** \param array  a pointer to the first element in the array
*** \param dim    the size of the array
*** \param shift  the first position the new values will be written in
**/
PRIVATE void  rd_1dim(int *array, int dim, int shift);
PRIVATE void  rd_1dim_slice(int *array, int dim, int shift, int post);
PRIVATE void  rd_2dim(int *array,
                      int dim1, int dim2,
                      int shift1, int shift2);
PRIVATE void  rd_2dim_slice(int *array,
                      int dim1, int dim2,
                      int shift1, int shift2,
                      int post1, int post2);
PRIVATE void  rd_3dim(int *array,
                      int dim1, int dim2, int dim3,
                      int shift1, int shift2, int shift3);
PRIVATE void  rd_3dim_slice(int *array,
                      int dim1, int dim2, int dim3,
                      int shift1, int shift2, int shift3,
                      int post1, int post2, int post3);
PRIVATE void  rd_4dim(int *array,
                      int dim1, int dim2, int dim3, int dim4,
                      int shift1, int shift2, int shift3, int shift4);
PRIVATE void  rd_4dim_slice(int *array,
                      int dim1, int dim2, int dim3, int dim4,
                      int shift1, int shift2, int shift3, int shift4,
                      int post1, int post2, int post3, int post4);
PRIVATE void  rd_5dim(int *array,
                      int dim1, int dim2, int dim3, int dim4, int dim5,
                      int shift1, int shift2, int shift3, int shift4, int shift5);
PRIVATE void  rd_5dim_slice(int *array,
                      int dim1, int dim2, int dim3, int dim4, int dim5,
                      int shift1, int shift2, int shift3, int shift4, int shift5,
                      int post1, int post2, int post3, int post4, int post5);
PRIVATE void  rd_6dim(int *array,
                      int dim1, int dim2, int dim3, int dim4, int dim5, int dim6,
                      int shift1, int shift2, int shift3, int shift4, int shift5, int shift6);
PRIVATE void  rd_6dim_slice(int *array,
                      int dim1, int dim2, int dim3, int dim4, int dim5, int dim6,
                      int shift1, int shift2, int shift3, int shift4, int shift5, int shift6,
                      int post1, int post2, int post3, int post4, int post5, int post6);
PRIVATE void  rd_Tetraloop37(void);
PRIVATE void  rd_Triloop37(void);
PRIVATE void  rd_Hexaloop37(void);

/*------------------------------------------------------------*/
PUBLIC void read_parameter_file(const char fname[]){
  char        *line, ident[256];
  enum parset type;
  int         r;

  if (!(fp=fopen(fname,"r"))) {
    fprintf(stderr,
            "\nread_parameter_file:\n"
            "\t\tcan't open file %s\n"
            "\t\tusing default parameters instead.\n", fname);
    return;
  }

  if (!(line = get_line(fp))) {
    fprintf(stderr," File %s is improper.\n", fname);
    fclose(fp);
    return;
  }

  if (strncmp(line,"## RNAfold parameter file v2.0",30)!=0) {
    fprintf(stderr,
            "Missing header line in file.\n"
            "May be this file has not v2.0 format.\n"
            "Use INTERRUPT-key to stop.\n");
  }
  free(line);

  while((line=get_line(fp))) {

    r = sscanf(line, "# %255s", ident);
    if (r==1) {
      type = gettype(ident);
      switch (type){
        case QUIT:    break;
        case S:       rd_2dim(&(stack37[0][0]), NBPAIRS+1, NBPAIRS+1, 1, 1);
                      break;
        case S_H:     rd_2dim(&(stackdH[0][0]), NBPAIRS+1, NBPAIRS+1, 1, 1);
                      break;
        case HP:      rd_1dim(&(hairpin37[0]), 31, 0);
                      break;
        case HP_H:    rd_1dim(&(hairpindH[0]), 31, 0);
                      break;
        case B:       rd_1dim(&(bulge37[0]), 31, 0);
                      break;
        case B_H:     rd_1dim(&(bulgedH[0]), 31, 0);
                      break;
        case IL:      rd_1dim(&(internal_loop37[0]), 31, 0);
                      break;
        case IL_H:    rd_1dim(&(internal_loopdH[0]), 31, 0);
                      break;
        case MME:     rd_3dim(&(mismatchExt37[0][0][0]),
                          NBPAIRS+1, 5, 5,
                          1, 0, 0);
                      break;
        case MME_H:   rd_3dim(&(mismatchExtdH[0][0][0]),
                          NBPAIRS+1, 5, 5,
                          1, 0, 0);
                      break;
        case MMH:     rd_3dim(&(mismatchH37[0][0][0]),
                          NBPAIRS+1, 5, 5,
                          1, 0, 0);
                      break;
        case MMH_H:   rd_3dim(&(mismatchHdH[0][0][0]),
                          NBPAIRS+1, 5, 5,
                          1, 0, 0);
                      break;
        case MMI:     rd_3dim(&(mismatchI37[0][0][0]),
                          NBPAIRS+1, 5, 5,
                          1, 0, 0);
                      break;
        case MMI_H:   rd_3dim(&(mismatchIdH[0][0][0]),
                          NBPAIRS+1, 5, 5,
                          1, 0, 0);
                      break;
        case MMI1N:   rd_3dim(&(mismatch1nI37[0][0][0]),
                          NBPAIRS+1, 5, 5,
                          1, 0, 0);
                      break;
        case MMI1N_H: rd_3dim(&(mismatch1nIdH[0][0][0]),
                          NBPAIRS+1, 5, 5,
                          1, 0, 0);
                      break;
        case MMI23:   rd_3dim(&(mismatch23I37[0][0][0]),
                          NBPAIRS+1, 5, 5,
                          1, 0, 0);
                      break;
        case MMI23_H: rd_3dim(&(mismatch23IdH[0][0][0]),
                          NBPAIRS+1, 5, 5,
                          1, 0, 0);
                      break;
        case MMM:     rd_3dim(&(mismatchM37[0][0][0]),
                          NBPAIRS+1, 5, 5,
                          1, 0, 0);
                      break;
        case MMM_H:   rd_3dim(&(mismatchMdH[0][0][0]),
                          NBPAIRS+1, 5, 5,
                          1, 0, 0);
                      break;
        case INT11:   rd_4dim(&(int11_37[0][0][0][0]),
                          NBPAIRS+1, NBPAIRS+1, 5, 5,
                          1, 1, 0, 0);
                      break;
        case INT11_H: rd_4dim(&(int11_dH[0][0][0][0]),
                          NBPAIRS+1, NBPAIRS+1, 5, 5,
                          1, 1, 0, 0);
                      break;
        case INT21:   rd_5dim(&(int21_37[0][0][0][0][0]),
                          NBPAIRS+1, NBPAIRS+1, 5, 5, 5,
                          1, 1, 0, 0, 0);
                      break;
        case INT21_H: rd_5dim(&(int21_dH[0][0][0][0][0]),
                          NBPAIRS+1, NBPAIRS+1, 5, 5, 5,
                          1, 1, 0, 0, 0);
                      break;
        case INT22:   rd_6dim_slice(&(int22_37[0][0][0][0][0][0]),
                          NBPAIRS+1, NBPAIRS+1, 5, 5, 5, 5,
                          1, 1, 1, 1, 1, 1,
                          1, 1, 0, 0, 0, 0);
                      update_nst(int22_37);
                      break;
        case INT22_H: rd_6dim_slice(&(int22_dH[0][0][0][0][0][0]),
                          NBPAIRS+1, NBPAIRS+1, 5, 5, 5, 5,
                          1, 1, 1, 1, 1, 1,
                          1, 1, 0, 0, 0, 0);
                      update_nst(int22_dH);
                      break;
        case D5:      rd_2dim(&(dangle5_37[0][0]), NBPAIRS+1, 5, 1, 0);
                      break;
        case D5_H:    rd_2dim(&(dangle5_dH[0][0]), NBPAIRS+1, 5, 1, 0);
                      break;
        case D3:      rd_2dim(&(dangle3_37[0][0]), NBPAIRS+1, 5, 1, 0);
                      break;
        case D3_H:    rd_2dim(&(dangle3_dH[0][0]), NBPAIRS+1, 5, 1, 0);
                      break;
        case ML:      {
                        int values[6];
                        rd_1dim(&values[0], 6, 0);
                        ML_BASE37     = values[0];
                        ML_BASEdH     = values[1];
                        ML_closing37  = values[2];
                        ML_closingdH  = values[3];
                        ML_intern37   = values[4];
                        ML_interndH   = values[5];
                      }
                      break;
        case NIN:     {
                        int values[3];
                        rd_1dim(&values[0], 3, 0);
                        ninio37 = values[0];
                        niniodH = values[1];
                        MAX_NINIO  = values[2];
                      }
                      break;
        case MISC:    {
                        int values[4];
                        rd_1dim(&values[0], 4, 0);
                        DuplexInit37 = values[0];
                        DuplexInitdH = values[1];
                        TerminalAU37 = values[2];
                        TerminalAUdH = values[3];
                      }
                      break;
        case TL:      rd_Tetraloop37();
                      break;
        case TRI:     rd_Triloop37();
                      break;
        case HEX:     rd_Hexaloop37();
                      break;
        default:      /* do nothing but complain */
                      fprintf(stderr,"read_epars: Unknown field identifier in `%s'\n", line);
      }
    } /* else ignore line */
    free(line);
  }
  fclose(fp);

  check_symmetry();
  return;
}

/*------------------------------------------------------------*/

PRIVATE void display_array(int *p, int size, int nl, FILE *fp)
{
  int i;

  for (i=1; i<=size; i++, p++) {
    switch(*p)
      {
      case  INF: fprintf(fp,"   INF"); break;
      case -INF: fprintf(fp,"  -INf"); break;
      case  DEF: fprintf(fp,"   DEF"); break;
      default:   fprintf(fp,"%6d",  *p); break;
      }
    if ((i%nl)==0) fprintf(fp,"\n");
  }
  if (size%nl) fprintf(fp,"\n");
  return;
}

/*------------------------------------------------------------*/

PRIVATE char *get_array1(int *arr, int size)
{
  int    i, p, pos, pp, r, last;
  char  *line, buf[16];


  i = last = 0;
  while( i<size ) {
    line = get_line(fp);
    if (!line) vrna_message_error("unexpected end of file in get_array1");
    ignore_comment(line);
    pos=0;
    while ((i<size)&&(sscanf(line+pos,"%15s%n", buf, &pp)==1)) {
      pos += pp;
      if (buf[0]=='*') {i++; continue;}
      else if (buf[0]=='x') { /* should only be used for loop parameters */
        if (i==0) vrna_message_error("can't extrapolate first value");
        p = arr[last] + (int) (0.5+ lxc37*log(((double) i)/(double)(last)));
      }
      else if (strcmp(buf,"DEF") == 0) p = DEF;
      else if (strcmp(buf,"INF") == 0) p = INF;
      else if (strcmp(buf,"NST") == 0) p = NST;
      else {
        r=sscanf(buf,"%d", &p);
        if (r!=1) {
          return line+pos;
          fprintf(stderr, "can't interpret `%s' in get_array1\n", buf);
          exit(1);
        }
        last = i;
      }
      arr[i++]=p;
    }
    free(line);
  }

  return NULL;
}

PRIVATE void rd_1dim(int *array, int dim, int shift){
  rd_1dim_slice(array, dim, shift, 0);
}

PRIVATE void rd_1dim_slice(int *array, int dim, int shift, int post){
  char *cp;
  cp   = get_array1(array+shift, dim-shift-post);

  if (cp) {
    fprintf(stderr,"\nrd_1dim: %s\n", cp);
    exit(1);
  }
  return;
}

PRIVATE void  rd_2dim(int *array, int dim1, int dim2, int shift1, int shift2){
  rd_2dim_slice(array, dim1, dim2, shift1, shift2, 0, 0);
}

PRIVATE void  rd_2dim_slice(int *array,
                      int dim1, int dim2,
                      int shift1, int shift2,
                      int post1, int post2){
  int i;
  int delta_pre   = shift1 + shift2;
  int delta_post  = post1 + post2;

  if(delta_pre + delta_post == 0){
    rd_1dim(array, dim1 * dim2, 0);
    return;
  }
  for (i=shift1; i<dim1 - post1; i++)
    rd_1dim_slice(array + (i*dim2), dim2, shift2, post2);
  return;
}

PRIVATE void  rd_3dim(int *array, int dim1, int dim2, int dim3, int shift1, int shift2, int shift3){
  rd_3dim_slice(array,
                dim1, dim2, dim3,
                shift1, shift2, shift3,
                0, 0, 0);
}

PRIVATE void  rd_3dim_slice(int *array,
                            int dim1, int dim2, int dim3,
                            int shift1, int shift2, int shift3,
                            int post1, int post2, int post3){
  int    i;
  int delta_pre   = shift1 + shift2 + shift3;
  int delta_post  = post1 + post2 + post3;

  if(delta_pre + delta_post == 0){
    rd_1dim(array, dim1 * dim2 * dim3, 0);
    return;
  }
  for (i=shift1; i<dim1 - post1; i++){
    rd_2dim_slice(array + (i * dim2 * dim3),
            dim2, dim3,
            shift2, shift3,
            post2, post3);
  }
  return;
}

PRIVATE void  rd_4dim(int *array,
                      int dim1, int dim2, int dim3, int dim4,
                      int shift1, int shift2, int shift3, int shift4){
  rd_4dim_slice(array,
                dim1, dim2, dim3, dim4,
                shift1, shift2, shift3, shift4,
                0, 0, 0, 0);
}

PRIVATE void  rd_4dim_slice(int *array,
                      int dim1, int dim2, int dim3, int dim4,
                      int shift1, int shift2, int shift3, int shift4,
                      int post1, int post2, int post3, int post4){
  int i;
  int delta_pre   = shift1 + shift2 + shift3 + shift4;
  int delta_post  = post1 + post2 + post3 + post4;

  if(delta_pre + delta_post == 0){
    rd_1dim(array, dim1 * dim2 * dim3 * dim4, 0);
    return;
  }
  for(i=shift1; i<dim1 - post1; i++){
    rd_3dim_slice(array + (i * dim2 * dim3 * dim4),
            dim2, dim3, dim4,
            shift2, shift3, shift4,
            post2, post3, post4);
  }
  return;
}

PRIVATE void  rd_5dim(int *array,
                      int dim1, int dim2, int dim3, int dim4, int dim5,
                      int shift1, int shift2, int shift3, int shift4, int shift5){
  rd_5dim_slice(array,
                dim1, dim2, dim3, dim4, dim5,
                shift1, shift2, shift3, shift4, shift5,
                0, 0, 0, 0, 0);
}

PRIVATE void  rd_5dim_slice(int *array,
                      int dim1, int dim2, int dim3, int dim4, int dim5,
                      int shift1, int shift2, int shift3, int shift4, int shift5,
                      int post1, int post2, int post3, int post4, int post5){
  int i;
  int delta_pre   = shift1 + shift2 + shift3 + shift4 + shift5;
  int delta_post  = post1 + post2 + post3 + post4 + post5;

  if(delta_pre + delta_post == 0){
    rd_1dim(array, dim1 * dim2 * dim3 * dim4 * dim5, 0);
    return;
  }
  for(i=shift1; i<dim1 - post1; i++)
    rd_4dim_slice(array + (i * dim2 * dim3 * dim4 * dim5),
            dim2, dim3, dim4, dim5,
            shift2, shift3, shift4, shift5,
            post2, post3, post4, post5);
  return;
}

/**
*** \param dim1   The size of the first dimension
*** \param shift1 The pre shift for the first dimension
**/
PRIVATE void  rd_6dim(int *array,
                      int dim1, int dim2, int dim3, int dim4, int dim5, int dim6,
                      int shift1, int shift2, int shift3, int shift4, int shift5, int shift6){
  rd_6dim_slice(array,
                dim1, dim2, dim3, dim4, dim5, dim6,
                shift1, shift2, shift3, shift4, shift5, shift6,
                0, 0, 0, 0, 0, 0);
}

PRIVATE void  rd_6dim_slice(int *array,
                      int dim1, int dim2, int dim3, int dim4, int dim5, int dim6,
                      int shift1, int shift2, int shift3, int shift4, int shift5, int shift6,
                      int post1, int post2, int post3, int post4, int post5, int post6){
  int i;
  int delta_pre   = shift1 + shift2 + shift3 + shift4 + shift5 + shift6;
  int delta_post  = post1 + post2 + post3 + post4 + post5 + post6;

  if(delta_pre + delta_post == 0){
    rd_1dim(array, dim1 * dim2 * dim3 * dim4 * dim5 * dim6, 0);
    return;
  }
  for(i=shift1; i<dim1 - post1; i++)
    rd_5dim_slice(array + (i * dim2 * dim3 * dim4 * dim5 * dim6),
            dim2, dim3, dim4, dim5, dim6,
            shift2, shift3, shift4, shift5, shift6,
            post2, post3, post4, post5, post6);
  return;
}


/*------------------------------------------------------------*/
PRIVATE void  rd_Tetraloop37(void)
{
  int    i, r;
  char   *buf;

  i=0;
  /* erase old tetraloop entries */
  memset(&Tetraloops, 0, 281);
  memset(&Tetraloop37, 0, sizeof(int)*40);
  memset(&TetraloopdH, 0, sizeof(int)*40);
  do {
    buf = get_line(fp);
    if (buf==NULL) break;
    r = sscanf(buf,"%6s %d %d", &Tetraloops[7*i], &Tetraloop37[i], &TetraloopdH[i]);
    strcat(Tetraloops, " ");
    free(buf);
    i++;
  } while((r==3)&&(i<40));
  return;
}

/*------------------------------------------------------------*/
PRIVATE void  rd_Hexaloop37(void)
{
  int    i, r;
  char   *buf;

  i=0;
  /* erase old hexaloop entries */
  memset(&Hexaloops, 0, 361);
  memset(&Hexaloop37, 0, sizeof(int)*40);
  memset(&HexaloopdH, 0, sizeof(int)*40);
  do {
    buf = get_line(fp);
    if (buf==NULL) break;
    r = sscanf(buf,"%8s %d %d", &Hexaloops[9*i], &Hexaloop37[i], &HexaloopdH[i]);
    strcat(Hexaloops, " ");
    free(buf);
    i++;
  } while((r==3)&&(i<40));
  return;
}

/*------------------------------------------------------------*/
PRIVATE void  rd_Triloop37(void)
{
  int    i, r;
  char   *buf;

  i=0;
  /* erase old hexaloop entries */
  memset(&Triloops,   0, 241);
  memset(&Triloop37,  0, sizeof(int)*40);
  memset(&TriloopdH,  0, sizeof(int)*40);
  do {
    buf = get_line(fp);
    if (buf==NULL) break;
    r = sscanf(buf,"%5s %d %d", &Triloops[6*i], &Triloop37[i], &TriloopdH[i]);
    strcat(Triloops, " ");
    free(buf);
    i++;
  } while((r==3)&&(i<40));
  return;
}

/*------------------------------------------------------------*/


PRIVATE void ignore_comment(char * line)
{
  /* excise C style comments */
  /* only one comment per line, no multiline comments */
  char *cp1, *cp2;

  if ((cp1=strstr(line, "/*"))) {
    cp2 = strstr(cp1, "*/");
    if (cp2==NULL)
      vrna_message_error("unclosed comment in parameter file");
    /* can't use strcpy for overlapping strings */
    for (cp2+=2; *cp2!='\0'; cp2++, cp1++)
      *cp1 = *cp2;
    *cp1 = '\0';
  }

  return;
}
/*------------------------------------------------------------*/

PUBLIC char *settype(enum parset s){
  switch(s){
    case        S:  return "stack";
    case      S_H:  return "stack_enthalpies";
    case       HP:  return "hairpin";
    case     HP_H:  return "hairpin_enthalpies";
    case        B:  return "bulge";
    case      B_H:  return "bulge_enthalpies";
    case       IL:  return "interior";
    case     IL_H:  return "interior_enthalpies";
    case      MME:  return "mismatch_exterior";
    case    MME_H:  return "mismatch_exterior_enthalpies";
    case      MMH:  return "mismatch_hairpin";
    case    MMH_H:  return "mismatch_hairpin_enthalpies";
    case      MMI:  return "mismatch_interior";
    case    MMI_H:  return "mismatch_interior_enthalpies";
    case    MMI1N:  return "mismatch_interior_1n";
    case  MMI1N_H:  return "mismatch_interior_1n_enthalpies";
    case    MMI23:  return "mismatch_interior_23";
    case  MMI23_H:  return "mismatch_interior_23_enthalpies";
    case      MMM:  return "mismatch_multi";
    case    MMM_H:  return "mismatch_multi_enthalpies";
    case       D5:  return "dangle5";
    case     D5_H:  return "dangle5_enthalpies";
    case       D3:  return "dangle3";
    case     D3_H:  return "dangle3_enthalpies";
    case    INT11:  return "int11";
    case  INT11_H:  return "int11_enthalpies";
    case    INT21:  return "int21";
    case  INT21_H:  return "int21_enthalpies";
    case    INT22:  return "int22";
    case  INT22_H:  return "int22_enthalpies";
    case       ML:  return "ML_params";
    case      NIN:  return "NINIO";
    case      TRI:  return "Triloops";
    case       TL:  return "Tetraloops";
    case      HEX:  return "Hexaloops";
    case     QUIT:  return "END";
    case     MISC:  return "Misc";
    default: vrna_message_error("\nThe answer is: 42\n");
  }
  return "";
}
/*------------------------------------------------------------*/

PUBLIC enum parset gettype(const char *ident){
  if      (strcmp(ident,"stack") == 0)                            return S;
  else if (strcmp(ident,"stack_enthalpies") == 0)                 return S_H;
  else if (strcmp(ident,"hairpin") == 0)                          return HP;
  else if (strcmp(ident,"hairpin_enthalpies") == 0)               return HP_H;
  else if (strcmp(ident,"bulge") == 0)                            return B;
  else if (strcmp(ident,"bulge_enthalpies") == 0)                 return B_H;
  else if (strcmp(ident,"interior") == 0)                         return IL;
  else if (strcmp(ident,"interior_enthalpies") == 0)              return IL_H;
  else if (strcmp(ident,"mismatch_exterior") == 0)                return MME;
  else if (strcmp(ident,"mismatch_exterior_enthalpies") == 0)     return MME_H;
  else if (strcmp(ident,"mismatch_hairpin") == 0)                 return MMH;
  else if (strcmp(ident,"mismatch_hairpin_enthalpies") == 0)      return MMH_H;
  else if (strcmp(ident,"mismatch_interior") == 0)                return MMI;
  else if (strcmp(ident,"mismatch_interior_enthalpies") == 0)     return MMI_H;
  else if (strcmp(ident,"mismatch_interior_1n") == 0)             return MMI1N;
  else if (strcmp(ident,"mismatch_interior_1n_enthalpies") == 0)  return MMI1N_H;
  else if (strcmp(ident,"mismatch_interior_23") == 0)             return MMI23;
  else if (strcmp(ident,"mismatch_interior_23_enthalpies") == 0)  return MMI23_H;
  else if (strcmp(ident,"mismatch_multi") == 0)                   return MMM;
  else if (strcmp(ident,"mismatch_multi_enthalpies") == 0)        return MMM_H;
  else if (strcmp(ident,"int11") == 0)                            return INT11;
  else if (strcmp(ident,"int11_enthalpies") == 0)                 return INT11_H;
  else if (strcmp(ident,"int21") == 0)                            return INT21;
  else if (strcmp(ident,"int21_enthalpies") == 0)                 return INT21_H;
  else if (strcmp(ident,"int22") == 0)                            return INT22;
  else if (strcmp(ident,"int22_enthalpies") == 0)                 return INT22_H;
  else if (strcmp(ident,"dangle5")== 0)                           return D5;
  else if (strcmp(ident,"dangle5_enthalpies")== 0)                return D5_H;
  else if (strcmp(ident,"dangle3")== 0)                           return D3;
  else if (strcmp(ident,"dangle3_enthalpies")== 0)                return D3_H;
  else if (strcmp(ident,"ML_params")== 0)                         return ML;
  else if (strcmp(ident,"NINIO") == 0)                            return NIN;
  else if (strcmp(ident,"Triloops") == 0)                         return TRI;
  else if (strcmp(ident,"Tetraloops") == 0)                       return TL;
  else if (strcmp(ident,"Hexaloops") == 0)                        return HEX;
  else if (strcmp(ident,"Misc") == 0)                             return MISC;
  else if (strcmp(ident,"END") == 0)                              return QUIT;
  else return UNKNOWN;
}

/*---------------------------------------------------------------*/

PUBLIC void write_parameter_file(const char fname[]){
  FILE *outfp;
  int c;
  char *pnames[] = {"NP", "CG", "GC", "GU", "UG", "AU", "UA", " @"};
  char bnames[] = "@ACGU";
  outfp = fopen(fname, "w");
  if (!outfp) {
    fprintf(stderr, "can't open file %s\n", fname);
    exit(1);
  }
  fprintf(outfp,"## RNAfold parameter file v2.0\n");

  fprintf(outfp,"\n# %s\n", settype(S));
  fprintf(outfp,"/*  CG    GC    GU    UG    AU    UA    @  */\n");
  for (c=1; c<NBPAIRS+1; c++)
    display_array(stack37[c]+1,NBPAIRS,NBPAIRS, outfp);

  fprintf(outfp,"\n# %s\n", settype(S_H));
  fprintf(outfp,"/*  CG    GC    GU    UG    AU    UA    @  */\n");
  for (c=1; c<NBPAIRS+1; c++)
    display_array(stackdH[c]+1,NBPAIRS,NBPAIRS, outfp);

  fprintf(outfp,"\n# %s\n", settype(MMH));
  { int i,k;
  for (k=1; k<NBPAIRS+1; k++)
    for (i=0; i<5; i++)
      display_array(mismatchH37[k][i],5,5, outfp);
  }

  fprintf(outfp,"\n# %s\n", settype(MMH_H));
  { int i,k;
  for (k=1; k<NBPAIRS+1; k++)
    for (i=0; i<5; i++)
      display_array(mismatchHdH[k][i],5,5, outfp);

  }

  fprintf(outfp,"\n# %s\n", settype(MMI));
  { int i,k;
  for (k=1; k<NBPAIRS+1; k++)
    for (i=0; i<5; i++)
      display_array(mismatchI37[k][i],5,5, outfp);
  }

  fprintf(outfp,"\n# %s\n", settype(MMI_H));
  { int i,k;
  for (k=1; k<NBPAIRS+1; k++)
    for (i=0; i<5; i++)
      display_array(mismatchIdH[k][i],5,5, outfp);
  }

  fprintf(outfp,"\n# %s\n", settype(MMI1N));
  { int i,k;
  for (k=1; k<NBPAIRS+1; k++)
    for (i=0; i<5; i++)
      display_array(mismatch1nI37[k][i],5,5, outfp);
  }

  fprintf(outfp,"\n# %s\n", settype(MMI1N_H));
  { int i,k;
  for (k=1; k<NBPAIRS+1; k++)
    for (i=0; i<5; i++)
      display_array(mismatch1nIdH[k][i],5,5, outfp);
  }

  fprintf(outfp,"\n# %s\n", settype(MMI23));
  { int i,k;
  for (k=1; k<NBPAIRS+1; k++)
    for (i=0; i<5; i++)
      display_array(mismatch23I37[k][i],5,5, outfp);
  }

  fprintf(outfp,"\n# %s\n", settype(MMI23_H));
  { int i,k;
  for (k=1; k<NBPAIRS+1; k++)
    for (i=0; i<5; i++)
      display_array(mismatch23IdH[k][i],5,5, outfp);
  }

  fprintf(outfp,"\n# %s\n", settype(MMM));
  { int i,k;
  for (k=1; k<NBPAIRS+1; k++)
    for (i=0; i<5; i++)
      display_array(mismatchM37[k][i],5,5, outfp);
  }

  fprintf(outfp,"\n# %s\n", settype(MMM_H));
  { int i,k;
  for (k=1; k<NBPAIRS+1; k++)
    for (i=0; i<5; i++)
      display_array(mismatchMdH[k][i],5,5, outfp);
  }

  fprintf(outfp,"\n# %s\n", settype(MME));
  { int i,k;
  for (k=1; k<NBPAIRS+1; k++)
    for (i=0; i<5; i++)
      display_array(mismatchExt37[k][i],5,5, outfp);
  }

  fprintf(outfp,"\n# %s\n", settype(MME_H));
  { int i,k;
  for (k=1; k<NBPAIRS+1; k++)
    for (i=0; i<5; i++)
      display_array(mismatchExtdH[k][i],5,5, outfp);
  }

  fprintf(outfp,"\n# %s\n", settype(D5));
  fprintf(outfp,"/*  @     A     C     G     U   */\n");
  for (c=1; c<NBPAIRS+1; c++)
    display_array(dangle5_37[c], 5, 5, outfp);

  fprintf(outfp,"\n# %s\n", settype(D5_H));
  fprintf(outfp,"/*  @     A     C     G     U   */\n");
  for (c=1; c<NBPAIRS+1; c++)
    display_array(dangle5_dH[c], 5, 5, outfp);

  fprintf(outfp,"\n# %s\n", settype(D3));
  fprintf(outfp,"/*  @     A     C     G     U   */\n");
  for (c=1; c<NBPAIRS+1; c++)
    display_array(dangle3_37[c], 5, 5, outfp);

  fprintf(outfp,"\n# %s\n", settype(D3_H));
  fprintf(outfp,"/*  @     A     C     G     U   */\n");
  for (c=1; c<NBPAIRS+1; c++)
    display_array(dangle3_dH[c], 5, 5, outfp);


  /* dont print "no pair" entries for interior loop arrays */
  fprintf(outfp,"\n# %s\n", settype(INT11));
  { int i,k,l;
  for (k=1; k<NBPAIRS+1; k++)
    for (l=1; l<NBPAIRS+1; l++) {
      fprintf(outfp, "/* %2s..%2s */\n", pnames[k], pnames[l]);
      for (i=0; i<5; i++)
        display_array(int11_37[k][l][i], 5, 5, outfp);
    }
  }

  fprintf(outfp,"\n# %s\n", settype(INT11_H));
  { int i,k,l;
  for (k=1; k<NBPAIRS+1; k++)
    for (l=1; l<NBPAIRS+1; l++) {
      fprintf(outfp, "/* %2s..%2s */\n", pnames[k], pnames[l]);
      for (i=0; i<5; i++)
        display_array(int11_dH[k][l][i],5,5, outfp);
    }
  }

  fprintf(outfp,"\n# %s\n", settype(INT21));
  { int p1, p2, i, j;
  for (p1=1; p1<NBPAIRS+1; p1++)
    for (p2=1; p2<NBPAIRS+1; p2++)
      for (i=0; i<5; i++) {
        fprintf(outfp, "/* %2s.%c..%2s */\n",
                pnames[p1], bnames[i], pnames[p2]);
        for (j=0; j<5; j++)
          display_array(int21_37[p1][p2][i][j],5,5, outfp);
      }
  }

  fprintf(outfp,"\n# %s\n", settype(INT21_H));
  { int p1, p2, i, j;
  for (p1=1; p1<NBPAIRS+1; p1++)
    for (p2=1; p2<NBPAIRS+1; p2++)
      for (i=0; i<5; i++) {
        fprintf(outfp, "/* %2s.%c..%2s */\n",
                pnames[p1], bnames[i], pnames[p2]);
        for (j=0; j<5; j++)
          display_array(int21_dH[p1][p2][i][j],5,5, outfp);
      }
  }

  fprintf(outfp,"\n# %s\n", settype(INT22));
  { int p1, p2, i, j, k;
  for (p1=1; p1<NBPAIRS; p1++)
    for (p2=1; p2<NBPAIRS; p2++)
      for (i=1; i<5; i++)
        for (j=1; j<5; j++) {
          fprintf(outfp, "/* %2s.%c%c..%2s */\n",
                  pnames[p1], bnames[i], bnames[j], pnames[p2]);
          for (k=1; k<5; k++)
            display_array(int22_37[p1][p2][i][j][k]+1,4,5, outfp);
        }
  }

  fprintf(outfp,"\n# %s\n", settype(INT22_H));
  { int p1, p2, i, j, k;
  for (p1=1; p1<NBPAIRS; p1++)
    for (p2=1; p2<NBPAIRS; p2++)
      for (i=1; i<5; i++)
        for (j=1; j<5; j++) {
          fprintf(outfp, "/* %2s.%c%c..%2s */\n",
                  pnames[p1], bnames[i], bnames[j], pnames[p2]);
          for (k=1; k<5; k++)
            display_array(int22_dH[p1][p2][i][j][k]+1,4,5, outfp);
        }
  }

  fprintf(outfp,"\n# %s\n", settype(HP));
  display_array(hairpin37, 31, 10, outfp);

  fprintf(outfp,"\n# %s\n", settype(HP_H));
  display_array(hairpindH, 31, 10, outfp);

  fprintf(outfp,"\n# %s\n", settype(B));
  display_array(bulge37, 31, 10, outfp);

  fprintf(outfp,"\n# %s\n", settype(B_H));
  display_array(bulgedH, 31, 10, outfp);

  fprintf(outfp,"\n# %s\n", settype(IL));
  display_array(internal_loop37, 31, 10, outfp);

  fprintf(outfp,"\n# %s\n", settype(IL_H));
  display_array(internal_loopdH, 31, 10, outfp);

  fprintf(outfp,"\n# %s\n", settype(ML));
  fprintf(outfp,"/* F = cu*n_unpaired + cc + ci*loop_degree (+TermAU) */\n");
  fprintf(outfp,"/*\t    cu\t cu_dH\t    cc\t cc_dH\t    ci\t ci_dH  */\n");
  fprintf(outfp,"\t%6d\t%6d\t%6d\t%6d\t%6d\t%6d\n", ML_BASE37, ML_BASEdH, ML_closing37, ML_closingdH, ML_intern37, ML_interndH);

  fprintf(outfp,"\n# %s\n", settype(NIN));
  fprintf(outfp,"/* Ninio = MIN(max, m*|n1-n2| */\n"
              "/*\t    m\t  m_dH     max  */\n"
              "\t%6d\t%6d\t%6d\n", ninio37, niniodH, MAX_NINIO);

  fprintf(outfp,"\n# %s\n", settype(MISC));
  fprintf(outfp,"/* all parameters are pairs of 'energy enthalpy' */\n");
  fprintf(outfp,"/*    DuplexInit     TerminalAU      LXC */\n");
  fprintf(outfp,"   %6d %6d %6d  %6d %3.6f %6d\n", DuplexInit37, DuplexInitdH, TerminalAU37, TerminalAUdH, lxc37, 0);

  fprintf(outfp,"\n# %s\n", settype(HEX));
  for (c=0; c< strlen(Hexaloops)/9; c++)
    fprintf(outfp,"\t%.8s %6d %6d\n", Hexaloops+c*9, Hexaloop37[c], HexaloopdH[c]);

  fprintf(outfp,"\n# %s\n", settype(TL));
  for (c=0; c< strlen(Tetraloops)/7; c++)
    fprintf(outfp,"\t%.6s %6d %6d\n", Tetraloops+c*7, Tetraloop37[c], TetraloopdH[c]);

  fprintf(outfp,"\n# %s\n", settype(TRI));
  for (c=0; c< strlen(Triloops)/6; c++)
    fprintf(outfp,"\t%.5s %6d %6d\n", Triloops+c*6, Triloop37[c], TriloopdH[c]);

  fprintf(outfp,"\n# %s\n", settype(QUIT));
  fclose(outfp);
}

PRIVATE void check_symmetry(void) {
  int i,j,k,l;

  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      if (stack37[i][j] != stack37[j][i])
        fprintf(stderr, "WARNING: stacking energies not symmetric\n");

  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      if (stackdH[i][j] != stackdH[j][i])
        fprintf(stderr, "WARNING: stacking enthalpies not symmetric\n");


  /* interior 1x1 loops */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      for (k=0; k<5; k++)
        for (l=0; l<5; l++)
          if (int11_37[i][j][k][l] != int11_37[j][i][l][k])
            fprintf(stderr, "WARNING: int11 energies not symmetric (%d,%d,%d,%d) (%d vs. %d)\n", i, j, k, l, int11_37[i][j][k][l], int11_37[j][i][l][k]);

  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      for (k=0; k<5; k++)
        for (l=0; l<5; l++)
          if (int11_dH[i][j][k][l] != int11_dH[j][i][l][k])
            fprintf(stderr, "WARNING: int11 enthalpies not symmetric\n");

  /* interior 2x2 loops */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      for (k=0; k<5; k++)
        for (l=0; l<5; l++) {
          int m,n;
          for (m=0; m<5; m++)
            for (n=0; n<5; n++)
              if (int22_37[i][j][k][l][m][n] != int22_37[j][i][m][n][k][l])
                fprintf(stderr, "WARNING: int22 energies not symmetric\n");
        }

  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      for (k=0; k<5; k++)
        for (l=0; l<5; l++) {
          int m,n;
          for (m=0; m<5; m++)
            for (n=0; n<5; n++)
              if (int22_dH[i][j][k][l][m][n] != int22_dH[j][i][m][n][k][l])
                fprintf(stderr, "WARNING: int22 enthalpies not symmetric: %d %d %d %d %d %d\n", i,j,k,l,m,n);
        }
}

/* update nonstandard nucleotide/basepair involved contributions for int22 */
PRIVATE void update_nst(int array[NBPAIRS+1][NBPAIRS+1][5][5][5][5]){
  int    i, j, k, l, m, n;
  int max, max2, max3, max4, max5, max6;

  /* get maxima for one nonstandard nucleotide */
  for (i=1; i<NBPAIRS; i++){
    for (j=1; j<NBPAIRS; j++){
      for (k=1; k<5; k++){
        for (l=1; l<5; l++){
          for (m=1; m<5; m++){
            max = max2 = max3 = max4 = -INF; /* max of {CGAU} */
            for(n=1;n<5;n++){
              max   = MAX2(max,   array[i][j][k][l][m][n]);
              max2  = MAX2(max2,  array[i][j][k][l][n][m]);
              max3  = MAX2(max3,  array[i][j][k][n][l][m]);
              max4  = MAX2(max4,  array[i][j][n][k][l][m]);
            }
            array[i][j][k][l][m][0] = max;
            array[i][j][k][l][0][m] = max2;
            array[i][j][k][0][l][m] = max3;
            array[i][j][0][k][l][m] = max4;
          }
        }
      }
    }
  }
  /* get maxima for two nonstandard nucleotides */
  for (i=1; i<NBPAIRS; i++){
    for (j=1; j<NBPAIRS; j++){
      for (k=1; k<5; k++){
        for (l=1; l<5; l++){
          max = max2 = max3 = max4 = max5 = max6 = -INF; /* max of {CGAU} */
          for (m=1; m<5; m++){
            max   = MAX2(max,   array[i][j][k][l][m][0]);
            max2  = MAX2(max2,  array[i][j][k][m][0][l]);
            max3  = MAX2(max3,  array[i][j][m][0][k][l]);
            max4  = MAX2(max4,  array[i][j][0][k][l][m]);
            max5  = MAX2(max5,  array[i][j][0][k][m][l]);
            max6  = MAX2(max6,  array[i][j][k][0][l][m]);
          }
          array[i][j][k][l][0][0] = max;
          array[i][j][k][0][0][l] = max2;
          array[i][j][0][0][k][l] = max3;
          array[i][j][k][0][l][0] = max6;
          array[i][j][0][k][0][l] = max5;
          array[i][j][0][k][l][0] = max4;
        }
      }
    }
  }
  /* get maxima for three nonstandard nucleotides */
  for (i=1; i<NBPAIRS; i++){
    for (j=1; j<NBPAIRS; j++){
      for (k=1; k<5; k++){
        max = max2 = max3 = max4 = -INF; /* max of {CGAU} */
        for (l=1; l<5; l++){
          /* should be arbitrary where index l resides in last 3 possible locations */
          max   = MAX2(max,   array[i][j][k][l][0][0]);
          max2  = MAX2(max2,  array[i][j][0][k][l][0]);
          max3  = MAX2(max3,  array[i][j][0][0][k][l]);
          max4  = MAX2(max4,  array[i][j][0][0][l][k]);
        }
        array[i][j][k][0][0][0] = max;
        array[i][j][0][k][0][0] = max2;
        array[i][j][0][0][k][0] = max3;
        array[i][j][0][0][0][k] = max4;
      }
    }
  }
  /* get maxima for 4 nonstandard nucleotides */
  for (i=1; i<NBPAIRS; i++){
    for (j=1; j<NBPAIRS; j++){
      max = -INF; /* max of {CGAU} */
      for (k=1; k<5; k++){
        max   = MAX2(max,   array[i][j][k][0][0][0]);
      }
      array[i][j][0][0][0][0] = max;
    }
  }

  /* now compute contributions for nonstandard base pairs ... */
  /* first, 1 nonstandard bp */
  for (i=1; i<NBPAIRS; i++){
    for (k=0; k<5; k++){
      for (l=0; l<5; l++){
        for (m=0; m<5; m++){
          for(n=0;n<5;n++){
            max = max2 = -INF;
            for(j=1;j<NBPAIRS;j++){
              max   = MAX2(max, array[i][j][k][l][m][n]);
              max2  = MAX2(max2, array[j][i][k][l][m][n]);
            }
            array[i][NBPAIRS][k][l][m][n] = max;
            array[NBPAIRS][i][k][l][m][n] = max2;
          }
        }
      }
    }
  }

  /* now 2 nst base pairs */
  for (k=0; k<5; k++){
    for (l=0; l<5; l++){
      for (m=0; m<5; m++){
        for(n=0;n<5;n++){
          max = -INF;
          for(j=1;j<NBPAIRS;j++){
            max   = MAX2(max, array[NBPAIRS][j][k][l][m][n]);
          }
          array[NBPAIRS][NBPAIRS][k][l][m][n] = max;
        }
      }
    }
  }

}
treedist.c/     0           0     0     644     16089     `
/*
		Tree edit distances for RNA secondary structures
		Walter Fontana, Ivo L Hofacker, Peter F Stadler
			     Vienna RNA Package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "edit_cost.h"
#include "dist_vars.h"
#include "utils.h"

#define PRIVATE  static
#define PUBLIC

#define MNODES	  4000	  /* Maximal number of nodes for alignment    */

PUBLIC  Tree     *make_tree(char *struc);
PUBLIC  float     tree_edit_distance(Tree *T1, Tree *T2);
PUBLIC  void      print_tree(Tree *t);
PUBLIC  void      free_tree(Tree *t);


PRIVATE void            tree_dist(int i, int j);
PRIVATE int             edit_cost(int i, int j);
PRIVATE int            *make_keyroots(Postorder_list *pl);
PRIVATE void            sort(int n, int *ra);
PRIVATE Postorder_list *make_postorder_list(char *struc);
PRIVATE int             decode(char *id);
PRIVATE int             number_of_nodes(char *struc);
PRIVATE void            encode(int type, char *label);
PRIVATE void            print_keyroots(int *keyroots);
PRIVATE void            print_postorder_list(Postorder_list *pl);
PRIVATE void            backtracking(void);
PRIVATE void            sprint_aligned_trees(void);


PRIVATE  Tree  *tree1, *tree2;
PRIVATE  int  **tdist;       /* contains distances between subtrees */
PRIVATE  int  **fdist;       /* contains distances between forests */
PRIVATE  int  *alignment[2]; /* contains numeric information on the alignment:
				alignment[0][p], aligment[1][p] are aligned postions.
				INDELs have one 0.
				alignment[0][0] contains the length of the alignment. */

/*---------------------------------------------------------------------------*/

PUBLIC float tree_edit_distance(Tree *T1, Tree *T2)
{
   int i1,j1,i,j, dist;
   int n1, n2;

   if (cost_matrix==0) EditCost = &UsualCost;
   else EditCost = &ShapiroCost;

   n1 = T1->postorder_list[0].sons;
   n2 = T2->postorder_list[0].sons;

   tdist = (int **) vrna_alloc(sizeof(int *) * (n1+1));
   fdist = (int **) vrna_alloc(sizeof(int *) * (n1+1));
   for (i=0; i<=n1; i++) {
      tdist[i] = (int *) vrna_alloc(sizeof(int) * (n2+1));
      fdist[i] = (int *) vrna_alloc(sizeof(int) * (n2+1));
   }

   tree1 = T1;  tree2 = T2;

   for (i1 = 1; i1 <= T1->keyroots[0]; i1++) {
      i = T1->keyroots[i1];
      for (j1 = 1; j1 <= T2->keyroots[0]; j1++) {
	 j = T2->keyroots[j1];

	 tree_dist(i,j);
      }
   }

   if (edit_backtrack) {

      if ((n1>MNODES)||(n2>MNODES)) vrna_message_error("tree too large for alignment");

      alignment[0] = (int *) vrna_alloc((n1+1)*sizeof(int));
      alignment[1] = (int *) vrna_alloc((n2+1)*sizeof(int));

      backtracking();
      sprint_aligned_trees();
      free(alignment[0]);
      free(alignment[1]);
   }
   dist = tdist[n1][n2];
   for (i=0; i<=n1; i++) {
      free(tdist[i]);
      free(fdist[i]);
   }
   free(tdist);
   free(fdist);

   return (float) dist;
}

/*---------------------------------------------------------------------------*/

PRIVATE void tree_dist(int i, int j)
{
   int li,lj,i1,j1,i1_1,j1_1,li1_1,lj1_1,f1,f2,f3,f;
   int cost, lleaf_i1, lleaf_j1;

   fdist[0][0] = 0;

   li = tree1->postorder_list[i].leftmostleaf;
   lj = tree2->postorder_list[j].leftmostleaf;

   for (i1 = li; i1 <= i; i1++) {
      i1_1 = (li == i1 ? 0 : i1-1);
      fdist[i1][0] = fdist[i1_1][0] + edit_cost(i1, 0);
   }

   for (j1 = lj; j1 <= j; j1++) {
      j1_1 = (lj == j1 ? 0 : j1-1);
      fdist[0][j1] = fdist[0][j1_1] + edit_cost(0, j1);
   }

   for (i1 = li; i1 <= i; i1++) {

      lleaf_i1 = tree1->postorder_list[i1].leftmostleaf;
      li1_1 = (li > lleaf_i1-1 ? 0 : lleaf_i1-1);
      i1_1 = (i1 == li ? 0: i1-1);
      cost = edit_cost(i1, 0);

      for (j1 = lj; j1 <= j; j1++) {

	 lleaf_j1 = tree2->postorder_list[j1].leftmostleaf;
	 j1_1 = (j1 == lj ? 0: j1-1);

	 f1 = fdist[i1_1][j1] + cost;
	 f2 = fdist[i1][j1_1] + edit_cost(0, j1);

	 f = f1 < f2 ? f1 : f2;

	 if (lleaf_i1 == li && lleaf_j1 == lj)   {

	    f3 = fdist[i1_1][j1_1] + edit_cost(i1, j1);

	    fdist[i1][j1] = f3 < f ? f3 : f;

	    tdist[i1][j1] = fdist[i1][j1];   /* store in array permanently */
	 }
	 else {
	    lj1_1 = (lj > lleaf_j1-1 ? 0 : lleaf_j1-1);

	    f3 = fdist[li1_1][lj1_1] + tdist[i1][j1];

	    fdist[i1][j1] = f3 < f ? f3 : f;
	 }
      }
   }
}

/*---------------------------------------------------------------------------*/

PRIVATE int edit_cost(int i, int j)
{
   int  c, diff, cd, min, a, b;

   c = (*EditCost)[tree1->postorder_list[i].type][tree2->postorder_list[j].type];

   diff = abs((a=tree1->postorder_list[i].weight) - (b=tree2->postorder_list[j].weight));

   min = (a < b ? a: b);
   if (min == a) cd = (*EditCost)[0][tree2->postorder_list[j].type];
   else          cd = (*EditCost)[0][tree1->postorder_list[i].type];

   return (c * min + cd * diff);

}

/*---------------------------------------------------------------------------*/

PUBLIC Tree *make_tree(char *struc)
{
   Tree *tree;

   tree = (Tree *) vrna_alloc(sizeof(Tree));

   tree->postorder_list = make_postorder_list(struc);
   tree->keyroots       = make_keyroots(tree->postorder_list);

   return (tree);
}


/*---------------------------------------------------------------------------*/

PRIVATE int  *make_keyroots(Postorder_list *pl)
{
   int   i, k, keys;
   int  *keyroots;

   keyroots = (int *) vrna_alloc(sizeof(int)*(pl[0].sons+1));
   keys      = 0;

   for (i = 1; i <= pl[0].sons; i++) {
      if (!pl[i].sons) {

	 /* leaf */

	 k = pl[0].sons;
	 while (pl[k].leftmostleaf != i) k--;
	 keyroots[++keys] = k;
      }
   }

   sort(keys, keyroots);
   keyroots[0] = keys;

   return (keyroots);
}

/*---------------------------------------------------------------------------*/

PRIVATE void sort(int n, int *ra)       /* heap sort,  indices are 1..n !!! */
{
   int l,j,ir,i;
   int rra;

   if (n == 1) return;

   l = (n >> 1)+1;
   ir = n;
   for (;;) {
      if (l > 1)
	 rra = ra[--l];
      else {
	 rra = ra[ir];
	 ra[ir] = ra[1];
	 if (--ir == 1) {
	    ra[1] = rra;
	    return;
	 }
      }
      i = l;
      j = l << 1;
      while (j <= ir) {
	 if (j < ir && ra[j] < ra[j+1]) ++j;
	 if (rra < ra[j]) {
	    ra[i] = ra[j];
	    j += (i = j);
	 }
	 else j = ir+1;
      }
      ra[i] = rra;
   }
}

/*---------------------------------------------------------------------------*/

PRIVATE Postorder_list *make_postorder_list(char *struc)

     /*
       Convention for structure representation "struc":
       Nodes are one pair of matching parentheses, with the type and possibly
       a weight of the node immediately preceding the closing parentheses.

       Types:

       U....unpaired
       P....paired
       H....hairpin loop
       B....bulge loop
       I....internal loop
       M....multiloop
       S....stack
       R....virtual root

       Example:

       .((..(((...)))..((..)))). in usual notation becomes:

       full tree:
       ((U)(((U)(U)((((U)(U)(U)P)P)P)(U)(U)(((U)(U)P)P)P)P)(U)R)
       HIT:
       ((U1)((U2)((U3)P3)(U2)((U2)P2)P2)(U1)R)
       Shapiro:
       (((((H)S)((H)S)M)S)R)

       */
{
   int  paren, i, l, order, local_order, w, sons, count;
   int  n_nodes, p;
   char id[100];
   Postorder_list *pl;
   int  match_pos[MNODES], match_order[MNODES];


   n_nodes = number_of_nodes(struc);
   if (n_nodes>MNODES) vrna_message_error("structure too long in make_postorder_list");
   pl = (Postorder_list *) vrna_alloc(sizeof(Postorder_list)*(n_nodes+1));
   pl[0].sons = n_nodes;

   paren = 1;
   match_pos[paren]   = 0;
   match_order[paren] = 0;

   i     = 1;
   l     = 0;
   order = 0;

   while (paren) {
      switch (struc[i]) {
       case '(':
	 match_pos[++paren] = i;
	 match_order[paren] = order;
	 break;
       case ')':
	 order++;
	 id[l] = '\0';
	 l = 0;
	 while (isalpha((int) id[l])) l++;
	 if (id[l]) sscanf(id+l, "%d", &w);
	 else  w = 1;
	 id[l] = '\0';
	 pl[order].type         = decode(id);
	 pl[order].weight       = w;
	 pl[order].leftmostleaf = match_order[paren]+1;

	 sons = count = 0;
	 local_order  = match_order[paren];
	 for (p = match_pos[paren]+1; p < i; p++) {
	    if (struc[p] == '(') count++;
	    else if (struc[p] == ')') {
	       local_order++;
	       if (count == 1) {
		  sons++;
		  pl[local_order].father = order;
	       }
	       count--;
	    }
	 }

	 pl[order].sons         = sons;
	 paren--;
	 l = 0;
	 break;
       default:
	 id[l++] = struc[i];
	 break;
      }
      i++;
   }

   return (pl);
}

/*---------------------------------------------------------------------------*/

PRIVATE int decode(char *id)
{
   int   n, quit, i;
   char  label[100], *code;

   n = 0;

   quit = 0;
   code = coding;

   while (!quit) {
      for (i = 0; code[i] != sep; i++) {
	 if (code[i] == '\0') {
	    quit = 1;
	    break;
	 }
	 label[i] = code[i];
      }
      label[i] = '\0';
      if (strcmp(id, label) == 0) return (n);
      code += (i+1);
      n++;
   }

   fprintf(stderr,"Syntax error: node identifier \"%s\" not found "
		  "in coding string \"%s\"\n", id, coding);
   fprintf(stderr, "Exiting...");
   exit(0);
}

/*---------------------------------------------------------------------------*/

PRIVATE void encode(int type, char label[])
{
   int   i, l;

   l = 0;
   for (i = 0; i < type; i++) {
      while (coding[l] != sep && coding[l]) l++;
      l++;
   }

   for (i = 0; coding[l+i] != sep; i++) {
      if (coding[l+i] == '\0') break;
      label[i] = coding[l+i];
   }
   label[i] = '\0';
}

/*---------------------------------------------------------------------------*/

PRIVATE int number_of_nodes(char *struc)
{
   int  l, c, i;

   l = strlen(struc);
   for (c = 0, i = 0; i < l; i++) if (struc[i] == ')') c++;
   return (c);
}

/*---------------------------------------------------------------------------*/

PRIVATE void print_keyroots(int *keyroots)
{
   int i;

   printf("--->  key roots  <---\n\n");

   printf("entries: %d\n", keyroots[0]);
   printf("{");
   for (i = 1; i <= keyroots[0]; i++) printf(" %d", keyroots[i]);
   printf(" }\n\n");
}

/*---------------------------------------------------------------------------*/

PRIVATE void print_postorder_list(Postorder_list *pl)
{
   register int i;
   char     label[100];

   printf("--->  postorder list  <---\n\n");

   for (i = 1; i <= pl[0].sons; i++) {
      printf("    postorder: %3d\n", i);
      *label = '\0';
      encode(pl[i].type, label);
      printf("         type: %3d (%s)\n", pl[i].type, label);
      printf("       weight: %3d\n", pl[i].weight);
      printf("       father: %3d\n", pl[i].father);
      printf("         sons: %3d\n", pl[i].sons);
      printf("leftmost leaf: %3d\n", pl[i].leftmostleaf);
      printf("\n");
   }
}

/*---------------------------------------------------------------------------*/

PUBLIC void print_tree(Tree *t)
{
   print_postorder_list(t->postorder_list);
   print_keyroots(t->keyroots);
   fflush(stdout);
}

/*---------------------------------------------------------------------------*/

PUBLIC void free_tree(Tree *t)
{
   free(t->postorder_list);
   free(t->keyroots);
   free(t);
}

/*---------------------------------------------------------------------------*/


PRIVATE void backtracking(void)
{
   int li,lj,i1,j1,i1_1,j1_1,li1_1,lj1_1,f;
   int cost, lleaf_i1, lleaf_j1, ss, i,j,k;
   struct {int i,j;} sector[MNODES/2];

   ss=0;

   i=i1=tree1->postorder_list[0].sons;
   j=j1=tree2->postorder_list[0].sons;

 start:
   li = tree1->postorder_list[i].leftmostleaf;
   lj = tree2->postorder_list[j].leftmostleaf;


   while ((i1>=li)&&(j1>=lj)) {

      lleaf_i1 = tree1->postorder_list[i1].leftmostleaf;
      li1_1 = (li > lleaf_i1-1 ? 0 : lleaf_i1-1);
      i1_1 = (i1 == li ? 0: i1-1);
      lleaf_j1 = tree2->postorder_list[j1].leftmostleaf;
      lj1_1 = (lj > lleaf_j1-1 ? 0 : lleaf_j1-1);
      j1_1 = (j1 == lj ? 0: j1-1);

      f = fdist[i1][j1];

      cost = edit_cost(i1, 0);
      if (f == fdist[i1_1][j1] + cost) {
	 alignment[0][i1]=0;
	 i1=i1_1;
      }
      else {
	 if (f ==  fdist[i1][j1_1] + edit_cost(0, j1)) {
	    alignment[1][j1]=0;
	    j1=j1_1;
	 }
	 else if (lleaf_i1 == li && lleaf_j1 == lj) {
	    alignment[0][i1] = j1;
	    alignment[1][j1] = i1;
	    i1=i1_1; j1=j1_1;
	 } else  {
	    sector[ss].i=i1;
	    sector[ss++].j=j1;
	    i1=li1_1;
	    j1=lj1_1;
	 }
      }
   }
   for (; i1>=li; ) {
      alignment[0][i1]=0;
      i1 = (i1 == li ? 0: i1-1);
   }
   for (; j1>=lj; ) {
      alignment[1][j1]=0;
      j1 = (j1 == lj ? 0: j1-1);
   }
   while (ss>0) {
      i1=sector[--ss].i;
      j1=sector[ss].j;
      for (k=1; 1; k++) {
	 i = tree1->keyroots[k];
	 if (tree1->postorder_list[i].leftmostleaf ==
	     tree1->postorder_list[i1].leftmostleaf) break;
      }
      for (k=1; 1; k++) {
	 j = tree2->keyroots[k];
	 if (tree2->postorder_list[j].leftmostleaf ==
	     tree2->postorder_list[j1].leftmostleaf) break;
      }
      tree_dist(i,j);
      goto start;
   }
}

/*---------------------------------------------------------------------------*/

PRIVATE void sprint_aligned_trees(void)
{
   int i,j,n1,n2,k,l,p, ni, nj, weights;
   char t1[2*MNODES+1], t2[2*MNODES+1], a1[8*MNODES], a2[8*MNODES], ll[20], ll1[20];

   weights=0;
   n1=tree1->postorder_list[0].sons;
   n2=tree2->postorder_list[0].sons;
   for (i=1; i<=n1; i++) weights |= (tree1->postorder_list[i].weight!=1);
   for (i=1; i<=n2; i++) weights |= (tree2->postorder_list[i].weight!=1);

   for (i=n1, l=2*n1-1; i>0; i--) {
      if (alignment[0][i]!=0) t1[l--]=']';
      else t1[l--]=')';
      p=i;
      while(i==tree1->postorder_list[p].leftmostleaf) {
	 if (alignment[0][p]!=0) t1[l--]='[';
	 else t1[l--]='(';
	 p=tree1->postorder_list[p].father;
      }
   }
   t1[2*n1]='\0';
   for (j=n2, l=2*n2-1; j>0; j--) {
      if (alignment[1][j]!=0) t2[l--]=']';
      else t2[l--]=')';
      p=j;
      while(j==tree2->postorder_list[p].leftmostleaf) {
	 if (alignment[1][p]!=0) t2[l--]='[';
	 else t2[l--]='(';
	 p=tree2->postorder_list[p].father;
      }
   }
   t2[2*n2]='\0';

   ni=nj=l=i=j=0;
   while (t1[i]||t2[j]) {
      while ((t1[i]=='(')||(t1[i]==')')) {
	 if (t1[i]==')') {
	    ni++;
	    encode(tree1->postorder_list[ni].type, ll);
	    if (weights)
	       sprintf(ll+strlen(ll), "%d", tree1->postorder_list[ni].weight);
	    for (k=0; k< strlen(ll); k++) {
	       a1[l]=ll[k];
	       a2[l++]='_';
	    }
	    a1[l]=')'; a2[l++]='_';
	 } else {
	    a1[l] = t1[i];
	    a2[l++] ='_';
	 }
	 i++;
      }

      while ((t2[j]=='(')||(t2[j]==')')) {
	 if (t2[j]==')') {
	    nj++;
	    encode(tree2->postorder_list[nj].type, ll);
	    if (weights)
	       sprintf(ll+strlen(ll), "%d", tree2->postorder_list[nj].weight);
	    for (k=0; k< strlen(ll); k++) {
	       a2[l]=ll[k];
	       a1[l++]='_';
	    }
	    a2[l]=')'; a1[l++]='_';
	 } else {
	    a2[l] = t2[j];
	    a1[l++] ='_';
	 }
	 j++;
      }

      if (t2[j]==']') {
	 ni++; nj++;
	 encode(tree2->postorder_list[nj].type, ll);
	 if (weights)
	    sprintf(ll+strlen(ll), "%d", tree2->postorder_list[nj].weight);
	 encode(tree1->postorder_list[ni].type, ll1);
	 if (weights)
	    sprintf(ll1+strlen(ll1), "%d", tree1->postorder_list[ni].weight);
	 if (strlen(ll)>strlen(ll1))
	    for (k=0; k<strlen(ll)-strlen(ll1); k++) strcat(ll1,"_");
	 if (strlen(ll)<strlen(ll1))
	    for (k=0; k<strlen(ll1)-strlen(ll); k++) strcat(ll,"_");
	 for (k=0; k< strlen(ll); k++) a2[l+k]=ll[k];
	 for (k=0; k< strlen(ll); k++) a1[l+k]=ll1[k];
	 l+=k;
	 a1[l]=a2[l]=')'; l++;
	 i++; j++;
      } else if (t2[j]=='[') {
	 a1[l]=a2[l]='('; l++;
	 i++; j++;
      }
   }
   a1[l]=a2[l]='\0';
   if (l>8*MNODES) vrna_message_error("structure too long in sprint_aligned_trees");
   if (aligned_line[0]!= NULL)  free(aligned_line[0]);
   if (aligned_line[1]!= NULL)  free(aligned_line[1]);
   aligned_line[0] = (char *) vrna_alloc((l+1)*sizeof(char));
   aligned_line[1] = (char *) vrna_alloc((l+1)*sizeof(char));
   strcpy(aligned_line[0], a1);
   strcpy(aligned_line[1], a2);
}

/*---------------------------------------------------------------------------*/

energy_par.c/   0           0     0     644     28211     `


/*
    Automatically generated using the TurnerParser
    TurnerParser (c) 2008,2009,2010
      Christian Hoener zu Siederdissen, TBI Vienna
      choener (at) tbi.univie.ac.at

    The library enabling this can be found at:
    http://hackage.haskell.org/package/BiobaseVienna
    the program can be found at:
    (sorry, not yet)
    install using cabal: cabal install (sorry, not yet)
*/

/*
     Current free energy parameters are summarized in:

     D.H.Mathews, J. Sabina, M. ZUker, D.H. Turner
     "Expanded sequence dependence of thermodynamic parameters improves
     prediction of RNA secondary structure"
     JMB, 288, pp 911-940, 1999

     Enthalpies taken from:

     A. Walter, D Turner, J Kim, M Lyttle, P M"uller, D Mathews, M Zuker
     "Coaxial stacking of helices enhances binding of oligoribonucleotides.."
     PNAS, 91, pp 9218-9222, 1994

     D.H. Turner, N. Sugimoto, and S.M. Freier.
     "RNA Structure Prediction",
     Ann. Rev. Biophys. Biophys. Chem. 17, 167-192, 1988.

     John A.Jaeger, Douglas H.Turner, and Michael Zuker.
     "Improved predictions of secondary structures for RNA",
     PNAS, 86, 7706-7710, October 1989.

     L. He, R. Kierzek, J. SantaLucia, A.E. Walter, D.H. Turner
     "Nearest-Neighbor Parameters for GU Mismatches...."
     Biochemistry 1991, 30 11124-11132

     A.E. Peritz, R. Kierzek, N, Sugimoto, D.H. Turner
     "Thermodynamic Study of Internal Loops in Oligoribonucleotides..."
     Biochemistry 1991, 30, 6428--6435
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "energy_const.h"

#define NST 0     /* Energy for nonstandard stacked pairs */
#define DEF -50   /* Default terminal mismatch, used for I */
                  /* and any non_pairing bases */
#define NSM 0     /* terminal mismatch for non standard pairs */

#define PUBLIC

PUBLIC double Tmeasure = 37+K0;  /* temperature of param measurements */


/* PUBLIC double lxc37=107.9; */
PUBLIC double lxc37=107.856;
PUBLIC int ML_intern37=-90;
PUBLIC int ML_interndH=-220;
PUBLIC int ML_closing37=930;
PUBLIC int ML_closingdH=3000;
PUBLIC int ML_BASE37=0;
PUBLIC int ML_BASEdH=0;
PUBLIC int MAX_NINIO=300;
PUBLIC int ninio37=60;
PUBLIC int niniodH=320;
PUBLIC int TerminalAU37=50;
PUBLIC int TerminalAUdH=370;
PUBLIC int DuplexInit37=410;
PUBLIC int DuplexInitdH=360;
PUBLIC int TripleC37=100;
PUBLIC int TripleCdH=1860;
PUBLIC int MultipleCA37=30;
PUBLIC int MultipleCAdH=340;
PUBLIC int MultipleCB37=160;
PUBLIC int MultipleCBdH=760;

PUBLIC int GQuadAlpha37 = -1800;
PUBLIC int GQuadAlphadH = -11934;
PUBLIC int GQuadBeta37 = 1200;
PUBLIC int GQuadBetadH = 0;

PUBLIC int stack37[NBPAIRS+1][NBPAIRS+1] =
{{   INF,   INF,   INF,   INF,   INF,   INF,   INF,   INF}
,{   INF,  -240,  -330,  -210,  -140,  -210,  -210,  -140}
,{   INF,  -330,  -340,  -250,  -150,  -220,  -240,  -150}
,{   INF,  -210,  -250,   130,   -50,  -140,  -130,   130}
,{   INF,  -140,  -150,   -50,    30,   -60,  -100,    30}
,{   INF,  -210,  -220,  -140,   -60,  -110,   -90,   -60}
,{   INF,  -210,  -240,  -130,  -100,   -90,  -130,   -90}
,{   INF,  -140,  -150,   130,    30,   -60,   -90,   130}};
PUBLIC int stackdH[NBPAIRS+1][NBPAIRS+1] =
{{   INF,   INF,   INF,   INF,   INF,   INF,   INF,   INF}
,{   INF, -1060, -1340, -1210,  -560, -1050, -1040,  -560}
,{   INF, -1340, -1490, -1260,  -830, -1140, -1240,  -830}
,{   INF, -1210, -1260, -1460, -1350,  -880, -1280,  -880}
,{   INF,  -560,  -830, -1350,  -930,  -320,  -700,  -320}
,{   INF, -1050, -1140,  -880,  -320,  -940,  -680,  -320}
,{   INF, -1040, -1240, -1280,  -700,  -680,  -770,  -680}
,{   INF,  -560,  -830,  -880,  -320,  -320,  -680,  -320}};

PUBLIC int hairpin37[31] = {   INF,   INF,   INF,   540,   560,   570,   540,   600,   550,   640,   650,   660,   670,   680,   690,   690,   700,   710,   710,   720,   720,   730,   730,   740,   740,   750,   750,   750,   760,   760,   770};
PUBLIC int hairpindH[31] = {   INF,   INF,   INF,   130,   480,   360,  -290,   130,  -290,   500,   500,   500,   500,   500,   500,   500,   500,   500,   500,   500,   500,   500,   500,   500,   500,   500,   500,   500,   500,   500,   500};
PUBLIC int bulge37[31] = {   INF,   380,   280,   320,   360,   400,   440,   460,   470,   480,   490,   500,   510,   520,   530,   540,   540,   550,   550,   560,   570,   570,   580,   580,   580,   590,   590,   600,   600,   600,   610};
PUBLIC int bulgedH[31] = {   INF,  1060,   710,   710,   710,   710,   710,   710,   710,   710,   710,   710,   710,   710,   710,   710,   710,   710,   710,   710,   710,   710,   710,   710,   710,   710,   710,   710,   710,   710,   710};
PUBLIC int internal_loop37[31] = {   INF,   INF,   100,   100,   110,   200,   200,   210,   230,   240,   250,   260,   270,   280,   290,   290,   300,   310,   310,   320,   330,   330,   340,   340,   350,   350,   350,   360,   360,   370,   370};
PUBLIC int internal_loopdH[31] = {   INF,   INF,   -720,   -720,  -720,  -680,  -130,  -130,  -130,  -130,  -130,  -130,  -130,  -130,  -130,  -130,  -130,  -130,  -130,  -130,  -130,  -130,  -130,  -130,  -130,  -130,  -130,  -130,  -130,  -130,  -130};

PUBLIC int mismatchI37[NBPAIRS+1][5][5] =
{{{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 }
,{{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,   -80,     0}
 ,{     0,     0,     0,     0,     0}
 ,{     0,  -100,     0,  -100,     0}
 ,{     0,     0,     0,     0,   -60}
 }
,{{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,   -80,     0}
 ,{     0,     0,     0,     0,     0}
 ,{     0,  -100,     0,  -100,     0}
 ,{     0,     0,     0,     0,   -60}
 }
,{{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,   -10,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,   -30,    70,   -30,    70}
 ,{    70,    70,    70,    70,    10}
 }
,{{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,   -10,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,   -30,    70,   -30,    70}
 ,{    70,    70,    70,    70,    10}
 }
,{{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,   -10,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,   -30,    70,   -30,    70}
 ,{    70,    70,    70,    70,    10}
 }
,{{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,   -10,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,   -30,    70,   -30,    70}
 ,{    70,    70,    70,    70,    10}
 }
,{{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,   -10,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,   -30,    70,   -30,    70}
 ,{    70,    70,    70,    70,    10}
 }};
PUBLIC int mismatchIdH[NBPAIRS+1][5][5] =
{{{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 }
,{{   280,     0,     0,   280,     0}
 ,{     0,     0,     0,  -340,     0}
 ,{     0,     0,     0,     0,     0}
 ,{   280,  -760,     0,   280,     0}
 ,{     0,     0,     0,     0,  -580}
 }
,{{   280,     0,     0,   280,     0}
 ,{     0,     0,     0,  -340,     0}
 ,{     0,     0,     0,     0,     0}
 ,{   280,  -760,     0,   280,     0}
 ,{     0,     0,     0,     0,  -580}
 }
,{{   790,   500,   500,   790,   500}
 ,{   500,   500,   500,   170,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   790,  -260,   500,   790,   500}
 ,{   500,   500,   500,   500,   -80}
 }
,{{   790,   500,   500,   790,   500}
 ,{   500,   500,   500,   170,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   790,  -260,   500,   790,   500}
 ,{   500,   500,   500,   500,   -80}
 }
,{{   790,   500,   500,   790,   500}
 ,{   500,   500,   500,   170,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   790,  -260,   500,   790,   500}
 ,{   500,   500,   500,   500,   -80}
 }
,{{   790,   500,   500,   790,   500}
 ,{   500,   500,   500,   170,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   790,  -260,   500,   790,   500}
 ,{   500,   500,   500,   500,   -80}
 }
,{{   790,   500,   500,   790,   500}
 ,{   500,   500,   500,   170,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   790,  -260,   500,   790,   500}
 ,{   500,   500,   500,   500,   -80}
 }};

PUBLIC int mismatchH37[NBPAIRS+1][5][5] =
{{{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 }
,{{   -80,  -100,  -110,  -100,   -80}
 ,{  -140,  -150,  -150,  -140,  -150}
 ,{   -80,  -100,  -110,  -100,   -80}
 ,{  -150,  -230,  -150,  -240,  -150}
 ,{  -100,  -100,  -140,  -100,  -210}
 }
,{{   -50,  -110,   -70,  -110,   -50}
 ,{  -110,  -110,  -150,  -130,  -150}
 ,{   -50,  -110,   -70,  -110,   -50}
 ,{  -150,  -250,  -150,  -220,  -150}
 ,{  -100,  -110,  -100,  -110,  -160}
 }
,{{    20,    20,   -20,   -10,   -20}
 ,{    20,    20,   -50,   -30,   -50}
 ,{   -10,   -10,   -20,   -10,   -20}
 ,{   -50,  -100,   -50,  -110,   -50}
 ,{   -10,   -10,   -30,   -10,  -100}
 }
,{{     0,   -20,   -10,   -20,     0}
 ,{   -30,   -50,   -30,   -60,   -30}
 ,{     0,   -20,   -10,   -20,     0}
 ,{   -30,   -90,   -30,  -110,   -30}
 ,{   -10,   -20,   -10,   -20,   -90}
 }
,{{   -10,   -10,   -20,   -10,   -20}
 ,{   -30,   -30,   -50,   -30,   -50}
 ,{   -10,   -10,   -20,   -10,   -20}
 ,{   -50,  -120,   -50,  -110,   -50}
 ,{   -10,   -10,   -30,   -10,  -120}
 }
,{{     0,   -20,   -10,   -20,     0}
 ,{   -30,   -50,   -30,   -50,   -30}
 ,{     0,   -20,   -10,   -20,     0}
 ,{   -30,  -150,   -30,  -150,   -30}
 ,{   -10,   -20,   -10,   -20,   -90}
 }
,{{    20,    20,   -10,   -10,     0}
 ,{    20,    20,   -30,   -30,   -30}
 ,{     0,   -10,   -10,   -10,     0}
 ,{   -30,   -90,   -30,  -110,   -30}
 ,{   -10,   -10,   -10,   -10,   -90}
 }};
PUBLIC int mismatchHdH[NBPAIRS+1][5][5] =
{{{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 }
,{{   560,  -570,   560,  -560,  -270}
 ,{  -560,  -910,  -560,  -560,  -560}
 ,{  -270,  -570,  -340,  -570,  -270}
 ,{   560, -1400,   560,  -920,  -560}
 ,{  -530,  -570,  -530,  -570, -1440}
 }
,{{    50,  -520,    50,  -560,  -400}
 ,{  -400,  -520,  -400,  -560,  -400}
 ,{    50,  -720,    50,  -720,  -420}
 ,{  -400, -1290,  -400,  -620,  -400}
 ,{   -30,  -720,   -30,  -720, -1080}
 }
,{{   970,   140,   970,   140,   570}
 ,{   570,    30,   570,    20,   570}
 ,{   970,   140,   970,   140,   340}
 ,{   570,  -270,   570,    20,   570}
 ,{   830,   140,   830,   140,   -50}
 }
,{{   230,   100,   230,   220,   190}
 ,{  -110,  -110,  -260,  -520,  -260}
 ,{   190,   -60,  -140,   -60,   190}
 ,{   220,   100,  -260,   220,  -260}
 ,{   230,   -60,   230,   -60,   -70}
 }
,{{   970,   140,   970,   140,   570}
 ,{   570,   -20,   570,    20,   570}
 ,{   970,   140,   970,   140,   340}
 ,{   570,  -520,   570,    20,   570}
 ,{   830,   140,   830,   140,  -380}
 }
,{{   230,   -30,   230,   -60,   190}
 ,{   -30,   -30,  -260,  -520,  -260}
 ,{   190,   -60,  -140,   -60,   190}
 ,{  -260,  -590,  -260,  -520,  -260}
 ,{   230,   -60,   230,   -60,   -70}
 }
,{{   970,   140,   970,   220,   570}
 ,{   570,    30,   570,    20,   570}
 ,{   970,   140,   970,   140,   340}
 ,{   570,   100,   570,   220,   570}
 ,{   830,   140,   830,   140,   -50}
 }};

/* mismatch_multi */
PUBLIC int mismatchM37[NBPAIRS+1][5][5] =
{{ /* NP.. */
  {   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 },
 { /* CG.. */
  {   -50,  -110,   -50,  -140,   -70}
 ,{  -110,  -110,  -110,  -160,  -110}
 ,{   -70,  -150,   -70,  -150,  -100}
 ,{  -110,  -130,  -110,  -140,  -110}
 ,{   -50,  -150,   -50,  -150,   -70}
 },
 { /* GC.. */
  {   -80,  -140,   -80,  -140,  -100}
 ,{  -100,  -150,  -100,  -140,  -100}
 ,{  -110,  -150,  -110,  -150,  -140}
 ,{  -100,  -140,  -100,  -160,  -100}
 ,{   -80,  -150,   -80,  -150,  -120}
 },
 { /* GU.. */
  {   -50,   -80,   -50,   -50,   -50}
 ,{   -50,  -100,   -70,   -50,   -70}
 ,{   -60,   -80,   -60,   -80,   -60}
 ,{   -70,  -110,   -70,   -80,   -70}
 ,{   -50,   -80,   -50,   -80,   -50}
 },
 { /* UG.. */
  {   -30,   -30,   -60,   -60,   -60}
 ,{   -30,   -30,   -60,   -60,   -60}
 ,{   -70,  -100,   -70,  -100,   -80}
 ,{   -60,   -80,   -60,   -80,   -60}
 ,{   -60,  -100,   -70,  -100,   -60}
 },
 { /* AU.. */
  {   -50,   -80,   -50,   -80,   -50}
 ,{   -70,  -100,   -70,  -110,   -70}
 ,{   -60,   -80,   -60,   -80,   -60}
 ,{   -70,  -110,   -70,  -120,   -70}
 ,{   -50,   -80,   -50,   -80,   -50}
 },
 { /* UA.. */
  {   -60,   -80,   -60,   -80,   -60}
 ,{   -60,   -80,   -60,   -80,   -60}
 ,{   -70,  -100,   -70,  -100,   -80}
 ,{   -60,   -80,   -60,   -80,   -60}
 ,{   -70,  -100,   -70,  -100,   -80}
 },
 { /* NN.. */
  {   -30,   -30,   -50,   -50,   -50}
 ,{   -30,   -30,   -60,   -50,   -60}
 ,{   -60,   -80,   -60,   -80,   -60}
 ,{   -60,   -80,   -60,   -80,   -60}
 ,{   -50,   -80,   -50,   -80,   -50}
 }};

/* mismatch_multi_enthalpies */
PUBLIC int mismatchMdH[NBPAIRS+1][5][5] =
{{ /* NP.. */
  {   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 },
 { /* CG.. */
  {    50,  -400,    50,  -400,   -30}
 ,{  -520,  -520,  -720,  -710,  -720}
 ,{    50,  -400,    50,  -400,   -30}
 ,{  -560,  -560,  -720,  -620,  -720}
 ,{  -400,  -400,  -420,  -400,  -500}
 },
 { /* GC.. */
  {  -270,  -560,  -270,  -560,  -530}
 ,{  -570,  -910,  -570,  -820,  -570}
 ,{  -340,  -560,  -340,  -560,  -530}
 ,{  -560,  -560,  -570,  -920,  -570}
 ,{  -270,  -560,  -270,  -560,  -860}
 },
 { /* GU.. */
  {   310,  -480,  -180,   310,   140}
 ,{   310,  -480,  -430,   310,  -430}
 ,{  -140,  -630,  -510,  -630,  -140}
 ,{  -150,  -890,  -430,  -150,  -430}
 ,{   140,  -630,  -180,  -630,   140}
 },
 { /* UG.. */
  {   600,   200,   600,   200,   460}
 ,{   -60,  -340,  -230,   -60,  -230}
 ,{   600,   200,   600,   200,   460}
 ,{  -230,  -350,  -230,  -350,  -230}
 ,{   200,   200,   -30,   200,   160}
 },
 { /* AU.. */
  {   140,  -400,  -180,  -380,   140}
 ,{  -380,  -400,  -430,  -380,  -430}
 ,{  -140,  -630,  -510,  -630,  -140}
 ,{  -430,  -890,  -430,  -890,  -430}
 ,{   140,  -630,  -180,  -630,   140}
 },
 { /* UA.. */
  {   600,   200,   600,   200,   460}
 ,{  -230,  -390,  -230,  -310,  -230}
 ,{   600,   200,   600,   200,   460}
 ,{  -230,  -350,  -230,  -350,  -230}
 ,{   200,   200,   -30,   200,  -170}
 },
 { /* NN.. */
  {   600,   200,   600,   310,   460}
 ,{   310,  -340,  -230,   310,  -230}
 ,{   600,   200,   600,   200,   460}
 ,{  -150,  -350,  -230,  -150,  -230}
 ,{   200,   200,   -30,   200,   160}
 }};

PUBLIC int mismatch1nI37[NBPAIRS+1][5][5] =
{{{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 }
,{{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,     0,     0}
 }
,{{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,     0,     0}
 }
,{{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 }
,{{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 }
,{{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 }
,{{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 }
,{{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 }};
PUBLIC int mismatch1nIdH[NBPAIRS+1][5][5] =
{{{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 }
,{{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,     0,     0}
 }
,{{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,     0,     0}
 }
,{{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 }
,{{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 }
,{{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 }
,{{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 }
,{{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 }};

PUBLIC int mismatch23I37[NBPAIRS+1][5][5] =
{{{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 }
,{{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,   -50,     0}
 ,{     0,     0,     0,     0,     0}
 ,{     0,  -110,     0,   -70,     0}
 ,{     0,     0,     0,     0,   -30}
 }
,{{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,     0,     0}
 ,{     0,  -120,     0,   -70,     0}
 ,{     0,     0,     0,     0,   -30}
 }
,{{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,   -40,    70,     0,    70}
 ,{    70,    70,    70,    70,    40}
 }
,{{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    20,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,   -40,    70,     0,    70}
 ,{    70,    70,    70,    70,    40}
 }
,{{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,   -40,    70,     0,    70}
 ,{    70,    70,    70,    70,    40}
 }
,{{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    20,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,   -40,    70,     0,    70}
 ,{    70,    70,    70,    70,    40}
 }
,{{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,    70,    70,    70,    70}
 ,{    70,   -40,    70,     0,    70}
 ,{    70,    70,    70,    70,    40}
 }};
PUBLIC int mismatch23IdH[NBPAIRS+1][5][5] =
{{{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 }
,{{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,  -570,     0}
 ,{     0,     0,     0,     0,     0}
 ,{     0,  -860,     0,  -900,     0}
 ,{     0,     0,     0,     0,  -640}
 }
,{{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,     0,     0}
 ,{     0,     0,     0,     0,     0}
 ,{     0, -1090,     0,  -900,     0}
 ,{     0,     0,     0,     0,  -640}
 }
,{{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,  -580,   500,  -400,   500}
 ,{   500,   500,   500,   500,  -140}
 }
,{{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   -60,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,  -360,   500,  -400,   500}
 ,{   500,   500,   500,   500,  -140}
 }
,{{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,  -580,   500,  -400,   500}
 ,{   500,   500,   500,   500,  -140}
 }
,{{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   -60,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,  -360,   500,  -400,   500}
 ,{   500,   500,   500,   500,  -140}
 }
,{{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,   500,   500,   500,   500}
 ,{   500,  -360,   500,  -400,   500}
 ,{   500,   500,   500,   500,  -140}
 }};

/* mismatch_exterior */
PUBLIC int mismatchExt37[NBPAIRS+1][5][5] =
{{ /* NP.. */
  {   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 },
 { /* CG.. */
  {   -50,  -110,   -50,  -140,   -70}
 ,{  -110,  -110,  -110,  -160,  -110}
 ,{   -70,  -150,   -70,  -150,  -100}
 ,{  -110,  -130,  -110,  -140,  -110}
 ,{   -50,  -150,   -50,  -150,   -70}
 },
 { /* GC.. */
  {   -80,  -140,   -80,  -140,  -100}
 ,{  -100,  -150,  -100,  -140,  -100}
 ,{  -110,  -150,  -110,  -150,  -140}
 ,{  -100,  -140,  -100,  -160,  -100}
 ,{   -80,  -150,   -80,  -150,  -120}
 },
 { /* GU.. */
  {   -50,   -80,   -50,   -50,   -50}
 ,{   -50,  -100,   -70,   -50,   -70}
 ,{   -60,   -80,   -60,   -80,   -60}
 ,{   -70,  -110,   -70,   -80,   -70}
 ,{   -50,   -80,   -50,   -80,   -50}
 },
 { /* UG.. */
  {   -30,   -30,   -60,   -60,   -60}
 ,{   -30,   -30,   -60,   -60,   -60}
 ,{   -70,  -100,   -70,  -100,   -80}
 ,{   -60,   -80,   -60,   -80,   -60}
 ,{   -60,  -100,   -70,  -100,   -60}
 },
 { /* AU.. */
  {   -50,   -80,   -50,   -80,   -50}
 ,{   -70,  -100,   -70,  -110,   -70}
 ,{   -60,   -80,   -60,   -80,   -60}
 ,{   -70,  -110,   -70,  -120,   -70}
 ,{   -50,   -80,   -50,   -80,   -50}
 },
 { /* UA.. */
  {   -60,   -80,   -60,   -80,   -60}
 ,{   -60,   -80,   -60,   -80,   -60}
 ,{   -70,  -100,   -70,  -100,   -80}
 ,{   -60,   -80,   -60,   -80,   -60}
 ,{   -70,  -100,   -70,  -100,   -80}
 },
 { /* NN.. */
  {   -30,   -30,   -50,   -50,   -50}
 ,{   -30,   -30,   -60,   -50,   -60}
 ,{   -60,   -80,   -60,   -80,   -60}
 ,{   -60,   -80,   -60,   -80,   -60}
 ,{   -50,   -80,   -50,   -80,   -50}
 }};

/* mismatch_exterior_enthalpies */
PUBLIC int mismatchExtdH[NBPAIRS+1][5][5] =
{{ /* NP.. */
  {   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 ,{   INF,   INF,   INF,   INF,   INF}
 },
 { /* CG.. */
  {    50,  -400,    50,  -400,   -30}
 ,{  -520,  -520,  -720,  -710,  -720}
 ,{    50,  -400,    50,  -400,   -30}
 ,{  -560,  -560,  -720,  -620,  -720}
 ,{  -400,  -400,  -420,  -400,  -500}
 },
 { /* GC.. */
  {  -270,  -560,  -270,  -560,  -530}
 ,{  -570,  -910,  -570,  -820,  -570}
 ,{  -340,  -560,  -340,  -560,  -530}
 ,{  -560,  -560,  -570,  -920,  -570}
 ,{  -270,  -560,  -270,  -560,  -860}
 },
 { /* GU.. */
  {   310,  -480,  -180,   310,   140}
 ,{   310,  -480,  -430,   310,  -430}
 ,{  -140,  -630,  -510,  -630,  -140}
 ,{  -150,  -890,  -430,  -150,  -430}
 ,{   140,  -630,  -180,  -630,   140}
 },
 { /* UG.. */
  {   600,   200,   600,   200,   460}
 ,{   -60,  -340,  -230,   -60,  -230}
 ,{   600,   200,   600,   200,   460}
 ,{  -230,  -350,  -230,  -350,  -230}
 ,{   200,   200,   -30,   200,   160}
 },
 { /* AU.. */
  {   140,  -400,  -180,  -380,   140}
 ,{  -380,  -400,  -430,  -380,  -430}
 ,{  -140,  -630,  -510,  -630,  -140}
 ,{  -430,  -890,  -430,  -890,  -430}
 ,{   140,  -630,  -180,  -630,   140}
 },
 { /* UA.. */
  {   600,   200,   600,   200,   460}
 ,{  -230,  -390,  -230,  -310,  -230}
 ,{   600,   200,   600,   200,   460}
 ,{  -230,  -350,  -230,  -350,  -230}
 ,{   200,   200,   -30,   200,  -170}
 },
 { /* NN.. */
  {   600,   200,   600,   310,   460}
 ,{   310,  -340,  -230,   310,  -230}
 ,{   600,   200,   600,   200,   460}
 ,{  -150,  -350,  -230,  -150,  -230}
 ,{   200,   200,   -30,   200,   160}
 }};

/* dangle5 */
PUBLIC int dangle5_37[NBPAIRS+1][5] =
{ /*           N      A      C      G      U */
/* NP */ {   INF,   INF,   INF,   INF,   INF},
/* CG */ {   -10,   -50,   -30,   -20,   -10},
/* GC */ {    -0,   -20,   -30,    -0,    -0},
/* GU */ {   -20,   -30,   -30,   -40,   -20},
/* UG */ {   -10,   -30,   -10,   -20,   -20},
/* AU */ {   -20,   -30,   -30,   -40,   -20},
/* UA */ {   -10,   -30,   -10,   -20,   -20},
/* NN */ {    -0,   -20,   -10,    -0,    -0}
};

/* dangle3 */
PUBLIC int dangle3_37[NBPAIRS+1][5] =
{ /*           N      A      C      G      U */
/* NP */ {   INF,   INF,   INF,   INF,   INF},
/* CG */ {   -40,  -110,   -40,  -130,   -60},
/* GC */ {   -80,  -170,   -80,  -170,  -120},
/* GU */ {   -10,   -70,   -10,   -70,   -10},
/* UG */ {   -50,   -80,   -50,   -80,   -60},
/* AU */ {   -10,   -70,   -10,   -70,   -10},
/* UA */ {   -50,   -80,   -50,   -80,   -60},
/* NN */ {   -10,   -70,   -10,   -70,   -10}
};

/* dangle5_enthalpies */
PUBLIC int dangle5_dH[NBPAIRS+1][5] =
{ /*           N      A      C      G      U */
/* NP */ {   INF,   INF,   INF,   INF,   INF},
/* CG */ {   330,  -240,   330,    80,  -140},
/* GC */ {    70,  -160,    70,  -460,   -40},
/* GU */ {   310,   160,   220,    70,   310},
/* UG */ {   690,   -50,   690,    60,    60},
/* AU */ {   310,   160,   220,    70,   310},
/* UA */ {   690,   -50,   690,    60,    60},
/* NN */ {   690,   160,   690,    80,   310}
};

/* dangle3_enthalpies */
PUBLIC int dangle3_dH[NBPAIRS+1][5] =
{ /*           N      A      C      G      U */
/* NP */ {   INF,   INF,   INF,   INF,   INF},
/* CG */ {  -280,  -740,  -280,  -640,  -360},
/* GC */ {  -410,  -900,  -410,  -860,  -750},
/* GU */ {   -70,  -570,   -70,  -580,  -220},
/* UG */ {   -90,  -490,   -90,  -550,  -230},
/* AU */ {   -70,  -570,   -70,  -580,  -220},
/* UA */ {   -90,  -490,   -90,  -550,  -230},
/* NN */ {   -70,  -490,   -70,  -550,  -220}
};

PUBLIC char Triloops[241] =
  "CAACG "
  "GUUAC "
;
PUBLIC int Triloop37[40] = {   680,   690};
PUBLIC int TriloopdH[40] = {  2370,  1080};

PUBLIC char Tetraloops[281] =
  "CAACGG "
  "CCAAGG "
  "CCACGG "
  "CCCAGG "
  "CCGAGG "
  "CCGCGG "
  "CCUAGG "
  "CCUCGG "
  "CUAAGG "
  "CUACGG "
  "CUCAGG "
  "CUCCGG "
  "CUGCGG "
  "CUUAGG "
  "CUUCGG "
  "CUUUGG "
;
PUBLIC int Tetraloop37[40] = {   550,   330,   370,   340,   350,   360,   370,   250,   360,   280,   370,   270,   280,   350,   370,   370};
PUBLIC int TetraloopdH[40] = {   690, -1030,  -330,  -890,  -660,  -750,  -350, -1390,  -760, -1070,  -660, -1290, -1070,  -620, -1530,  -680};

PUBLIC char Hexaloops[361] =
  "ACAGUACU "
  "ACAGUGAU "
  "ACAGUGCU "
  "ACAGUGUU "
;
PUBLIC int Hexaloop37[40] = {   280,   360,   290,   180};
PUBLIC int HexaloopdH[40] = { -1680, -1140, -1280, -1540};

#include "intl11.h"
#include "intl11dH.h"
#include "intl21.h"
#include "intl21dH.h"
#include "intl22.h"
#include "intl22dH.h"


inverse.c/      0           0     0     644     14166     `
/*
		      search for sequences that
		  fold into a given target structure

			    c Ivo Hofacker
			  Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#define TDIST 0     /* use tree distance */
#define PF    1     /* include support for partiton function */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <float.h>
#if PF
#include "part_func.h"
#endif
#include "fold.h"
#if TDIST
#include "dist_vars.h"
#include "treedist.h"
#include "RNAstruct.h"
#endif
#include "utils.h"
#include "fold_vars.h"
#include "pair_mat.h"

PRIVATE double  adaptive_walk(char *start, const char *target);
PRIVATE void   shuffle(int *list, int len);
PRIVATE void   make_start(char* start, const char *structure);
PRIVATE void   make_ptable(const char *structure, int *table);
PRIVATE void   make_pairset(void);
PRIVATE double  mfe_cost(const char *, char*, const char *);
PRIVATE double  pf_cost(const char *, char *, const char *);
PRIVATE char  *aux_struct(const char* structure );

/* for backward compatibility, make sure symbolset can hold 20 characters */
PRIVATE char   default_alpha[21] = "AUGC";
PUBLIC  char   *symbolset = default_alpha;
PUBLIC  int    give_up = 0;
PUBLIC  float  final_cost = 0; /* when to stop inverse_pf_fold */
PUBLIC  int    inv_verbose=0;  /* print out substructure on which inverse_fold() fails */

PRIVATE char   pairset[2*MAXALPHA+1];
PRIVATE int    base, npairs;
PRIVATE int    nc2;

/*-------------------------------------------------------------------------*/
PRIVATE int fold_type;
#if TDIST
PRIVATE Tree *T0;
#endif
PRIVATE double cost2;

PRIVATE double adaptive_walk(char *start, const char *target)
{
#ifdef DUMMY
   printf("%s\n%s %c\n", start, target, backtrack_type );
   return 0.;
#endif
   int i,j,p,tt,w1,w2, n_pos, len, flag;
   long  walk_len;
   char *string, *string2, *cstring, *structure, *struct2;
   int *mut_pos_list, mut_sym_list[MAXALPHA+1], mut_pair_list[2*MAXALPHA+1];
   int *w1_list, *w2_list, mut_position, symbol, bp;
   int *target_table, *test_table;
   char cont;
   double cost, current_cost, ccost2;
   double (*cost_function)(const char *, char *, const char *);

   len = strlen(start);
   if (strlen(target)!=len) {
      fprintf(stderr, "%s\n%s\n", start, target);
      vrna_message_error("adaptive_walk: start and target have unequal length");
   }
   string    = (char *) vrna_alloc(sizeof(char)*(len+1));
   cstring   = (char *) vrna_alloc(sizeof(char)*(len+1));
   string2   = (char *) vrna_alloc(sizeof(char)*(len+1));
   structure = (char *) vrna_alloc(sizeof(char)*(len+1));
   struct2   = (char *) vrna_alloc(sizeof(char)*(len+1));
   mut_pos_list = (int *) vrna_alloc(sizeof(int)*len);
   w1_list = (int *) vrna_alloc(sizeof(int)*len);
   w2_list = (int *) vrna_alloc(sizeof(int)*len);
   target_table = (int *) vrna_alloc(sizeof(int)*len);
   test_table = (int *) vrna_alloc(sizeof(int)*len);

   make_ptable(target, target_table);

   for (i=0; i<base; i++) mut_sym_list[i] = i;
   for (i=0; i<npairs; i++) mut_pair_list[i] = i;

   for (i=0; i<len; i++)
      string[i] = (islower(start[i]))?toupper(start[i]):start[i];
   walk_len = 0;

   if (fold_type==0) cost_function = mfe_cost;
   else cost_function = pf_cost;

   cost = cost_function(string, structure, target);

   if (fold_type==0) ccost2=cost2;
   else { ccost2 = -1.; cost2=0; }

   strcpy(cstring, string);
   current_cost = cost;

   if (cost>0) do {
      cont=0;

      if (fold_type==0) { /* min free energy fold */
	 make_ptable(structure, test_table);
	 for (j=w1=w2=flag=0; j<len; j++)
	    if ((tt=target_table[j])!=test_table[j]) {
	       if ((tt<j)&&(isupper(start[j]))) w1_list[w1++] = j;   /* incorrectly paired */
	       if ((flag==0)&&(j>0))
		  if ((target_table[j-1]<j-1)&&isupper(start[j-1]))
			w2_list[w2++] = j-1;                  /* adjacent to incorrect position */
	       if (w2>1) if (w2_list[w2-2]==w2_list[w2-1]) w2--;

	       flag = 1;
	    } else {
	       if (flag==1) if ((tt<j)&&isupper(start[j]))
		  w2_list[w2++] = j;                          /* adjacent to incorrect position */
	       flag = 0;
	    }
	 shuffle(w1_list, w1);
	 shuffle(w2_list, w2);
	 for (j=n_pos=0; j<w1; j++) mut_pos_list[n_pos++] = w1_list[j];
	 for (j=0; j<w2; j++) mut_pos_list[n_pos++] = w2_list[j];
      } else { /* partition_function */
	 for (j=n_pos=0; j<len; j++) if (isupper(start[j]))
	    if (target_table[j]<=j) mut_pos_list[n_pos++] = j;
	 shuffle(mut_pos_list, n_pos);
      }

      string2[0]='\0';
      for (mut_position=0; mut_position<n_pos; mut_position++){

	 strcpy(string, cstring);
	 shuffle(mut_sym_list,  base);
	 shuffle(mut_pair_list, npairs);

	 i = mut_pos_list[mut_position];

	 if (target_table[i]<0) /* unpaired base */
	    for (symbol=0;symbol<base;symbol++) {

	       if(cstring[i]==
		  symbolset[mut_sym_list[symbol]]) continue;

	       string[i] = symbolset[mut_sym_list[symbol]];

	       cost = cost_function(string, structure, target);

	       if ( cost + DBL_EPSILON < current_cost  ) break;
	       if (( cost == current_cost)&&(cost2<ccost2)){
		  strcpy(string2, string);
		  strcpy(struct2, structure);
		  ccost2 = cost2;
	       }
	    }
	 else  /* paired base */
	    for  (bp=0; bp<npairs; bp++) {
	       j = target_table[i];
	       p = mut_pair_list[bp]*2;
	       if ((cstring[i] == pairset[p]) &&
		   (cstring[j] == pairset[p+1]))
		  continue;
	       string[i] = pairset[p];
	       string[j] = pairset[p+1];

	       cost = cost_function(string, structure, target);

	       if ( cost < current_cost ) break;
	       if (( cost == current_cost)&&(cost2<ccost2)){
		  strcpy(string2, string);
		  strcpy(struct2, structure);
		  ccost2 = cost2;
	       }
	    }

	 if ( cost < current_cost ) {
	    strcpy(cstring, string);
	    current_cost = cost;
	    ccost2 = cost2;
	    walk_len++;
	    if (cost>0) cont=1;
	    break;
	 }
      }
      if ((current_cost>0)&&(cont==0)&&(string2[0])) {
	 /* no mutation that decreased cost was found,
	    but the the sequence in string2 decreases cost2 while keeping
	    cost constant */
	 strcpy(cstring, string2);
	 strcpy(structure, struct2);
	 nc2++; cont=1;
      }
   } while (cont);

   for (i=0; i<len; i++) if (isupper(start[i])) start[i]=cstring[i];

#if TDIST
   if (fold_type==0) { free_tree(T0); T0=NULL; }
#endif
   free(test_table);
   free(target_table);
   free(mut_pos_list);
   free(w2_list);
   free(w1_list);
   free(struct2);
   free(structure);
   free(string2);
   free(cstring);
   free(string);

   return current_cost;
}

/*-------------------------------------------------------------------------*/

/* shuffle produces a ronaom list by doing len exchanges */
PRIVATE void shuffle(int *list, int len)
{
   int i, rn;

   for (i=0;i<len;i++) {
     int temp;
     rn = i + (int) (vrna_urn()*(len-i));   /* [i..len-1] */
     /* swap element i and rn */
     temp = list[i];
     list[i] = list[rn];
     list[rn] = temp;
   }
}

/*-------------------------------------------------------------------------*/

PRIVATE void make_ptable(const char *structure, int *table)
{
   int i,j,hx;
   int *stack;

   hx=0;
   stack = (int *) vrna_alloc(sizeof(int)*(strlen(structure)+1));

   for (i=0; i<strlen(structure); i++) {
      switch (structure[i]) {
       case '.':
	 table[i]= -1;
	 break;
       case '(':
	 stack[hx++]=i;
	 break;
       case ')':
	 j = stack[--hx];
	 if (hx<0) {
	    fprintf(stderr, "%s\n", structure);
	    vrna_message_error("unbalanced brackets in make_ptable");
	 }
	 table[i]=j;
	 table[j]=i;
	 break;
      }
   }
   if (hx!=0) {
      fprintf(stderr, "%s\n", structure);
      vrna_message_error("unbalanced brackets in make_ptable");
   }
   free(stack);
}

/*-------------------------------------------------------------------------*/

#define WALK(i,j) \
    strncpy(wstruct, structure+i, j-i+1); \
    wstruct[j-i+1]='\0'; \
    strncpy(wstring, string+i, j-i+1); \
    wstring[j-i+1]='\0'; \
    dist=adaptive_walk(wstring, wstruct); \
    strncpy(string+i, wstring, j-i+1); \
    if ((dist>0)&&(give_up)) goto adios

PUBLIC float inverse_fold(char *start, char *structure)
{
   int i, j, jj, len, o;
   int *pt;
   char *string, *wstring, *wstruct, *aux;
   double dist=0;

   nc2 = j = o = fold_type = 0;

   len = strlen(structure);
   if (strlen(start)!=len) {
      fprintf(stderr, "%s\n%s\n", start, structure);
      vrna_message_error("inverse_fold: start and structure have unequal length");
   }
   string = (char *) vrna_alloc(len+1);
   wstring = (char *) vrna_alloc(len+1);
   wstruct = (char *) vrna_alloc(len+1);
   pt = (int *) vrna_alloc(sizeof(int)*(len+2));
   pt[len] = len+1;

   aux = aux_struct(structure);
   strcpy(string, start);
   make_pairset();
   make_start(string, structure);

   make_ptable(structure, pt);

   while (j<len) {
      while ((j<len)&&(structure[j]!=')')) {
	 if (aux[j]=='[') o++;
	 if (aux[j]==']') o--;
	 j++;
      }
      i=j;
      while ((i>0) && structure[--i]!='(');
      if (structure[i]=='.') { /* no pair found -> open chain */
	WALK(0,len-1);
      }

      if (aux[i]!='[') { i--; j++;}
      while (pt[j]==i) {
	 backtrack_type='C';
	 if (aux[i]!='[') {
	    while (aux[--i]!='[');
	    while (aux[++j]!=']');
	    /* WALK(i,j); */
	 }
	 WALK(i,j);
	 o--;
	 jj = j; i--;
	 while (aux[++j]=='.');
	 while ((i>=0)&&(aux[i]=='.')) i--;
	 if (pt[j]!=i) {
	    backtrack_type = (o==0)? 'F' : 'M';
	    if (j-jj>8) { WALK((i+1),(jj)); }
	    WALK((i+1), (j-1));
	    while ((i>=0) &&(aux[i]==']')) {
	       i=pt[i]-1;
	       while ((i>=0)&&(aux[i]=='.')) i--;
	       WALK((i+1), (j-1));
	    }
	 }
      }
   }
 adios:
   backtrack_type='F';
   if ((dist>0)&&(inv_verbose)) printf("%s\n%s\n", wstring, wstruct);
   /*if ((dist==0)||(give_up==0))*/ strcpy(start, string);
   free(wstring); free(wstruct);
   free(string); free(aux);
   free(pt);
/*   if (dist>0) printf("%3d \n", nc2); */
   return dist;
}

/*-------------------------------------------------------------------------*/

PUBLIC float inverse_pf_fold(char *start, char *target)
{
   double dist;
   int dang;

   dang=dangles;
   if (dangles!=0) dangles=2;

   update_fold_params();    /* make sure there is a valid pair matrix */
   make_pairset();
   make_start(start, target);
   fold_type=1;
   do_backtrack = 0;
   dist = adaptive_walk(start, target);
   dangles=dang;
   return (dist+final_cost);
}

/*-------------------------------------------------------------------------*/

PRIVATE void make_start(char* start, const char *structure)
{
   int i,j,k,l,r,length;
   int *table, *S, sym[MAXALPHA], ss;

   length=strlen(start);
   table = (int *) vrna_alloc(sizeof(int)*length);
   S = (int *) vrna_alloc(sizeof(int)*length);

   make_ptable(structure, table);
   for (i=0; i<strlen(start); i++) S[i] = encode_char(toupper(start[i]));
   for (i=0; i<strlen(symbolset); i++) sym[i] = i;

   for (k=0; k<length; k++) {
      if (table[k]<k) continue;
      if (((vrna_urn()<0.5) && isupper(start[k])) ||
	  islower(start[table[k]])) {
	i = table[k]; j = k;
      } else {
	i = k; j = table[k];
      }

      if (!pair[S[i]][S[j]]) {   /* make a valid pair by mutating j */
	shuffle(sym, (int) base);
	for (l=0; l<base; l++) {
	  ss = encode_char(symbolset[sym[l]]);
	  if (pair[S[i]][ss]) break;
	}
	if (l==base) { /* nothing pairs start[i] */
	  r = 2*vrna_int_urn(0, npairs-1);
	  start[i] = pairset[r];
	  start[j] = pairset[r+1];
	} else start[j] = symbolset[sym[l]];
      }
   }
   free(table);
   free(S);
}

/*---------------------------------------------------------------------------*/

PRIVATE void make_pairset(void)
{
   int i,j;
   int sym[MAXALPHA];

   make_pair_matrix();
   base = strlen(symbolset);

   for (i=0; i< base; i++) sym[i] = encode_char(symbolset[i]);

   for (i=npairs=0; i< base; i++)
      for (j=0; j<base; j++)
	 if (pair[sym[i]][sym[j]]) {
	    pairset[npairs++] = symbolset[i];
	    pairset[npairs++] = symbolset[j];
	 }
   npairs /= 2;
   if (npairs==0) vrna_message_error("No pairs in this alphabet!");
}
/*---------------------------------------------------------------------------*/

PRIVATE double mfe_cost(const char *string, char *structure, const char *target)
{
#if TDIST
   Tree *T1;
   char *xstruc;
#endif
   double energy, distance;

   if (strlen(string)!=strlen(target)) {
      fprintf(stderr, "%s\n%s\n", string, target);
      vrna_message_error("unequal length in mfe_cost");
   }
   energy = fold(string, structure);
#if TDIST
   if (T0 == NULL) {
      xstruc = expand_Full(target);
      T0=make_tree(xstruc);
      free(xstruc);
   }

   xstruc = expand_Full(structure);
   T1=make_tree(xstruc);
   distance = tree_edit_distance(T0,T1);
   free(xstruc);
   free_tree(T1);
#else
   distance = (double) vrna_bp_distance(target, structure);
#endif
   cost2 = energy_of_structure(string, target, 0) - energy;
   return (double) distance;
}
/*---------------------------------------------------------------------------*/

PRIVATE double pf_cost(const char *string, char *structure, const char *target)
{
#if PF
   double  f, e;

   f = pf_fold(string, structure);
   e = energy_of_structure(string, target, 0);
   return (double) (e-f-final_cost);
#else
   vrna_message_error("this version not linked with pf_fold");
   return 0;
#endif
}

/*---------------------------------------------------------------------------*/

PRIVATE char *aux_struct(const char* structure )
{
   int       *match_paren;
   int          i, o, p;
   char        *string;

   string = (char *) vrna_alloc(sizeof(char)*(strlen(structure)+1));
   match_paren = (int *) vrna_alloc(sizeof(int)*(strlen(structure)/2+1));
   strcpy(string, structure);

   i = o = 0;
   while (string[i]) {
      switch (string[i]) {
       case '.': break;
       case '(':
	 match_paren[++o]=i;
	 break;
       case ')':
	 p=i;
	 while ((string[p+1]==')')&&(match_paren[o-1]==match_paren[o]-1)) {
	    p++; o--;
	 }
	 string[p]=']';
	 i=p;
	 string[match_paren[o]]='[';
	 o--;
	 break;
       default:
	 vrna_message_error("Junk in structure at aux_structure\n");
      }
      i++;
   }
   free(match_paren);
   return(string);
}
ProfileDist.c/  0           0     0     644     7034      `
/*
	  Functions for handling the Base Pair Probability Matrix
		      Peter F Stadler, Ivo L Hofacker
			    Vienna RNA Package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include "dist_vars.h"
#include "fold_vars.h"
#include "part_func.h"
#include "utils.h"
#include "profiledist.h"

PRIVATE int *alignment[2];

PRIVATE void    sprint_aligned_bppm(const float *T1, const float *T2);
PRIVATE double  PrfEditCost(int i, int j, const float *T1, const float *T2);
PRIVATE double  average(double x, double y);

/*---------------------------------------------------------------------------*/

PUBLIC float profile_edit_distance(const float *T1, const float *T2)
{
  /* align the 2 probability profiles T1, T2 */
  /* This is like a Needleman-Wunsch alignment,
     we should really use affine gap-costs ala Gotoh */

  float    **distance;
  short    **i_point, **j_point;

  int           i, j, i1, j1, pos, length1,length2;
  float         minus, plus, change, temp;

  length1 = (int) T1[0];
  length2 = (int) T2[0];
  distance = (float **)     vrna_alloc((length1 +1)*sizeof(float *));
  if(edit_backtrack){
    i_point  = (short **)  vrna_alloc((length1 +1)*sizeof(short *));
    j_point  = (short **)  vrna_alloc((length1 +1)*sizeof(short *));
  }
  for(i=0; i<= length1; i++){
    distance[i] = (float *) vrna_alloc( (length2+1)*sizeof(float));
    if(edit_backtrack){
      i_point[i]  = (short *) vrna_alloc( (length2+1)*sizeof(short));
      j_point[i]  = (short *) vrna_alloc( (length2+1)*sizeof(short));
    }
  }

  for(i = 1; i <= length1; i++) {
    distance[i][0] = distance[i-1][0]+PrfEditCost(i,0,T1,T2);
    if(edit_backtrack){ i_point[i][0] = (short) i-1; j_point[i][0] = 0;   }
  }
  for(j = 1; j <= length2; j++) {
    distance[0][j] = distance[0][j-1]+PrfEditCost(0,j,T1,T2);
    if(edit_backtrack){ i_point[0][j] = 0;   j_point[0][j] = (short) j-1; }
  }
  for (i = 1; i <= length1; i++) {
    for (j = 1; j <= length2 ; j++) {
      minus  = distance[i-1][j]  + PrfEditCost(i,0,T1,T2);
      plus   = distance[i][j-1]  + PrfEditCost(0,j,T1,T2);
      change = distance[i-1][j-1]+ PrfEditCost(i,j,T1,T2);

      distance[i][j] = MIN3(minus, plus, change);
      /* printf("%g ", distance[i][j]); */

      if(edit_backtrack){
	if(distance[i][j] == change) {
	  i_point[i][j]= (short)i-1; j_point[i][j]= (short) j-1;  }
	else if(distance[i][j] == plus) {
	  i_point[i][j]= (short)i  ; j_point[i][j]= (short)j-1;  }
	else {
	  i_point[i][j]= (short)i-1; j_point[i][j]= (short)j  ;  }
      }
    }
    /* printf("\n"); */
  }
  /* printf("\n"); */
  temp = distance[length1][length2];
  for(i=0;i<=length1;i++)
    free(distance[i]);
  free(distance);

  if(edit_backtrack){
    alignment[0] = (int *) vrna_alloc((length1+length2+1)*sizeof(int));
    alignment[1] = (int *) vrna_alloc((length1+length2+1)*sizeof(int));

    pos = length1+length2;
    i   = length1;
    j   = length2;
    while( (i>0)||(j>0) ) {
      i1 = i_point[i][j];
      j1 = j_point[i][j];
      if( ((i-i1)==1)&&((j-j1)==1) )  {  /* substitution    */
	alignment[0][pos] = i;
	alignment[1][pos] = j;
      }
      if( ((i-i1)==1)&&(j==j1) )      {  /* Deletion in [1] */
	alignment[0][pos] = i;
	alignment[1][pos] = 0;
      }
      if( (i==i1)&&((j-j1)==1)  )      {  /* Deletion in [0] */
	alignment[0][pos] = 0;
	alignment[1][pos] = j;
      }
      pos--;
      i = i1;
      j = j1;
    }
    for(i=pos+1; i<=length1+length2; i++){
      alignment[0][i-pos] = alignment[0][i];
      alignment[1][i-pos] = alignment[1][i];
    }
    alignment[0][0] = length1+length2-pos;   /* length of alignment */

    for(i=0; i<=length1; i++){
      free(i_point[i]); free(j_point[i]);
    }
    free(i_point); free(j_point);
    sprint_aligned_bppm(T1,T2);
    free(alignment[0]);
    free(alignment[1]);
  }

  return temp;
}


/*---------------------------------------------------------------------------*/

PRIVATE double PrfEditCost(int i, int j, const float *T1, const float *T2)
{
  double  dist;
  int    k, kmax;

  kmax = (int) T1[1];
  if ((int) T2[1] != kmax) vrna_message_error("inconsistent Profiles in PrfEditCost");

  if(i==0) {
    for(dist = 0. ,k=0 ; k<kmax ; k++)
      dist += T2[j*kmax+k];
  }
  if(j==0) {
    for(dist = 0. ,k=0 ; k<kmax ; k++)
      dist += T1[i*kmax+k];
  }
  if((i>0)&&(j>0)) {
    for(dist = 2.,k=0; k<kmax; k++)
      dist -= 2.*average(T1[i*kmax+k],T2[j*kmax+k]);
  }
  return dist;
}

/*---------------------------------------------------------------------------*/

PRIVATE double average(double x, double y)

/* can be essentially anything that fulfils :
   1.)     a(x,y)  =  a(y,x)
   2.)     a(x,y) >=  0       for 0<= x,y <= 1
   3.)     a(x,y) <=  (x+y)/2
   4.)     a(x,x) >=  a(x,y)  for 0<= x,y <= 1
   As in Bonhoeffer et al (1993) 'RNA Multi Structure Landscapes',
   Eur. Biophys. J. 22: 13-24 we have chosen  the geometric mean.
*/

{
    float a;
    a = (float) sqrt(x*y);
    return a;
}

/*---------------------------------------------------------------------------*/

PUBLIC float *Make_bp_profile_bppm(FLT_OR_DBL *bppm, int length){
   int i,j;
   int L=3;
   float *P; /* P[i*3+0] unpaired, P[i*3+1] upstream, P[i*3+2] downstream p */
   int *index = vrna_idx_row_wise((unsigned) length);

   P =  (float *) vrna_alloc((length+1)*3*sizeof(float));
   /* indices start at 1 use first entries to store length and dimension */
   P[0] = (float) length;
   P[1] = (float) L;

   for( i=1; i<length; i++)
     for( j=i+1; j<=length; j++ ) {
       P[i*L+1] += bppm[index[i]-j];
       P[j*L+2] += bppm[index[i]-j];
     }
   for( i=1; i<=length; i++)
     P[i*3+0] = 1 - P[i*3+1] - P[i*3+2];

   free(index);

   return (float *) P;
}

/*---------------------------------------------------------------------------*/

PRIVATE void sprint_aligned_bppm(const float *T1, const float *T2)
{
   int     i, length;
   length = alignment[0][0];
   aligned_line[0] = (char *) vrna_alloc((length+1)*sizeof(char));
   aligned_line[1] = (char *) vrna_alloc((length+1)*sizeof(char));
   for(i=1; i<=length; i++){
      if(alignment[0][i] ==0) aligned_line[0][i-1] = '_';
      else { aligned_line[0][i-1] = vrna_bpp_symbol(T1+alignment[0][i]*3); }
      if(alignment[1][i] ==0) aligned_line[1][i-1] = '_';
      else { aligned_line[1][i-1] = vrna_bpp_symbol(T2+alignment[1][i]*3); }
   }
}

/*---------------------------------------------------------------------------*/

PUBLIC void print_bppm(const float *T)
{
   int i;
   for(i=1; i<=( (int)T[0]); i++)
      printf("%c",vrna_bpp_symbol(T+i*3));
   printf("\n");
}

/*---------------------------------------------------------------------------*/

PUBLIC void     free_profile(float *T)
{
   free(T);
}

/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/

PUBLIC float *Make_bp_profile(int length){
   return Make_bp_profile_bppm(pr, length);
}


RNAstruct.c/    0           0     0     644     13240     `
/*
		parse and convert secondary structures
	   Walter Fontana, Ivo L Hofacker, Peter F Stadler
			Vienna RNA Package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "utils.h"
#include "RNAstruct.h"

#define PRIVATE  static
#define PUBLIC

#define MAXLEN    10000


PRIVATE char *aux_struct(const char *structure);

/* on return from parse_structure(), b2C() or b2Shapiro() ... */
PUBLIC int    loop_size[STRUC];       /* contains loop sizes of a structure */
PUBLIC int    helix_size[STRUC];      /* contains helix sizes of a structure */
PUBLIC int    loop_degree[STRUC];     /* contains loop degrees of a structure */
PUBLIC int    loops;                  /* n of loops and stacks in a structure */
PUBLIC int    unpaired, pairs;        /* n of unpaired digits and pairs */

/*---------------------------------------------------------------------------*/

PRIVATE char *aux_struct(const char* structure )
{
   short        *match_paren;
   int          i, o, p;
   char        *string;

   string = (char *) vrna_alloc(sizeof(char)*(strlen(structure)+1));
   match_paren = (short *) vrna_alloc(sizeof(short)*(strlen(structure)/2+1));
   strcpy(string, structure);

   i = o = 0;
   while (string[i]) {
      switch (string[i]) {
       case '.': break;
       case '(':
	 match_paren[++o]=i;
	 break;
       case ')':
	 p=i;
	 while ((string[p+1]==')')&&(match_paren[o-1]==match_paren[o]-1)) {
	    p++; o--;
	 }
	 string[p]=']';
	 i=p;
	 string[match_paren[o]]='[';
	 o--;
	 break;
       default:
	 vrna_message_error("Junk in structure at aux_structure\n");
      }
      i++;
   }
   free(match_paren);
   return(string);
}

/*---------------------------------------------------------------------------*/

PUBLIC char *b2HIT(const char *structure)
{

   int            i, u, p, l;
   char          *string, *temp, *HIT, tt[10];

   temp = (char *) vrna_alloc(strlen(structure)*4+4);
   string = aux_struct( structure );

   strcpy(temp,"(");
   i=p=u=0; l=1;
   while (string[i]) {
      switch(string[i]) {
       case '.':
	 u++; break;
       case '[':
	 if (u>0) {
	    sprintf(tt, "(U%d)" , u);
	    strcat(temp+l, tt);
	    l+=strlen(tt);
	    u=0;
	 }
	 strcat(temp+l, "("); l++;
	 break;
       case ')':
	 if (u>0) {
	    sprintf(tt, "(U%d)" , u);
	    strcat(temp+l, tt);
	    l+=strlen(tt);
	    u=0;
	 }
	 p++;
	 break;
       case ']':
	 if (u>0) {
	    sprintf(tt, "(U%d)" , u);
	    strcat(temp+l, tt);
	    l+=strlen(tt);
	    u=0;
	 }
	 sprintf(tt,"P%d)", p+1);
	 strcat(temp+l, tt);
	 l+=strlen(tt);
	 p=0;
	 break;
      }
      i++;
   }
   if (u>0) {
      sprintf(tt, "(U%d)" , u);
      strcat(temp+l, tt);
      l+=strlen(tt);
   }
   strcat(temp+l, "R)");

   free( string );

   HIT = (char *) vrna_alloc(sizeof(char)*(strlen(temp)+2));
   strcpy(HIT, temp);
   free(temp);
   return(HIT);
}

/*---------------------------------------------------------------------------*/

PUBLIC char *b2C(const char *structure )
{
   short *bulge, *loop;

   int    i, lp, p, l;
   char  *string, *Coarse, *temp;

   bulge = (short *) vrna_alloc(sizeof(short)*(strlen(structure)/3+1));
   loop = (short *) vrna_alloc(sizeof(short)*(strlen(structure)/3+1));
   temp = (char *) vrna_alloc(4*strlen(structure)+2);

   for (i = 0; i < STRUC; i++) {
      loop_size[i] = helix_size[i] = 0;
   }
   loop_degree[0]=0;         /* open structure has degree 0 */
   pairs = unpaired = loops = lp = 0;
   loop[0]=0;

   string = aux_struct( structure );

   i=p=l=0;
   temp[l++] = '(';
   while (string[i]) {
      switch(string[i]) {
       case '.':
	 loop_size[loop[lp]]++;
	 break;
       case '[':
	 temp[l++]='(';
	 if ((i>0)&&(string[i-1]=='(')) bulge[lp]=1;
	 lp++;
	 loop_degree[++loops]=1;
	 loop[lp]=loops;
	 bulge[lp]=0;
	 break;
       case ')':
	 if (string[i-1]==']') bulge[lp]=1;
	 p++;
	 break;
       case ']':
	 if (string[i-1]==']') bulge[lp]=1;
	 switch (loop_degree[loop[lp]]) {
	  case 1:  temp[l++]='H'; break;           /* hairpin */
	  case 2:
	    if (bulge[lp]==1)
	       temp[l++] = 'B';                    /* bulge */
	    else
	       temp[l++] = 'I';                    /* internal loop */
	    break;
	  default: temp[l++] = 'M';                /* multiloop */
	 }
	 temp[l++] = ')';
	 pairs+=p+1;
	 p=0;
	 loop_degree[loop[--lp]]++;
	 break;
      }
      i++;
   }
   temp[l++] = 'R';
   temp[l++] = ')';
   temp[l]='\0';
   free(string);
   Coarse = (char *) vrna_alloc(sizeof(char)*(strlen(temp)+2));
   strcpy(Coarse, temp);
   free(temp);
   free(bulge); free(loop);
   return(Coarse);
}

/*---------------------------------------------------------------------------*/

PUBLIC char *b2Shapiro(const char *structure )
{

   short *bulge, *loop;

   int            i, lp, p, l, k;
   char          *string, *Shapiro, *temp, tt[10];

   bulge = (short *) vrna_alloc(sizeof(short)*(strlen(structure)/3+1));
   loop = (short *) vrna_alloc(sizeof(short)*(strlen(structure)/3+1));
   temp = (char *) vrna_alloc(4*strlen(structure)+3);

   for (i = 0; i < STRUC; i++) {
      loop_size[i] = helix_size[i] = 0;
   }
   loop_degree[0]=0;         /* open structure has degree 0 */
   pairs = unpaired = loops = lp = 0;
   loop[0]=0;

   string = aux_struct( structure );

   i=p=l=0;
   temp[l++] = '(';    /* root */
   while (string[i]) {
      switch(string[i]) {
       case '.':
	 unpaired++;
	 loop_size[loop[lp]]++;
	 break;
       case '[':
	 temp[l++]='(';
	 temp[l++]='(';
	 if ((i>0)&&(string[i-1]=='(' || string[i-1]=='['))
	   bulge[lp]=1;
	 lp++;
	 loop_degree[++loops]=1;
	 loop[lp]=loops;
	 bulge[lp]=0;
	 break;
       case ')':
	 if (string[i-1]==']') bulge[lp]=1;
	 p++;
	 break;
       case ']':
	 if (string[i-1]==']') bulge[lp]=1;
	 switch (loop_degree[loop[lp]]) {
	  case 1:  temp[l++]='H'; break;           /* hairpin */
	  case 2:
	    if (bulge[lp]==1)
	       temp[l++] = 'B';                    /* bulge */
	    else
	       temp[l++] = 'I';                    /* internal loop */
	    break;
	  default: temp[l++] = 'M';                /* multiloop */
	 }
	 helix_size[loop[lp]]=p+1;

         sprintf(tt, "%d)" , loop_size[loop[lp]]);
         for(k=0; k<strlen(tt); k++) temp[l++] = tt[k];
	 sprintf(tt, "S%d)" , helix_size[loop[lp]]);
         for(k=0; k<strlen(tt); k++) temp[l++] = tt[k];

	 pairs+=p+1;
	 p=0;
	 loop_degree[loop[--lp]]++;
	 break;
      }
      i++;
   }

   *tt = '\0';
   if (loop_size[0]) sprintf(tt, "E%d)" , loop_size[0]);
   strcat(tt,"R)");
   temp[l]='\0';
   strcat(temp, tt);
   Shapiro = (char *) vrna_alloc(sizeof(char)*(strlen(temp)+2));
   if (loop_size[0]) {
      Shapiro[0]='(';
      strcpy(Shapiro+1, temp);
   } else strcpy(Shapiro, temp);
   free(string);
   free(temp);
   free(loop); free(bulge);
   return Shapiro;
}




/*---------------------------------------------------------------------------*/

PUBLIC void parse_structure(const char *structure)

/*-----------------------------------------------------------------------------

    upon return from parse_structure():

    loops    ....................... number of loops or stacks in structure.
    loop_size[1 <= i <= loops] ..... size of i-th loop.
    loop_size[0] ................... number of external digits.
    loop_degree[1 <= i <= loops] ... degree (branches) of i-th loop.
    loop_degree[0] ................. number of components.
    helix_size[1 <= i <= loops] .... size of i-th stack.
    unpaired ....................... n of unpaired digits.
    pairs .......................... n of base pairs.

-----------------------------------------------------------------------------*/

{
   short  *bulge, *loop;

   int            i, lp, p;
   char          *string, *temp;

   temp = (char *)  vrna_alloc(strlen(structure)*4+2);
   bulge = (short *) vrna_alloc(sizeof(short)*(strlen(structure)/3+1));
   loop = (short *) vrna_alloc(sizeof(short)*(strlen(structure)/3+1));

   for (i = 0; i < STRUC; i++) {
      loop_size[i] = helix_size[i] = 0;
   }
   loop[0] = loop_degree[0]=0;         /* open structure has degree 0 */
   pairs = unpaired = loops = lp = 0;
   *temp='\0';

   string = aux_struct(structure);

   i=p=0;
   while (string[i]) {
      switch(string[i]) {
       case '.':
	 unpaired++;
	 loop_size[loop[lp]]++;
	 break;
       case '[':
	 if ((i>0)&&(string[i-1]=='(')) bulge[lp]=1;
	 lp++;
	 loop_degree[++loops]=1;
	 loop[lp]=loops;
	 bulge[lp]=0;
	 break;
       case ')':
	 if (string[i-1]==']') bulge[lp]=1;
	 p++;
	 break;
       case ']':
	 if (string[i-1]==']') bulge[lp]=1;
	 helix_size[loop[lp]]=p+1;
	 pairs+=p+1;
	 p=0;
	 loop_degree[loop[--lp]]++;
	 break;
      }
      i++;
   }
   free(string);
   free(bulge); free(loop);
   free(temp);
}

/*---------------------------------------------------------------------------*/

PUBLIC char *add_root(const char *structure)
{
    char *xS;
    xS = (char *) vrna_alloc(sizeof(char)*(strlen(structure)+4));
    xS[0] = '(';
    strcat(xS,structure);
    strcat(xS,"R)");
    return xS;
}


/*---------------------------------------------------------------------------*/

PUBLIC char *expand_Shapiro(const char *structure)
{
   char  *xS, *temp;
   int  i, l;

   temp = (char *) vrna_alloc(4*strlen(structure)+2);

   i = 1;
   l = 1;
   temp[0] = '(';
   while (i<strlen(structure)-1) {
      temp[l++] = structure[i];
      if      (structure[i] == '(') temp[l++] = '(';
      else if (structure[i] == ')') {
	 temp[l++] = 'S';
	 temp[l++] = ')';
      }
      i++;
   }
   temp[l++] = ')';
   temp[l] = '\0';

   xS = (char *) vrna_alloc(sizeof(char)*(strlen(temp)+1));
   strcpy(xS, temp);
   free(temp);
   return (xS);
}

/*---------------------------------------------------------------------------*/

PUBLIC char *expand_Full(const char *structure)
{
    char *xF, *temp;
    int  i, l;

    temp = (char *) vrna_alloc(4*strlen(structure)+2);

    i = 0;
    l = 0;
    while (structure[i]) {
        if      (structure[i] == '(') temp[l++] = '(';
        else if (structure[i] == ')') {
            temp[l++] = 'P';
	    temp[l++] = ')';
        }
        else {
            temp[l++] = '(';
            temp[l++] = 'U';
            temp[l++] = ')';
        }
        i++;
     }
     temp[l] = '\0';

     xF = (char *) vrna_alloc(sizeof(char)*(l+5));
     strcpy(xF, "(");
     strcat(xF, temp);
     strcat(xF, "R)");
     free(temp);
     return (xF);
}

/*---------------------------------------------------------------------------*/

PUBLIC char *unexpand_Full(const char *structure)
{
   short        *match_paren;
   char id[10], *full, *temp;
   int    i, j, k, l, o, w;

   temp = (char *) vrna_alloc(4*strlen(structure)+2);
   match_paren = (short *) vrna_alloc(sizeof(short)*(strlen(structure)/2+1));

   i = strlen(structure)-1;
   l = o = 0; k=9;
   id[9]='\0';
   while (i>=0) {
     switch (structure[i]) {
     case '(':
       for (j=0; j<match_paren[o]; j++) temp[l++]='(';
       match_paren[o--] = 0;
       break;
     case 'U':
       w=1;
       sscanf(id+k, "%d", &w);
       for (j=0; j<w; j++) temp[l++]='.';
       k=9;
       break;
     case 'P':
           w=1;
       sscanf(id+k, "%d", &w);
       for (j=0; j<w; j++) temp[l++]=')';
       match_paren[o]=w;
       k=9;
       break;
     case 'R':
       break;
     case ')':
       o++;
       break;
     default:
       id[--k]=structure[i];
     }
     i--;
   }

   temp[l] = '\0';
   full = (char *) vrna_alloc(sizeof(char)*(l+1));
   for (i=0; i<l; i++) full[i]=temp[l-i-1];
   full[l]='\0';
   free(temp);
   free(match_paren);
   return full;
}


/*---------------------------------------------------------------------------*/

PUBLIC char *unweight(const char *structure)
{
   int i,l;
   char *full, *temp;

   temp = (char *) vrna_alloc(4*strlen(structure)+1);

   i=l=0;
   while (structure[i]) {
      if (!isdigit((int)structure[i])) temp[l++]=structure[i];
      i++;
   }
   temp[l]='\0';
   full = (char *) vrna_alloc(sizeof(char)*(l+1));
   strcpy(full, temp);
   free(temp);
   return full;
}

/*---------------------------------------------------------------------------*/

PUBLIC void unexpand_aligned_F(char *align[2])
{
   char *t0, *t1;
   int i,l;

   t0 = (char *) vrna_alloc(strlen(align[0])+1);
   t1 = (char *) vrna_alloc(strlen(align[0])+1);

   for (i=0, l=0; i<strlen(align[0]); i++) {
      switch (align[0][i]) {
       case '(':
       case ')':
	 t0[l] = align[0][i];
	 t1[l++]=align[1][i];
	 break;
       case 'U':
	 switch (align[1][i]) {
	  case 'U':
	    t0[l-1]=t1[l-1]='.';
	    break;
	  case '_':
	    t0[l-1]='.';
	    t1[l-1]='_';
	    break;
	  case 'P':
	    t0[l-1]='_'; t0[l]='.';
	    t1[l-1]='('; t1[l]=')'; l++;
	 }
	 while (align[0][i]!=')') i++;
	 break;
       case '_':
	 switch (align[1][i]) {
	  case '(':
	  case ')':
	    t0[l] = align[0][i];
	    t1[l++]=align[1][i];
	    break;
	  case 'U':
	    while (align[1][i]!=')') i++;
	    t1[l-1]='.';
	    t0[l-1]='_';
	    break;
	 }
       case 'P':
	 if (align[1][i]=='U') {
	    t1[l-1]='_'; t1[l]='.'; t0[l++]=')';
	    while (align[0][i]!=')') i++;
	 }
	 break;
      }
   }
   t0[l-1]=t1[l-1]='\0';
   strcpy(align[0], t0+1);
   strcpy(align[1], t1+1);
   free(t0); free(t1);
}
utils.c/        0           0     0     644     10761     `
/*
                               utils.c

                 c  Ivo L Hofacker and Walter Fontana
                          Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>
#include <time.h>
#include <string.h>
#include <sys/types.h>
#include <stdint.h>

/* for getpid() we need some distinction between UNIX and Win systems */
#ifdef _WIN32
#include <windows.h>
#define getpid() GetCurrentProcessId() /* rename windows specific getpid function */
#else
#include <unistd.h>
#endif

#include "utils.h"

#ifdef WITH_DMALLOC
#include "dmalloc.h"
#endif

#define PRIVATE  static
#define PUBLIC

#include "color_output.inc"

/*@notnull@ @only@*/
PUBLIC unsigned short xsubi[3];

PRIVATE char  scale1[] = "....,....1....,....2....,....3....,....4";
PRIVATE char  scale2[] = "....,....5....,....6....,....7....,....8";
PRIVATE char  *inbuf = NULL;

PRIVATE char  *inbuf2 = NULL;
PRIVATE unsigned int typebuf2 = 0;

/*-------------------------------------------------------------------------*/

#ifndef WITH_DMALLOC
/* include the following two functions only if not including <dmalloc.h> */

PUBLIC void *
vrna_alloc(unsigned size){

  void *pointer;

  if ( (pointer = (void *) calloc(1, (size_t) size)) == NULL) {
#ifdef EINVAL
    if (errno==EINVAL) {
      fprintf(stderr,"vrna_alloc: requested size: %d\n", size);
      vrna_message_error("Memory allocation failure -> EINVAL");
    }
    if (errno==ENOMEM)
#endif
      vrna_message_error("Memory allocation failure -> no memory");
  }
  return  pointer;
}

PUBLIC void *
vrna_realloc(void *p, unsigned size){

  if (p == NULL)
    return vrna_alloc(size);
  p = (void *) realloc(p, size);
  if (p == NULL) {
#ifdef EINVAL
    if (errno==EINVAL) {
      fprintf(stderr,"vrna_realloc: requested size: %d\n", size);
      vrna_message_error("vrna_realloc allocation failure -> EINVAL");
    }
    if (errno==ENOMEM)
#endif
      vrna_message_error("vrna_realloc allocation failure -> no memory");
  }
  return p;
}

#endif

/*------------------------------------------------------------------------*/

PUBLIC void
vrna_message_error(const char message[]){       /* output message upon error */

#ifndef WITHOUT_TTY_COLORS
  if(isatty(fileno(stderr)))
    fprintf(stderr, ANSI_COLOR_RED_B "ERROR: " ANSI_COLOR_RESET ANSI_COLOR_BRIGHT "%s" ANSI_COLOR_RESET "\n", message);
  else
#endif
    fprintf(stderr, "ERROR: %s\n", message);
  exit(EXIT_FAILURE);
}

PUBLIC void
vrna_message_warning(const char message[]){
#ifndef WITHOUT_TTY_COLORS
  if(isatty(fileno(stderr)))
    fprintf(stderr, ANSI_COLOR_MAGENTA_B "WARNING: " ANSI_COLOR_RESET ANSI_COLOR_BRIGHT "%s" ANSI_COLOR_RESET "\n", message);
  else
#endif
    fprintf(stderr, "WARNING: %s\n", message);
}

PUBLIC void
vrna_message_info(FILE *fp, const char message[]){
  if(!fp)
    fp = stdout;

#ifndef WITHOUT_TTY_COLORS
  if(isatty(fileno(fp)))
    fprintf(fp, ANSI_COLOR_BLUE_B "%s" ANSI_COLOR_RESET "\n", message);
  else
#endif
    fprintf(fp, "%s\n", message);
}

PRIVATE uint32_t
rj_mix( uint32_t a,
        uint32_t b,
        uint32_t c){

/*
  This is Robert Jenkins' 96 bit Mix function

  we use it to produce a more diverse seed for our random number
  generators. E.g.:
  
  seed = rj_mix(clock(), time(NULL), getpid());

  original comments on that function can be found below
*/


/*
--------------------------------------------------------------------
mix -- mix 3 32-bit values reversibly.
For every delta with one or two bits set, and the deltas of all three
  high bits or all three low bits, whether the original value of a,b,c
  is almost all zero or is uniformly distributed,
* If mix() is run forward or backward, at least 32 bits in a,b,c
  have at least 1/4 probability of changing.
* If mix() is run forward, every bit of c will change between 1/3 and
  2/3 of the time.  (Well, 22/100 and 78/100 for some 2-bit deltas.)
mix() was built out of 36 single-cycle latency instructions in a 
  structure that could supported 2x parallelism, like so:
      a -= b; 
      a -= c; x = (c>>13);
      b -= c; a ^= x;
      b -= a; x = (a<<8);
      c -= a; b ^= x;
      c -= b; x = (b>>13);
      ...
  Unfortunately, superscalar Pentiums and Sparcs can't take advantage 
  of that parallelism.  They've also turned some of those single-cycle
  latency instructions into multi-cycle latency instructions.  Still,
  this is the fastest good hash I could find.  There were about 2^^68
  to choose from.  I only looked at a billion or so.
--------------------------------------------------------------------
*/

  a=a-b;  a=a-c;  a=a^(c >> 13);
  b=b-c;  b=b-a;  b=b^(a << 8); 
  c=c-a;  c=c-b;  c=c^(b >> 13);
  a=a-b;  a=a-c;  a=a^(c >> 12);
  b=b-c;  b=b-a;  b=b^(a << 16);
  c=c-a;  c=c-b;  c=c^(b >> 5);
  a=a-b;  a=a-c;  a=a^(c >> 3);
  b=b-c;  b=b-a;  b=b^(a << 10);
  c=c-a;  c=c-b;  c=c^(b >> 15);
  return c;
}

/*------------------------------------------------------------------------*/
PUBLIC void
vrna_init_rand(void){

  uint32_t seed = rj_mix(clock(), time(NULL), getpid());

  xsubi[0] = xsubi[1] = xsubi[2] = (unsigned short) seed;  /* lower 16 bit */
  xsubi[1] += (unsigned short) ((unsigned)seed >> 6);
  xsubi[2] += (unsigned short) ((unsigned)seed >> 12);
#ifndef HAVE_ERAND48
  srand((unsigned int) seed);
#endif
}

/*------------------------------------------------------------------------*/

/* uniform random number generator; vrna_urn() is in [0,1] */
/* uses a linear congruential library routine */
/* 48 bit arithmetic */
PUBLIC double
vrna_urn(void){

#ifdef HAVE_ERAND48
  extern double erand48(unsigned short[]);
  return erand48(xsubi);
#else
  return ((double) rand())/RAND_MAX;
#endif
}

/*------------------------------------------------------------------------*/

PUBLIC int
vrna_int_urn(int from, int to){

  return ( ( (int) (vrna_urn()*(to-from+1)) ) + from );
}

/*------------------------------------------------------------------------*/

PUBLIC void
vrna_file_copy(FILE *from, FILE *to){

  int c;

  while ((c = getc(from)) != EOF) (void)putc(c, to);
}

/*-----------------------------------------------------------------*/

PUBLIC char *
vrna_time_stamp(void){

  time_t  cal_time;

  cal_time = time(NULL);
  return ( ctime(&cal_time) );
}

/*-----------------------------------------------------------------*/

PUBLIC char *get_line(FILE *fp) /* reads lines of arbitrary length from fp */
{
  char s[512], *line, *cp;
  int len=0, size=0, l;
  line=NULL;
  do {
    if (fgets(s, 512, fp)==NULL) break;
    cp = strchr(s, '\n');
    if (cp != NULL) *cp = '\0';
    l = len + (int)strlen(s);
    if (l+1>size) {
      size = (int)((l+1)*1.2);
      line = (char *) vrna_realloc(line, size*sizeof(char));
    }
    strcat(line+len, s);
    len=l;
  } while(cp==NULL);

  return line;
}

PUBLIC  unsigned int get_input_line(char **string, unsigned int option){
  char  *line;
  int   i, l, r;

  /*
  * read lines until informative data appears or
  * report an error if anything goes wrong
  */
  if((line = get_line(stdin))==NULL) return VRNA_INPUT_ERROR;

  if(!(option & VRNA_INPUT_NOSKIP_COMMENTS))
    while((*line=='*')||(*line=='\0')){
      free(line);
      if((line = get_line(stdin))==NULL) return VRNA_INPUT_ERROR;
    }

  l = (int) strlen(line);

  /* break on '@' sign if not disabled */
  if(*line == '@'){
    free(line);
    return VRNA_INPUT_QUIT;
  }
  /* print line read if not disabled */
  /* if(!(option & VRNA_INPUT_NOPRINT)) printf("%s\n", line); */

  /* eliminate whitespaces at the end of the line read */
  if(!(option & VRNA_INPUT_NO_TRUNCATION)){
    for(i = l-1; i >= 0; i--){
      if      (line[i] == ' ')  continue;
      else if (line[i] == '\t') continue;
      else                      break;
    }
    line[(i >= 0) ? (i+1) : 0] = '\0';
  }

  if(*line == '>'){
    /* fasta header */
    /* alloc memory for the string */
    *string = (char *) vrna_alloc(sizeof(char) * (strlen(line) + 1));
    r = VRNA_INPUT_FASTA_HEADER;
    i = sscanf(line, ">%s", *string);
    if(i > 0){
      i       = (int)     strlen(*string);
      *string = (char *)  vrna_realloc(*string, (i+1)*sizeof(char));
      free(line);
      return r;
    }
    else{
      free(line);
      free(*string);
      *string = NULL;
      return VRNA_INPUT_ERROR;
    }
  }
  else{
    *string = strdup(line);
    free(line);
  }
  return VRNA_INPUT_MISC;
}

/*-----------------------------------------------------------------*/

/*--------------------------------------------------------------------------*/


PUBLIC void
vrna_message_input_seq_simple(void){

  vrna_message_input_seq("Input string (upper or lower case)");
}

PUBLIC  void
vrna_message_input_seq(const char *s){
#ifndef WITHOUT_TTY_COLORS
  if(isatty(fileno(stdout))){
    printf("\n" ANSI_COLOR_CYAN "%s; @ to quit" ANSI_COLOR_RESET "\n", s);
    printf(ANSI_COLOR_BRIGHT "%s%s" ANSI_COLOR_RESET "\n", scale1, scale2);
  } else {
#endif
    printf("\n%s; @ to quit\n", s);
    printf("%s%s\n", scale1, scale2);
#ifndef WITHOUT_TTY_COLORS
  }
#endif
  (void) fflush(stdout);
}

PUBLIC int *
vrna_idx_row_wise(unsigned int length){

  int i;
  int *idx = (int *)vrna_alloc(sizeof(int) * (length+1));
  for (i=1; i <= length; i++)
    idx[i] = (((length + 1 - i) * (length - i)) / 2) + length + 1;
  return idx;
}

PUBLIC int *
vrna_idx_col_wise(unsigned int length){

  unsigned int i;
  int *idx = (int *)vrna_alloc(sizeof(int) * (length+1));
  for (i = 1; i <= length; i++)
    idx[i] = (i*(i-1)) / 2; 
  return idx;
}


#ifdef  VRNA_BACKWARD_COMPAT

/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/

PUBLIC int *
get_iindx(unsigned int length){

  return vrna_idx_row_wise(length);
}

PUBLIC int *
get_indx(unsigned int length){

  return vrna_idx_col_wise(length);
}

PUBLIC void
print_tty_input_seq(void){

  vrna_message_input_seq_simple();
}

PUBLIC void
print_tty_input_seq_str(const char *s){

  vrna_message_input_seq(s);
}

PUBLIC void
warn_user(const char message[]){

  vrna_message_warning(message);
}

PUBLIC void
nrerror(const char message[]){

  vrna_message_error(message);
}

PUBLIC void *space(unsigned size) {

  return vrna_alloc(size);
}

#undef  xrealloc
/* dmalloc.h #define's vrna_realloc */
PUBLIC void *xrealloc(void *p, unsigned size){

  return vrna_realloc(p, size);
}

PUBLIC void
init_rand(void){

  vrna_init_rand();
}

PUBLIC double urn(void){

  return vrna_urn();
}

PUBLIC int
int_urn(int from, int to){

  return vrna_int_urn(from, to);
}

PUBLIC void
filecopy(FILE *from, FILE *to){

  vrna_file_copy(from, to);
}

PUBLIC char *
time_stamp(void){

  return vrna_time_stamp();
}

#endif

mfe.c/          0           0     0     644     41625     `
/** \file **/

/*
                  minimum free energy
                  RNA secondary structure prediction

                  c Ivo Hofacker, Chrisoph Flamm
                  original implementation by
                  Walter Fontana
                  g-quadruplex support and threadsafety
                  by Ronny Lorenz

                  Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>

#include "utils.h"
#include "energy_par.h"
#include "data_structures.h"
#include "fold_vars.h"
#include "params.h"
#include "constraints.h"
#include "gquad.h"
#include "loop_energies.h"
#include "mfe.h"

/* make this interface backward compatible with RNAlib < 2.2.0 */
#define VRNA_BACKWARD_COMPAT

#define MAXSECTORS        500     /* dimension for a backtrack array */

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/

PRIVATE int           fill_arrays(vrna_fold_compound_t *vc);
PRIVATE void          fill_arrays_circ(vrna_fold_compound_t *vc, sect bt_stack[], int *bt);
PRIVATE void          backtrack(vrna_fold_compound_t *vc, vrna_bp_stack_t *bp_stack, sect bt_stack[], int s);

PRIVATE int           fill_arrays_comparative(vrna_fold_compound_t *vc);
PRIVATE void          fill_arrays_comparative_circ(vrna_fold_compound_t *vc, sect bt_stack[], int *bt);
PRIVATE void          backtrack_comparative(vrna_fold_compound_t *vc, vrna_bp_stack_t *bp_stack, sect bt_stack[], int s);


/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PUBLIC float
vrna_mfe( vrna_fold_compound_t *vc,
          char *structure){


  int     length, energy, s;
  float   mfe;
  char    *ss;
  sect    bt_stack[MAXSECTORS]; // stack of partial structures for backtracking 
  vrna_bp_stack_t   *bp;

  s       = 0;
  mfe     = (float)(INF/100.);
 
  if(vc){
    length  = (int) vc->length;
   
    vrna_fold_compound_prepare(vc, VRNA_OPTION_MFE);

   // call user-defined recursion status callback function
    if(vc->stat_cb)
      vc->stat_cb(VRNA_STATUS_MFE_PRE, vc->auxdata);

    switch(vc->type){
      case VRNA_VC_TYPE_SINGLE:     energy = fill_arrays(vc);
                                    if(vc->params->model_details.circ){
                                      fill_arrays_circ(vc, bt_stack, &s);
                                      energy = vc->matrices->Fc;
                                    }
                                    break;

      case VRNA_VC_TYPE_ALIGNMENT:  energy = fill_arrays_comparative(vc);
                                    if(vc->params->model_details.circ){
                                      fill_arrays_comparative_circ(vc, bt_stack, &s);
                                      energy = vc->matrices->Fc;
                                    }
                                    break;

      default:                      vrna_message_warning("unrecognized fold compound type");
                                    return mfe;
                                    break;
    }


    
    // call user-defined recursion status callback function
    if(vc->stat_cb)
      vc->stat_cb(VRNA_STATUS_MFE_POST, vc->auxdata);


     

    if(structure && vc->params->model_details.backtrack){
      bp = (vrna_bp_stack_t *)vrna_alloc(sizeof(vrna_bp_stack_t) * (4*(1+length/2))); // add a guess of how many G's may be involved in a G quadruplex


      switch(vc->type){
       // case VRNA_VC_TYPE_ALIGNMENT:  backtrack_comparative(vc, bp, bt_stack, s);
                                     // break;

        case VRNA_VC_TYPE_SINGLE:    //fall through 

        default:                      backtrack(vc, bp, bt_stack, s);
                                      break;
      }
     

      ss = vrna_db_from_bp_stack(bp, length);
      strncpy(structure, ss, length + 1);
      free(ss);


#ifdef  VRNA_BACKWARD_COMPAT

      //  Backward compatibility:
      //  This block may be removed if deprecated functions
      //  relying on the global variable "base_pair" vanish from within the package!

      {
        if(base_pair) free(base_pair);
        base_pair = bp;
      }
#endif
	
    }

    


    if (vc->params->model_details.backtrack_type=='C')
      mfe = (float) vc->matrices->c[vc->jindx[length]+1]/100.;
    else if (vc->params->model_details.backtrack_type=='M')
      mfe = (float) vc->matrices->fML[vc->jindx[length]+1]/100.;
    else
      mfe = (float) energy/100.;

    if(vc->type == VRNA_VC_TYPE_ALIGNMENT)
      mfe /= (float)vc->n_seq;

  }

  return mfe;
}

/**
*** fill "c", "fML" and "f5" arrays and return  optimal energy
**/
PRIVATE int
fill_arrays(vrna_fold_compound_t *vc){

  int               i, j, ij, length, energy, new_c, stackEnergy, no_close, type_2;
  int               noGUclosure, noLP, uniq_ML, with_gquad, dangle_model, *rtype, *indx;
  int               *my_f5, *my_c, *my_fML, *my_fM1, *my_ggg, hc_decompose, *hc_up_ml;
  int               *cc, *cc1;  /* auxilary arrays for canonical structures     */
  int               *Fmi;       /* holds row i of fML (avoids jumps in memory)  */
  int               *DMLi;      /* DMLi[j] holds  MIN(fML[i,k]+fML[k+1,j])      */
  int               *DMLi1;     /*                MIN(fML[i+1,k]+fML[k+1,j])    */
  int               *DMLi2;     /*                MIN(fML[i+2,k]+fML[k+1,j])    */
  unsigned char     type;
  char              *ptype, *hard_constraints;
  short             *S1;
  vrna_param_t      *P;
  vrna_mx_mfe_t     *matrices;
  vrna_hc_t         *hc;
  vrna_sc_t         *sc;

  length            = (int)vc->length;
  ptype             = vc->ptype;
  indx              = vc->jindx;
  P                 = vc->params;
  S1                = vc->sequence_encoding;
  noGUclosure       = P->model_details.noGUclosure;
  noLP              = P->model_details.noLP;
  uniq_ML           = P->model_details.uniq_ML;
  with_gquad        = P->model_details.gquad;
  dangle_model      = P->model_details.dangles;
  rtype             = &(P->model_details.rtype[0]);
  hc                = vc->hc;
  hard_constraints  = hc->matrix;
  hc_up_ml          = hc->up_ml;
  sc                = vc->sc;
  matrices          = vc->matrices;
  my_f5             = matrices->f5;
  my_c              = matrices->c;
  my_fML            = matrices->fML;
  my_fM1            = matrices->fM1;
  my_ggg            = matrices->ggg;


  /* allocate memory for all helper arrays */
  cc    = (int *) vrna_alloc(sizeof(int)*(length + 2));
  cc1   = (int *) vrna_alloc(sizeof(int)*(length + 2));
  Fmi   = (int *) vrna_alloc(sizeof(int)*(length + 1));
  DMLi  = (int *) vrna_alloc(sizeof(int)*(length + 1));
  DMLi1 = (int *) vrna_alloc(sizeof(int)*(length + 1));
  DMLi2 = (int *) vrna_alloc(sizeof(int)*(length + 1));


  /* prefill helper arrays */
  for(j = 0; j <= length; j++){
    Fmi[j] = DMLi[j] = DMLi1[j] = DMLi2[j] = INF;
  }




  // prefill matrices with init contributions 
  /*
  for(j = 1; j <= length; j++)
    for(i = (j > TURN ? (j - TURN) : 1); i < j; i++){
      my_c[indx[j] + i] = my_fML[indx[j] + i] = INF;
      if(uniq_ML)
        my_fM1[indx[j] + i] = INF;
    }
    */
   

  /* start recursion */

  if (length <= TURN){
    /* clean up memory */
    free(cc);
    free(cc1);
    free(Fmi);
    free(DMLi);
    free(DMLi1);
    free(DMLi2);
    /* return free energy of unfolded chain */
    return 0;
  }

  for (i = length-TURN-1; i >= 1; i--) { /* i,j in [1..length] */

    for (j = i+TURN+1; j <= length; j++) {
      ij            = indx[j]+i;


      if (matrices->evaluated[ij]) continue;

      type          = (unsigned char)ptype[ij];
      hc_decompose  = hard_constraints[ij];
      energy        = INF;

      no_close = (((type==3)||(type==4))&&noGUclosure);

      if (hc_decompose) {   /* we evaluate this pair */
        new_c = INF;

        if(!no_close){
          /* check for hairpin loop */
          energy = vrna_E_hp_loop(vc, i, j);
          new_c = MIN2(new_c, energy);

          /* check for multibranch loops */
          energy  = vrna_E_mb_loop_fast(vc, i, j, DMLi1, DMLi2);
          new_c   = MIN2(new_c, energy);
        }

        if(dangle_model == 3){ /* coaxial stacking */
          energy  = E_mb_loop_stack(i, j, vc);
          new_c   = MIN2(new_c, energy);
        }

        /* check for interior loops */
    	energy = vrna_E_int_loop(vc, i, j);
   	 	new_c = MIN2(new_c, energy);

        /* remember stack energy for --noLP option */
        if(noLP){
			stackEnergy = vrna_E_stack(vc, i, j);
			new_c       = MIN2(new_c, cc1[j-1]+stackEnergy);
			cc[j]       = new_c;
			my_c[ij]    = cc1[j-1]+stackEnergy;
        } else {
        	my_c[ij]    = new_c;
        }
      } /* end >> if (pair) << */

      else my_c[ij] = INF;

      /* done with c[i,j], now compute fML[i,j] and fM1[i,j] */

      my_fML[ij] = vrna_E_ml_stems_fast(vc, i, j, Fmi, DMLi);

      if(uniq_ML){  /* compute fM1 for unique decomposition */
		my_fM1[ij] = E_ml_rightmost_stem(i, j, vc);
      }

      matrices->evaluated[ij] = 1;


    } /* end of j-loop */

    {
      int *FF; /* rotate the auxilliary arrays */
      FF = DMLi2; DMLi2 = DMLi1; DMLi1 = DMLi; DMLi = FF;
      FF = cc1; cc1=cc; cc=FF;
      for (j=1; j<=length; j++) {cc[j]=Fmi[j]=DMLi[j]=INF; }
    }
  } /* end of i-loop */

  /* calculate energies of 5' fragments */
  E_ext_loop_5(vc);

  /* clean up memory */
  free(cc);
  free(cc1);
  free(Fmi);
  free(DMLi);
  free(DMLi1);
  free(DMLi2);

  return my_f5[length];
}

#include "circfold.inc"


/**
*** the actual forward recursion to fill the energy arrays
**/
PRIVATE int
fill_arrays_comparative(vrna_fold_compound_t *vc){

  int   i, j, k, p, q, energy, stackEnergy, new_c;
  int   decomp, MLenergy, new_fML;
  int   s, *type, type_2, tt;
  int   *cc;        /* linear array for calculating canonical structures */
  int   *cc1;       /*   "     "        */
  int   *Fmi;       /* holds row i of fML (avoids jumps in memory) */
  int   *DMLi;      /* DMLi[j] holds MIN(fML[i,k]+fML[k+1,j])  */
  int   *DMLi1;     /*             MIN(fML[i+1,k]+fML[k+1,j])  */
  int   *DMLi2;     /*             MIN(fML[i+2,k]+fML[k+1,j])  */


  int             n_seq         = vc->n_seq;
  int             length        = vc->length;
  short           **S           = vc->S;
  short           **S5          = vc->S5;     /*S5[s][i] holds next base 5' of i in sequence s*/
  short           **S3          = vc->S3;     /*Sl[s][i] holds next base 3' of i in sequence s*/
  char            **Ss          = vc->Ss;
  unsigned short  **a2s         = vc->a2s;
  vrna_param_t    *P            = vc->params;
  vrna_md_t       *md           = &(P->model_details);
  int             *indx         = vc->jindx;     /* index for moving in the triangle matrices c[] and fMl[]*/
  int             *c            = vc->matrices->c;     /* energy array, given that i-j pair */
  int             *f5           = vc->matrices->f5;     /* energy of 5' end */
  int             *fML          = vc->matrices->fML;     /* multi-loop auxiliary energy array */
  int             *ggg          = vc->matrices->ggg;
  int             *pscore       = vc->pscore;     /* precomputed array of pair types */
  short           *S_cons       = vc->S_cons;
  int             *rtype        = &(md->rtype[0]);
  int             dangle_model  = md->dangles;

  vrna_hc_t       *hc           = vc->hc;
  vrna_sc_t       **sc          = vc->scs;

  char              *hard_constraints = hc->matrix;

  type  = (int *) vrna_alloc(n_seq*sizeof(int));
  cc    = (int *) vrna_alloc(sizeof(int)*(length+2));
  cc1   = (int *) vrna_alloc(sizeof(int)*(length+2));
  Fmi   = (int *) vrna_alloc(sizeof(int)*(length+1));
  DMLi  = (int *) vrna_alloc(sizeof(int)*(length+1));
  DMLi1 = (int *) vrna_alloc(sizeof(int)*(length+1));
  DMLi2 = (int *) vrna_alloc(sizeof(int)*(length+1));

  /* init energies */

  int max_bpspan = (md->max_bp_span > 0) ? md->max_bp_span : length;

  for (j=1; j<=length; j++){
    Fmi[j]=DMLi[j]=DMLi1[j]=DMLi2[j]=INF;
    for (i=(j>TURN?(j-TURN):1); i<j; i++) {
      c[indx[j]+i] = fML[indx[j]+i] = INF;
    }
  }

  /* begin recursions */
  for (i = length-TURN-1; i >= 1; i--) { /* i,j in [1..length] */
    for (j = i+TURN+1; j <= length; j++) {
      int ij, psc, l1, maxq, minq, c0;
      ij = indx[j]+i;

      for (s=0; s<n_seq; s++) {
        type[s] = md->pair[S[s][i]][S[s][j]];
        if (type[s]==0) type[s]=7;
      }

      psc = pscore[indx[j]+i];
      if (hard_constraints[ij]) {   /* a pair to consider */
        new_c = INF;

        /* hairpin ----------------------------------------------*/
        energy  = vrna_E_hp_loop(vc, i, j);
        new_c   = MIN2(new_c, energy);

        /* check for multibranch loops */
        energy  = vrna_E_mb_loop_fast(vc, i, j, DMLi1, DMLi2);
        new_c   = MIN2(new_c, energy);

        /* check for interior loops */
        energy  = vrna_E_int_loop(vc, i, j);
        new_c   = MIN2(new_c, energy);

        /* remember stack energy for --noLP option */
        if(md->noLP){
          stackEnergy = vrna_E_stack(vc, i, j);
          new_c       = MIN2(new_c, cc1[j-1]+stackEnergy);
          cc[j]       = new_c - psc; /* add covariance bonnus/penalty */
          c[ij]       = cc1[j-1] + stackEnergy - psc;
        } else {
          c[ij]       = new_c - psc; /* add covariance bonnus/penalty */
        }
      } /* end >> if (pair) << */

      else c[ij] = INF;

      /* done with c[i,j], now compute fML[i,j] */
      fML[ij] = vrna_E_ml_stems_fast(vc, i, j, Fmi, DMLi);

    } /* END for j */

    {
      int *FF; /* rotate the auxilliary arrays */
      FF = DMLi2; DMLi2 = DMLi1; DMLi1 = DMLi; DMLi = FF;
      FF = cc1; cc1=cc; cc=FF;
      for (j=1; j<=length; j++) {cc[j]=Fmi[j]=DMLi[j]=INF; }
    }
  } /* END for i */
  /* calculate energies of 5' and 3' fragments */

  f5[0] = 0;
  for(j = 1; j <= TURN + 1; j++){
    if(hc->up_ext[j]){
      energy = f5[j-1];
      if((energy < INF) && sc)
        for(s=0;s < n_seq; s++){
          if(sc[s]){
            if(sc[s]->energy_up)
              energy += sc[s]->energy_up[a2s[s][j]][1];
          }
        }
    } else {
      energy = INF;
    }
    f5[j] = energy;
  }

  switch(dangle_model){
    case 0:   for(j = TURN + 2; j <= length; j++){
                f5[j] = INF;

                if(hc->up_ext[j]){
                  energy = f5[j-1];
                  if((energy < INF) && sc)
                    for(s=0; s < n_seq; s++){
                      if(sc[s]){
                        if(sc[s]->energy_up)
                          energy += sc[s]->energy_up[a2s[s][j]][1];
                      }
                    }
                  f5[j] = MIN2(f5[j], energy);
                }

                if (hard_constraints[indx[j]+1] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
                  if(c[indx[j]+1] < INF){
                    energy = c[indx[j]+1];
                    for(s = 0; s < n_seq; s++){
                      tt = md->pair[S[s][1]][S[s][j]];
                      if(tt==0) tt=7;
                      energy += E_ExtLoop(tt, -1, -1, P);
                    }
                    f5[j] = MIN2(f5[j], energy);
                  }

                  if(md->gquad){
                    if(ggg[indx[j]+1] < INF)
                      f5[j] = MIN2(f5[j], ggg[indx[j]+1]);
                  }
                }

                for(i = j - TURN - 1; i > 1; i--){
                  if(hard_constraints[indx[j]+i] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
                    if(c[indx[j]+i]<INF){
                      energy = f5[i-1] + c[indx[j]+i];
                      for(s = 0; s < n_seq; s++){
                        tt = md->pair[S[s][i]][S[s][j]];
                        if(tt==0) tt=7;
                        energy += E_ExtLoop(tt, -1, -1, P);
                      }
                      f5[j] = MIN2(f5[j], energy);
                    }

                    if(md->gquad){
                      if(ggg[indx[j]+i] < INF)
                        f5[j] = MIN2(f5[j], f5[i-1] + ggg[indx[j]+i]);
                    }
                  }
                }
              }
              break;

    default:  for(j = TURN + 2; j <= length; j++){
                f5[j] = INF;

                if(hc->up_ext[j]){
                  energy = f5[j-1];
                  if((energy < INF) && sc)
                    for(s=0; s < n_seq; s++){
                      if(sc[s]){
                        if(sc[s]->energy_up)
                          energy += sc[s]->energy_up[a2s[s][j]][1];
                      }
                    }
                  f5[j] = MIN2(f5[j], energy);
                }

                if(hard_constraints[indx[j]+1] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
                  if (c[indx[j]+1]<INF) {
                    energy = c[indx[j]+1];
                    for(s = 0; s < n_seq; s++){
                      tt = md->pair[S[s][1]][S[s][j]];
                      if(tt==0) tt=7;
                      energy += E_ExtLoop(tt, -1, (j<length) ? S3[s][j] : -1, P);
                    }
                    f5[j] = MIN2(f5[j], energy);
                  }

                  if(md->gquad){
                    if(ggg[indx[j]+1] < INF)
                      f5[j] = MIN2(f5[j], ggg[indx[j]+1]);
                  }
                }

                for(i = j - TURN - 1; i > 1; i--){
                  if(hard_constraints[indx[j]+i] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
                    if (c[indx[j]+i]<INF) {
                      energy = f5[i-1] + c[indx[j]+i];
                      for(s = 0; s < n_seq; s++){
                        tt = md->pair[S[s][i]][S[s][j]];
                        if(tt==0) tt=7;
                        energy += E_ExtLoop(tt, S5[s][i], (j < length) ? S3[s][j] : -1, P);
                      }
                      f5[j] = MIN2(f5[j], energy);
                    }

                    if(md->gquad){
                      if(ggg[indx[j]+i] < INF)
                        f5[j] = MIN2(f5[j], f5[i-1] + ggg[indx[j]+i]);
                    }
                  }
                }
              }
              break;
  }
  free(type);
  free(cc);
  free(cc1);
  free(Fmi);
  free(DMLi);
  free(DMLi1);
  free(DMLi2);
  return(f5[length]);
}

#include "alicircfold.inc"

PUBLIC void
vrna_backtrack_from_intervals(vrna_fold_compound_t *vc,
                              vrna_bp_stack_t *bp_stack,
                              sect bt_stack[],
                              int s){

  backtrack(vc, bp_stack, bt_stack, s);
}

/**
*** trace back through the "c", "f5" and "fML" arrays to get the
*** base pairing list. No search for equivalent structures is done.
*** This is fast, since only few structure elements are recalculated.
***
*** normally s=0.
*** If s>0 then s items have been already pushed onto the bt_stack
**/
PRIVATE void
backtrack(vrna_fold_compound_t *vc,
          vrna_bp_stack_t *bp_stack,
          sect bt_stack[],
          int s){

  int   i, j, ij, k, mm3, length, energy, en, newX;
  int   no_close, minq;
  int   b=0;
  unsigned char type, tt, type_2;
  char  *string         = vc->sequence;
  vrna_param_t  *P      = vc->params;
  int     *indx         = vc->jindx;
  char    *ptype        = vc->ptype;

  short *S1             = vc->sequence_encoding;
  short *S              = vc->sequence_encoding2;
  int   dangle_model    = P->model_details.dangles;
  int   noLP            = P->model_details.noLP;
  int   noGUclosure     = P->model_details.noGUclosure;
  int   *rtype          = &(P->model_details.rtype[0]);
  char  backtrack_type  = P->model_details.backtrack_type;
  int   with_gquad      = P->model_details.gquad;

  /* the folding matrices */
  int   *my_f5, *my_c, *my_fML, *my_ggg;


  length  = vc->length;
  my_f5   = vc->matrices->f5;
  my_c    = vc->matrices->c;
  my_fML  = vc->matrices->fML;
  my_ggg  = vc->matrices->ggg;

  vrna_hc_t *hc               = vc->hc;
  vrna_sc_t *sc               = vc->sc;
  char      *hard_constraints = hc->matrix;

  if (s==0) {
    bt_stack[++s].i = 1;
    bt_stack[s].j = length;
    bt_stack[s].ml = (backtrack_type=='M') ? 1 : ((backtrack_type=='C')? 2: 0);
  }


  int goto_repeat1;
  while (s>0) {

    goto_repeat1 = 0;
  	
    int ml, fij, fi, cij, traced, i1, j1, p, q, jj=0, gq=0;
    int canonical = 1;     // (i,j) closes a canonical structure

    // pop one element from stack
    i  = bt_stack[s].i;
    j  = bt_stack[s].j;
    ml = bt_stack[s--].ml;

    switch(ml){
      // backtrack in f5 
      case 0:   {
                  int p, q;
                  if(vrna_BT_ext_loop_f5(vc, &j, &p, &q, bp_stack, &b)){
                    if(j > 0){
                      bt_stack[++s].i = 1;
                      bt_stack[s].j   = j;
                      bt_stack[s].ml  = 0;
                    }
                    if(p > 0){
                      i = p;
                      j = q;
                      //goto repeat1;
                      goto_repeat1 = 1;
                      break;
                    }

                    continue;
                  } else {
                    fprintf(stderr, "%s\n", string);
                    vrna_message_error("backtrack failed in f5");
                  }
                }
                break;

      // trace back in fML array 
      case 1:   {
                  int p, q, comp1, comp2;
                  if(vrna_BT_mb_loop_split(vc, &i, &j, &p, &q, &comp1, &comp2, bp_stack, &b)){
                    if(i > 0){
                      bt_stack[++s].i = i;
                      bt_stack[s].j   = j;
                      bt_stack[s].ml  = comp1;
                    }
                    if(p > 0){
                      bt_stack[++s].i = p;
                      bt_stack[s].j   = q;
                      bt_stack[s].ml  = comp2;
                    }

                    continue;
                  } else {
                    fprintf(stderr, "%s\n", string);
                    vrna_message_error("backtrack failed in fML");
                  }
                }
                break;

      // backtrack in c 
      case 2:   bp_stack[++b].i = i;
                bp_stack[b].j   = j;
                //goto repeat1;
                goto_repeat1 = 1;
                break;

      default:  vrna_message_error("Backtracking failed due to unrecognized DP matrix!");
                break;
    }

    // Jordan Douglas, April 2018. I have turned the goto into a while loop so that it compiles on emscripten
    while (goto_repeat1) {
        
	    /*----- begin of "repeat:" -----*/
	    ij = indx[j]+i;

	    if (canonical)
	      cij = my_c[ij];

	    type = (unsigned char)ptype[ij];

	    if (noLP)
	      if(vrna_BT_stack(vc, &i, &j, &cij, bp_stack, &b)){
	        canonical = 0;
	        continue; //goto repeat1;
	      }

	    canonical = 1;

	    no_close = (((type==3)||(type==4))&&noGUclosure);

	    if (no_close) {
	      if (cij == FORBIDDEN) break; // continue;
	    } else {
	      if(vrna_BT_hp_loop(vc, i, j, cij, bp_stack, &b))
	        break; // continue;
	    }

	    if(vrna_BT_int_loop(vc, &i, &j, cij, bp_stack, &b)){
	      if(i < 0)
	        break; // continue;
	      else
	        continue; //goto repeat1;
	    }

	    /* (i.j) must close a multi-loop */
	    int comp1, comp2;

	    if(vrna_BT_mb_loop(vc, &i, &j, &k, cij, &comp1, &comp2)){
	      bt_stack[++s].i = i;
	      bt_stack[s].j   = k;
	      bt_stack[s].ml  = comp1;
	      bt_stack[++s].i = k + 1;
	      bt_stack[s].j   = j;
	      bt_stack[s].ml  = comp2;
	    } else {
	      vrna_message_error("backtracking failed in repeat");
	    }

  	    // end of repeat: --------------------------------------------------
    	goto_repeat1 = 0;
    }

  } // end of infinite while loop 

  bp_stack[0].i = b;    // save the total number of base pairs 

 
}




/**
*** backtrack in the energy matrices to obtain a structure with MFE
**/
PRIVATE void
backtrack_comparative(vrna_fold_compound_t *vc,
                      vrna_bp_stack_t *bp_stack,
                      sect bt_stack[],
                      int s) {

  /*------------------------------------------------------------------
    trace back through the "c", "f5" and "fML" arrays to get the
    base pairing list. No search for equivalent structures is done.
    This inverts the folding procedure, hence it's very fast.
    ------------------------------------------------------------------*/
   /* normally s=0.
     If s>0 then s items have been already pushed onto the sector stack */

  int  i, j, k, p, q, energy, en, c0, l1, minq, maxq, type_2, tt, mm, b=0, cov_en = 0, *type;

  int             n_seq         = vc->n_seq;
  int             length        = vc->length;
  short           **S           = vc->S;
  short           **S5          = vc->S5;     /*S5[s][i] holds next base 5' of i in sequence s*/
  short           **S3          = vc->S3;     /*Sl[s][i] holds next base 3' of i in sequence s*/
  char            **Ss          = vc->Ss;
  unsigned short  **a2s         = vc->a2s;
  vrna_param_t    *P            = vc->params;
  vrna_md_t       *md           = &(P->model_details);
  int             *indx         = vc->jindx;     /* index for moving in the triangle matrices c[] and fMl[]*/
  int             *c            = vc->matrices->c;     /* energy array, given that i-j pair */
  int             *f5           = vc->matrices->f5;     /* energy of 5' end */
  int             *fML          = vc->matrices->fML;     /* multi-loop auxiliary energy array */
  int             *pscore       = vc->pscore;     /* precomputed array of pair types */
  int             *ggg          = vc->matrices->ggg;
  short           *S_cons       = vc->S_cons;
  int             *rtype        = &(md->rtype[0]);
  int             dangle_model  = md->dangles;
  int             with_gquad    = md->gquad;

  vrna_hc_t       *hc           = vc->hc;
  vrna_sc_t       **sc          = vc->scs;

  type = (int *) vrna_alloc(n_seq*sizeof(int));

  if (s==0) {
    bt_stack[++s].i = 1;
    bt_stack[s].j = length;
    bt_stack[s].ml = (md->backtrack_type=='M') ? 1 : ((md->backtrack_type=='C')?2:0);
  }
  while (s>0) {
    int ss, ml, fij, fi, cij, traced, i1, j1, jj=0, gq=0;
    int canonical = 1;     /* (i,j) closes a canonical structure */
    i  = bt_stack[s].i;
    j  = bt_stack[s].j;
    ml = bt_stack[s--].ml;   /* ml is a flag indicating if backtracking is to
                              occur in the fML- (1) or in the f-array (0) */
    if (ml==2) {
      bp_stack[++b].i = i;
      bp_stack[b].j   = j;
      cov_en += pscore[indx[j]+i];
      goto repeat1_comparative;
    }

    if (j < i+TURN+1) continue; /* no more pairs in this interval */

    if(ml != 0){
      fij = fML[indx[j]+i];
      fi  = (hc->up_ml[j]) ? fML[indx[j-1]+i] + n_seq*P->MLbase : INF;
    } else {
      fij = f5[j];
      fi  = (hc->up_ext[j]) ? f5[j-1] : INF;
    }

    if(sc)
      for(ss = 0; ss < n_seq; ss++)
        if(sc[ss]){
          if(sc[ss]->energy_up)
            fi += sc[ss]->energy_up[a2s[ss][j]][1];
        }

    if (fij == fi) {  /* 3' end is unpaired */
      bt_stack[++s].i = i;
      bt_stack[s].j   = j-1;
      bt_stack[s].ml  = ml;
      continue;
    }

    if (ml == 0) { /* backtrack in f5 */
      switch(dangle_model){
        case 0:   /* j or j-1 is paired. Find pairing partner */
                  for (i=j-TURN-1,traced=0; i>=1; i--) {
                    int en;
                    jj = i-1;

                    if (hc->matrix[indx[j] + i] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
                      en = c[indx[j]+i] + f5[i-1];
                      for(ss = 0; ss < n_seq; ss++){
                        type[ss] = md->pair[S[ss][i]][S[ss][j]];
                        if (type[ss]==0) type[ss] = 7;
                        en += E_ExtLoop(type[ss], -1, -1, P);
                      }
                      if (fij == en) traced=j;
                    }

                    if(with_gquad){
                      if(fij == f5[i-1] + ggg[indx[j]+i]){
                        /* found the decomposition */
                        traced = j; jj = i - 1; gq = 1;
                        break;
                      }
                    }

                    if (traced) break;
                  }
                  break;
        default:  /* j or j-1 is paired. Find pairing partner */
                  for (i=j-TURN-1,traced=0; i>=1; i--) {
                    int en;
                    jj = i-1;
                    if (hc->matrix[indx[j] + i] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
                      en = c[indx[j]+i] + f5[i-1];
                      for(ss = 0; ss < n_seq; ss++){
                        type[ss] = md->pair[S[ss][i]][S[ss][j]];
                        if (type[ss]==0) type[ss] = 7;
                        en += E_ExtLoop(type[ss], (i>1) ? S5[ss][i]: -1, (j < length) ? S3[ss][j] : -1, P);
                      }
                      if (fij == en) traced=j;
                    }

                    if(with_gquad){
                      if(fij == f5[i-1] + ggg[indx[j]+i]){
                        /* found the decomposition */
                        traced = j; jj = i - 1; gq = 1;
                        break;
                      }
                    }

                    if (traced) break;
                  }
                  break;
      }

      if (!traced) vrna_message_error("backtrack failed in f5");
      /* push back the remaining f5 portion */
      bt_stack[++s].i = 1;
      bt_stack[s].j   = jj;
      bt_stack[s].ml  = ml;

      /* trace back the base pair found */
      j=traced;

      if(with_gquad && gq){
        /* goto backtrace of gquadruplex */
        goto repeat_gquad_comparative;
      }

      bp_stack[++b].i = i;
      bp_stack[b].j   = j;
      cov_en += pscore[indx[j]+i];
      goto repeat1_comparative;
    }
    else { /* trace back in fML array */
      if(hc->up_ml[i]){
        en = fML[indx[j]+i+1] + n_seq * P->MLbase;

        if(sc)
          for(ss = 0; ss < n_seq; ss++)
            if(sc[ss]){
              if(sc[ss]->energy_up)
                en += sc[ss]->energy_up[a2s[ss][i]][1];
            }

        if(en == fij) { /* 5' end is unpaired */
          bt_stack[++s].i = i+1;
          bt_stack[s].j   = j;
          bt_stack[s].ml  = ml;
          continue;
        }
      }

      if(md->gquad){
        if(fij == ggg[indx[j]+i] + n_seq * E_MLstem(0, -1, -1, P)){
          /* go to backtracing of quadruplex */
          goto repeat_gquad_comparative;
        }
      }

      if(hc->matrix[indx[j] + i] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC){
        cij = c[indx[j]+i];
        if(dangle_model){
          for(ss = 0; ss < n_seq; ss++){
            tt = md->pair[S[ss][i]][S[ss][j]];
            if(tt==0) tt=7;
            cij += E_MLstem(tt, S5[ss][i], S3[ss][j], P);
          }
        }
        else{
          for(ss = 0; ss < n_seq; ss++){
            tt = md->pair[S[ss][i]][S[ss][j]];
            if(tt==0) tt=7;
            cij += E_MLstem(tt, -1, -1, P);
          }
        }

        if (fij==cij){
          /* found a pair */
          bp_stack[++b].i = i;
          bp_stack[b].j   = j;
          cov_en += pscore[indx[j]+i];
          goto repeat1_comparative;
        }
      }

      for (k = i+1+TURN; k <= j-2-TURN; k++)
        if (fij == (fML[indx[k]+i]+fML[indx[j]+k+1]))
          break;

      bt_stack[++s].i = i;
      bt_stack[s].j   = k;
      bt_stack[s].ml  = ml;
      bt_stack[++s].i = k+1;
      bt_stack[s].j   = j;
      bt_stack[s].ml  = ml;

      if (k>j-2-TURN) vrna_message_error("backtrack failed in fML");
      continue;
    }

  repeat1_comparative:

    /*----- begin of "repeat:" -----*/
    if (canonical)  cij = c[indx[j]+i];

    for (ss=0; ss<n_seq; ss++) {
      type[ss] = md->pair[S[ss][i]][S[ss][j]];
      if (type[ss]==0) type[ss] = 7;
    }

    if (md->noLP)
      if (cij == c[indx[j]+i]) {
        /* (i.j) closes canonical structures, thus
           (i+1.j-1) must be a pair                */
        for (ss=0; ss<n_seq; ss++) {
          type_2 = md->pair[S[ss][j-1]][S[ss][i+1]];  /* j,i not i,j */
          if (type_2==0) type_2 = 7;
          cij -= P->stack[type[ss]][type_2];
          if(sc){
            if(sc[ss]->energy_bp)
              cij -= sc[s]->energy_bp[indx[j] + i];
          }
        }
        cij += pscore[indx[j]+i];
        bp_stack[++b].i = i+1;
        bp_stack[b].j   = j-1;
        cov_en += pscore[indx[j-1]+i+1];
        i++; j--;
        canonical=0;
        goto repeat1_comparative;
      }
    canonical = 1;
    cij += pscore[indx[j]+i];

    /* does (i,j) close a hairpin loop ? */
    if(vrna_BT_hp_loop(vc, i, j, cij, bp_stack, &b))
      continue;

    for (p = i+1; p <= MIN2(j-2-TURN,i+MAXLOOP+1); p++) {
      minq = j-i+p-MAXLOOP-2;
      if (minq<p+1+TURN) minq = p+1+TURN;
      if(hc->up_int[i+1] < (p - i - 1)) break;

      for (q = j-1; q >= minq; q--) {

        if(hc->up_int[q+1] < (j - q - 1)) break;

        if (c[indx[q]+p]>=INF) continue;

        for (ss=energy=0; ss<n_seq; ss++) {
          int u1 = a2s[ss][p-1] - a2s[ss][i];
          int u2 = a2s[ss][j-1] - a2s[ss][q];
          type_2 = md->pair[S[ss][q]][S[ss][p]];  /* q,p not p,q */
          if (type_2==0) type_2 = 7;
          energy += E_IntLoop(u1, u2, type[ss], type_2, S3[ss][i], S5[ss][j], S5[ss][p], S3[ss][q], P);

        }

        if(sc)
          for(ss = 0; ss < n_seq; ss++)
            if(sc[ss]){
              int u1 = a2s[ss][p-1] - a2s[ss][i];
              int u2 = a2s[ss][j-1] - a2s[ss][q];
/*
              int u1 = p - i - 1;
              int u2 = j - q - 1;
*/
              if(u1 + u2 == 0)
                if(sc[ss]->energy_stack){
                  if(S[ss][i] && S[ss][j] && S[ss][p] && S[ss][q]){ /* don't allow gaps in stack */
                    energy +=   sc[ss]->energy_stack[a2s[ss][i]]
                              + sc[ss]->energy_stack[a2s[ss][p]]
                              + sc[ss]->energy_stack[a2s[ss][q]]
                              + sc[ss]->energy_stack[a2s[ss][j]];
                  }
                }
              if(sc[ss]->energy_bp)
                energy += sc[ss]->energy_bp[indx[j] + i];

              if(sc[ss]->energy_up)
                energy +=   sc[ss]->energy_up[a2s[ss][i] + 1][u1]
                          + sc[ss]->energy_up[a2s[ss][q] + 1][u2];
            }

        traced = (cij == energy+c[indx[q]+p]);
        if (traced) {
          bp_stack[++b].i = p;
          bp_stack[b].j   = q;
          cov_en += pscore[indx[q]+p];
          i = p, j = q;
          goto repeat1_comparative;
        }
      }
    }

    /* end of repeat: --------------------------------------------------*/

    /* (i.j) must close a multi-loop */

    i1 = i+1;
    j1 = j-1;

    if(with_gquad){
      /*
        The case that is handled here actually resembles something like
        an interior loop where the enclosing base pair is of regular
        kind and the enclosed pair is not a canonical one but a g-quadruplex
        that should then be decomposed further...
      */
      mm = 0;
      for(ss=0;ss<n_seq;ss++){
        tt = type[ss];
        if(tt == 0) tt = 7;
        if(dangle_model == 2)
          mm += P->mismatchI[tt][S3[ss][i]][S5[ss][j]];
        if(tt > 2)
          mm += P->TerminalAU;
      }

      for(p = i + 2;
        p < j - VRNA_GQUAD_MIN_BOX_SIZE;
        p++){
        if(S_cons[p] != 3) continue;
        l1    = p - i - 1;
        if(l1>MAXLOOP) break;
        minq  = j - i + p - MAXLOOP - 2;
        c0    = p + VRNA_GQUAD_MIN_BOX_SIZE - 1;
        minq  = MAX2(c0, minq);
        c0    = j - 1;
        maxq  = p + VRNA_GQUAD_MAX_BOX_SIZE + 1;
        maxq  = MIN2(c0, maxq);
        for(q = minq; q < maxq; q++){
          if(S_cons[q] != 3) continue;
          c0  = mm + ggg[indx[q] + p] + n_seq * P->internal_loop[l1 + j - q - 1];
          if(cij == c0){
            i=p;j=q;
            goto repeat_gquad_comparative;
          }
        }
      }
      p = i1;
      if(S_cons[p] == 3){
        if(p < j - VRNA_GQUAD_MIN_BOX_SIZE){
          minq  = j - i + p - MAXLOOP - 2;
          c0    = p + VRNA_GQUAD_MIN_BOX_SIZE - 1;
          minq  = MAX2(c0, minq);
          c0    = j - 3;
          maxq  = p + VRNA_GQUAD_MAX_BOX_SIZE + 1;
          maxq  = MIN2(c0, maxq);
          for(q = minq; q < maxq; q++){
            if(S_cons[q] != 3) continue;
            if(cij == mm + ggg[indx[q] + p] + n_seq * P->internal_loop[j - q - 1]){
              i = p; j=q;
              goto repeat_gquad_comparative;
            }
          }
        }
      }
      q = j1;
      if(S_cons[q] == 3)
        for(p = i1 + 3; p < j - VRNA_GQUAD_MIN_BOX_SIZE; p++){
          l1    = p - i - 1;
          if(l1>MAXLOOP) break;
          if(S_cons[p] != 3) continue;
          if(cij == mm + ggg[indx[q] + p] + n_seq * P->internal_loop[l1]){
            i = p; j = q;
            goto repeat_gquad_comparative;
          }
        }
    }

    if(hc->matrix[indx[j] + i] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP){
      mm = n_seq*P->MLclosing;
      switch(dangle_model){
        case 0:   for(ss = 0; ss < n_seq; ss++){
                    tt = rtype[type[ss]];
                    mm += E_MLstem(tt, -1, -1, P);
                  }
                  break;
        default:  for(ss = 0; ss < n_seq; ss++){
                    tt = rtype[type[ss]];
                    mm += E_MLstem(tt, S5[ss][j], S3[ss][i], P);
                  }
                  break;
      }

      if(sc)
        for(ss = 0; ss < n_seq; ss++)
          if(sc[ss]){
            if(sc[ss]->energy_bp)
              mm += sc[ss]->energy_bp[indx[j] + i];
          }

      bt_stack[s+1].ml  = bt_stack[s+2].ml = 1;

      for (k = i1+TURN+1; k < j1-TURN-1; k++){
        if(cij == fML[indx[k]+i1] + fML[indx[j1]+k+1] + mm) break;
      }

      if (k<=j-3-TURN) { /* found the decomposition */
        bt_stack[++s].i = i1;
        bt_stack[s].j   = k;
        bt_stack[++s].i = k+1;
        bt_stack[s].j   = j1;
      } else {
          vrna_message_error("backtracking failed in repeat");
      }
    } else
      vrna_message_error("backtracking failed in repeat");

    continue; /* this is a workarround to not accidentally proceed in the following block */

  repeat_gquad_comparative:
    /*
      now we do some fancy stuff to backtrace the stacksize and linker lengths
      of the g-quadruplex that should reside within position i,j
    */
    {
      int cnt1, l[3], L, size;
      size = j-i+1;

      for(L=0; L < VRNA_GQUAD_MIN_STACK_SIZE;L++){
        if(S_cons[i+L] != 3) break;
        if(S_cons[j-L] != 3) break;
      }

      if(L == VRNA_GQUAD_MIN_STACK_SIZE){
        /* continue only if minimum stack size starting from i is possible */
        for(; L<=VRNA_GQUAD_MAX_STACK_SIZE;L++){
          if(S_cons[i+L-1] != 3) break; /* break if no more consecutive G's 5' */
          if(S_cons[j-L+1] != 3) break; /* break if no more consecutive G'1 3' */
          for(    l[0] = VRNA_GQUAD_MIN_LINKER_LENGTH;
                  (l[0] <= VRNA_GQUAD_MAX_LINKER_LENGTH)
              &&  (size - 4*L - 2*VRNA_GQUAD_MIN_LINKER_LENGTH - l[0] >= 0);
              l[0]++){
            /* check whether we find the second stretch of consecutive G's */
            for(cnt1 = 0; (cnt1 < L) && (S_cons[i+L+l[0]+cnt1] == 3); cnt1++);
            if(cnt1 < L) continue;
            for(    l[1] = VRNA_GQUAD_MIN_LINKER_LENGTH;
                    (l[1] <= VRNA_GQUAD_MAX_LINKER_LENGTH)
                &&  (size - 4*L - VRNA_GQUAD_MIN_LINKER_LENGTH - l[0] - l[1] >= 0);
                l[1]++){
              /* check whether we find the third stretch of consectutive G's */
              for(cnt1 = 0; (cnt1 < L) && (S_cons[i+2*L+l[0]+l[1]+cnt1] == 3); cnt1++);
              if(cnt1 < L) continue;

              /*
                the length of the third linker now depends on position j as well
                as the other linker lengths... so we do not have to loop too much
              */
              l[2] = size - 4*L - l[0] - l[1];
              if(l[2] < VRNA_GQUAD_MIN_LINKER_LENGTH) break;
              if(l[2] > VRNA_GQUAD_MAX_LINKER_LENGTH) continue;
              /* check for contribution */
              if(ggg[indx[j]+i] == E_gquad_ali(i, L, l, (const short **)S, n_seq, P)){
                int a;
                /* fill the G's of the quadruplex into base_pair2 */
                for(a=0;a<L;a++){
                  bp_stack[++b].i = i+a;
                  bp_stack[b].j   = i+a;
                  bp_stack[++b].i = i+L+l[0]+a;
                  bp_stack[b].j   = i+L+l[0]+a;
                  bp_stack[++b].i = i+L+l[0]+L+l[1]+a;
                  bp_stack[b].j   = i+L+l[0]+L+l[1]+a;
                  bp_stack[++b].i = i+L+l[0]+L+l[1]+L+l[2]+a;
                  bp_stack[b].j   = i+L+l[0]+L+l[1]+L+l[2]+a;
                }
                goto repeat_gquad_comparative_exit;
              }
            }
          }
        }
      }
      vrna_message_error("backtracking failed in repeat_gquad_comparative");
    }
  repeat_gquad_comparative_exit:
    __asm("nop");

  }

  /* fprintf(stderr, "covariance energy %6.2f\n", cov_en/100.);  */

  bp_stack[0].i = b;    /* save the total number of base pairs */
  free(type);
}


fold.c/         0           0     0     644     14705     `
/** \file **/

/*
                  minimum free energy
                  RNA secondary structure prediction

                  c Ivo Hofacker, Chrisoph Flamm
                  original implementation by
                  Walter Fontana
                  g-quadruplex support and threadsafety
                  by Ronny Lorenz

                  Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>

#include "utils.h"
#include "energy_par.h"
#include "data_structures.h"
#include "fold_vars.h"
#include "params.h"
#include "constraints.h"
#include "gquad.h"
#include "loop_energies.h"
#include "fold.h"

#ifdef  VRNA_BACKWARD_COMPAT

#ifdef _OPENMP
#include <omp.h>
#endif

#endif

#define MAXSECTORS        500     /* dimension for a backtrack array */

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/

#ifdef  VRNA_BACKWARD_COMPAT

/* some backward compatibility stuff */
PRIVATE int                 backward_compat           = 0;
PRIVATE vrna_fold_compound_t  *backward_compat_compound = NULL;

#ifdef _OPENMP

#pragma omp threadprivate(backward_compat_compound, backward_compat)

#endif

#endif

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/

#ifdef  VRNA_BACKWARD_COMPAT

/* wrappers for old API compatibility */
PRIVATE float wrap_fold( const char *string, char *structure, vrna_param_t *parameters, int is_constrained, int is_circular);
PRIVATE void  wrap_array_export(int **f5_p, int **c_p, int **fML_p, int **fM1_p, int **indx_p, char **ptype_p);
PRIVATE void  wrap_array_export_circ( int *Fc_p, int *FcH_p, int *FcI_p, int *FcM_p, int **fM2_p);

#endif

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PUBLIC float
vrna_fold(const char *string,
          char *structure){

  float                 mfe;
  vrna_fold_compound_t  *vc;
  vrna_md_t             md;

  vrna_md_set_default(&md);
  vc  = vrna_fold_compound(string, &md, 0);
  mfe = vrna_mfe(vc, structure);

  vrna_fold_compound_free(vc);

  return mfe;
}

PUBLIC float
vrna_circfold(const char *string,
              char *structure){

  float                 mfe;
  vrna_fold_compound_t  *vc;
  vrna_md_t             md;

  vrna_md_set_default(&md);
  md.circ = 1;
  vc      = vrna_fold_compound(string, &md, 0);
  mfe     = vrna_mfe(vc, structure);

  vrna_fold_compound_free(vc);

  return mfe;

}

/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/

#ifdef  VRNA_BACKWARD_COMPAT

PRIVATE void
wrap_array_export(int **f5_p,
                  int **c_p,
                  int **fML_p,
                  int **fM1_p,
                  int **indx_p,
                  char **ptype_p){

  /* make the DP arrays available to routines such as subopt() */
  if(backward_compat_compound){
    *f5_p     = backward_compat_compound->matrices->f5;
    *c_p      = backward_compat_compound->matrices->c;
    *fML_p    = backward_compat_compound->matrices->fML;
    *fM1_p    = backward_compat_compound->matrices->fM1;
    *indx_p   = backward_compat_compound->jindx;
    *ptype_p  = backward_compat_compound->ptype;
  }
}

PRIVATE void
wrap_array_export_circ( int *Fc_p,
                        int *FcH_p,
                        int *FcI_p,
                        int *FcM_p,
                        int **fM2_p){

  /* make the DP arrays available to routines such as subopt() */
  if(backward_compat_compound){
    *Fc_p   = backward_compat_compound->matrices->Fc;
    *FcH_p  = backward_compat_compound->matrices->FcH;
    *FcI_p  = backward_compat_compound->matrices->FcI;
    *FcM_p  = backward_compat_compound->matrices->FcM;
    *fM2_p  = backward_compat_compound->matrices->fM2;
  }
}

PRIVATE float
wrap_fold( const char *string,
          char *structure,
          vrna_param_t *parameters,
          int is_constrained,
          int is_circular){

  vrna_fold_compound_t  *vc;
  vrna_param_t          *P;

#ifdef _OPENMP
/* Explicitly turn off dynamic threads */
  omp_set_dynamic(0);
#endif

  /* we need the parameter structure for hard constraints */
  if(parameters){
    P = vrna_params_copy(parameters);
  } else {
    vrna_md_t md;
    set_model_details(&md);
    md.temperature = temperature;
    P = vrna_params(&md);
  }
  P->model_details.circ = is_circular;

  vc = vrna_fold_compound(string, &(P->model_details), VRNA_OPTION_DEFAULT);

  if(parameters){ /* replace params if necessary */
    free(vc->params);
    vc->params = P;
  } else {
    free(P);
  }

  /* handle hard constraints in pseudo dot-bracket format if passed via simple interface */
  if(is_constrained && structure){
    unsigned int constraint_options = 0;
    constraint_options |= VRNA_CONSTRAINT_DB
                          | VRNA_CONSTRAINT_DB_PIPE
                          | VRNA_CONSTRAINT_DB_DOT
                          | VRNA_CONSTRAINT_DB_X
                          | VRNA_CONSTRAINT_DB_ANG_BRACK
                          | VRNA_CONSTRAINT_DB_RND_BRACK;

    vrna_constraints_add(vc, (const char *)structure, constraint_options);
  }

  if(backward_compat_compound && backward_compat)
    vrna_fold_compound_free(backward_compat_compound);

  backward_compat_compound  = vc;
  backward_compat           = 1;

  return vrna_mfe(vc, structure);
}

PUBLIC void
free_arrays(void){

  if(backward_compat_compound && backward_compat){
    vrna_fold_compound_free(backward_compat_compound);
    backward_compat_compound = NULL;
    backward_compat          = 0;
  }
}

PUBLIC float
fold_par( const char *string,
          char *structure,
          vrna_param_t *parameters,
          int is_constrained,
          int is_circular){

  return wrap_fold(string, structure, parameters, is_constrained, is_circular);

}

PUBLIC float
fold( const char *string,
      char *structure){

  return wrap_fold(string, structure, NULL, fold_constrained, 0);
}

PUBLIC float
circfold( const char *string,
          char *structure){

  return wrap_fold(string, structure, NULL, fold_constrained, 1);
}

PUBLIC void
initialize_fold(int length){

  /* DO NOTHING */
}

PUBLIC void
update_fold_params(void){

  vrna_md_t           md;

  if(backward_compat_compound && backward_compat){
    set_model_details(&md);
    vrna_params_reset(backward_compat_compound, &md);
  }
}

PUBLIC void
update_fold_params_par(vrna_param_t *parameters){

  vrna_md_t           md;

  if(backward_compat_compound && backward_compat){
    if(parameters)
      vrna_params_subst(backward_compat_compound, parameters);
    else{
      set_model_details(&md);
      vrna_params_reset(backward_compat_compound, &md);
    }
  }
}

PUBLIC void
export_fold_arrays( int **f5_p,
                    int **c_p,
                    int **fML_p,
                    int **fM1_p,
                    int **indx_p,
                    char **ptype_p){

  wrap_array_export(f5_p,c_p,fML_p,fM1_p,indx_p,ptype_p);
}

PUBLIC void
export_fold_arrays_par( int **f5_p,
                        int **c_p,
                        int **fML_p,
                        int **fM1_p,
                        int **indx_p,
                        char **ptype_p,
                        vrna_param_t **P_p){

  wrap_array_export(f5_p,c_p,fML_p,fM1_p,indx_p,ptype_p);
  if(backward_compat_compound) *P_p  = backward_compat_compound->params;
}

PUBLIC void
export_circfold_arrays( int *Fc_p,
                        int *FcH_p,
                        int *FcI_p,
                        int *FcM_p,
                        int **fM2_p,
                        int **f5_p,
                        int **c_p,
                        int **fML_p,
                        int **fM1_p,
                        int **indx_p,
                        char **ptype_p){

  wrap_array_export(f5_p,c_p,fML_p,fM1_p,indx_p,ptype_p);
  wrap_array_export_circ(Fc_p,FcH_p,FcI_p,FcM_p,fM2_p);
}

PUBLIC void
export_circfold_arrays_par( int *Fc_p,
                            int *FcH_p,
                            int *FcI_p,
                            int *FcM_p,
                            int **fM2_p,
                            int **f5_p,
                            int **c_p,
                            int **fML_p,
                            int **fM1_p,
                            int **indx_p,
                            char **ptype_p,
                            vrna_param_t **P_p){

  wrap_array_export(f5_p,c_p,fML_p,fM1_p,indx_p,ptype_p);
  wrap_array_export_circ(Fc_p,FcH_p,FcI_p,FcM_p,fM2_p);
  if(backward_compat_compound) *P_p  = backward_compat_compound->params;
}

PUBLIC char *
backtrack_fold_from_pair( char *sequence,
                          int i,
                          int j){

  char          *structure  = NULL;
  unsigned int  length      = 0;
  vrna_bp_stack_t         *bp         = NULL;
  sect          bt_stack[MAXSECTORS]; /* stack of partial structures for backtracking */

  if(sequence){
    length = strlen(sequence);
    bp = (vrna_bp_stack_t *)vrna_alloc(sizeof(vrna_bp_stack_t) * (1+length/2));
  } else {
    vrna_message_error("backtrack_fold_from_pair@fold.c: no sequence given");
  }

  bt_stack[1].i  = i;
  bt_stack[1].j  = j;
  bt_stack[1].ml = 2;

  bp[0].i = 0; /* ??? this is set by backtrack anyway... */

  vrna_backtrack_from_intervals(backward_compat_compound, bp, bt_stack, 1);
  structure = vrna_db_from_bp_stack(bp, length);

  /* backward compatibitlity stuff */
  if(base_pair) free(base_pair);
  base_pair = bp;

  return structure;
}

#define STACK_BULGE1      1       /* stacking energies for bulges of size 1 */
#define NEW_NINIO         1       /* new asymetry penalty */

PUBLIC int HairpinE(int size, int type, int si1, int sj1, const char *string) {
  vrna_param_t  *P  = backward_compat_compound->params;
  int energy;

  energy = (size <= 30) ? P->hairpin[size] :
    P->hairpin[30]+(int)(P->lxc*log((size)/30.));

  if (tetra_loop){
    if (size == 4) { /* check for tetraloop bonus */
      char tl[7]={0}, *ts;
      strncpy(tl, string, 6);
      if ((ts=strstr(P->Tetraloops, tl)))
        return (P->Tetraloop_E[(ts - P->Tetraloops)/7]);
    }
    if (size == 6) {
      char tl[9]={0}, *ts;
      strncpy(tl, string, 8);
      if ((ts=strstr(P->Hexaloops, tl)))
        return (energy = P->Hexaloop_E[(ts - P->Hexaloops)/9]);
    }
    if (size == 3) {
      char tl[6]={0,0,0,0,0,0}, *ts;
      strncpy(tl, string, 5);
      if ((ts=strstr(P->Triloops, tl))) {
        return (P->Triloop_E[(ts - P->Triloops)/6]);
      }
      if (type>2)  /* neither CG nor GC */
        energy += P->TerminalAU; /* penalty for closing AU GU pair IVOO??
                                    sind dass jetzt beaunuesse oder mahlnuesse (vorzeichen?)*/
      return energy;
    }
   }
   energy += P->mismatchH[type][si1][sj1];

  return energy;
}

/*---------------------------------------------------------------------------*/

PUBLIC int oldLoopEnergy(int i, int j, int p, int q, int type, int type_2) {

  vrna_param_t  *P  = backward_compat_compound->params;
  short   *S1 = backward_compat_compound->sequence_encoding;

  /* compute energy of degree 2 loop (stack bulge or interior) */
  int n1, n2, m, energy;
  n1 = p-i-1;
  n2 = j-q-1;

  if (n1>n2) { m=n1; n1=n2; n2=m; } /* so that n2>=n1 */

  if (n2 == 0)
    energy = P->stack[type][type_2];   /* stack */

  else if (n1==0) {                  /* bulge */
    energy = (n2<=MAXLOOP)?P->bulge[n2]:
      (P->bulge[30]+(int)(P->lxc*log(n2/30.)));

#if STACK_BULGE1
    if (n2==1) energy+=P->stack[type][type_2];
#endif
  } else {                           /* interior loop */

    if ((n1+n2==2)&&(james_rule))
      /* special case for loop size 2 */
      energy = P->int11[type][type_2][S1[i+1]][S1[j-1]];
    else {
      energy = (n1+n2<=MAXLOOP)?(P->internal_loop[n1+n2]):
        (P->internal_loop[30]+(int)(P->lxc*log((n1+n2)/30.)));

#if NEW_NINIO
      energy += MIN2(MAX_NINIO, (n2-n1)*P->ninio[2]);
#else
      m       = MIN2(4, n1);
      energy += MIN2(MAX_NINIO,((n2-n1)*P->ninio[m]));
#endif
      energy += P->mismatchI[type][S1[i+1]][S1[j-1]]+
        P->mismatchI[type_2][S1[q+1]][S1[p-1]];
    }
  }
  return energy;
}

/*--------------------------------------------------------------------------*/

PUBLIC int LoopEnergy(int n1, int n2, int type, int type_2,
                      int si1, int sj1, int sp1, int sq1) {

  vrna_param_t  *P  = backward_compat_compound->params;
  /* compute energy of degree 2 loop (stack bulge or interior) */
  int nl, ns, energy;

  if (n1>n2) { nl=n1; ns=n2;}
  else {nl=n2; ns=n1;}

  if (nl == 0)
    return P->stack[type][type_2];    /* stack */

  if (ns==0) {                       /* bulge */
    energy = (nl<=MAXLOOP)?P->bulge[nl]:
      (P->bulge[30]+(int)(P->lxc*log(nl/30.)));
    if (nl==1) energy += P->stack[type][type_2];
    else {
      if (type>2) energy += P->TerminalAU;
      if (type_2>2) energy += P->TerminalAU;
    }
    return energy;
  }
  else {                             /* interior loop */
    if (ns==1) {
      if (nl==1)                     /* 1x1 loop */
        return P->int11[type][type_2][si1][sj1];
      if (nl==2) {                   /* 2x1 loop */
        if (n1==1)
          energy = P->int21[type][type_2][si1][sq1][sj1];
        else
          energy = P->int21[type_2][type][sq1][si1][sp1];
        return energy;
      }
        else {  /* 1xn loop */
        energy = (nl+1<=MAXLOOP)?(P->internal_loop[nl+1]):
        (P->internal_loop[30]+(int)(P->lxc*log((nl+1)/30.)));
        energy += MIN2(MAX_NINIO, (nl-ns)*P->ninio[2]);
        energy += P->mismatch1nI[type][si1][sj1]+
        P->mismatch1nI[type_2][sq1][sp1];
        return energy;
        }
    }
    else if (ns==2) {
      if(nl==2)      {   /* 2x2 loop */
        return P->int22[type][type_2][si1][sp1][sq1][sj1];}
      else if (nl==3)  { /* 2x3 loop */
        energy = P->internal_loop[5]+P->ninio[2];
        energy += P->mismatch23I[type][si1][sj1]+
          P->mismatch23I[type_2][sq1][sp1];
        return energy;
      }

    }
    { /* generic interior loop (no else here!)*/
      energy = (n1+n2<=MAXLOOP)?(P->internal_loop[n1+n2]):
        (P->internal_loop[30]+(int)(P->lxc*log((n1+n2)/30.)));

      energy += MIN2(MAX_NINIO, (nl-ns)*P->ninio[2]);

      energy += P->mismatchI[type][si1][sj1]+
        P->mismatchI[type_2][sq1][sp1];
    }
  }
  return energy;
}

#endif

naview.c/       0           0     0     644     31198     `
/*
*   NAVIEW -- A program to make a modified radial drawing of an RNA
*   secondary structure.
*
*   Copyright (c) 1988 Robert E. Bruccoleri
*   Copying of this software, in whole or in part, is permitted
*   provided that the copies are not made for commercial purposes,
*   appropriate credit for the use of the software is given, this
*   copyright notice appears, and notice is given that the copying
*   is by permission of Robert E. Bruccoleri. Any other copying
*   requires specific permission.
*
*   See R. Bruccoleri and G. Heinrich, Computer Applications in the
*   Biosciences, 4, 167-173 (1988) for a full description.
*
*   In November 1997, Michael Zuker made a number of changes to bring
*   naview up to modern standards. All functions defined in naview are
*   now declared before main() with arguments and argument types.
*   When functions are defined, their argument types are declared
*   with the function and these definitions are removed after the '{'.
*   The 'void' declaration was used as necessary for functions.
*
*   The troublesome na_scanf function was deleted and replaced by
*   scanf. Finally, there is now no default for the minimum separation
*   of bases. A floating point number must be entered. However, as
*   before an entry < 0 will be moved up to 0 and an entry > 0.5
*   will be reduced to 0.5.
*
*   Adapted for use as a subroutine in the Vienna RNA Package
*   by Ivo Hofacker, May 1998:
*   deleted output routines, replaced main() by naview_xy_coordinates(),
*   which fills the X and Y arrays used by PS_rna_plot() etc.
*   added ansi prototypes and fixed memory leaks.
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "utils.h"
#include "naview.h"

typedef int LOGICAL;
#define logical LOGICAL

#define true 1
#define false 0
#define FATAL_ERROR 1
#define SUCCESS 0

#define type_alloc(type) (type *) vrna_alloc(sizeof(type))

#define struct_alloc(structure_name) type_alloc(struct structure_name)

#define add_double_list(head,tail,newp) {\
	(newp)->next = (newp)->prev = NULL; \
        if ((head) == NULL) (head) = (tail) = (newp); \
	else { \
	     (tail)->next = (newp); \
	     (newp)->prev = (tail); \
	     (tail) = (newp); \
	     } \
	}

static double pi = 3.141592653589793;
static double anum = 9999.0;



/*
*   Function data type definitions
*/

#define minf2(x1, x2) ((x1)<(x2))?(x1):(x2)
#define maxf2(x1, x2) ((x1)>(x2))?(x1):(x2)

static struct base {
  int mate;
  double x,y;
  logical extracted;
  struct region *region;
} *bases;

struct region {
  int start1,end1,start2,end2;
};

struct loop {
  int nconnection;
  struct connection **connections;
  int number;
  int depth;
  logical mark;
  double x,y,radius;
};

struct connection {
  struct loop *loop;
  struct region *region;
  int start,end;       /* Start and end form the 1st base pair of the region. */
  double xrad,yrad,angle;
  logical extruded;	  /* True if segment between this connection and
			     the next must be extruded out of the circle */
  logical broken;	  /* True if the extruded segment must be drawn long. */
};

static int nbase, nregion, loop_count;

static struct loop *root, *loops;

static struct region *regions;

static struct loop *construct_loop(int ibase);

struct radloop {
  double radius;
  int loopnumber;
  struct radloop *next, *prev;
};

static struct radloop *rlphead;

static double lencut;

static logical debug = false;

static void read_in_bases(short *pair_table);
static void find_regions(void);
static void dump_loops(void);
static void find_central_loop(void);
static void determine_depths(void);
static void traverse_loop(struct loop *lp,struct connection *anchor_connection);
static void determine_radius(struct loop *lp,double lencut);
static void generate_region(struct connection *cp);
static void construct_extruded_segment(struct connection *cp,struct connection *cpnext);
static void find_center_for_arc(int n,double b,double *hp,double *thetap);
static int depth(struct loop *lp);

static logical connected_connection(struct connection *cp, struct connection *cpnext);
static int    find_ic_middle(int icstart, int icend, struct connection *anchor_connection, struct connection *acp, struct loop *lp);



int naview_xy_coordinates(short *pair_table, float *X, float *Y) {
  int i;

  nbase = pair_table[0]; /* length */
  bases = (struct base *) vrna_alloc(sizeof(struct base)*(nbase+1));
  regions = (struct region *) vrna_alloc(sizeof(struct region)*(nbase+1));
  read_in_bases(pair_table);
  lencut = 0.5;
  rlphead = NULL;
  find_regions();
  loop_count = 0;
  loops = (struct loop *) vrna_alloc(sizeof(struct loop)*(nbase+1));
  construct_loop(0);
  find_central_loop();
  if (debug) dump_loops();

  traverse_loop(root,NULL);
  for (i=0; i<nbase; i++) {
    X[i] = 100 + 15*bases[i+1].x;
    Y[i] = 100 + 15*bases[i+1].y;
  }
  free(bases);
  free(regions);
  free(loops);
  return nbase;
}


static void read_in_bases(short *pair_table)
{
  int i,npairs;

  /* Set up an origin.  */
  bases[0].mate = 0;
  bases[0].extracted = false;
  bases[0].x = anum;
  bases[0].y = anum;

  for (npairs=0,i=1; i<=nbase; i++) {
    bases[i].extracted = false;
    bases[i].x = anum;
    bases[i].y = anum;
    bases[i].mate = pair_table[i];
    if ((int) pair_table[i]>i) npairs++;
  }
  if (npairs==0) { /* must have at least 1 pair to avoid segfault */
    bases[1].mate=nbase;
    bases[nbase].mate=1;
  }
}


static void find_regions(void)
/*
*   Identifies the regions in the structure.
*/

{
  int i,mate,nb1;
  logical *mark;

  nb1 = nbase + 1;
  mark = (int *) vrna_alloc(sizeof(int)*nb1);
  for (i = 0; i < nb1; i++) mark[i] = false;
  nregion = 0;
  for (i=0; i<=nbase; i++) {
    if ( (mate = bases[i].mate) && !mark[i]) {
      regions[nregion].start1 = i;
      regions[nregion].end2 = mate;
      mark[i] = true;
      mark[mate] = true;
      bases[i].region = bases[mate].region = &regions[nregion];
      for (i++,mate--;
	   i<mate && bases[i].mate == mate;
	   i++,mate--) {
	mark[i] = mark[mate] = true;
	bases[i].region = bases[mate].region = &regions[nregion];
      }
      regions[nregion].end1 = --i;
      regions[nregion].start2 = mate+1;
      if (debug) {
	if (nregion == 0) printf("\nRegions are:\n");
	printf("Region %d is %d-%d and %d-%d with gap of %d.\n",
	       nregion+1,regions[nregion].start1,regions[nregion].end1,
	       regions[nregion].start2,regions[nregion].end2,
	       regions[nregion].start2-regions[nregion].end1+1);
      }
      nregion++;
    }
  }
  free(mark);
}


static struct loop *construct_loop(int ibase)
/*
*   Starting at residue ibase, recursively constructs the loop containing
*   said base and all deeper bases.
*/

{
  int i,mate;
  struct loop *retloop,*lp;
  struct connection *cp;
  struct region *rp;
  struct radloop *rlp;

  retloop = &loops[loop_count++];
  retloop->nconnection = 0;
  retloop->connections = (struct connection **) vrna_alloc(sizeof(struct connection *));
  retloop->depth = 0;
  retloop->number = loop_count;
  retloop->radius = 0.0;
  for (rlp = rlphead;  rlp;  rlp = rlp->next)
    if (rlp->loopnumber == loop_count) retloop->radius = rlp->radius;
  i = ibase;
  do {
    if ((mate = bases[i].mate) != 0) {
      rp = bases[i].region;
      if (!bases[rp->start1].extracted) {
	if (i == rp->start1) {
	  bases[rp->start1].extracted = true;
	  bases[rp->end1].extracted = true;
	  bases[rp->start2].extracted = true;
	  bases[rp->end2].extracted = true;
	  lp = construct_loop(rp->end1 < nbase ? rp->end1+1 : 0);
	}
	else if (i == rp->start2){
	  bases[rp->start2].extracted = true;
	  bases[rp->end2].extracted = true;
	  bases[rp->start1].extracted = true;
	  bases[rp->end1].extracted = true;
	  lp = construct_loop(rp->end2 < nbase ? rp->end2+1 : 0);
	}
	else {
	  fprintf(stderr, "naview: Error detected in construct_loop. i = %d not found in region table.\n",i);
	  exit(FATAL_ERROR);
	}
	retloop->connections = (struct connection **)
	  realloc(retloop->connections,
		  (++retloop->nconnection+1) *
		  sizeof(struct connection *));
	retloop->connections[retloop->nconnection-1] = cp =
	  struct_alloc(connection);
	retloop->connections[retloop->nconnection] = NULL;
	cp->loop = lp;
	cp->region = rp;
	if (i == rp->start1) {
	  cp->start = rp->start1;
	  cp->end = rp->end2;
	}
	else {
	  cp->start = rp->start2;
	  cp->end = rp->end1;
	}
	cp->extruded = false;
	cp->broken = false;
	lp->connections = (struct connection **)
	  realloc(lp->connections,
		  (++lp->nconnection+1) *
		  sizeof(struct connection *));
	lp->connections[lp->nconnection-1] = cp =
	  struct_alloc(connection);
	lp->connections[lp->nconnection] = NULL;
	cp->loop = retloop;
	cp->region = rp;
	if (i == rp->start1) {
	  cp->start = rp->start2;
	  cp->end = rp->end1;
	}
	else {
	  cp->start = rp->start1;
	  cp->end = rp->end2;
	}
	cp->extruded = false;
	cp->broken = false;
      }
      i = mate;
    }
    if (++i > nbase) i = 0;
  }
  while (i != ibase);
  return retloop;
}


static void dump_loops(void)
/*
*   Displays all the loops.
*/

{
  int il,ilp,irp;
  struct loop *lp;
  struct connection *cp,**cpp;

  printf("\nRoot loop is #%ld\n",(root-loops)+1);
  for (il=0; il < loop_count; il++) {
    lp = &loops[il];
    printf("Loop %d has %d connections:\n",il+1,lp->nconnection);
    for (cpp = lp->connections; (cp = *cpp); cpp++) {
      ilp = (cp->loop - loops) + 1;
      irp = (cp->region - regions) + 1;
      printf("  Loop %d Region %d (%d-%d)\n",
	     ilp,irp,cp->start,cp->end);
    }
  }
}


static void find_central_loop(void)
/*
*   Find node of greatest branching that is deepest.
*/

{
  struct loop *lp;
  int maxconn,maxdepth,i;

  determine_depths();
  maxconn = 0;
  maxdepth = -1;

  for (i=0; i<loop_count; i++) {
    lp = &loops[i];
    if (lp->nconnection > maxconn) {
      maxdepth = lp->depth;
      maxconn = lp->nconnection;
      root = lp;
    }
    else if (lp->depth > maxdepth && lp->nconnection == maxconn) {
      maxdepth = lp->depth;
      root = lp;
    }
  }
}


static void determine_depths(void)
/*
*   Determine the depth of all loops.
*/

{
  struct loop *lp;
  int i,j;

  for (i=0; i<loop_count; i++) {
    lp = &loops[i];
    for (j=0; j<loop_count; j++) loops[j].mark = false;
    lp->depth = depth(lp);
  }
}



static int depth(struct loop *lp)
/*
*   Determines the depth of loop, lp. Depth is defined as the minimum
*   distance to a leaf loop where a leaf loop is one that has only one
*   or no connections.
*/

{
  struct connection *cp,**cpp;
  int count,ret,d;

  if (lp->nconnection <= 1) return 0;
  if (lp->mark) return -1;
  lp->mark = true;
  count = 0;
  ret = 0;
  for (cpp=lp->connections; (cp = *cpp); cpp++) {
    d = depth(cp->loop);
    if (d >= 0) {
      if (++count == 1) ret = d;
      else if (ret > d) ret = d;
    }
  }
  lp->mark = false;
  return ret+1;
}


static void traverse_loop(struct loop *lp, struct connection *anchor_connection)
/*
*   This is the workhorse of the display program. The algorithm is
*   recursive based on processing individual loops. Each base pairing
*   region is displayed using the direction given by the circle diagram,
*   and the connections between the regions is drawn by equally spaced
*   points. The radius of the loop is set to minimize the square error
*   for lengths between sequential bases in the loops. The "correct"
*   length for base links is 1. If the least squares fitting of the
*   radius results in loops being less than 1/2 unit apart, then that
*   segment is extruded.
*
*   The variable, anchor_connection, gives the connection to the loop
*   processed in an previous level of recursion.
*/

{
  double xs,ys,xe,ye,xn,yn,angleinc,r;
  double radius,xc,yc,xo,yo,astart,aend,a;
  struct connection *cp,*cpnext,**cpp,*acp,*cpprev;
  int i,j,n,ic;
  double da,maxang;
  int count,icstart,icend,icmiddle,icroot;
  logical done,done_all_connections,rooted;
  int sign;
  double midx,midy,nrx,nry,mx,my,vx,vy,dotmv,nmidx,nmidy;
  int icstart1,icup,icdown,icnext,direction;
  double dan,dx,dy,rr;
  double cpx,cpy,cpnextx,cpnexty,cnx,cny,rcn,rc,lnx,lny,rl,ac,acn,sx,sy,dcp;
  int imaxloop;

  angleinc = 2 * pi / (nbase+1);
  acp = NULL;
  icroot = -1;
  for (cpp=lp->connections, ic = 0; (cp = *cpp); cpp++, ic++) {
    /*	xs = cos(angleinc*cp->start);
	ys = sin(angleinc*cp->start);
	xe = cos(angleinc*cp->end);
	ye = sin(angleinc*cp->end); */
    xs = -sin(angleinc*cp->start);
    ys = cos(angleinc*cp->start);
    xe = -sin(angleinc*cp->end);
    ye = cos(angleinc*cp->end);
    xn = ye-ys;
    yn = xs-xe;
    r = sqrt(xn*xn + yn*yn);
    cp->xrad = xn/r;
    cp->yrad = yn/r;
    cp->angle = atan2(yn,xn);
    if (cp->angle < 0.0) cp->angle += 2*pi;
    if (anchor_connection != NULL &&
	anchor_connection->region == cp->region) {
      acp = cp;
      icroot = ic;
    }
  }

 set_radius:
  determine_radius(lp,lencut);
  radius = lp->radius;
  if (anchor_connection == NULL) xc = yc = 0.0;
  else {
    xo = (bases[acp->start].x+bases[acp->end].x) / 2.0;
    yo = (bases[acp->start].y+bases[acp->end].y) / 2.0;
    xc = xo - radius * acp->xrad;
    yc = yo - radius * acp->yrad;
  }

  /*
   *   The construction of the connectors will proceed in blocks of
   *   connected connectors, where a connected connector pairs means
   *   two connectors that are forced out of the drawn circle because they
   *   are too close together in angle.
   */

  /*
   *   First, find the start of a block of connected connectors
   */

  if (icroot == -1)
    icstart = 0;
  else icstart = icroot;
  cp = lp->connections[icstart];
  count = 0;
  if (debug) printf("Now processing loop %d\n",lp->number);
  done = false;
  do {
    j = icstart - 1;
    if (j < 0) j = lp->nconnection - 1;
    cpprev = lp->connections[j];
    if (!connected_connection(cpprev,cp)) {
      done = true;
    }
    else {
      icstart = j;
      cp = cpprev;
    }
    if (++count > lp->nconnection) {
      /*
       *  Here everything is connected. Break on maximum angular separation
       *  between connections.
       */
      maxang = -1.0;
      for (ic = 0;  ic < lp->nconnection;  ic++) {
	j = ic + 1;
	if (j >= lp->nconnection) j = 0;
	cp = lp->connections[ic];
	cpnext = lp->connections[j];
	ac = cpnext->angle - cp->angle;
	if (ac < 0.0) ac += 2*pi;
	if (ac > maxang) {
	  maxang = ac;
	  imaxloop = ic;
	}
      }
      icend = imaxloop;
      icstart = imaxloop + 1;
      if (icstart >= lp->nconnection) icstart = 0;
      cp = lp->connections[icend];
      cp->broken = true;
      done = true;
    }
  } while    (!done);
  done_all_connections = false;
  icstart1 = icstart;
  if (debug) printf("Icstart1 = %d\n",icstart1);
  while (!done_all_connections) {
    count = 0;
    done = false;
    icend = icstart;
    rooted = false;
    while (!done) {
      cp = lp->connections[icend];
      if (icend == icroot) rooted = true;
      j = icend + 1;
      if (j >= lp->nconnection) {
	j = 0;
      }
      cpnext = lp->connections[j];
      if (connected_connection(cp,cpnext)) {
	if (++count >= lp->nconnection) break;
	icend = j;
      }
      else {
	done = true;
      }
    }
    icmiddle = find_ic_middle(icstart,icend,anchor_connection,acp,lp);
    ic = icup = icdown = icmiddle;
    if (debug)
      printf("IC start = %d  middle = %d  end = %d\n",
	     icstart,icmiddle,icend);
    done = false;
    direction = 0;
    while (!done) {
      if (direction < 0) {
	ic = icup;
      }
      else if (direction == 0) {
	ic = icmiddle;
      }
      else {
	ic = icdown;
      }
      if (ic >= 0) {
	cp = lp->connections[ic];
	if (anchor_connection == NULL || acp != cp) {
	  if (direction == 0) {
	    astart = cp->angle - asin(1.0/2.0/radius);
	    aend = cp->angle + asin(1.0/2.0/radius);
	    bases[cp->start].x = xc + radius*cos(astart);
	    bases[cp->start].y = yc + radius*sin(astart);
	    bases[cp->end].x = xc + radius*cos(aend);
	    bases[cp->end].y = yc + radius*sin(aend);
	  }
	  else if (direction < 0) {
	    j = ic + 1;
	    if (j >= lp->nconnection) j = 0;
	    cp = lp->connections[ic];
	    cpnext = lp->connections[j];
	    cpx = cp->xrad;
	    cpy = cp->yrad;
	    ac = (cp->angle + cpnext->angle) / 2.0;
	    if (cp->angle > cpnext->angle) ac -= pi;
	    cnx = cos(ac);
	    cny = sin(ac);
	    lnx = cny;
	    lny = -cnx;
	    da = cpnext->angle - cp->angle;
	    if (da < 0.0) da += 2*pi;
	    if (cp->extruded) {
	      if (da <= pi/2) rl = 2.0;
	      else rl = 1.5;
	    }
	    else {
	      rl = 1.0;
	    }
	    bases[cp->end].x = bases[cpnext->start].x + rl*lnx;
	    bases[cp->end].y = bases[cpnext->start].y + rl*lny;
	    bases[cp->start].x = bases[cp->end].x + cpy;
	    bases[cp->start].y = bases[cp->end].y - cpx;
	  }
	  else {
	    j = ic - 1;
	    if (j < 0) j = lp->nconnection - 1;
	    cp = lp->connections[j];
	    cpnext = lp->connections[ic];
	    cpnextx = cpnext->xrad;
	    cpnexty = cpnext->yrad;
	    ac = (cp->angle + cpnext->angle) / 2.0;
	    if (cp->angle > cpnext->angle) ac -= pi;
	    cnx = cos(ac);
	    cny = sin(ac);
	    lnx = -cny;
	    lny = cnx;
	    da = cpnext->angle - cp->angle;
	    if (da < 0.0) da += 2*pi;
	    if (cp->extruded) {
	      if (da <= pi/2) rl = 2.0;
	      else rl = 1.5;
	    }
	    else {
	      rl = 1.0;
	    }
	    bases[cpnext->start].x = bases[cp->end].x + rl*lnx;
	    bases[cpnext->start].y = bases[cp->end].y + rl*lny;
	    bases[cpnext->end].x = bases[cpnext->start].x - cpnexty;
	    bases[cpnext->end].y = bases[cpnext->start].y + cpnextx;
	  }
	}
      }
      if (direction < 0) {
	if (icdown == icend) {
	  icdown = -1;
	}
	else if (icdown >= 0) {
	  if (++icdown >= lp->nconnection) {
	    icdown = 0;
	  }
	}
	direction = 1;
      }
      else {
	if (icup == icstart) icup = -1;
	else if (icup >= 0) {
	  if (--icup < 0) {
	    icup = lp->nconnection - 1;
	  }
	}
	direction = -1;
      }
      done = icup == -1 && icdown == -1;
    }
    icnext = icend + 1;
    if (icnext >= lp->nconnection) icnext = 0;
    if (icend != icstart && (! (icstart == icstart1 && icnext == icstart1))) {
      /*
       *	    Move the bases just constructed (or the radius) so
       *	    that the bisector of the end points is radius distance
       *	    away from the loop center.
       */
      cp = lp->connections[icstart];
      cpnext = lp->connections[icend];
      dx = bases[cpnext->end].x - bases[cp->start].x;
      dy = bases[cpnext->end].y - bases[cp->start].y;
      midx = bases[cp->start].x + dx/2.0;
      midy = bases[cp->start].y + dy/2.0;
      rr = sqrt(dx*dx + dy*dy);
      mx = dx / rr;
      my = dy / rr;
      vx = xc - midx;
      vy = yc - midy;
      rr = sqrt(dx*dx + dy*dy);
      vx /= rr;
      vy /= rr;
      dotmv = vx*mx + vy*my;
      nrx = dotmv*mx - vx;
      nry = dotmv*my - vy;
      rr = sqrt(nrx*nrx + nry*nry);
      nrx /= rr;
      nry /= rr;
      /*
       *	    Determine which side of the bisector the center should be.
       */
      dx = bases[cp->start].x - xc;
      dy = bases[cp->start].y - yc;
      ac = atan2(dy,dx);
      if (ac < 0.0) ac += 2*pi;
      dx = bases[cpnext->end].x - xc;
      dy = bases[cpnext->end].y - yc;
      acn = atan2(dy,dx);
      if (acn < 0.0) acn += 2*pi;
      if (acn < ac) acn += 2*pi;
      if (acn - ac > pi) sign = -1;
      else sign = 1;
      nmidx = xc + sign*radius*nrx;
      nmidy = yc + sign*radius*nry;
      if (rooted) {
	xc -= nmidx - midx;
	yc -= nmidy - midy;
      }
      else {
	for (ic=icstart; ; ++ic >= lp->nconnection ? (ic = 0) : 0) {
	  cp = lp->connections[ic];
	  i = cp->start;
	  bases[i].x += nmidx - midx;
	  bases[i].y += nmidy - midy;
	  i = cp->end;
	  bases[i].x += nmidx - midx;
	  bases[i].y += nmidy - midy;
	  if (ic == icend) break;
	}
      }
    }
    icstart = icnext;
    done_all_connections = icstart == icstart1;
  }
  for (ic=0; ic < lp->nconnection; ic++) {
    cp = lp->connections[ic];
    j = ic + 1;
    if (j >= lp->nconnection) j = 0;
    cpnext = lp->connections[j];
    dx = bases[cp->end].x - xc;
    dy = bases[cp->end].y - yc;
    rc = sqrt(dx*dx + dy*dy);
    ac = atan2(dy,dx);
    if (ac < 0.0) ac += 2*pi;
    dx = bases[cpnext->start].x - xc;
    dy = bases[cpnext->start].y - yc;
    rcn = sqrt(dx*dx + dy*dy);
    acn = atan2(dy,dx);
    if (acn < 0.0) acn += 2*pi;
    if (acn < ac) acn += 2*pi;
    dan = acn - ac;
    dcp = cpnext->angle - cp->angle;
    if (dcp <= 0.0) dcp += 2*pi;
    if (fabs(dan-dcp) > pi) {
      if (cp->extruded) {
	fprintf(stderr, "Warning from traverse_loop. Loop %d has crossed regions\n",
	       lp->number);
      }
      else if ((cpnext->start - cp->end) != 1) {
	cp->extruded = true;
	goto set_radius;	    /* Forever shamed */
      }
    }
    if (cp->extruded) {
      construct_extruded_segment(cp,cpnext);
    }
    else {
      n = cpnext->start - cp->end;
      if (n < 0) n += nbase + 1;
      angleinc = dan / n;
      for (j = 1;  j < n;  j++) {
	i = cp->end + j;
	if (i > nbase) i -= nbase + 1;
	a = ac + j*angleinc;
	rr = rc + (rcn-rc)*(a-ac)/dan;
	bases[i].x = xc + rr*cos(a);
	bases[i].y = yc + rr*sin(a);
      }
    }
  }
  for (ic=0; ic < lp->nconnection; ic++) {
    if (icroot != ic) {
      cp = lp->connections[ic];
      generate_region(cp);
      traverse_loop(cp->loop,cp);
    }
  }
  n = 0;
  sx = 0.0;
  sy = 0.0;
  for (ic = 0;  ic < lp->nconnection;  ic++) {
    j = ic + 1;
    if (j >= lp->nconnection) j = 0;
    cp = lp->connections[ic];
    cpnext = lp->connections[j];
    n += 2;
    sx += bases[cp->start].x + bases[cp->end].x;
    sy += bases[cp->start].y + bases[cp->end].y;
    if (!cp->extruded) {
      for (j = cp->end + 1;  j != cpnext->start;  j++) {
	if (j > nbase) j -= nbase + 1;
	n++;
	sx += bases[j].x;
	sy += bases[j].y;
      }
    }
  }
  lp->x = sx / n;
  lp->y = sy / n;

  /* free connections (ih) */
  for (ic = 0;  ic < lp->nconnection;  ic++)
    free(lp->connections[ic]);
  free(lp->connections);
}



static void determine_radius(struct loop *lp,double lencut)
/*
*   For the loop pointed to by lp, determine the radius of
*   the loop that will ensure that each base around the loop will
*   have a separation of at least lencut around the circle.
*   If a segment joining two connectors will not support this separation,
*   then the flag, extruded, will be set in the first of these
*   two indicators. The radius is set in lp.
*
*   The radius is selected by a least squares procedure where the sum of the
*   squares of the deviations of length from the ideal value of 1 is used
*   as the error function.
*/

{
  double mindit,ci,dt,sumn,sumd,radius,dit;
  int i,j,end,start,imindit;
  struct connection *cp,*cpnext;
  static double rt2_2 = 0.7071068;

  do {
    mindit = 1.0e10;
    for (sumd=0.0, sumn=0.0, i=0;
	 i < lp->nconnection;
	 i++) {
      cp = lp->connections[i];
      j = i + 1;
      if (j >= lp->nconnection) j = 0;
      cpnext = lp->connections[j];
      end =  cp->end;
      start = cpnext->start;
      if (start < end) start += nbase + 1;
      dt = cpnext->angle - cp->angle;
      if (dt <= 0.0) dt += 2*pi;
      if (!cp->extruded)
	ci = start - end;
      else {
	if (dt <= pi/2) ci = 2.0;
	else ci = 1.5;
      }
      sumn += dt * (1.0/ci + 1.0);
      sumd += dt * dt / ci;
      dit = dt/ci;
      if (dit < mindit && !cp->extruded && ci > 1.0) {
	mindit = dit;
	imindit = i;
      }
    }
    radius = sumn/sumd;
    if (radius < rt2_2) radius = rt2_2;
    if (mindit*radius < lencut) {
      lp->connections[imindit]->extruded = true;
    }
  } while (mindit*radius < lencut);
  if (lp->radius > 0.0)
    radius = lp->radius;
  else lp->radius = radius;
}


static logical    connected_connection(struct connection *cp, struct connection *cpnext)
/*
*   Determines if the connections cp and cpnext are connected
*/

{

  if (cp->extruded) {
    return true;
  }
  else if (cp->end+1 == cpnext->start) {
    return true;
  }
  else {
    return false;
  }
}


static int    find_ic_middle(int icstart, int icend, struct connection *anchor_connection, struct connection *acp, struct loop *lp)
/*
*   Finds the middle of a set of connected connectors. This is normally
*   the middle connection in the sequence except if one of the connections
*   is the anchor, in which case that connection will be used.
*/

{
  int count,ret,ic,i;
  logical done;

  count = 0;
  ret = -1;
  ic = icstart;
  done = false;
  while (!done) {
    if (count++ > lp->nconnection * 2) {
      printf("Infinite loop detected in find_ic_middle\n");
      exit(FATAL_ERROR);
    }
    if (anchor_connection != NULL && lp->connections[ic] == acp) {
      ret = ic;
    }
    done = ic == icend;
    if (++ic >= lp->nconnection) {
      ic = 0;
    }
  }
  if (ret == -1) {
    for (i=1, ic=icstart; i<(count+1)/2; i++) {
      if (++ic >= lp->nconnection) ic = 0;
    }
    ret = ic;
  }
  return ret;
}


static void generate_region(struct connection *cp)
/*
*   Generates the coordinates for the base pairing region of a connection
*   given the position of the starting base pair.
*/

{
  int l,start,end,i,mate;
  struct region *rp;

  rp = cp->region;
  l = 0;
  if (cp->start == rp->start1) {
    start = rp->start1;
    end = rp->end1;
  }
  else {
    start = rp->start2;
    end = rp->end2;
  }
  if (bases[cp->start].x > anum - 100.0 ||
      bases[cp->end].x > anum - 100.0) {
    printf("Bad region passed to generate_region. Coordinates not defined.\n");
    exit(FATAL_ERROR);
  }
  for (i=start+1; i<=end; i++) {
    l++;
    bases[i].x = bases[cp->start].x + l*cp->xrad;
    bases[i].y = bases[cp->start].y + l*cp->yrad;
    mate = bases[i].mate;
    bases[mate].x = bases[cp->end].x + l*cp->xrad;
    bases[mate].y = bases[cp->end].y + l*cp->yrad;
  }
}


static void construct_circle_segment(int start, int end)
/*
*   Draws the segment of residue between the bases numbered start
*   through end, where start and end are presumed to be part of a base
*   pairing region. They are drawn as a circle which has a chord given
*   by the ends of two base pairing regions defined by the connections.
*/

{
  double dx,dy,rr,h,angleinc,midx,midy,xn,yn,nrx,nry,mx,my,a;
  int l,j,i;

  dx = bases[end].x - bases[start].x;
  dy = bases[end].y - bases[start].y;
  rr = sqrt(dx*dx + dy*dy);
  l = end - start;
  if (l < 0) l += nbase + 1;
  if (rr >= l) {
    dx /= rr;
    dy /= rr;
    for (j = 1;  j < l;  j++) {
      i = start + j;
      if (i > nbase) i -= nbase + 1;
      bases[i].x = bases[start].x + dx*(double)j/(double)l;
      bases[i].y = bases[start].y + dy*(double)j/(double)l;
    }
  }
  else {
    find_center_for_arc(l-1,rr,&h,&angleinc);
    dx /= rr;
    dy /= rr;
    midx = bases[start].x + dx*rr/2.0;
    midy = bases[start].y + dy*rr/2.0;
    xn = dy;
    yn = -dx;
    nrx = midx + h*xn;
    nry = midy + h*yn;
    mx = bases[start].x - nrx;
    my = bases[start].y - nry;
    rr = sqrt(mx*mx + my*my);
    a = atan2(my,mx);
    for (j = 1;  j < l;  j++) {
      i = start + j;
      if (i > nbase) i -= nbase + 1;
      bases[i].x = nrx + rr*cos(a+j*angleinc);
      bases[i].y = nry + rr*sin(a+j*angleinc);
    }
  }
}


static void construct_extruded_segment(struct connection *cp, struct connection *cpnext)
/*
*   Constructs the segment between cp and cpnext as a circle if possible.
*   However, if the segment is too large, the lines are drawn between
*   the two connecting regions, and bases are placed there until the
*   connecting circle will fit.
*/

{
  double astart,aend1,aend2,aave,dx,dy,a1,a2,ac,rr,da,dac;
  int start,end,n,nstart,nend;
  logical collision;

  astart = cp->angle;
  aend2 = aend1 = cpnext->angle;
  if (aend2 < astart) aend2 += 2*pi;
  aave = (astart + aend2) / 2.0;
  start = cp->end;
  end = cpnext->start;
  n = end - start;
  if (n < 0) n += nbase + 1;
  da = cpnext->angle - cp->angle;
  if (da < 0.0) {
    da += 2*pi;
  }
  if (n == 2) construct_circle_segment(start,end);
  else {
    dx = bases[end].x - bases[start].x;
    dy = bases[end].y - bases[start].y;
    rr = sqrt(dx*dx + dy*dy);
    dx /= rr;
    dy /= rr;
    if (rr >= 1.5 && da <= pi/2) {
      nstart = start + 1;
      if (nstart > nbase) nstart -= nbase + 1;
      nend = end - 1;
      if (nend < 0) nend += nbase + 1;
      bases[nstart].x = bases[start].x + 0.5*dx;
      bases[nstart].y = bases[start].y + 0.5*dy;
      bases[nend].x = bases[end].x - 0.5*dx;
      bases[nend].y = bases[end].y - 0.5*dy;
      start = nstart;
      end = nend;
    }
    do {
      collision = false;
      construct_circle_segment(start,end);
      nstart = start + 1;
      if (nstart > nbase) nstart -= nbase + 1;
      dx = bases[nstart].x - bases[start].x;
      dy = bases[nstart].y - bases[start].y;
      a1 = atan2(dy,dx);
      if (a1 < 0.0) a1 += 2*pi;
      dac = a1 - astart;
      if (dac < 0.0) dac += 2*pi;
      if (dac > pi) collision = true;
      nend = end - 1;
      if (nend < 0) nend += nbase + 1;
      dx = bases[nend].x - bases[end].x;
      dy = bases[nend].y - bases[end].y;
      a2 = atan2(dy,dx);
      if (a2 < 0.0) a2 += 2*pi;
      dac = aend1 - a2;
      if (dac < 0.0) dac += 2*pi;
      if (dac > pi) collision = true;
      if (collision) {
	ac = minf2(aave,astart + 0.5);
	bases[nstart].x = bases[start].x + cos(ac);
	bases[nstart].y = bases[start].y + sin(ac);
	start = nstart;
	ac = maxf2(aave,aend2 - 0.5);
	bases[nend].x = bases[end].x + cos(ac);
	bases[nend].y = bases[end].y + sin(ac);
	end = nend;
	n -= 2;
      }
    } while    (collision && n > 1);
  }
}


static void find_center_for_arc(int n,double b,double *hp,double *thetap)
/*
*   Given n points to be placed equidistantly and equiangularly on a
*   polygon which has a chord of length, b, find the distance, h, from the
*   midpoint of the chord for the center of polygon. Positive values
*   mean the center is within the polygon and the chord, whereas
*   negative values mean the center is outside the chord. Also, the
*   radial angle for each polygon side is returned in theta.
*
*   The procedure uses a bisection algorithm to find the correct
*   value for the center. Two equations are solved, the angles
*   around the center must add to 2*pi, and the sides of the polygon
*   excluding the chord must have a length of 1.
*/

{
  double h,hhi,hlow,r,disc,theta,e,phi;
  int iter;
#define maxiter 500

  hhi = (n+1) / pi;
  hlow = - hhi - b/(n+1.000001-b);  /* changed to prevent div by zero if (ih) */
  if (b<1) hlow = 0;  /* otherwise we might fail below (ih) */
  iter = 0;
  do {
    h = (hhi + hlow) / 2.0;
    r = sqrt(h*h + b*b/4.0);
    /*  if (r<0.5) {r = 0.5; h = 0.5*sqrt(1-b*b);} */
    disc = 1.0 - 0.5/(r*r);
    if (fabs(disc) > 1.0) {
      fprintf(stderr, "Unexpected large magnitude discriminant = %g %g\n", disc,r);
      exit(FATAL_ERROR);
    }
    theta = acos(disc);
    /*    theta = 2*acos(sqrt(1-1/(4*r*r))); */
    phi = acos(h/r);
    e = theta * (n+1) + 2*phi - 2*pi;
    if (e > 0.0) {
      hlow = h;
    }
    else {
      hhi = h;
    }
  } while    (fabs(e) > 0.0001 && ++iter < maxiter);
  if (iter >= maxiter) {
    fprintf(stderr, "Iteration failed in find_center_for_arc\n");
    h = 0.0;
    theta = 0.0;
  }
  *hp = h;
  *thetap = theta;
}

stringdist.c/   0           0     0     644     11575     `
/*
		String alignment for RNA secondary structures
		      Peter F Stadler, Ivo Hofacker
			   Vienna RNA Package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include "edit_cost.h"
#include "dist_vars.h"
#include "utils.h"


#define PUBLIC
#define PRIVATE        static

PUBLIC  float      string_edit_distance(swString *T1, swString *T2);
PUBLIC  swString  *Make_swString(char *string);
PUBLIC  void       print_swString(swString *x);
PUBLIC  void       print_alignment_list(void);

PRIVATE void       sprint_aligned_swStrings(swString *T1, swString *T2);
PRIVATE float      StrEditCost(int i, int j, swString *T1, swString *T2);
PRIVATE void       DeCode(char *string, int k, int *tp, float *w);
PRIVATE int        decode(char *id);
PRIVATE void       encode(int type, char label[]);
PRIVATE int       *alignment[2]; /* contains information from backtracking
				    alignment[0][n] is the node in tree2
				    matching node n in tree1               */


/*---------------------------------------------------------------------------*/

PUBLIC float string_edit_distance(swString *T1, swString *T2)

{
    float  **distance;
    short    **i_point, **j_point;

    int           i, j, i1, j1, pos, length1,length2;
    float         minus, plus, change, temp;

    if (cost_matrix==0) EditCost = &UsualCost;
    else EditCost = &ShapiroCost;

    length1 = T1[0].sign;
    length2 = T2[0].sign;

    distance = (float **)  vrna_alloc((length1 +1)*sizeof(float *));
    if(edit_backtrack){
       i_point  = (short **)  vrna_alloc((length1 +1)*sizeof(short *));
       j_point  = (short **)  vrna_alloc((length1 +1)*sizeof(short *));
    }
    for(i=0; i<= length1; i++){
       distance[i] = (float *) vrna_alloc( (length2+1)*sizeof(float));
       if(edit_backtrack){
	  i_point[i]  = (short *) vrna_alloc( (length2+1)*sizeof(short));
	  j_point[i]  = (short *) vrna_alloc( (length2+1)*sizeof(short));
       }
    }

    for(i = 1; i <= length1; i++) {
       if (edit_backtrack){
	  i_point[i][0] = i-1;
	  j_point[i][0] = 0;
       }
       distance[i][0] = distance[i-1][0]+StrEditCost(i,0,T1,T2);
    }
    for(j = 1; j <= length2; j++) {
       if (edit_backtrack){
	  j_point[0][j] = j-1;
	  i_point[0][j] = 0;
       }
       distance[0][j] = distance[0][j-1]+StrEditCost(0,j,T1,T2);
    }

    for (i = 1; i <= length1; i++) {
       for (j = 1; j <= length2 ; j++) {
          minus  = distance[i-1][j]  + StrEditCost(i,0,T1,T2);
          plus   = distance[i][j-1]  + StrEditCost(0,j,T1,T2);
          change = distance[i-1][j-1]+ StrEditCost(i,j,T1,T2);

          distance[i][j] = MIN3(minus, plus, change);
          /* printf("%g ", distance[i][j]); */

          if(edit_backtrack){
             if(distance[i][j] == change) {
                i_point[i][j]=i-1; j_point[i][j]=j-1;  }
             else if(distance[i][j] == plus) {
                i_point[i][j]=i  ; j_point[i][j]=j-1;  }
             else {
                i_point[i][j]=i-1; j_point[i][j]=j  ;  }
          }
       }
       /* printf("\n"); */
    }
    /* printf("\n"); */
    temp = distance[length1][length2];
    for(i=0;i<=length1;i++)
       free(distance[i]);
    free(distance);

    if(edit_backtrack){
       if(alignment[0]!= NULL) free(alignment[0]);
       if(alignment[1]!= NULL) free(alignment[1]);
       alignment[0] = (int *) vrna_alloc((length1+length2+1)*sizeof(int));
       alignment[1] = (int *) vrna_alloc((length1+length2+1)*sizeof(int));

       pos = length1+length2;
       i   = length1;
       j   = length2;
       while( (i>0)||(j>0) ) {
          i1 = i_point[i][j];
          j1 = j_point[i][j];
          if( ((i-i1)==1)&&((j-j1)==1) )  {  /* substitution    */
              alignment[0][pos] = i;
              alignment[1][pos] = j;
          }
          if( ((i-i1)==1)&&(j==j1) )      {  /* Deletion in [1] */
              alignment[0][pos] = i;
              alignment[1][pos] = 0;
          }
          if( (i==i1)&&((j-j1)==1)  )      {  /* Deletion in [0] */
              alignment[0][pos] = 0;
              alignment[1][pos] = j;
          }
          pos--;
          i = i1;
          j = j1;
       }
       for(i=pos+1; i<=length1+length2; i++){
          alignment[0][i-pos] = alignment[0][i];
          alignment[1][i-pos] = alignment[1][i];
       }
       alignment[0][0] = length1+length2-pos;   /* length of alignment */

       for(i=0; i<=length1; i++){
          free(i_point[i]); free(j_point[i]);
       }
       free(i_point); free(j_point);
       sprint_aligned_swStrings(T1,T2);

    }

    return temp;
}


/*---------------------------------------------------------------------------*/

PRIVATE float StrEditCost(int i, int j, swString *T1, swString *T2)
{
    float  c, diff, cd, min, a, b, dist;

    if(i==0) {
       cd   =  (float) (*EditCost)[0][T2[j].type];
       diff =  T2[j].weight;
       dist =  cd*diff;
    }
    else
    if(j==0) {
       cd   =  (float) (*EditCost)[T1[i].type][0];
       diff =  T1[i].weight;
       dist =  cd*diff;
    }
    else
    if( ((T1[i].sign)*(T2[j].sign)) > 0) {
       c = (float) (*EditCost)[T1[i].type][T2[j].type];
       diff = (float) fabs((a=T1[i].weight) - (b=T2[j].weight));
       min = MIN2(a,b);
       if (min == a) cd = (float) (*EditCost)[0][T2[j].type];
       else          cd = (float) (*EditCost)[T1[i].type][0];
       dist = c * min + cd * diff;
    }
    else dist = (float) DIST_INF;
    return dist;
}

/*---------------------------------------------------------------------------*/

PUBLIC swString *Make_swString(char *string)
{
   int i=0, j=0, k=0;
   int tp, len, l, length;
   float w;
   swString  *S;

   length = strlen(string);

   for(i=0; i<length; i++) {
      if( (string[i]=='(') || (string[i]==')') ) j++;
      if(string[i]=='.') j+=2;
   }

   len = j;

   S= (swString *) vrna_alloc(sizeof(swString)*(len+1));
   S[0].sign = j; /* number of entries */
   S[0].weight= 0.0;
   S[0].type=     0;

   i=0;
   j=1;
   while(i<length){
      switch(string[i]){
       case '(' :
          S[j].sign = 1;
          l=1;
          k=i;
          while (l>0) {
             k++;
             if(string[k] == '(' ) l++;
             if(string[k] == ')' ) l--;
          }
          DeCode(string,k,&tp,&w);
          S[j].type   = tp;
          S[j].weight = w/2.0;
	  j++;
          break;
       case ')' :
          k=i;
          S[j].sign = -1;
          DeCode(string,k,&tp,&w);
          S[j].type = tp;
          S[j].weight = w/2.0;
	  j++;
          break;
       case '.' :
          S[j].sign = 1;
          S[j].type = 1;
          S[j].weight = 0.5;
          j++;
          S[j].sign = -1;
          S[j].type =  1;
          S[j].weight = 0.5;
	  j++;
          break;
      }
      i++;
   }
   return S;
}

/*---------------------------------------------------------------------------*/

PRIVATE void DeCode(char *string, int k, int *tp, float *w)
   /* retrieves type and weigth for a node closed  by a bracket at position k */
{
   int i,j,l,m;
   char  label[20], id[20] ;
   i=k;
   label[0] = '\0';
   while(i>=0){
      i--;
      if( (string[i]=='(')||(string[i]==')')||(string[i]=='.') ) break;
      else {
         label[k-i-1] = string[i]; label[k-i] = '\0';
      }
   }
   l=strlen(label);
   if (l==0) {           /* Dot-Bracket notation */
     *w  = 1.0;
     *tp =   2;
   }
   else{
     for (i=0; i<l; i++) {
       if (!isalpha(label[l-i-1])) break;
       id[i] = label[l-i-1];
      }
      id[i] = '\0';
      *tp=decode(id);
      l=l-i-1;
      if(l>=0){
         for(j=0; j<=l; j++)
            id[j] = label[l-j];
         label[l+1] ='\0';
         m=-1;
         sscanf(label,"%d",&m);
         *w= (float) m;
         if(m==-1) {
            fprintf(stderr, "Warning: Non-integer weight in DeCode ignored\n");
            *w=1.0;
         }
      }
      else
         *w=1.0;
   }
}

/*---------------------------------------------------------------------------*/

PRIVATE int decode(char *id)
{
    int   n, quit, i;
    char  label[100], *code;

    n = 0;

    quit = 0;
    code = coding;

    while (!quit) {
        for (i = 0; code[i] != sep; i++) {
            if (code[i] == '\0') {
                quit = 1;
                break;
            }
            label[i] = code[i];
        }
        label[i] = '\0';
        if (strcmp(id, label) == 0) return (n);
        code += (i+1);
        n++;
    }

    fprintf(stderr,"Syntax error: node identifier \"%s\" not found "
		   "in coding string \"%s\"\n", id, coding);
    fprintf(stderr,"Exiting...");
    exit(0);
}


/*---------------------------------------------------------------------------*/

PRIVATE void encode( int type, char label[])

{
    int   i, l;

    l = 0;
    for (i = 0; i < type; i++) {
        while (coding[l] != sep && coding[l]) l++;
        l++;
    }

    for (i = 0; coding[l+i] != sep; i++) {
        if (coding[l+i] == '\0') break;
        label[i] = coding[l+i];
    }
    label[i] = '\0';
}

/*---------------------------------------------------------------------------*/

PRIVATE void sprint_aligned_swStrings(swString *T1, swString *T2)
{
   int i, j, l0, l1, ltmp=0, weights;
   char label[10], *a0, *a1, tmp0[20], tmp1[20];

   weights = 0;
   for (i=1; i<=T1[0].sign; i++) weights = (weights||(T1[i].weight!=0.5));
   for (i=1; i<=T2[0].sign; i++) weights = (weights||(T2[i].weight!=0.5));

   a0 = (char *) vrna_alloc(alignment[0][0]*4+2);
   a1 = (char *) vrna_alloc(alignment[0][0]*4+2);
   for(i=1; i<= alignment[0][0]; i++){
      tmp0[0] = '\0'; l0=0;
      if(alignment[0][i] > 0) {
         encode(T1[alignment[0][i]].type, label);
         if(T1[alignment[0][i]].sign > 0) {
            tmp0[0] = '(';
            tmp0[1] = '\0';
         }
         strcat(tmp0,label);
	 if (weights)
	    sprintf(tmp0+strlen(tmp0), "%d",
		    (int)(2*T1[alignment[0][i]].weight));

         if(T1[alignment[0][i]].sign < 0) strcat(tmp0, ")");
	 l0 = strlen(tmp0);
      }
      tmp1[0]= '\0'; l1=0;
      if(alignment[1][i] > 0) {
         encode(T2[alignment[1][i]].type, label);
         if(T2[alignment[1][i]].sign > 0) {
            tmp1[0] = '(';
            tmp1[1] = '\0';
         }
         strcat(tmp1,label);
	 if (weights)
	    sprintf(tmp1+strlen(tmp1), "%d",
		    (int)(2*T2[alignment[1][i]].weight));

	 if(T2[alignment[1][i]].sign < 0) strcat(tmp1, ")");
         l1 = strlen(tmp1);
      }
      ltmp = MAX2(l0,l1);
      for (j=l0; j<ltmp; j++) tmp0[j] = '_';
      for (j=l1; j<ltmp; j++) tmp1[j] = '_';
      tmp0[ltmp] = '\0'; tmp1[ltmp] = '\0';

      strcat(a0,tmp0); strcat(a1,tmp1);
      ltmp = strlen(a0);
   }
   if (aligned_line[0]!= NULL) { free(aligned_line[0]); aligned_line[0]= NULL;}
   if (aligned_line[1]!= NULL) { free(aligned_line[1]); aligned_line[1]= NULL;}
   aligned_line[0] = strdup(a0);
   free(a0);
   aligned_line[1] = strdup(a1);
   free(a1);
}

/*---------------------------------------------------------------------------*/


PUBLIC void print_swString(swString *x)
{
   int i;
   for (i=0; i<=x[0].sign; i++)
      printf("(%d,%d,%f\n) ", x[i].type, x[i].sign, x[i].weight );
   printf("\n");
}

/*---------------------------------------------------------------------------*/

PUBLIC void print_alignment_list(void)
{
   int i;
   printf("\n");
   for (i=1; i<= alignment[0][0]; i++)
      printf("%3d ",alignment[0][i]);
      printf("\n");
   for (i=1; i<= alignment[0][0]; i++)
      printf("%3d ",alignment[1][i]);
   printf("\n");
}

params.c/       0           0     0     644     27346     `
/*

                  c Ivo Hofacker

                  Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "energy_par.h"
#include "fold_vars.h"
#include "utils.h"
#include "params.h"
/**
*** \file params.c
*** <P>
*** This file provides functions that return temperature scaled energy parameters and
*** Boltzmann weights packed in datastructures
*** </P>
***/

/*------------------------------------------------------------------------*/
#define SCALE 10
/**
*** dangling ends should never be destabilizing, i.e. expdangle>=1<BR>
*** specific heat needs smooth function (2nd derivative)<BR>
*** we use a*(sin(x+b)+1)^2, with a=2/(3*sqrt(3)), b=Pi/6-sqrt(3)/2,
*** in the interval b<x<sqrt(3)/2
*/
#define SMOOTH(X) ((X)/SCALE<-1.2283697)?0:(((X)/SCALE>0.8660254)?(X):\
          SCALE*0.38490018*(sin((X)/SCALE-0.34242663)+1)*(sin((X)/SCALE-0.34242663)+1))

/* #define SMOOTH(X) ((X)<0 ? 0 : (X)) */

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/
PRIVATE vrna_param_t p;
PRIVATE int id=-1;
/* variables for partition function */
PRIVATE vrna_exp_param_t pf;
PRIVATE int pf_id=-1;

#ifdef _OPENMP
#pragma omp threadprivate(id, pf_id)
#endif

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/

PRIVATE vrna_param_t      *get_scaled_params(vrna_md_t *md);
PRIVATE vrna_exp_param_t  *get_scaled_exp_params(vrna_md_t *md, double pfs);
PRIVATE vrna_exp_param_t  *get_exp_params_ali(vrna_md_t *md, unsigned int n_seq, double pfs);
PRIVATE void              rescale_params(vrna_fold_compound_t *vc);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PUBLIC vrna_param_t *
vrna_params(vrna_md_t *md){

  if(md){
    return get_scaled_params(md);
  } else {
    vrna_md_t md;
    vrna_md_set_default(&md);
    return get_scaled_params(&md);
  }
}

PUBLIC vrna_exp_param_t *
vrna_exp_params(vrna_md_t *md){

  if(md){
    return  get_scaled_exp_params(md, -1.);
  } else {
    vrna_md_t md;
    vrna_md_set_default(&md);
    return get_scaled_exp_params(&md, -1.);
  }
}

PUBLIC vrna_exp_param_t *
vrna_exp_params_comparative(unsigned int n_seq, vrna_md_t *md){

  if(md){
    return  get_exp_params_ali(md, n_seq, -1.);
  } else {
    vrna_md_t md;
    vrna_md_set_default(&md);
    return get_exp_params_ali(&md, n_seq, -1.);
  }
}

PUBLIC vrna_param_t *
vrna_params_copy(vrna_param_t *par){

  vrna_param_t *copy = NULL;
  if(par){
    copy = (vrna_param_t *) vrna_alloc(sizeof(vrna_param_t));
    memcpy(copy, par, sizeof(vrna_param_t));
  }
  return copy;
}

PUBLIC vrna_exp_param_t *
vrna_exp_params_copy(vrna_exp_param_t *par){

  vrna_exp_param_t *copy = NULL;
  if(par){
    copy = (vrna_exp_param_t *) vrna_alloc(sizeof(vrna_exp_param_t));
    memcpy(copy, par, sizeof(vrna_exp_param_t));
  }
  return copy;
}

PUBLIC void
vrna_params_subst( vrna_fold_compound_t *vc,
                    vrna_param_t *parameters){

  if(vc){
    if(vc->params)
      free(vc->params);
    if(parameters){
      vc->params = vrna_params_copy(parameters);
    } else {
      switch(vc->type){
        case VRNA_VC_TYPE_SINGLE:     /* fall through */

        case VRNA_VC_TYPE_ALIGNMENT:  vc->params = vrna_params(NULL);
                                      break;

        default:                      break;
      }
    }
  }
}

PUBLIC void
vrna_params_reset(vrna_fold_compound_t *vc,
                  vrna_md_t *md_p){

  if(vc){
    switch(vc->type){
      case VRNA_VC_TYPE_SINGLE:     /* fall through */

      case VRNA_VC_TYPE_ALIGNMENT:  if(vc->params)
                                      free(vc->params);
                                    vc->params = vrna_params(md_p);
                                    break;

      default:                      break;
    }
  }
}

PUBLIC void
vrna_exp_params_reset(vrna_fold_compound_t *vc,
                      vrna_md_t *md_p){

  if(vc){
    switch(vc->type){
      case VRNA_VC_TYPE_SINGLE:     /* fall through */

      case VRNA_VC_TYPE_ALIGNMENT:  if(vc->exp_params)
                                      free(vc->exp_params);
                                    vc->exp_params = vrna_exp_params(md_p);
                                    break;

      default:                      break;
    }
  }
}

PUBLIC void
vrna_exp_params_subst(vrna_fold_compound_t *vc,
                      vrna_exp_param_t *params){

  if(vc){
    if(vc->exp_params)
      free(vc->exp_params);
    if(params){
      vc->exp_params = vrna_exp_params_copy(params);
    } else {
      switch(vc->type){
        case VRNA_VC_TYPE_SINGLE:     vc->exp_params = vrna_exp_params(NULL);
                                      if(vc->cutpoint > 0)
                                        vc->exp_params->model_details.min_loop_size = 0;
                                      break;

        case VRNA_VC_TYPE_ALIGNMENT:  vc->exp_params = vrna_exp_params_comparative(vc->n_seq, NULL);
                                      break;

        default:                      break;
      }
    }
    /* fill additional helper arrays for scaling etc. */
    vrna_exp_params_rescale(vc, NULL);
  }
}

PUBLIC void
vrna_exp_params_rescale(vrna_fold_compound_t *vc,
                        double *mfe){

  vrna_exp_param_t  *pf;
  double            kT;
  vrna_md_t         *md;

  if(vc){
    
    if(!vc->exp_params){
      switch(vc->type){
        case VRNA_VC_TYPE_SINGLE:
          vc->exp_params = vrna_exp_params(&(vc->params->model_details));
          break;
        case VRNA_VC_TYPE_ALIGNMENT:
          vc->exp_params = vrna_exp_params_comparative(vc->n_seq, &(vc->params->model_details));
          break;
      }
    }

    pf = vc->exp_params;
    if(pf){
      kT = pf->kT;
      md = &(pf->model_details);

      if(vc->type == VRNA_VC_TYPE_ALIGNMENT)
        kT /= vc->n_seq;

      if(mfe){
        kT /= 1000.;
        pf->pf_scale = exp(-(md->sfact * *mfe)/ kT / vc->length);
      } else if(pf->pf_scale < 1.){  /* mean energy for random sequences: 184.3*length cal */
        pf->pf_scale = exp(-(-185+(pf->temperature-37.)*7.27)/kT);
        if(pf->pf_scale < 1.)
          pf->pf_scale = 1.;
      }
      rescale_params(vc);
    }
  }
}

/*
#####################################
# BEGIN OF STATIC HELPER FUNCTIONS  #
#####################################
*/

PRIVATE vrna_param_t *
get_scaled_params(vrna_md_t *md){

  unsigned int i,j,k,l;
  double tempf;
  vrna_param_t *params;

  params  = (vrna_param_t *)vrna_alloc(sizeof(vrna_param_t));

  params->model_details = *md;  /* copy over the model details */
  params->temperature   = md->temperature;
  tempf                 = ((params->temperature+K0)/Tmeasure);

  for(i = VRNA_GQUAD_MIN_STACK_SIZE; i <= VRNA_GQUAD_MAX_STACK_SIZE; i++)
    for(j = 3*VRNA_GQUAD_MIN_LINKER_LENGTH; j <= 3*VRNA_GQUAD_MAX_LINKER_LENGTH; j++){
      double GQuadAlpha_T = (double)GQuadAlphadH - (double)(GQuadAlphadH - GQuadAlpha37) * tempf;
      double GQuadBeta_T = (double)GQuadBetadH - (double)(GQuadBetadH - GQuadBeta37) * tempf;
      params->gquad[i][j] = (int)GQuadAlpha_T*(i-1) + (int)(((double)GQuadBeta_T)*log(j - 2));
    }

  for (i=0; i<31; i++)
    params->hairpin[i]  = hairpindH[i] - (hairpindH[i] - hairpin37[i])*tempf;
  for (i=0; i<=MIN2(30,MAXLOOP); i++) {
    params->bulge[i]          = bulgedH[i] - (bulgedH[i] - bulge37[i]) * tempf;
    params->internal_loop[i]  = internal_loopdH[i] - (internal_loopdH[i] - internal_loop37[i]) * tempf;
  }
  params->lxc = lxc37*tempf;
  for (; i<=MAXLOOP; i++) {
    params->bulge[i] = params->bulge[30]+(int)(params->lxc*log((double)(i)/30.));
    params->internal_loop[i] = params->internal_loop[30]+(int)(params->lxc*log((double)(i)/30.));
  }

  params->ninio[2] = niniodH - (niniodH - ninio37) * tempf;

  params->TripleC = TripleCdH - (TripleCdH - TripleC37) * tempf;
  params->MultipleCA = MultipleCAdH - (MultipleCAdH - MultipleCA37) * tempf;
  params->MultipleCB = MultipleCBdH - (MultipleCBdH - MultipleCB37) * tempf;

  for (i=0; (i*7)<strlen(Tetraloops); i++)
    params->Tetraloop_E[i] = TetraloopdH[i] - (TetraloopdH[i]-Tetraloop37[i])*tempf;
  for (i=0; (i*5)<strlen(Triloops); i++)
    params->Triloop_E[i] =  TriloopdH[i] - (TriloopdH[i]-Triloop37[i])*tempf;
  for (i=0; (i*9)<strlen(Hexaloops); i++)
    params->Hexaloop_E[i] =  HexaloopdH[i] - (HexaloopdH[i]-Hexaloop37[i])*tempf;

  params->TerminalAU = TerminalAUdH - (TerminalAUdH - TerminalAU37) * tempf;

  params->DuplexInit = DuplexInitdH - (DuplexInitdH - DuplexInit37) *tempf;

  params->MLbase = ML_BASEdH - (ML_BASEdH - ML_BASE37) * tempf;

  for (i=0; i<=NBPAIRS; i++)
    params->MLintern[i] = ML_interndH - (ML_interndH - ML_intern37) * tempf;

  params->MLclosing = ML_closingdH - (ML_closingdH - ML_closing37) * tempf;


  /* stacks    G(T) = H - [H - G(T0)]*T/T0 */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      params->stack[i][j] = stackdH[i][j] - (stackdH[i][j] - stack37[i][j])*tempf;

  /* mismatches */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<5; j++)
      for (k=0; k<5; k++) {
        int mm;
        params->mismatchI[i][j][k]    = mismatchIdH[i][j][k] - (mismatchIdH[i][j][k] - mismatchI37[i][j][k])*tempf;
        params->mismatchH[i][j][k]    = mismatchHdH[i][j][k] - (mismatchHdH[i][j][k] - mismatchH37[i][j][k])*tempf;
        params->mismatch1nI[i][j][k]  = mismatch1nIdH[i][j][k]-(mismatch1nIdH[i][j][k]-mismatch1nI37[i][j][k])*tempf;/* interior nx1 loops */
        params->mismatch23I[i][j][k]  = mismatch23IdH[i][j][k]-(mismatch23IdH[i][j][k]-mismatch23I37[i][j][k])*tempf;/* interior 2x3 loops */
        if(md->dangles){
          mm                      = mismatchMdH[i][j][k] - (mismatchMdH[i][j][k] - mismatchM37[i][j][k])*tempf;
          params->mismatchM[i][j][k]    = (mm > 0) ? 0 : mm;
          mm                      = mismatchExtdH[i][j][k] - (mismatchExtdH[i][j][k] - mismatchExt37[i][j][k])*tempf;
          params->mismatchExt[i][j][k]  = (mm > 0) ? 0 : mm;
        }
        else{
          params->mismatchM[i][j][k] = params->mismatchExt[i][j][k] = 0;
        }
      }

  /* dangles */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<5; j++) {
      int dd;
      dd = dangle5_dH[i][j] - (dangle5_dH[i][j] - dangle5_37[i][j])*tempf;
      params->dangle5[i][j] = (dd>0) ? 0 : dd;  /* must be <= 0 */
      dd = dangle3_dH[i][j] - (dangle3_dH[i][j] - dangle3_37[i][j])*tempf;
      params->dangle3[i][j] = (dd>0) ? 0 : dd;  /* must be <= 0 */
    }
  /* interior 1x1 loops */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      for (k=0; k<5; k++)
        for (l=0; l<5; l++)
          params->int11[i][j][k][l] = int11_dH[i][j][k][l] - (int11_dH[i][j][k][l] - int11_37[i][j][k][l])*tempf;

  /* interior 2x1 loops */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      for (k=0; k<5; k++)
        for (l=0; l<5; l++) {
          int m;
          for (m=0; m<5; m++)
            params->int21[i][j][k][l][m] = int21_dH[i][j][k][l][m] - (int21_dH[i][j][k][l][m] - int21_37[i][j][k][l][m])*tempf;
        }
  /* interior 2x2 loops */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      for (k=0; k<5; k++)
        for (l=0; l<5; l++) {
          int m,n;
          for (m=0; m<5; m++)
            for (n=0; n<5; n++)
              params->int22[i][j][k][l][m][n] = int22_dH[i][j][k][l][m][n] - (int22_dH[i][j][k][l][m][n]-int22_37[i][j][k][l][m][n])*tempf;
        }

  strncpy(params->Tetraloops, Tetraloops, 281);
  strncpy(params->Triloops, Triloops, 241);
  strncpy(params->Hexaloops, Hexaloops, 361);

  params->id = ++id;
  return params;
}

PRIVATE vrna_exp_param_t *
get_scaled_exp_params(vrna_md_t *md,
                      double pfs){

  unsigned  int i, j, k, l;
  double        kT, TT;
  double        GT;
  vrna_exp_param_t     *pf;

  pf                = (vrna_exp_param_t *)vrna_alloc(sizeof(vrna_exp_param_t));
  pf->model_details = *md;
  pf->temperature   = md->temperature;
  pf->alpha         = md->betaScale;
  pf->kT = kT       = md->betaScale * (md->temperature + K0) * GASCONST;   /* kT in cal/mol  */
  pf->pf_scale      = pfs;
  TT                = (md->temperature + K0) / (Tmeasure);

  for(i = VRNA_GQUAD_MIN_STACK_SIZE; i <= VRNA_GQUAD_MAX_STACK_SIZE; i++)
    for(j = 3*VRNA_GQUAD_MIN_LINKER_LENGTH; j <= 3*VRNA_GQUAD_MAX_LINKER_LENGTH; j++){
      double GQuadAlpha_T = (double)GQuadAlphadH - (double)(GQuadAlphadH - GQuadAlpha37) * TT;
      double GQuadBeta_T = (double)GQuadBetadH - (double)(GQuadBetadH - GQuadBeta37) * TT;
      GT = ((double)GQuadAlpha_T)*((double)(i-1)) + ((double)GQuadBeta_T)*log(((double)j) - 2.);
      pf->expgquad[i][j] = exp( -GT*10./kT);
    }

  /* loop energies: hairpins, bulges, interior, mulit-loops */
  for (i=0; i<31; i++){
    GT  = hairpindH[i] - (hairpindH[i] - hairpin37[i])*TT;
    pf->exphairpin[i] = exp( -GT*10./kT);
  }

  for (i=0; i<=MIN2(30, MAXLOOP); i++) {
    GT =  bulgedH[i]- (bulgedH[i] - bulge37[i])*TT;
    pf->expbulge[i] = exp( -GT*10./kT);
    GT =  internal_loopdH[i] - (internal_loopdH[i] - internal_loop37[i])*TT;
    pf->expinternal[i] = exp( -GT*10./kT);
  }
  /* special case of size 2 interior loops (single mismatch) */
  if (james_rule) pf->expinternal[2] = exp ( -80*10./kT);

  pf->lxc = lxc37*TT;

  GT =  DuplexInitdH - (DuplexInitdH - DuplexInit37)*TT;
  pf->expDuplexInit = exp( -GT*10./kT);

  for (i=31; i<=MAXLOOP; i++) {
    GT = bulge37[30]*TT + (pf->lxc*log( i/30.));
    pf->expbulge[i] = exp( -GT*10./kT);
    GT = internal_loop37[30]*TT + (pf->lxc*log( i/30.));
    pf->expinternal[i] = exp( -GT*10./kT);
  }

  GT = niniodH - (niniodH - ninio37)*TT;
  for (j=0; j<=MAXLOOP; j++)
      pf->expninio[2][j]=exp(-MIN2(MAX_NINIO,j*GT)*10./kT);

  for (i=0; (i*7)<strlen(Tetraloops); i++) {
    GT = TetraloopdH[i] - (TetraloopdH[i]-Tetraloop37[i])*TT;
    pf->exptetra[i] = exp( -GT*10./kT);
  }
  for (i=0; (i*5)<strlen(Triloops); i++) {
    GT = TriloopdH[i] - (TriloopdH[i]-Triloop37[i])*TT;
    pf->exptri[i] = exp( -GT*10./kT);
  }
  for (i=0; (i*9)<strlen(Hexaloops); i++) {
    GT = HexaloopdH[i] - (HexaloopdH[i]-Hexaloop37[i])*TT;
    pf->exphex[i] = exp( -GT*10./kT);
  }
  GT =  ML_closingdH - (ML_closingdH - ML_closing37)*TT;
  pf->expMLclosing = exp( -GT*10./kT);

  for (i=0; i<=NBPAIRS; i++) {
    GT =  ML_interndH - (ML_interndH - ML_intern37)*TT;
    /* if (i>2) GT += TerminalAU; */
    pf->expMLintern[i] = exp( -GT*10./kT);
  }
  GT = TerminalAUdH - (TerminalAUdH - TerminalAU37)*TT;
  pf->expTermAU = exp(-GT*10./kT);

  GT = ML_BASEdH - (ML_BASEdH - ML_BASE37)*TT;

  pf->expMLbase=exp(-10.*GT/kT);


  /* if dangles==0 just set their energy to 0,
     don't let dangle energies become > 0 (at large temps),
     but make sure go smoothly to 0                        */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=4; j++) {
      if (md->dangles) {
        GT = dangle5_dH[i][j] - (dangle5_dH[i][j] - dangle5_37[i][j])*TT;
        pf->expdangle5[i][j] = exp(SMOOTH(-GT)*10./kT);
        GT = dangle3_dH[i][j] - (dangle3_dH[i][j] - dangle3_37[i][j])*TT;
        pf->expdangle3[i][j] =  exp(SMOOTH(-GT)*10./kT);
      } else
        pf->expdangle3[i][j] = pf->expdangle5[i][j] = 1;
    }

  /* stacking energies */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++) {
      GT =  stackdH[i][j] - (stackdH[i][j] - stack37[i][j])*TT;
      pf->expstack[i][j] = exp( -GT*10./kT);
    }

  /* mismatch energies */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<5; j++)
      for (k=0; k<5; k++) {
        GT =  mismatchIdH[i][j][k] - ( mismatchIdH[i][j][k] - mismatchI37[i][j][k])*TT;
        pf->expmismatchI[i][j][k] = exp(-GT*10.0/kT);
        GT = mismatch1nIdH[i][j][k] - (mismatch1nIdH[i][j][k] - mismatch1nI37[i][j][k])*TT;
        pf->expmismatch1nI[i][j][k] = exp(-GT*10.0/kT);
        GT = mismatchHdH[i][j][k] - (mismatchHdH[i][j][k] - mismatchH37[i][j][k])*TT;
        pf->expmismatchH[i][j][k] = exp(-GT*10.0/kT);
        if (md->dangles) {
          GT = mismatchMdH[i][j][k] - (mismatchMdH[i][j][k] - mismatchM37[i][j][k])*TT;
          pf->expmismatchM[i][j][k] = exp(SMOOTH(-GT)*10.0/kT);
          GT = mismatchExtdH[i][j][k] - (mismatchExtdH[i][j][k] - mismatchExt37[i][j][k])*TT;
          pf->expmismatchExt[i][j][k] = exp(SMOOTH(-GT)*10.0/kT);
        }
        else{
          pf->expmismatchM[i][j][k] = pf->expmismatchExt[i][j][k] = 1.;
        }
        GT = mismatch23IdH[i][j][k] - (mismatch23IdH[i][j][k] - mismatch23I37[i][j][k])*TT;
        pf->expmismatch23I[i][j][k] = exp(-GT*10.0/kT);
      }

  /* interior lops of length 2 */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      for (k=0; k<5; k++)
        for (l=0; l<5; l++) {
          GT = int11_dH[i][j][k][l] -
            (int11_dH[i][j][k][l] - int11_37[i][j][k][l])*TT;
          pf->expint11[i][j][k][l] = exp(-GT*10./kT);
        }
  /* interior 2x1 loops */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      for (k=0; k<5; k++)
        for (l=0; l<5; l++) {
          int m;
          for (m=0; m<5; m++) {
            GT = int21_dH[i][j][k][l][m] -
              (int21_dH[i][j][k][l][m] - int21_37[i][j][k][l][m])*TT;
            pf->expint21[i][j][k][l][m] = exp(-GT*10./kT);
          }
        }

  /* interior 2x2 loops */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      for (k=0; k<5; k++)
        for (l=0; l<5; l++) {
          int m,n;
          for (m=0; m<5; m++)
            for (n=0; n<5; n++) {
              GT = int22_dH[i][j][k][l][m][n] -
                (int22_dH[i][j][k][l][m][n]-int22_37[i][j][k][l][m][n])*TT;
              pf->expint22[i][j][k][l][m][n] = exp(-GT*10./kT);
            }
        }

  strncpy(pf->Tetraloops, Tetraloops, 281);
  strncpy(pf->Triloops, Triloops, 241);
  strncpy(pf->Hexaloops, Hexaloops, 361);

  return pf;
}

PRIVATE vrna_exp_param_t *
get_exp_params_ali( vrna_md_t *md,
                    unsigned int n_seq,
                    double pfs){

  /* scale energy parameters and pre-calculate Boltzmann weights */
  unsigned int  i, j, k, l;
  double        kTn, TT;
  double        GT;
  vrna_exp_param_t     *pf;

  pf                = (vrna_exp_param_t *)vrna_alloc(sizeof(vrna_exp_param_t));
  pf->model_details = *md;
  pf->alpha         = md->betaScale;
  pf->temperature   = md->temperature;
  pf->pf_scale      = pfs;
  pf->kT = kTn      = ((double)n_seq)*md->betaScale*(md->temperature+K0)*GASCONST;   /* kT in cal/mol  */
  TT                = (md->temperature+K0)/(Tmeasure);


   /* loop energies: hairpins, bulges, interior, mulit-loops */
  for (i=0; i<31; i++) {
    GT =  hairpindH[i] - (hairpindH[i] - hairpin37[i])*TT;
    pf->exphairpin[i] = exp( -GT*10./kTn);
  }
  /*add penalty for too short hairpins*/
  for (i=0; i<3; i++) {
    GT= 600/*Penalty*/*TT;
    pf->exphairpin[i] = exp( -GT*10./kTn);
  }

  for (i=0; i<=MIN2(30, MAXLOOP); i++) {
    GT =  bulgedH[i]- (bulgedH[i] - bulge37[i])*TT;
    pf->expbulge[i] = exp( -GT*10./kTn);
    GT =  internal_loopdH[i] - (internal_loopdH[i] - internal_loop37[i])*TT;
    pf->expinternal[i] = exp( -GT*10./kTn);
  }
  /* special case of size 2 interior loops (single mismatch) */
  if (james_rule) pf->expinternal[2] = exp ( -80*10./kTn);

  pf->lxc = lxc37*TT;

  GT =  DuplexInitdH - (DuplexInitdH - DuplexInit37)*TT;
  pf->expDuplexInit = exp( -GT*10./kTn);

  for (i=31; i<=MAXLOOP; i++) {
    GT = bulge37[30]*TT + (pf->lxc*log( i/30.));
    pf->expbulge[i] = exp( -GT*10./kTn);
    GT = internal_loop37[30]*TT + (pf->lxc*log( i/30.));
    pf->expinternal[i] = exp( -GT*10./kTn);
  }

  GT = niniodH - (niniodH - ninio37)*TT;
  for (j=0; j<=MAXLOOP; j++)
    pf->expninio[2][j]=exp(-MIN2(MAX_NINIO,j*GT)*10./kTn);

  for (i=0; (i*7)<strlen(Tetraloops); i++) {
    GT = TetraloopdH[i] - (TetraloopdH[i]-Tetraloop37[i])*TT;
    pf->exptetra[i] = exp( -GT*10./kTn);
  }
  for (i=0; (i*5)<strlen(Triloops); i++) {
    GT = TriloopdH[i] - (TriloopdH[i]-Triloop37[i])*TT;
    pf->exptri[i] = exp( -GT*10./kTn);
  }
  for (i=0; (i*9)<strlen(Hexaloops); i++) {
    GT = HexaloopdH[i] - (HexaloopdH[i]-Hexaloop37[i])*TT;
    pf->exphex[i] = exp( -GT*10./kTn);
  }
  GT =  ML_closingdH - (ML_closingdH - ML_closing37)*TT;
  pf->expMLclosing = exp( -GT*10./kTn);

  for (i=0; i<=NBPAIRS; i++) { /* includes AU penalty */
    GT =  ML_interndH - (ML_interndH - ML_intern37)*TT;
    /* if (i>2) GT += TerminalAU; */
    pf->expMLintern[i] = exp( -GT*10./kTn);
  }
  GT = TerminalAUdH - (TerminalAUdH - TerminalAU37)*TT;
  pf->expTermAU = exp(-GT*10./kTn);

  GT = ML_BASEdH - (ML_BASEdH - ML_BASE37)*TT;
  pf->expMLbase=exp(-10.*GT/(kTn/n_seq));


  /* if dangle_model==0 just set their energy to 0,
     don't let dangle energies become > 0 (at large temps),
     but make sure go smoothly to 0                        */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=4; j++) {
      if (md->dangles) {
        GT = dangle5_dH[i][j] - (dangle5_dH[i][j] - dangle5_37[i][j])*TT;
        pf->expdangle5[i][j] = exp(SMOOTH(-GT)*10./kTn);
        GT = dangle3_dH[i][j] - (dangle3_dH[i][j] - dangle3_37[i][j])*TT;
        pf->expdangle3[i][j] =  exp(SMOOTH(-GT)*10./kTn);
      } else
        pf->expdangle3[i][j] = pf->expdangle5[i][j] = 1;
    }

  /* stacking energies */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++) {
      GT =  stackdH[i][j] - (stackdH[i][j] - stack37[i][j])*TT;
      pf->expstack[i][j] = exp( -GT*10./kTn);
    }

  /* mismatch energies */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<5; j++)
      for (k=0; k<5; k++) {
        GT =  mismatchIdH[i][j][k] - ( mismatchIdH[i][j][k] - mismatchI37[i][j][k])*TT;
        pf->expmismatchI[i][j][k] = exp(-GT*10.0/kTn);
        GT = mismatch1nIdH[i][j][k] - (mismatch1nIdH[i][j][k] - mismatch1nI37[i][j][k])*TT;
        pf->expmismatch1nI[i][j][k] = exp(-GT*10.0/kTn);
        GT = mismatchHdH[i][j][k] - (mismatchHdH[i][j][k] - mismatchH37[i][j][k])*TT;
        pf->expmismatchH[i][j][k] = exp(-GT*10.0/kTn);
        if (md->dangles) {
          GT = mismatchMdH[i][j][k] - (mismatchMdH[i][j][k] - mismatchM37[i][j][k])*TT;
          pf->expmismatchM[i][j][k] = exp(SMOOTH(-GT)*10.0/kTn);
          GT = mismatchExtdH[i][j][k] - (mismatchExtdH[i][j][k] - mismatchExt37[i][j][k])*TT;
          pf->expmismatchExt[i][j][k] = exp(SMOOTH(-GT)*10.0/kTn);
        }
        else{
          pf->expmismatchM[i][j][k] = pf->expmismatchExt[i][j][k] = 1.;
        }
        GT = mismatch23IdH[i][j][k] - (mismatch23IdH[i][j][k] - mismatch23I37[i][j][k])*TT;
        pf->expmismatch23I[i][j][k] = exp(-GT*10.0/kTn);
      }


  /* interior lops of length 2 */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      for (k=0; k<5; k++)
        for (l=0; l<5; l++) {
          GT = int11_dH[i][j][k][l] -
            (int11_dH[i][j][k][l] - int11_37[i][j][k][l])*TT;
          pf->expint11[i][j][k][l] = exp(-GT*10./kTn);
        }
  /* interior 2x1 loops */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      for (k=0; k<5; k++)
        for (l=0; l<5; l++) {
          int m;
          for (m=0; m<5; m++) {
            GT = int21_dH[i][j][k][l][m] -
              (int21_dH[i][j][k][l][m] - int21_37[i][j][k][l][m])*TT;
            pf->expint21[i][j][k][l][m] = exp(-GT*10./kTn);
          }
        }

  /* interior 2x2 loops */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      for (k=0; k<5; k++)
        for (l=0; l<5; l++) {
          int m,n;
          for (m=0; m<5; m++)
            for (n=0; n<5; n++) {
              GT = int22_dH[i][j][k][l][m][n] -
                (int22_dH[i][j][k][l][m][n]-int22_37[i][j][k][l][m][n])*TT;
              pf->expint22[i][j][k][l][m][n] = exp(-GT*10./kTn);
            }
        }

  strncpy(pf->Tetraloops, Tetraloops, 281);
  strncpy(pf->Triloops, Triloops, 241);
  strncpy(pf->Hexaloops, Hexaloops, 361);

  return pf;
}

PRIVATE void
rescale_params(vrna_fold_compound_t *vc){

  int           i;
  vrna_exp_param_t  *pf = vc->exp_params;
  vrna_mx_pf_t      *m  = vc->exp_matrices;

  if(m && pf){
    m->scale[0] = 1.;
    m->scale[1] = (FLT_OR_DBL)(1./pf->pf_scale);
    m->expMLbase[0] = 1;
    m->expMLbase[1] = (FLT_OR_DBL)(pf->expMLbase / pf->pf_scale);
    for (i=2; i<=vc->length; i++) {
      m->scale[i] = m->scale[i/2]*m->scale[i-(i/2)];
      m->expMLbase[i] = (FLT_OR_DBL)pow(pf->expMLbase, (double)i) * m->scale[i];
    }
  }
}


#ifdef  VRNA_BACKWARD_COMPAT

/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/

PUBLIC vrna_param_t *
scale_parameters(void){

  vrna_md_t md;
  set_model_details(&md);
  return vrna_params(&md);
}

PUBLIC vrna_param_t *
get_scaled_parameters(double temp,
                      vrna_md_t md){

  md.temperature = temp;
  return get_scaled_params(&md);
}

PUBLIC vrna_exp_param_t *
get_boltzmann_factors(double temp,
                      double betaScale,
                      vrna_md_t md,
                      double pfs){

  md.temperature  = temp;
  md.betaScale    = betaScale;
  pf_scale        = pfs;

  return get_scaled_exp_params(&md, pfs);
}

PUBLIC vrna_exp_param_t *
get_scaled_pf_parameters(void){

  vrna_md_t         md;
  vrna_exp_param_t  *pf;

  set_model_details(&md);

  pf = vrna_exp_params(&md);
  pf->pf_scale = pf_scale;

  return pf;
}

PUBLIC vrna_exp_param_t *
get_boltzmann_factors_ali(unsigned int n_seq,
                         double temp,
                         double betaScale,
                         vrna_md_t md,
                         double pfs){

  md.temperature  = temp;
  md.betaScale    = betaScale;
  pf_scale        = pfs;

  return get_exp_params_ali(&md, n_seq, pfs);
  
}

PUBLIC vrna_exp_param_t *
get_scaled_alipf_parameters(unsigned int n_seq){

  vrna_md_t  md;

  set_model_details(&md);

  return get_exp_params_ali(&md, n_seq, pf_scale);
}

PUBLIC vrna_exp_param_t *
get_boltzmann_factor_copy(vrna_exp_param_t *par){

  return vrna_exp_params_copy(par);
}

PUBLIC vrna_param_t *get_parameter_copy(vrna_param_t *par){

  return vrna_params_copy(par);
}

PUBLIC vrna_param_t *copy_parameters(void){
  vrna_param_t *copy;
  if (p.id != id){
    vrna_md_t md;
    set_model_details(&md);
    return vrna_params(&md);
  } else {
    copy = (vrna_param_t *) vrna_alloc(sizeof(vrna_param_t));
    memcpy(copy, &p, sizeof(vrna_param_t));
  }
  return copy;
}

PUBLIC vrna_param_t *set_parameters(vrna_param_t *dest){
  memcpy(&p, dest, sizeof(vrna_param_t));
  return &p;
}

PUBLIC vrna_exp_param_t *copy_pf_param(void){
  vrna_exp_param_t *copy;
  if (pf.id != pf_id){
    vrna_md_t md;
    set_model_details(&md);
    copy = vrna_exp_params(&md);
    copy->pf_scale = pf_scale;
    return copy;
  }
  else{
    copy = (vrna_exp_param_t *) vrna_alloc(sizeof(vrna_exp_param_t));
    memcpy(copy, &pf, sizeof(vrna_exp_param_t));
  }
  return copy;
}

PUBLIC vrna_exp_param_t *set_pf_param(vrna_param_t *dest){
  memcpy(&pf, dest, sizeof(vrna_exp_param_t));
  return &pf;
}

PUBLIC vrna_exp_param_t *scale_pf_parameters(void){
  vrna_md_t         md;
  vrna_exp_param_t  *pf;

  set_model_details(&md);

  pf = vrna_exp_params(&md);
  pf->pf_scale = pf_scale;

  return pf;
}

#endif

subopt.c/       0           0     0     644     61211     `
/*
   suboptimal folding - Stefan Wuchty, Walter Fontana & Ivo Hofacker

                       Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include "fold.h"
#include "constraints.h"
#include "utils.h"
#include "energy_par.h"
#include "fold_vars.h"
#include "list.h"
#include "eval.h"
#include "params.h"
#include "loop_energies.h"
#include "cofold.h"
#include "gquad.h"
#include "subopt.h"

/* hack */
#include "color_output.inc"

#ifdef _OPENMP
#include <omp.h>
#endif

#define true              1
#define false             0
#define ON_SAME_STRAND(I,J,C)  (((I)>=(C))||((J)<(C)))

/**
 *  @brief  Sequence interval stack element used in subopt.c
 */
typedef struct INTERVAL {
    int i;
    int j;
    int array_flag;
} INTERVAL;

typedef struct {
    char *structure;
    LIST *Intervals;
    int partial_energy;
    int is_duplex;
    /* int best_energy;   */ /* best attainable energy */
} STATE;

typedef struct {
  LIST          *Intervals;
  LIST          *Stack;
  int           nopush;
} subopt_env;


struct old_subopt_dat {

  unsigned long max_sol;
  unsigned long n_sol;
  SOLUTION      *SolutionList;
  FILE          *fp;
};

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/
PUBLIC  int     subopt_sorted=0;                           /* output sorted by energy */
PUBLIC  int     density_of_states[MAXDOS+1];
PUBLIC  double  print_energy = 9999; /* printing threshold for use with logML */

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/

/* some backward compatibility stuff */
PRIVATE int                 backward_compat           = 0;
PRIVATE vrna_fold_compound_t  *backward_compat_compound = NULL;

#ifdef _OPENMP

#pragma omp threadprivate(backward_compat_compound, backward_compat)

#endif

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/

#ifdef VRNA_BACKWARD_COMPAT

PRIVATE SOLUTION *
wrap_subopt(char *seq,
            char *structure,
            vrna_param_t *parameters,
            int delta,
            int is_constrained,
            int is_circular,
            FILE *fp);
#endif

PRIVATE void      make_pair(int i, int j, STATE *state);

/* mark a gquadruplex in the resulting dot-bracket structure */
PRIVATE void      make_gquad(int i, int L, int l[3], STATE *state);

PRIVATE INTERVAL  *make_interval (int i, int j, int ml);
/*@out@*/ PRIVATE STATE *make_state(/*@only@*/LIST *Intervals,
                                    /*@only@*/ /*@null@*/ char *structure,
                                    int partial_energy, int is_duplex, int length);
PRIVATE STATE     *copy_state(STATE * state);
PRIVATE void      print_state(STATE * state);
/*@only@*/ PRIVATE LIST *make_list(void);
PRIVATE void      push(LIST * list, /*@only@*/ void *data);
PRIVATE void      *pop(LIST * list);
PRIVATE int       best_attainable_energy(vrna_fold_compound_t *vc, STATE * state);
PRIVATE void      scan_interval(vrna_fold_compound_t *vc, int i, int j, int array_flag, int threshold, STATE * state, subopt_env *env);
PRIVATE void      free_interval_node(/*@only@*/ INTERVAL * node);
PRIVATE void      free_state_node(/*@only@*/ STATE * node);
PRIVATE void      push_back(LIST *Stack, STATE * state);
PRIVATE char*     get_structure(STATE * state);
PRIVATE int       compare(const void *solution1, const void *solution2);
PRIVATE void      make_output(SOLUTION *SL, int cp, FILE *fp);
PRIVATE void      repeat(vrna_fold_compound_t *vc, int i, int j, STATE * state, int part_energy, int temp_energy, int best_energy, int threshold, subopt_env *env);
PRIVATE void      repeat_gquad(vrna_fold_compound_t *vc, int i, int j, STATE *state, int part_energy, int temp_energy, int best_energy, int threshold, subopt_env *env);


PRIVATE void      old_subopt_print( const char *structure, float energy, void *data);
PRIVATE void      old_subopt_store( const char *structure, float energy, void *data);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/



/*---------------------------------------------------------------------------*/
/*List routines--------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

PRIVATE void
make_pair(int i, int j, STATE *state)
{
  state->structure[i-1] = '(';
  state->structure[j-1] = ')';
}

PRIVATE void
make_gquad(int i, int L, int l[3], STATE *state)
{
  int x;
  for(x = 0; x < L; x++){
    state->structure[i - 1 + x] = '+';
    state->structure[i - 1 + x + L + l[0]] = '+';
    state->structure[i - 1 + x + 2*L + l[0] + l[1]] = '+';
    state->structure[i - 1 + x + 3*L + l[0] + l[1] + l[2]] = '+';
  }
}

/*---------------------------------------------------------------------------*/

PRIVATE INTERVAL *
make_interval(int i, int j, int array_flag)
{
  INTERVAL *interval;

  interval = lst_newnode(sizeof(INTERVAL));
  interval->i = i;
  interval->j = j;
  interval->array_flag = array_flag;
  return interval;
}

/*---------------------------------------------------------------------------*/

PRIVATE void
free_interval_node(INTERVAL * node)
{
  lst_freenode(node);
}

/*---------------------------------------------------------------------------*/

PRIVATE void
free_state_node(STATE * node)
{
  free(node->structure);
  if (node->Intervals)
    // JORDAN DELETED lst_kill(node->Intervals, lst_freenode);
  lst_freenode(node);
}

/*---------------------------------------------------------------------------*/

PRIVATE STATE *
make_state(LIST * Intervals,
           char *structure,
           int partial_energy,
           int is_duplex,
           int length)
{
  STATE *state;

  state = lst_newnode(sizeof(STATE));

  if (Intervals)
    state->Intervals = Intervals;
  else
    state->Intervals = lst_init();
  if (structure)
    state->structure = structure;
  else {
    int i;
    state->structure = (char *) vrna_alloc(length+1);
    for (i=0; i<length; i++)
      state->structure[i] = '.';
  }

  state->partial_energy = partial_energy;

  return state;
}

/*---------------------------------------------------------------------------*/

PRIVATE STATE *
copy_state(STATE * state)
{
  STATE *new_state;
  void *after;
  INTERVAL *new_interval, *next;

  new_state = lst_newnode(sizeof(STATE));
  new_state->Intervals = lst_init();
  new_state->partial_energy = state->partial_energy;
  /* new_state->best_energy = state->best_energy; */

  if (state->Intervals->count) {
    after = LST_HEAD(new_state->Intervals);
    for ( next = lst_first(state->Intervals); next; next = lst_next(next))
      {
        new_interval = lst_newnode(sizeof(INTERVAL));
        *new_interval = *next;
        lst_insertafter(new_state->Intervals, new_interval, after);
        after = new_interval;
      }
  }
  new_state->structure = strdup(state->structure);
  if (!new_state->structure) vrna_message_error("out of memory");
  return new_state;
}

/*---------------------------------------------------------------------------*/

/*@unused @*/ PRIVATE void
print_state(STATE * state)
{
  INTERVAL *next;

  if (state->Intervals->count)
    {
      printf("%d intervals:\n", state->Intervals->count);
      for (next = lst_first(state->Intervals); next; next = lst_next(next))
        {
          printf("[%d,%d],%d ", next->i, next->j, next->array_flag);
        }
      printf("\n");
    }
  printf("partial structure: %s\n", state->structure);
  printf("\n");
  printf(" partial_energy: %d\n", state->partial_energy);
  /* printf(" best_energy: %d\n", state->best_energy); */
  (void) fflush(stdout);
}



PRIVATE LIST *
make_list(void)
{
  return lst_init();
}

/*---------------------------------------------------------------------------*/

PRIVATE void
push(LIST * list, void *data)
{
  lst_insertafter(list, data, LST_HEAD(list));
}

/* PRIVATE void */
/* push_stack(STATE *state) { */ /* keep the stack sorted by energy */
/*   STATE *after, *next; */
/*   nopush = false; */
/*   next = after = LST_HEAD(Stack); */
/*   while ( next = lst_next(next)) { */
/*     if ( next->best_energy >= state->best_energy ) break; */
/*     after = next; */
/*   } */
/*   lst_insertafter(Stack, state, after); */
/* } */

/*---------------------------------------------------------------------------*/

PRIVATE void *
pop(LIST * list)
{
  void *data;

  data = lst_deletenext(list, LST_HEAD(list));
  return data;
}

/*---------------------------------------------------------------------------*/
/*auxiliary routines---------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

PRIVATE int
best_attainable_energy( vrna_fold_compound_t *vc,
                        STATE *state){

  /* evaluation of best possible energy attainable within remaining intervals */

  register int sum;
  INTERVAL        *next;
  vrna_md_t       *md;
  vrna_mx_mfe_t   *matrices;
  int             *indx;

  md        = &(vc->params->model_details);
  matrices  = vc->matrices;
  indx      = vc->jindx;

  sum = state->partial_energy;  /* energy of already found elements */

  for (next = lst_first(state->Intervals); next; next = lst_next(next))
    {
      if (next->array_flag == 0)
        sum += (md->circ) ? matrices->Fc : matrices->f5[next->j];
      else if (next->array_flag == 1)
        sum += matrices->fML[indx[next->j] + next->i];
      else if (next->array_flag == 2)
        sum += matrices->c[indx[next->j] + next->i];
      else if (next->array_flag == 3)
        sum += matrices->fM1[indx[next->j] + next->i];
      else if (next->array_flag == 4)
        sum += matrices->fc[next->i];
      else if (next->array_flag == 5)
        sum += matrices->fc[next->j];
      else if (next->array_flag == 6)
        sum += matrices->ggg[indx[next->j] + next->i];
    }

  return sum;
}

/*---------------------------------------------------------------------------*/

PRIVATE void
push_back(LIST *Stack, STATE * state)
{
  push(Stack, copy_state(state));
  return;
}

/*---------------------------------------------------------------------------*/

PRIVATE char*
get_structure(STATE * state)
{
  char* structure;

  structure = strdup(state->structure);
  return structure;
}

/*---------------------------------------------------------------------------*/
PRIVATE int
compare(const void *solution1, const void *solution2)
{
  if (((SOLUTION *) solution1)->energy > ((SOLUTION *) solution2)->energy)
    return 1;
  if (((SOLUTION *) solution1)->energy < ((SOLUTION *) solution2)->energy)
    return -1;
  return strcmp(((SOLUTION *) solution1)->structure,
                ((SOLUTION *) solution2)->structure);
}

/*---------------------------------------------------------------------------*/

PRIVATE void make_output(SOLUTION *SL, int cp, FILE *fp)  /* prints stuff */
{
  int r;
  SOLUTION *sol;

  for (sol = SL; sol->structure!=NULL; sol++){
    char *e_string = NULL;
    r = asprintf(&e_string, " %6.2f", sol->energy);
    if(r == -1)
      vrna_message_error("Out of memory in subopt output");
    else
      print_structure(fp, sol->structure, e_string);
    free(e_string);
  }
}

PRIVATE STATE *
derive_new_state( int i,
                  int j,
                  STATE *s,
                  int e,
                  int flag){

  STATE     *s_new  = copy_state(s);
  INTERVAL  *ival   = make_interval(i, j, flag);
  push(s_new->Intervals, ival);

  s_new->partial_energy += e;

  return s_new;
}

PRIVATE void
fork_state( int i,
            int j,
            STATE *s,
            int e,
            int flag,
            subopt_env *env){

  STATE *s_new = derive_new_state(i, j, s, e, flag);
  push(env->Stack, s_new);
  env->nopush = false;
}

PRIVATE void
fork_int_state( int i, int j,
                int p, int q,
                STATE *s,
                int e,
                subopt_env *env){

  STATE *s_new = derive_new_state(p, q, s, e, 2);
  make_pair(i, j, s_new);
  make_pair(p, q, s_new);
  push(env->Stack, s_new);
  env->nopush = false;
}

PRIVATE void
fork_state_pair(int i,
                int j,
                STATE *s,
                int e,
                subopt_env *env){

  STATE     *new_state;

  new_state = copy_state(s);
  make_pair(i, j, new_state);
  new_state->partial_energy += e;
  push(env->Stack, new_state);
  env->nopush = false;
}

PRIVATE void
fork_two_states_pair( int i,
                      int j,
                      int k,
                      STATE *s,
                      int e,
                      int flag1,
                      int flag2,
                      subopt_env *env){

  INTERVAL  *interval1, *interval2;
  STATE     *new_state;

  new_state = copy_state(s);
  interval1 = make_interval(i+1, k-1, flag1);
  interval2 = make_interval(k, j-1, flag2);
  if (k-i < j-k) { /* push larger interval first */
    push(new_state->Intervals, interval1);
    push(new_state->Intervals, interval2);
  } else {
    push(new_state->Intervals, interval2);
    push(new_state->Intervals, interval1);
  }
  make_pair(i, j, new_state);
  new_state->partial_energy += e;

  push(env->Stack, new_state);
  env->nopush = false;
}


PRIVATE void
fork_two_states(int i,
                int j,
                int p,
                int q,
                STATE *s,
                int e,
                int flag1,
                int flag2,
                subopt_env *env){

  INTERVAL  *interval1, *interval2;
  STATE     *new_state;

  new_state = copy_state(s);
  interval1 = make_interval(i, j, flag1);
  interval2 = make_interval(p, q, flag2);

  if((j - i) < (q - p)){
    push(new_state->Intervals, interval1);
    push(new_state->Intervals, interval2);
  } else {
    push(new_state->Intervals, interval2);
    push(new_state->Intervals, interval1);
  }
  new_state->partial_energy += e;

  push(env->Stack, new_state);
  env->nopush = false;
}

/*---------------------------------------------------------------------------*/
/* start of subopt backtracking ---------------------------------------------*/
/*---------------------------------------------------------------------------*/

PUBLIC SOLUTION *
vrna_subopt(vrna_fold_compound_t *vc,
            int delta,
            int sorted,
            FILE *fp){

  SOLUTION      *SolutionList;
  unsigned long max_sol, n_sol;
  struct old_subopt_dat data;

  data.SolutionList = NULL;
  data.max_sol      = 128;
  data.n_sol        = 0;
  data.fp           = fp;

  if(vc){
    /* SolutionList stores the suboptimal structures found */

    data.SolutionList = (SOLUTION *) vrna_alloc(data.max_sol*sizeof(SOLUTION));

    /* end initialize ------------------------------------------------------- */

    if (fp) {
      int r;
      float min_en;
      char  *SeQ, *energies = NULL;
      if(vc->cutpoint > 0)
        min_en = vrna_mfe_dimer(vc, NULL);
      else
        min_en = vrna_mfe(vc, NULL);

      SeQ = vrna_cut_point_insert(vc->sequence, vc->cutpoint);
      r = asprintf(&energies, " %6.2f %6.2f", min_en, (float)delta/100.);
      if(r != -1)
        print_structure(fp, SeQ, energies);
      free(SeQ);
      free(energies);

      vrna_mx_mfe_free(vc);
    }
    /* call subopt() */
    vrna_subopt_cb(vc, delta, (!sorted && fp) ? &old_subopt_print : &old_subopt_store, (void *)&data);

    if(sorted){
      /* sort structures by energy */
      if(data.n_sol > 0)
        qsort(data.SolutionList, data.n_sol - 1, sizeof(SOLUTION), compare);
      if(fp)
        make_output(data.SolutionList, vc->cutpoint, fp);
    }

    if(fp){ /* we've printed everything -- free solutions */
      SOLUTION *sol;
      for(sol = data.SolutionList; sol->structure != NULL; sol++)
        free(sol->structure);
      free(data.SolutionList);
      data.SolutionList = NULL;
    }
  }

  return data.SolutionList;
}

PUBLIC void
vrna_subopt_cb( vrna_fold_compound_t *vc,
                int delta,
                vrna_subopt_callback *cb,
                void *data){

  subopt_env    *env;
  STATE         *state;
  INTERVAL      *interval;
  int           maxlevel, count, partial_energy, old_dangles, logML, dangle_model, length, circular, threshold, cp;
  double        structure_energy, min_en, eprint;
  char          *struc, *structure, *sequence;
  float         correction;
  vrna_param_t  *P;
  vrna_md_t     *md;
  int           minimal_energy;
  int           Fc;
  int           *f5;

  vrna_fold_compound_prepare(vc, VRNA_OPTION_MFE | VRNA_OPTION_HYBRID);

  sequence            = vc->sequence;
  length              = vc->length;
  cp                  = vc->cutpoint;
  P                   = vc->params;
  md                  = &(P->model_details);

  /* do mfe folding to get fill arrays and get ground state energy  */
  /* in case dangles is neither 0 or 2, set dangles=2 while folding */

  circular    = md->circ;
  logML       = md->logML;
  old_dangles = dangle_model = md->dangles;

  /* temporarily set dangles to 2 if necessary */
  if((md->dangles != 0) && (md->dangles != 2))
    md->dangles = 2;

  struc = (char *)vrna_alloc(sizeof(char) * (length + 1));

  if(circular){
    min_en = vrna_mfe(vc, struc);
    Fc  = vc->matrices->Fc;
    f5    = vc->matrices->f5;

    /* restore dangle model */
    md->dangles = old_dangles;
    /* re-evaluate in case we're using logML etc */
    min_en = vrna_eval_structure(vc, struc);
  } else {
    min_en = vrna_mfe_dimer(vc, struc);

    f5    = vc->matrices->f5;

    /* restore dangle model */
    md->dangles = old_dangles;
    /* re-evaluate in case we're using logML etc */
    min_en = vrna_eval_structure(vc, struc);
  }

  free(struc);
  eprint = print_energy + min_en;

  correction = (min_en < 0) ? -0.1 : 0.1;

  /* Initialize ------------------------------------------------------------ */

  maxlevel = 0;
  count = 0;
  partial_energy = 0;

  /* Initialize the stack ------------------------------------------------- */

  minimal_energy = (circular) ? Fc : f5[length];
  threshold = minimal_energy + delta;
  if(threshold > INF){
    vrna_message_warning("Energy range too high, limiting to reasonable value");
    threshold = INF-EMAX;
  }

  /* init env data structure */
  env = (subopt_env *)vrna_alloc(sizeof(subopt_env));
  env->Stack      = NULL;
  env->nopush     = true;
  env->Stack      = make_list();                                                   /* anchor */
  env->Intervals  = make_list();                                   /* initial state: */
  interval   = make_interval(1, length, 0);          /* interval [1,length,0] */
  push(env->Intervals, interval);
  env->nopush = false;
  state  = make_state(env->Intervals, NULL, partial_energy,0, length);
  /* state->best_energy = minimal_energy; */
  push(env->Stack, state);
  env->nopush = false;

  /* end initialize ------------------------------------------------------- */


  while (1) {                    /* forever, til nothing remains on stack */

    maxlevel = (env->Stack->count > maxlevel ? env->Stack->count : maxlevel);

    if (LST_EMPTY (env->Stack))                   /* we are done! clean up and quit */
      {
        /* fprintf(stderr, "maxlevel: %d\n", maxlevel); */

        // JORDAN DELETED lst_kill(env->Stack, free_state_node);

        cb(NULL, 0, data); /* NULL (last time to call callback function */

        break;
      }

    /* pop the last element ---------------------------------------------- */

    state = pop(env->Stack);                       /* current state to work with */

    if (LST_EMPTY(state->Intervals))
      {
        int e;
        /* state has no intervals left: we got a solution */

        count++;
        structure = get_structure(state);
        structure_energy = state->partial_energy / 100.;

#ifdef CHECK_ENERGY
        structure_energy = vrna_eval_structure(vc, structure);

        if (!logML)
          if ((double) (state->partial_energy / 100.) != structure_energy) {
            fprintf(stderr, "%s %6.2f %6.2f\n", structure,
                    state->partial_energy / 100., structure_energy );
            exit(1);
          }
#endif
        if (logML || (dangle_model==1) || (dangle_model==3)) { /* recalc energy */
          structure_energy = vrna_eval_structure(vc, structure);
        }

        e = (int) ((structure_energy-min_en)*10. - correction); /* avoid rounding errors */
        if (e>MAXDOS) e=MAXDOS;
        density_of_states[e]++;
        if(structure_energy <= eprint){
          char *outstruct = vrna_cut_point_insert(structure, cp);
          cb((const char *)outstruct, structure_energy, data);
          free(outstruct);
        }
        free(structure);
      }
    else {
      /* get (and remove) next interval of state to analyze */

      interval = pop(state->Intervals);
      scan_interval(vc, interval->i, interval->j, interval->array_flag, threshold, state, env);

      free_interval_node(interval);        /* free the current interval */
    }

    free_state_node(state);                     /* free the current state */
  } /* end of while (1) */

  /* cleanup memory */
  free(env);
}


PRIVATE void
scan_interval(vrna_fold_compound_t *vc,
              int i,
              int j,
              int array_flag,
              int threshold,
              STATE * state,
              subopt_env *env){

  /* real backtrack routine */

  /* array_flag = 0:  trace back in f5-array  */
  /* array_flag = 1:  trace back in fML-array */
  /* array_flag = 2:  trace back in repeat()  */
  /* array_flag = 3:  trace back in fM1-array */

  STATE           *new_state, *temp_state;
  INTERVAL        *new_interval;
  vrna_param_t    *P;
  vrna_md_t       *md;
  register int    k, fi, cij, ij;
  register int    type;
  register int    dangle_model;
  register int    noLP;
  int             element_energy, best_energy;
  int             *fc, *f5, *c, *fML, *fM1, *ggg;
  int             FcH, FcI, FcM, *fM2;
  int             length, *indx, *rtype, circular, with_gquad, turn, cp;
  char            *ptype;
  short           *S1;
  char            *hard_constraints, hc_decompose;
  vrna_hc_t       *hc;
  vrna_sc_t       *sc;

  length    = vc->length;
  cp        = vc->cutpoint;
  indx      = vc->jindx;
  ptype     = vc->ptype;
  S1        = vc->sequence_encoding;
  P         = vc->params;
  md        = &(P->model_details);
  rtype     = &(md->rtype[0]);

  dangle_model  = md->dangles;
  noLP          = md->noLP;
  circular      = md->circ;
  with_gquad    = md->gquad;
  turn          = md->min_loop_size;

  fc  = vc->matrices->fc;
  f5  = vc->matrices->f5;
  c   = vc->matrices->c;
  fML = vc->matrices->fML;
  fM1 = vc->matrices->fM1;
  ggg = vc->matrices->ggg;
  FcH = vc->matrices->FcH;
  FcI = vc->matrices->FcI;
  FcM = vc->matrices->FcM;
  fM2 = vc->matrices->fM2;

  hc                = vc->hc;
  hard_constraints  = hc->matrix;

  sc                = vc->sc;

  best_energy = best_attainable_energy(vc, state);  /* .. on remaining intervals */
  env->nopush = true;

  if ((i > 1) && (!array_flag))
    vrna_message_error ("Error while backtracking!");

  if (j < i + turn + 1 && ON_SAME_STRAND(i,j,cp)) { /* minimal structure element */
    if(array_flag == 0){
      /* do not forget to add f5[j], since it may contain pseudo energies from soft constraining */
      state->partial_energy += f5[j];
    }
    if (env->nopush){
      push_back(env->Stack, state);
      env->nopush = false;
    }
    return;
  }

  ij = indx[j] + i;

  /* 13131313131313131313131313131313131313131313131313131313131313131313131 */
  if (array_flag == 3 || array_flag == 1) {
    /* array_flag = 3: interval i,j was generated during */
    /*                 a multiloop decomposition using array fM1 in repeat() */
    /*                 or in this block */

    /* array_flag = 1: interval i,j was generated from a */
    /*                 stack, bulge, or internal loop in repeat() */
    /*                 or in this block */

    if(hc->up_ml[j]){
      if (array_flag == 3)
        fi = fM1[indx[j-1] + i] + P->MLbase;
      else
        fi = fML[indx[j-1] + i] + P->MLbase;

      if(sc){
        if(sc->energy_up)
          fi += sc->energy_up[j][1];
        if(sc->f)
          fi += sc->f(i, j, i, j - 1, VRNA_DECOMP_ML_ML, sc->data);
      }

      if ((fi + best_energy <= threshold)&&(ON_SAME_STRAND(j-1,j, cp))) {
        /* no basepair, nibbling of 3'-end */
        fork_state(i, j-1, state, P->MLbase, array_flag, env);
      }
    }

    hc_decompose  = hard_constraints[ij];

    if (hc_decompose & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC) { /* i,j may pair */
      cij = c[ij];

      type = ptype[ij];

      if(type == 0)
        type = 7;

      switch(dangle_model){
        case 0:   element_energy = E_MLstem(type, -1, -1, P);
                  break;
        default:  element_energy = E_MLstem(type,
                                  (((i > 1)&&(ON_SAME_STRAND(i-1,i,cp))) || circular)       ? S1[i-1] : -1,
                                  (((j < length)&&(ON_SAME_STRAND(j,j+1,cp))) || circular)  ? S1[j+1] : -1,
                                  P);
                  break;
      }

      if(sc){
/* should be unnecessary
        if(sc->energy_bp)
          element_energy += sc->energy_bp[ij];
*/
        if(sc->f)
          element_energy += sc->f(i, j, i, j, VRNA_DECOMP_ML_STEM, sc->data);
      }
      cij += element_energy;

      if (cij + best_energy <= threshold)
        repeat(vc, i, j, state, element_energy, 0, best_energy, threshold, env);
    } else if (with_gquad){
      element_energy = E_MLstem(0, -1, -1, P);
      cij = ggg[ij] + element_energy;
      if(cij + best_energy <= threshold)
        repeat_gquad(vc, i, j, state, element_energy, 0, best_energy, threshold, env);
    }
  }                                   /* array_flag == 3 || array_flag == 1 */

  /* 11111111111111111111111111111111111111111111111111111111111111111111111 */

  if (array_flag == 1) {
    /* array_flag = 1:                   interval i,j was generated from a */
    /*                          stack, bulge, or internal loop in repeat() */
    /*                          or in this block */

    int stopp, k1j;
    if ((ON_SAME_STRAND(i-1,i,cp))&&(ON_SAME_STRAND(j,j+1,cp))) { /*backtrack in FML only if multiloop is possible*/
      for ( k = i+turn+1 ; k <= j-1-turn ; k++) {
        /* Multiloop decomposition if i,j contains more than 1 stack */

        if(with_gquad){
          if(ON_SAME_STRAND(k, k+1, cp)){
            element_energy = E_MLstem(0, -1, -1, P);
            if(fML[indx[k]+i] + ggg[indx[j] + k + 1] + element_energy + best_energy <= threshold){
              
              temp_state = derive_new_state(i, k, state, 0, array_flag);
              env->nopush = false;
              repeat_gquad(vc, k+1, j, temp_state, element_energy, fML[indx[k]+i], best_energy, threshold, env);
              free_state_node(temp_state);
            }
          }
        }

        k1j = indx[j] + k + 1;

        if(hard_constraints[k1j] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC){
          short s5, s3;
          type = ptype[k1j];

          if(type == 0)
            type = 7;

          switch(dangle_model){
            case 0:   s5 = s3 = -1;
                      break;
            default:  s5 = (ON_SAME_STRAND(i-1,i,cp)) ? S1[k] : -1;
                      s3 = (ON_SAME_STRAND(j,j+1,cp)) ? S1[j+1] : -1;
                      break;
          }

          element_energy = E_MLstem(type, s5, s3, P);

          if(sc){
/* should be unnecessary
            if(sc->energy_bp)
              element_energy += sc->energy_bp[k1j];
*/
            if(sc->f)
              element_energy += sc->f(i, j, k, k + 1, VRNA_DECOMP_ML_ML_STEM, sc->data);
          }

          if(ON_SAME_STRAND(k, k+1, cp)){
            if(fML[indx[k]+i] + c[k1j] + element_energy + best_energy <= threshold){
              temp_state  = derive_new_state(i, k, state, 0, array_flag);
              env->nopush = false;
              repeat(vc, k+1, j, temp_state, element_energy, fML[indx[k]+i], best_energy, threshold, env);
              free_state_node(temp_state);
            }
          }
        }
      }
    }

    stopp=(cp>0)? (cp-2):(length); /*if cp -1: k on cut, => no ml*/
    stopp=MIN2(stopp, j-1-turn);
    if (i>cp) stopp=j-1-turn;
    else if (i==cp) stopp=0;   /*not a multi loop*/

    int up = 1;
    for(k = i; k <= stopp; k++, up++){

      if(hc->up_ml[i] >= up){
        k1j = indx[j] + k + 1;

        /* Multiloop decomposition if i,j contains only 1 stack */
        if(with_gquad){
          element_energy = E_MLstem(0, -1, -1, P) + P->MLbase * up;

          if(sc){
            if(sc->energy_up)
              element_energy += sc->energy_up[i][up];
          }

          if(ggg[k1j] + element_energy + best_energy <= threshold)
            repeat_gquad(vc, k+1, j, state, element_energy, 0, best_energy, threshold, env);
        }

        if(hard_constraints[k1j] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC){
          int s5, s3;
          type = ptype[k1j];

          if(type == 0)
            type = 7;

          switch(dangle_model){
            case 0:   s5 = s3 = -1;
                      break;
            default:  s5 = (ON_SAME_STRAND(k-1,k,cp)) ? S1[k] : -1;
                      s3 = (ON_SAME_STRAND(j,j+1,cp)) ? S1[j+1] : -1;
                      break;
          }

          element_energy = E_MLstem(type, s5, s3, P);

          element_energy += P->MLbase * up;

          if(sc){
            if(sc->energy_up)
              element_energy += sc->energy_up[i][up];

/* should be unnecessary
            if(sc->energy_bp)
              element_energy += sc->energy_bp[k1j];
*/
          }

          if (c[k1j] + element_energy + best_energy <= threshold)
            repeat(vc, k+1, j, state, element_energy, 0, best_energy, threshold, env);
        }
      }
    }
  } /* array_flag == 1 */

  /* 22222222222222222222222222222222222222222222222222 */
  /*                                                    */
  /* array_flag = 2:  interval i,j was generated from a */
  /* stack, bulge, or internal loop in repeat()         */
  /*                                                    */
  /* 22222222222222222222222222222222222222222222222222 */
  if(array_flag == 2){
    repeat(vc, i, j, state, 0, 0, best_energy, threshold, env);

    if (env->nopush){
      if (!noLP){
        fprintf(stderr, "%d,%d", i, j);
        fprintf(stderr, "Oops, no solution in repeat!\n");
      }
    }
    return;
  }

  /* 00000000000000000000000000000000000000000000000000 */
  /*                                                    */
  /* array_flag = 0:  interval i,j was found while      */
  /* tracing back through f5-array and c-array          */
  /* or within this block                               */
  /*                                                    */
  /* 00000000000000000000000000000000000000000000000000 */
  if((array_flag == 0) && !circular){
    int s5, s3, kj, tmp_en;

    if(hc->up_ext[j]){
      tmp_en = 0;
      if(sc){
        if(sc->energy_up)
          tmp_en += sc->energy_up[j][1];
      }
      if (f5[j-1] + tmp_en + best_energy <= threshold) {
        /* no basepair, nibbling of 3'-end */
        fork_state(i, j-1, state, tmp_en, 0, env);
      }
    }

    for (k = j-turn-1; k > 1; k--) {
      kj = indx[j] + k;

      if(with_gquad){
        if(ON_SAME_STRAND(k,j,cp)){
          element_energy = 0;
          if(f5[k-1] + ggg[kj] + element_energy + best_energy <= threshold){
            temp_state = derive_new_state(1, k-1, state, 0, 0);
            env->nopush = false;
            /* backtrace the quadruplex */
            repeat_gquad(vc, k, j, temp_state, element_energy, f5[k-1], best_energy, threshold, env);
            free_state_node(temp_state);
          }
        }
      }

      if(hard_constraints[kj] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
        type = ptype[kj];

        if(type == 0)
          type = 7;

        /* k and j pair */
        switch(dangle_model){
          case 0:   s5 = s3 = -1;
                    break;
          default:  s5 = (ON_SAME_STRAND(k-1,k,cp)) ? S1[k-1] : -1;
                    s3 = ((j < length)&&(ON_SAME_STRAND(j,j+1,cp))) ? S1[j+1] : -1;
                    break;
        }
        
        element_energy = E_ExtLoop(type, s5, s3, P);

        if (!(ON_SAME_STRAND(k,j,cp)))/*&&(state->is_duplex==0))*/ {
          element_energy+=P->DuplexInit;
          /*state->is_duplex=1;*/
        }

        if (f5[k-1] + c[kj] + element_energy + best_energy <= threshold){
          temp_state = derive_new_state(1, k-1, state, 0, 0);
          env->nopush = false;
          repeat(vc, k, j, temp_state, element_energy, f5[k-1], best_energy, threshold, env);
          free_state_node(temp_state);
        }
      }
    }

    kj = indx[j] + 1;

    if(with_gquad){
      if(ON_SAME_STRAND(k,j,cp)){
        element_energy = 0;
        if(ggg[kj] + element_energy + best_energy <= threshold){
          /* backtrace the quadruplex */
          repeat_gquad(vc, 1, j, state, element_energy, 0, best_energy, threshold, env);
        }
      }
    }

    if(hard_constraints[kj] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
      type  = ptype[kj];
      s5    = -1;

      if(type == 0)
        type = 7;

      switch(dangle_model){
        case 0:   s3 = -1;
                  break;
        default:  s3 = (j < length) && (ON_SAME_STRAND(j,j+1,cp)) ? S1[j+1] : -1;
                  break;
      }

      element_energy = E_ExtLoop(type, s5, s3, P);

      if(!(ON_SAME_STRAND(1,j,cp)))
        element_energy += P->DuplexInit;
      if (c[kj] + element_energy + best_energy <= threshold)
        repeat(vc, 1, j, state, element_energy, 0, best_energy, threshold, env);
    }
  } /* end array_flag == 0 && !circular*/
  /* or do we subopt circular? */
  else if(array_flag == 0){
    int k, l, p, q, tmp_en;
    /* if we've done everything right, we will never reach this case more than once   */
    /* right after the initilization of the stack with ([1,n], empty, 0)              */
    /* lets check, if we can have an open chain without breaking the threshold        */
    /* this is an ugly work-arround cause in case of an open chain we do not have to  */
    /* backtrack anything further...                                                  */
    if(hc->up_ext[1] >= length){
      tmp_en = 0;

      if(sc){
        if(sc->energy_up)
          tmp_en += sc->energy_up[1][length];
      }

      if(tmp_en <= threshold){
        new_state = derive_new_state(1,2,state,0,0);
        new_state->partial_energy = 0;
        push(env->Stack, new_state);
        env->nopush = false;
      }
    }

    /* ok, lets check if we can do an exterior hairpin without breaking the threshold */
    /* best energy should be 0 if we are here                                         */
    if(FcH + best_energy <= threshold){
      /* lets search for all exterior hairpin cases, that fit into our threshold barrier  */
      /* we use index k,l to avoid confusion with i,j index of our state...               */
      /* if we reach here, i should be 1 and j should be n respectively                   */
      for(k=i; k<j; k++){
        if(hc->up_hp[1] < k)
          break;

        for (l=j; l >= k + turn + 1; l--){
          int kl, tmpE;

          kl    = indx[l] + k;
          tmpE  = vrna_E_hp_loop(vc, l, k);

          if(c[kl] + tmpE + best_energy <= threshold){
            /* what we really have to do is something like this, isn't it?  */
            /* we have to create a new state, with interval [k,l], then we  */
            /* add our loop energy as initial energy of this state and put  */
            /* the state onto the stack R... for further refinement...      */
            /* we also denote this new interval to be scanned in C          */
            fork_state(k, l, state, tmpE, 2, env);
          }
        }
      }
    }

    /* now lets see, if we can do an exterior interior loop without breaking the threshold */
    if(FcI + best_energy <= threshold){
      /* now we search for our exterior interior loop possibilities */
      for(k=i; k<j; k++){
        for (l=j; l >= k + turn + 1; l--){
          int kl, type, tmpE;

          kl    = indx[l]+k;        /* just confusing these indices ;-) */

          if(hard_constraints[kl] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP){
            type  = ptype[kl];
            type  = rtype[type];

            if(type == 0)
              type = 7;

            for (p = l+1; p < j ; p++){
              int u1, qmin;
              u1 = p-l-1;
              if (u1+k-1>MAXLOOP) break;
              if (hc->up_int[l+1] < u1) break;

              qmin = u1+k-1+j-MAXLOOP;
              if(qmin<p+turn+1) qmin = p+turn+1;

              for(q = j; q >= qmin; q--){
                int u2, type_2;

                if(hc->up_int[q+1] < (j - q + k - 1))
                  break;

                if(hard_constraints[indx[q]+p] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP){
                  type_2 = rtype[ptype[indx[q]+p]];

                  if(type_2 == 0)
                    type_2 = 7;

                  u2 = k-1 + j-q;
                  if(u1+u2>MAXLOOP) continue;
                  tmpE = E_IntLoop(u1, u2, type, type_2, S1[l+1], S1[k-1], S1[p-1], S1[q+1], P);
                  
                  if(sc){
                    if(sc->energy_up)
                      tmpE += sc->energy_up[l+1][p-l-1]
                              + sc->energy_up[q+1][j-q]
                              + sc->energy_up[1][k-1];
                    
                    if(sc->energy_stack)
                      if(u1 + u2 == 0)
                        tmpE += sc->energy_stack[k]
                                + sc->energy_stack[l]
                                + sc->energy_stack[p]
                                + sc->energy_stack[q];
                  }

                  if(c[kl] + c[indx[q]+p] + tmpE + best_energy <= threshold){
                    /* ok, similar to the hairpin stuff, we add new states onto the stack R */
                    /* but in contrast to the hairpin decomposition, we have to add two new */
                    /* intervals, enclosed by k,l and p,q respectively and we also have to  */
                    /* add the partial energy, that comes from the exterior interior loop   */
                    fork_two_states(k, l, p, q, state, tmpE, 2, 2, env);
                  }
                }
              }
            }
          }
        }
      }
    }

    /* and last but not least, we have a look, if we can do an exterior multiloop within the energy threshold */
    if(FcM <= threshold){
      /* this decomposition will be somehow more complicated...so lets see what we do here...           */
      /* first we want to find out which split inidices we can use without exceeding the threshold */
      int tmpE2;
      for (k=turn+1; k<j-2*turn; k++){
        tmpE2 = fML[indx[k]+1]+fM2[k+1]+P->MLclosing;
        if(tmpE2 + best_energy <= threshold){
          /* grmpfh, we have found a possible split index k so we have to split fM2 and fML now */
          /* lets do it first in fM2 anyway */
          for(l=k+turn+2; l<j-turn-1; l++){
            tmpE2 = fM1[indx[l]+k+1] + fM1[indx[j]+l+1];
            if(tmpE2 + fML[indx[k]+1] + P->MLclosing <= threshold){
              /* we've (hopefully) found a valid decomposition of fM2 and therefor we have all */
              /* three intervals for our new state to be pushed on stack R */
              new_state = copy_state(state);

              /* first interval leads for search in fML array */
              new_interval = make_interval(1, k, 1);
              push(new_state->Intervals, new_interval);
              env->nopush = false;

              /* next, we have the first interval that has to be traced in fM1 */
              new_interval = make_interval(k+1, l, 3);
              push(new_state->Intervals, new_interval);
              env->nopush = false;

              /* and the last of our three intervals is also one to be traced within fM1 array... */
              new_interval = make_interval(l+1, j, 3);
              push(new_state->Intervals, new_interval);
              env->nopush = false;

              /* mmh, we add the energy for closing the multiloop now... */
              new_state->partial_energy += P->MLclosing;
              /* next we push our state onto the R stack */
              push(env->Stack, new_state);
              env->nopush = false;

            }
            /* else we search further... */
          }

          /* ok, we have to decompose fML now... */
        }
      }
    }
  }        /* thats all folks for the circular case... */

  /* 44444444444444444444444444444444444444444444444444 */
  /*                                                    */
  /* array_flag = 4:  interval i,j was found while      */
  /* tracing back through fc-array smaller than than cp */
  /* or within this block                               */
  /*                                                    */
  /* 44444444444444444444444444444444444444444444444444 */
  if (array_flag == 4) {
    int ik, s5, s3, tmp_en;

    if(hc->up_ext[i]){
      tmp_en = 0;

      if(sc){
        if(sc->energy_up)
          tmp_en += sc->energy_up[i][1];
      }

      if (fc[i+1] + tmp_en + best_energy <= threshold) {
        /* no basepair, nibbling of 5'-end */
        fork_state(i+1, j, state, tmp_en, 4, env);
      }
    }

    for (k = i+TURN+1; k < j; k++) {

      ik = indx[k] + i;

      if(with_gquad){
        if(fc[k+1] + ggg[ik] + best_energy <= threshold){
          temp_state = derive_new_state(k+1, j, state, 0, 4);
          env->nopush = false;
          repeat_gquad(vc, i, k, temp_state, 0, fc[k+1], best_energy, threshold, env);
          free_state_node(temp_state);
        }
      }

      if(hard_constraints[ik] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
        type = ptype[ik];

        if(type == 0)
          type = 7;

        switch(dangle_model){
          case 0:   s5 = s3 = -1;
                    break;
          default:  s5 = (i > 1) ? S1[i-1]: -1;
                    s3 = S1[k+1];
                    break;
        }

        element_energy = E_ExtLoop(type, s5, s3, P);

/* should be unnecessary
        if(sc){
          if(sc->energy_bp)
            element_energy += sc->energy_bp[ik];
        }
*/

        if (fc[k+1] + c[ik] + element_energy + best_energy <= threshold){
          temp_state = derive_new_state(k+1, j, state, 0, 4);
          env->nopush = false;
          repeat(vc, i, k, temp_state, element_energy, fc[k+1], best_energy, threshold, env);
          free_state_node(temp_state);
        }
      }
    }

    ik = indx[cp -1] + i; /* indx[j] + i; */

    if(with_gquad){
      if(ggg[ik] + best_energy <= threshold)
        repeat_gquad(vc, i, cp - 1, state, 0, 0, best_energy, threshold, env);
    }

    if(hard_constraints[ik] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
      type  = ptype[ik];
      s3    = -1;

      if(type == 0)
        type = 7;

      switch(dangle_model){
        case 0:   s5 = -1;
                  break;
        default:  s5 = (i>1) ? S1[i-1] : -1;
                  break;
      }

      element_energy = E_ExtLoop(type, s5, s3, P);

/* should be unnecessary
      if(sc){
        if(sc->energy_bp)
          element_energy += sc->energy_bp[ik];
      }
*/

      if(c[ik] + element_energy + best_energy <= threshold)
        repeat(vc, i, cp-1, state, element_energy, 0, best_energy, threshold, env);
    }
  } /* array_flag == 4 */

  /* 55555555555555555555555555555555555555555555555555 */
  /*                                                    */
  /* array_flag = 5:  interval cp=i,j was found while   */
  /* tracing back through fc-array greater than cp      */
  /* or within this block                               */
  /*                                                    */
  /* 55555555555555555555555555555555555555555555555555 */
  if (array_flag == 5) {
    int kj, s5, s3, tmp_en;

    if(hc->up_ext[j]){
      tmp_en = 0;

      if(sc){
        if(sc->energy_up)
          tmp_en += sc->energy_up[j][1];
      }

      if (fc[j-1] + tmp_en + best_energy <= threshold) {
        /* no basepair, nibbling of 3'-end */
        fork_state(i, j-1, state, tmp_en, 5, env);
      }
    }


    for (k = j-TURN-1; k > i; k--) {
      kj = indx[j] + k;

      if(with_gquad){
        if(fc[k-1] + ggg[kj] + best_energy <= threshold){
          temp_state = derive_new_state(i, k-1, state, 0, 5);
          env->nopush = false;
          repeat_gquad(vc, k, j, temp_state, 0, fc[k-1], best_energy, threshold, env);
          free_state_node(temp_state);
        }
      }

      if(hard_constraints[kj] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
        type            = ptype[kj];
        element_energy  = 0;

        if(type == 0)
          type = 7;

        switch(dangle_model){
          case 0:   s3 = s5 = -1;
                    break;
          default:  s5 = S1[k-1];
                    s3 = (j < length) ? S1[j+1] : -1;
                    break;
        }

        element_energy = E_ExtLoop(type, s5, s3, P);

/*  should be unnecessary
        if(sc){
          if(sc->energy_bp)
            element_energy += sc->energy_bp[kj];
        }
*/

        if (fc[k-1] + c[kj] + element_energy + best_energy <= threshold) {
          temp_state = derive_new_state(i, k-1, state, 0, 5);
          env->nopush = false;
          repeat(vc, k, j, temp_state, element_energy, fc[k-1], best_energy, threshold, env);
          free_state_node(temp_state);
        }
      }
    }

    kj = indx[j] + cp; /* indx[j] + i; */

    if(with_gquad){
      if(ggg[kj] + best_energy <= threshold)
        repeat_gquad(vc, cp, j, state, 0, 0, best_energy, threshold, env);
    }

    if(hard_constraints[kj] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
      type  = ptype[kj];
      s5    = -1;

      if(type == 0)
        type = 7;

      switch(dangle_model){
        case 0:   s3 = -1;
                  break;
        default:  s3 = (j<length) ? S1[j+1] : -1;
                  break;
      }

      element_energy = E_ExtLoop(type, s5, s3, P);

      if (c[kj] + element_energy + best_energy <= threshold)
        repeat(vc, cp, j, state, element_energy, 0, best_energy, threshold, env);
    }
  } /* array_flag == 5 */

  if (array_flag == 6) { /* we have a gquad */
    repeat_gquad(vc, i, j, state, 0, 0, best_energy, threshold, env);
    if (env->nopush){
      fprintf(stderr, "%d,%d", i, j);
      fprintf(stderr, "Oops, no solution in gquad-repeat!\n");
    }
    return;
  }

  if (env->nopush){
    push_back(env->Stack, state);
    env->nopush = false;
  }
  return;
}

/*---------------------------------------------------------------------------*/
PRIVATE void
repeat_gquad( vrna_fold_compound_t *vc,
              int i,
              int j,
              STATE *state,
              int part_energy,
              int temp_energy,
              int best_energy,
              int threshold,
              subopt_env *env){

  int           *ggg, *indx, element_energy, cp;
  short         *S1;
  vrna_param_t  *P;

  indx  = vc->jindx;
  cp    = vc->cutpoint;
  ggg   = vc->matrices->ggg;
  S1    = vc->sequence_encoding;
  P     = vc->params;


  /* find all gquads that fit into the energy range and the interval [i,j] */
  STATE *new_state;
  best_energy += part_energy; /* energy of current structural element */
  best_energy += temp_energy; /* energy from unpushed interval */

  if(ON_SAME_STRAND(i,j,cp)){
    element_energy = ggg[indx[j] + i];
    if(element_energy + best_energy <= threshold){
      int cnt;
      int *L;
      int *l;
      /* find out how many gquads we might expect in the interval [i,j] */
      int num_gquads = get_gquad_count(S1, i, j);
      num_gquads++;
      L = (int *)vrna_alloc(sizeof(int) * num_gquads);
      l = (int *)vrna_alloc(sizeof(int) * num_gquads * 3);
      L[0] = -1;

      get_gquad_pattern_exhaustive(S1, i, j, P, L, l, threshold - best_energy);

      for(cnt = 0; L[cnt] != -1; cnt++){
        new_state = copy_state(state);

        make_gquad(i, L[cnt], &(l[3*cnt]), new_state);
        new_state->partial_energy += part_energy;
        new_state->partial_energy += element_energy;
        /* new_state->best_energy =
           hairpin[unpaired] + element_energy + best_energy; */
        push(env->Stack, new_state);
        env->nopush = false;
      }
      free(L);
      free(l);
    }
  }

  best_energy -= part_energy;
  best_energy -= temp_energy;
  return;
}



PRIVATE void
repeat( vrna_fold_compound_t *vc,
        int i,
        int j,
        STATE * state,
        int part_energy,
        int temp_energy,
        int best_energy,
        int threshold,
        subopt_env *env){

  /* routine to find stacks, bulges, internal loops and  multiloops */
  /* within interval closed by basepair i,j */

  STATE           *new_state;
  vrna_param_t    *P;
  vrna_md_t       *md;

  register int  ij, k, p, q, energy, newX;
  register int  mm;
  register int  no_close, type, type_2;
  char          *ptype;
  int           element_energy;
  int             *fc, *c, *fML, *fM1, *ggg;
  int           rt, *indx, *rtype, noGUclosure, noLP, with_gquad, dangle_model, turn, cp;
  short         *S1;
  vrna_hc_t     *hc;
  vrna_sc_t     *sc;

  S1        = vc->sequence_encoding;
  ptype     = vc->ptype;
  indx      = vc->jindx;
  cp        = vc->cutpoint;
  P         = vc->params;
  md        = &(P->model_details);
  rtype     = &(md->rtype[0]);

  noGUclosure   = md->noGUclosure;
  noLP          = md->noLP;
  with_gquad    = md->gquad;
  dangle_model  = md->dangles;
  turn          = md->min_loop_size;

  fc  = vc->matrices->fc;
  c   = vc->matrices->c;
  fML = vc->matrices->fML;
  fM1 = vc->matrices->fM1;
  ggg = vc->matrices->ggg;

  hc    = vc->hc;
  sc    = vc->sc;

  ij = indx[j]+i;

  type = ptype[ij];
/*
  if (type==0) fprintf(stderr, "repeat: Warning: %d %d can't pair\n", i,j);
*/

  if(type == 0)
    type = 7;

  no_close = (((type == 3) || (type == 4)) && noGUclosure);

  if(hc->matrix[ij] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP){
    if (noLP) /* always consider the structure with additional stack */
      if(i + turn + 2 < j){
        if(hc->matrix[indx[j-1]+i+1] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP_ENC){
          type_2 = rtype[ptype[indx[j-1]+i+1]];

          if(type_2 == 0)
            type_2 = 7;

          energy = 0;

          if(ON_SAME_STRAND(i,i+1,cp) && ON_SAME_STRAND(j-1,j, cp)){
            energy = E_IntLoop(0, 0, type, type_2,S1[i+1],S1[j-1],S1[i+1],S1[j-1], P);

            if(sc){
              if(sc->energy_bp)
                energy += sc->energy_bp[ij];

              if(sc->energy_stack)
                energy += sc->energy_stack[i]
                          + sc->energy_stack[i+1]
                          + sc->energy_stack[j-1]
                          + sc->energy_stack[j];

              if(sc->f)
                energy += sc->f(i, j, i+1, j-1, VRNA_DECOMP_PAIR_IL, sc->data);
            }

            new_state = derive_new_state(i+1, j-1, state, part_energy + energy, 2);
            make_pair(i, j, new_state);
            make_pair(i+1, j-1, new_state);

            /* new_state->best_energy = new + best_energy; */
            push(env->Stack, new_state);
            env->nopush = false;
            if (i==1 || state->structure[i-2]!='('  || state->structure[j]!=')')
              /* adding a stack is the only possible structure */
              return;
          }
        }
      }
  }

  best_energy += part_energy; /* energy of current structural element */
  best_energy += temp_energy; /* energy from unpushed interval */

  if(hc->matrix[ij] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP){
    for (p = i + 1; p <= MIN2 (j-2-turn,  i+MAXLOOP+1); p++) {
      int minq = j-i+p-MAXLOOP-2;
      if (minq<p+1+turn) minq = p+1+turn;

      if(hc->up_int[i+1] < (p - i - 1))
        break;

      for (q = j - 1; q >= minq; q--) {
        if(hc->up_int[q+1] < (j - q - 1))
          break;

        /* skip stack if noLP, since we've already processed it above */
        if((noLP) && (p==i+1) && (q==j-1))
          continue;

        if(!(hc->matrix[indx[q]+p] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP_ENC))
          continue;

        type_2 = ptype[indx[q]+p];

        if(type_2 == 0)
          type_2 = 7;

        if (noGUclosure)
          if (no_close||(type_2==3)||(type_2==4))
            if ((p>i+1)||(q<j-1)) continue;  /* continue unless stack */

        if (ON_SAME_STRAND(i,p,cp) && ON_SAME_STRAND(q,j,cp)) {
          energy = E_IntLoop(p-i-1, j-q-1, type, rtype[type_2],
                              S1[i+1],S1[j-1],S1[p-1],S1[q+1], P);

          newX = energy + c[indx[q]+p];

          if(sc){
            if(sc->energy_up)
              energy  +=  sc->energy_up[i+1][p-i-1]
                          + sc->energy_up[q+1][j-q-1];

            if(sc->energy_bp)
              energy  += sc->energy_bp[ij];

            if(sc->energy_stack)
              if((p == i+1) && (q == j-1))
                energy  +=  sc->energy_stack[i]
                            + sc->energy_stack[p]
                            + sc->energy_stack[q]
                            + sc->energy_stack[j];

            if(sc->f)
              energy  += sc->f(i, j, p, q, VRNA_DECOMP_PAIR_IL, sc->data);
          }

          newX = energy + c[indx[q]+p];

          if (newX + best_energy <= threshold) {
            /* stack, bulge, or interior loop */
            fork_int_state(i, j, p, q, state, part_energy + energy, env);
          }
        }/*end of if block */
      } /* end of q-loop */
    } /* end of p-loop */
  }

  if (!ON_SAME_STRAND(i,j,cp)) { /*look in fc*/
    if(hc->matrix[ij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
      rt = rtype[type];

      if(rt == 0)
        rt = 7;

      element_energy=0;
      switch(dangle_model){
        case 0:   element_energy = E_ExtLoop(rt, -1, -1, P);
                  break;
        default:  element_energy = E_ExtLoop(rt, (ON_SAME_STRAND(j-1,j,cp)) ? S1[j-1] : -1, (ON_SAME_STRAND(i,i+1,cp)) ? S1[i+1] : -1, P);
                  break;
      }

      if (fc[i+1] + fc[j-1] +element_energy + best_energy  <= threshold)
        {
          fork_two_states_pair(i, j, cp, state, part_energy + element_energy, 4, 5, env);
        }
    }
  }

  mm = P->MLclosing;
  rt = rtype[type];

  if((hc->matrix[ij] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP) && (i != cp-1) && (j != cp)){

    if(rt == 0)
      rt = 7;

    element_energy = mm;
    switch(dangle_model){
      case 0:   element_energy = E_MLstem(rt, -1, -1, P) + mm;
                break;
      default:  element_energy = E_MLstem(rt, S1[j-1], S1[i+1], P) + mm;
                break;
    }

    if(sc){
      if(sc->energy_bp)
        element_energy += sc->energy_bp[ij];
    }

    for (k = i + turn + 2; k <= j - turn - 2; k++)  {
      /* multiloop decomposition */
      if ((fML[indx[k-1] + i+1] + fM1[indx[j-1] + k] +
          element_energy + best_energy)  <= threshold)
        {
          fork_two_states_pair(i, j, k, state, part_energy + element_energy, 1, 3, env);
        }
    }
  }

  if (ON_SAME_STRAND(i,j,cp)) {
    if(hc->matrix[ij] & VRNA_CONSTRAINT_CONTEXT_HP_LOOP){

      if(no_close)
        element_energy = FORBIDDEN;
      else
          element_energy = vrna_E_hp_loop(vc, i, j);

      if (element_energy + best_energy <= threshold) {
        /* hairpin structure */
        fork_state_pair(i, j, state, part_energy + element_energy, env);
      }
    }

    if(with_gquad){
      /* now we have to find all loops where (i,j) encloses a gquad in an interior loops style */
      int cnt, *p, *q, *en, tmp_en;
      p = q = en = NULL;
      en = E_GQuad_IntLoop_exhaustive(i, j, &p, &q, type, S1, ggg, threshold - best_energy, indx, P);
      for(cnt = 0; p[cnt] != -1; cnt++){
        if((hc->up_int[i+1] >= p[cnt] - i - 1) && (hc->up_int[q[cnt]+1] >= j - q[cnt] - 1)){
          tmp_en = en[cnt];

          if(sc){
            if(sc->energy_bp)
              tmp_en += sc->energy_bp[ij];

            if(sc->energy_up)
              tmp_en += sc->energy_up[i+1][p[cnt] - i - 1]
                        + sc->energy_up[q[cnt]+1][j - q[cnt] - 1];
          }

          new_state = derive_new_state(p[cnt], q[cnt], state, tmp_en + part_energy, 6);

          make_pair(i, j, new_state);

          /* new_state->best_energy = new + best_energy; */
          push(env->Stack, new_state);
          env->nopush = false;
        }
      }
      free(en);
      free(p);
      free(q);
    }
  }

  best_energy -= part_energy;
  best_energy -= temp_energy;
  return;
}

PRIVATE void
old_subopt_print( const char *structure,
                  float energy,
                  void *data){

  int r;
  char *e_string = NULL;
  struct old_subopt_dat *d = (struct old_subopt_dat *)data;

  if(structure){
    r = asprintf(&e_string, " %6.2f", energy);

    if((d->fp) && (r != -1))
      print_structure(d->fp, structure, e_string);

    free(e_string);
  }
}


PRIVATE void
old_subopt_store( const char *structure,
                  float energy,
                  void *data){

  struct old_subopt_dat *d = (struct old_subopt_dat *)data;

  /* store solution */
  if(d->n_sol + 1 == d->max_sol){
    d->max_sol     *= 2;
    d->SolutionList = (SOLUTION *)vrna_realloc(d->SolutionList, d->max_sol*sizeof(SOLUTION));
  }

  if(structure){
    d->SolutionList[d->n_sol].energy      = energy;
    d->SolutionList[d->n_sol++].structure = strdup(structure);
  } else {
    d->SolutionList[d->n_sol].energy      = 0;
    d->SolutionList[d->n_sol++].structure = NULL;
  }
}

/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/
#ifdef VRNA_BACKWARD_COMPAT

PUBLIC SOLUTION *
subopt( char *seq,
        char *structure,
        int delta,
        FILE *fp){

  return wrap_subopt(seq, structure, NULL, delta, fold_constrained, 0, fp);
}

PUBLIC SOLUTION *
subopt_circ(char *seq,
            char *structure,
            int delta,
            FILE *fp){

  return wrap_subopt(seq, structure, NULL, delta, fold_constrained, 1, fp);
}

PUBLIC SOLUTION *subopt_par(char *seq,
                            char *structure,
                            vrna_param_t *parameters,
                            int delta,
                            int is_constrained,
                            int is_circular,
                            FILE *fp){

  return wrap_subopt(seq, structure, parameters, delta, is_constrained, is_circular, fp);
}

PRIVATE SOLUTION *
wrap_subopt(char *string,
            char *structure,
            vrna_param_t *parameters,
            int delta,
            int is_constrained,
            int is_circular,
            FILE *fp){

  vrna_fold_compound_t  *vc;
  vrna_param_t        *P;
  char                *seq;

#ifdef _OPENMP
/* Explicitly turn off dynamic threads */
  omp_set_dynamic(0);
#endif

  /* we need the parameter structure for hard constraints */
  if(parameters){
    P = vrna_params_copy(parameters);
  } else {
    vrna_md_t md;
    set_model_details(&md);
    md.temperature = temperature;
    P = vrna_params(&md);
  }
  P->model_details.circ     = is_circular;
  P->model_details.uniq_ML  = uniq_ML = 1;

  /* what about cofold sequences here? Is it safe to call the below cut_point_insert() ? */
  /* dirty hack to reinsert the '&' according to the global variable 'cut_point' */
  seq = vrna_cut_point_insert(string, cut_point);

  vc = vrna_fold_compound(seq, &(P->model_details), ((is_circular == 0) ? VRNA_OPTION_HYBRID : VRNA_OPTION_DEFAULT));

  if(parameters){ /* replace params if necessary */
    free(vc->params);
    vc->params = P;
  } else {
    free(P);
  }

  /* handle hard constraints in pseudo dot-bracket format if passed via simple interface */
  if(is_constrained && structure){
    unsigned int constraint_options = 0;
    constraint_options |= VRNA_CONSTRAINT_DB
                          | VRNA_CONSTRAINT_DB_PIPE
                          | VRNA_CONSTRAINT_DB_DOT
                          | VRNA_CONSTRAINT_DB_X
                          | VRNA_CONSTRAINT_DB_ANG_BRACK
                          | VRNA_CONSTRAINT_DB_RND_BRACK
                          | VRNA_CONSTRAINT_DB_INTRAMOL
                          | VRNA_CONSTRAINT_DB_INTERMOL;

    vrna_constraints_add(vc, (const char *)structure, constraint_options);
  }

  if(backward_compat_compound && backward_compat)
    vrna_fold_compound_free(backward_compat_compound);

  backward_compat_compound  = vc;
  backward_compat           = 1;

  /* cleanup */
  free(seq);

  return vrna_subopt(vc, delta, subopt_sorted, fp);
}

#endif

/*---------------------------------------------------------------------------*/
/* Well, that is the end!----------------------------------------------------*/
/*---------------------------------------------------------------------------*/

list.c/         0           0     0     644     10567     `
/*
  $Log: list.c,v $
  Revision 1.5  2003/07/14 13:36:58  ivo
  use vrna_alloc() instead of malloc

  Revision 1.4  2000/10/10 08:53:52  ivo
  include dmalloc.h header if DMALLOC defined

  Revision 1.4  2000/10/10 08:04:34  ivo
  include dmalloc header id DMALLOC defined

  Revision 1.3  1998/03/30 14:24:51  ivo
  use RNA package utils.h

  Revision 1.2  1997/10/09  19:01:50  steve
  *** empty log message ***

  Revision 1.1  1997/08/04 21:05:32  walter
  Initial revision

*/
/*
   (C) 1991 Kendall Bennett.
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include "utils.h"
#include "list.h"

#define PUBLIC
PUBLIC void *
lst_newnode (int size)
/****************************************************************************
*
* Function:	lst_newnode
* Parameters:	size - Amount of memory to allocate for node
* Returns:      Pointer to the allocated node's user space.
*
* Description:	Allocates the memory required for a node, adding a small
*		header at the start of the node. We return a reference to
*		the user space of the node, as if it had been allocated via
*		malloc().
*
****************************************************************************/
{
  LST_BUCKET *node;

  node = (LST_BUCKET *) vrna_alloc(size + sizeof (LST_BUCKET));

  return LST_USERSPACE (node);	/* Return pointer to user space */
}

PUBLIC void
lst_freenode (void *node)
/****************************************************************************
*
* Function:	lst_freenode
* Parameters:	node - Node to free.
*
* Description:  Frees a node previously allocated with lst_newnode().
*
****************************************************************************/
{
  free (LST_HEADER (node));
}

PUBLIC LIST *
lst_init (void)
/****************************************************************************
*
* Function:	lst_init
* Returns:      Pointer to a newly created list.
*
* Description:	Initialises a list and returns a pointer to it.
*
****************************************************************************/
{
  LIST *l;

  if ((l = (LIST *) vrna_alloc(sizeof (LIST))) != NULL)
    {
      l->count = 0;
      l->head = &(l->hz[0]);
      l->z = &(l->hz[1]);
      l->head->next = l->z->next = l->z;
    }

  return l;
}

PUBLIC void
lst_kill (LIST * l, void (*freeNode) (void *node))
/****************************************************************************
*
* Function:	lst_kill
* Parameters:	l - List to kill
*		freeNode - Pointer to user routine to free a node
*
* Description:	Kills the list l, by deleting all of the elements contained
*		within the list one by one and then deleting the list
*		itself. Note that we call the user supplied routine
*		(*freeNode)() to free each list node. This allows the user
*		program to perform any extra processing needed to kill each
*		node (if each node contains pointers to other items on the
*		heap for example). If no extra processing is required, just
*		pass the address of lst_freenode(), ie:
*
*		lst_kill(myList,lst_freenode);
*
****************************************************************************/
{
  LST_BUCKET *n, *p;

  n = l->head->next;
  while (n != l->z)
    {				/* Free all nodes in list  */
      p = n;
      n = n->next;
      (*freeNode) (LST_USERSPACE (p));
    }
  free (l);			/* Free the list itself    */
}

PUBLIC void
lst_insertafter (LIST * l, void *node, void *after)
/****************************************************************************
*
* Function:	lst_insertafter
* Parameters:	l - List to insert node into
*		node - Pointer to user space of node to insert
*		after - Pointer to user space of node to insert node after
*
* Description:	Inserts a new node into the list after the node 'after'. To
*		insert a new node at the beginning of the list, user the
*		macro LST_HEAD in place of 'after'. ie:
*
*		lst_insertafter(mylist,node,LST_HEAD(mylist));
*
****************************************************************************/
{
  LST_BUCKET *n = LST_HEADER (node), *a = LST_HEADER (after);

  n->next = a->next;
  a->next = n;
  l->count++;
}

PUBLIC void *
lst_deletenext (LIST * l, void *node)
/****************************************************************************
*
* Function:	lst_deletenext
* Parameters:	l - List to delete node from.
*		node - Node to delete the next node from
* Returns:	Pointer to the deleted node's userspace.
*
* Description:	Removes the node AFTER 'node' from the list l.
*
****************************************************************************/
{
  LST_BUCKET *n = LST_HEADER (node);

  node = LST_USERSPACE (n->next);
  n->next = n->next->next;
  l->count--;
  return node;
}

PUBLIC void *
lst_first (LIST * l)
/****************************************************************************
*
* Function:	lst_first
* Parameters:	l - List to obtain first node from
* Returns:	Pointer to first node in list, NULL if list is empty.
*
* Description:	Returns a pointer to the user space of the first node in
*		the list. If the list is empty, we return NULL.
*
****************************************************************************/
{
  LST_BUCKET *n;

  n = l->head->next;
  return (n == l->z ? NULL : LST_USERSPACE (n));
}

PUBLIC void *
lst_next (void *prev)
/****************************************************************************
*
* Function:	lst_next
* Parameters:	prev - Previous node in list to obtain next node from
* Returns:	Pointer to the next node in the list, NULL at end of list.
*
* Description:	Returns a pointer to the user space of the next node in the
*		list given a pointer to the user space of the previous node.
*		If we have reached the end of the list, we return NULL. The
*		end of the list is detected when the next pointer of a node
*		points back to itself, as does the dummy last node's next
*		pointer. This enables us to detect the end of the list
*		without needed access to the list data structure itself.
*
*		NOTE:	We do no checking to ensure that 'prev' is NOT a
*			NULL pointer.
*
****************************************************************************/
{
  LST_BUCKET *n = LST_HEADER (prev);

  n = n->next;
  return (n == n->next ? NULL : LST_USERSPACE (n));
}

/* Static globals required by merge()   */

static LST_BUCKET *z;
static int (*cmp) (void *, void *);

static LST_BUCKET *
merge (LST_BUCKET * a, LST_BUCKET * b, LST_BUCKET ** end)
/****************************************************************************
*
* Function:	merge
* Parameters:	a,b - Sublist's to merge
* Returns:	Pointer to the merged sublists.
*
* Description:	Merges two sorted lists of nodes together into a single
*		sorted list.
*
****************************************************************************/
{
  LST_BUCKET *c;

  /* Go through the lists, merging them together in sorted order  */

  c = z;
  while (a != z && b != z)
    {
      if ((*cmp) (LST_USERSPACE (a), LST_USERSPACE (b)) <= 0)
	{
	  c->next = a;
	  c = a;
	  a = a->next;
	}
      else
	{
	  c->next = b;
	  c = b;
	  b = b->next;
	}
    };

  /* If one of the lists is not exhausted, then re-attach it to the end
   * of the newly merged list
   */

  if (a != z)
    c->next = a;
  if (b != z)
    c->next = b;

  /* Set *end to point to the end of the newly merged list        */

  while (c->next != z)
    c = c->next;
  *end = c;

  /* Determine the start of the merged lists, and reset z to point to
   * itself
   */

  c = z->next;
  z->next = z;
  return c;
}

PUBLIC void
lst_mergesort (LIST * l, int (*cmp_func) (void *, void *))
/****************************************************************************
*
* Function:	lst_mergesort
* Parameters:	l - List to merge sort
*		cmp_func - Function to compare two user spaces
*
* Description:	Mergesort's all the nodes in the list. 'cmp' must point to
*		a comparison function that can compare the user spaces of
*		two different nodes. 'cmp' should work the same as
*		strcmp(), in terms of the values it returns.
*
****************************************************************************/
{
  int i, N;
  LST_BUCKET *a, *b;		/* Pointers to sublists to merge                */
  LST_BUCKET *c;		/* Pointer to end of sorted sublists            */
  LST_BUCKET *head;		/* Pointer to dummy head node for list          */
  LST_BUCKET *todo;		/* Pointer to sublists yet to be sorted         */
  LST_BUCKET *t;		/* Temporary                                                            */

  /* Set up globals required by merge() and pointer to head       */

  z = l->z;
  cmp = cmp_func;
  head = l->head;

  for (N = 1, a = z; a != head->next; N = N + N)
    {
      todo = head->next;
      c = head;
      while (todo != z)
	{

	  /* Build first sublist to be merged, and splice from main list
	   */

	  a = t = todo;
	  for (i = 1; i < N; i++)
	    t = t->next;
	  b = t->next;
	  t->next = z;
	  t = b;

	  /* Build second sublist to be merged and splice from main list
	   */

	  for (i = 1; i < N; i++)
	    t = t->next;
	  todo = t->next;
	  t->next = z;

	  /* Merge the two sublists created, and set 'c' to point to the
	   * end of the newly merged sublists.
	   */

	  c->next = merge (a, b, &t);
	  c = t;
	}
    }
}

#ifdef LIST_TEST

/*---------------------------------------------------------------*/
/*---------------------------------------------------------------*/

/* Simple program to test the list routines */

typedef struct
{
  char name[40];
  int age;
}
REC;

/*---------------------------------------------------------------*/

int
my_cmp (REC * r1, REC * r2)
{
  return strcmp (r1->name, r2->name);
}

/*---------------------------------------------------------------*/

void
main (void)
{
  LIST *list;
  int done = 0;
  REC *rec;
  char line[80];

  list = lst_init ();

  printf ("Type a list of names and ages. Empty line quits\n\n");

  while (!done)
    {
      rec = lst_newnode (sizeof (REC));
      gets (line);
      if ((done = (line[0] == '\0')) != 1)
	{
	  strcpy (rec->name, line);
	  gets (line);
	  rec->age = atoi (line);
	  lst_insertafter (list, rec, LST_HEAD (list));
	}
    };

  printf ("\nThe list you typed in was:\n\n");

  for (rec = lst_first (list); rec; rec = lst_next (rec))
    printf ("Name: %s, Age: %d\n", rec->name, rec->age);

  printf ("\nSorting the list...\n\n");

  lst_mergesort (list, my_cmp);

  for (rec = lst_first (list); rec; rec = lst_next (rec))
    printf ("Name: %s, Age: %d\n", rec->name, rec->age);

  lst_kill (list, lst_freenode);
}

/*---------------------------------------------------------------*/

#endif

Lfold.c/        0           0     0     644     48200     `
/*
                  minimum free energy
                  RNA secondary structure prediction
                  with maximum distance base pairs

                  c Ivo Hofacker, Peter Stadler

                  Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>
#include "utils.h"
#include "energy_par.h"
#include "fold_vars.h"
#include "params.h"
#include "loop_energies.h"
#include "gquad.h"
#include "Lfold.h"

#ifdef USE_SVM
#include "svm.h"
#include "svm_utils.h"
#endif

#define MAXSECTORS                  500   /* dimension for a backtrack array */
#define INT_CLOSE_TO_UNDERFLOW(i)   ((i) <= (INT_MIN/16))
#define UNDERFLOW_CORRECTION        (INT_MIN/32)

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/
PRIVATE float wrap_Lfold( vrna_fold_compound_t *vc,
                          int with_zsc,
                          double min_z,
                          FILE *file);
PRIVATE void  make_ptypes(vrna_fold_compound_t *vc,
                          int i);
PRIVATE char  *backtrack( vrna_fold_compound_t *vc,
                          int start,
                          int maxdist);
PRIVATE int   fill_arrays(vrna_fold_compound_t *vc,
                          int with_zsc,
                          double min_z,
#ifdef USE_SVM
                          struct svm_model *avg_model,
                          struct svm_model *sd_model,
#endif
                          int *underflow,
                          FILE *output);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PUBLIC float
vrna_Lfold( const char *string,
            int window_size,
            FILE  *file){

  float               energy;
  vrna_fold_compound_t  *vc;
  vrna_md_t           md;

  vrna_md_set_default(&md);

  md.window_size = window_size;
  md.max_bp_span = window_size;

  vc  = vrna_fold_compound(string, &md, VRNA_OPTION_WINDOW);

  energy = wrap_Lfold(vc, 0, 0.0, file);

  vrna_fold_compound_free(vc);

  return energy;
}

PUBLIC float
vrna_mfe_window( vrna_fold_compound_t *vc,
            FILE *file){

  return wrap_Lfold(vc, 0, 0.0, file);
}

#ifdef USE_SVM

PUBLIC float
vrna_Lfoldz(const char *string,
            int window_size,
            double min_z,
            FILE *file){

  float               energy;
  vrna_fold_compound_t  *vc;
  vrna_md_t           md;

  vrna_md_set_default(&md);

  md.window_size = window_size;
  md.max_bp_span = window_size;

  vc  = vrna_fold_compound(string, &md, VRNA_OPTION_WINDOW);

  energy = wrap_Lfold(vc, 1, min_z, file);

  vrna_fold_compound_free(vc);

  return energy;
}

PUBLIC float
vrna_mfe_window_zscore( vrna_fold_compound_t *vc,
             double min_z,
             FILE *file){

  return wrap_Lfold(vc, 1, min_z, file);
}

#endif

/*
#####################################
# BEGIN OF STATIC HELPER FUNCTIONS  #
#####################################
*/

PRIVATE float
wrap_Lfold( vrna_fold_compound_t *vc,
            int with_zsc,
            double min_z,
            FILE *file){

  int     i, energy, underflow, n, maxdist;
  float   mfe_local;
  FILE    *out;

#ifdef USE_SVM
  struct svm_model  *avg_model = NULL;
  struct svm_model  *sd_model = NULL;
#endif

  vrna_fold_compound_prepare(vc, VRNA_OPTION_MFE | VRNA_OPTION_WINDOW);

  n       = vc->length;
  maxdist = vc->window_size;
  out     = (file) ? file : stdout;

  for(i = n; (i >= (int)n - (int)maxdist - 4) && (i > 0); i--)
    make_ptypes(vc, i);

#ifdef USE_SVM  /*svm*/
  if(with_zsc){
    avg_model = svm_load_model_string(avg_model_string);
    sd_model  = svm_load_model_string(sd_model_string);
  }
#endif

  /* keep track of how many times we were close to an integer underflow */
  underflow = 0;

#ifdef USE_SVM
  energy = fill_arrays(vc, with_zsc, min_z, avg_model, sd_model, &underflow, out);
  if(with_zsc){
    svm_free_model_content(avg_model);
    svm_free_model_content(sd_model);
  }
#else
  energy = fill_arrays(vc, with_zsc, min_z, &underflow, out);
#endif

  mfe_local = (underflow > 0) ? ((float)underflow * (float)(UNDERFLOW_CORRECTION)) / 100. : 0.;
  mfe_local += (float)energy/100.;

  return mfe_local;
}

PRIVATE int
fill_arrays(vrna_fold_compound_t *vc,
            int zsc,
            double min_z,
#ifdef USE_SVM
            struct svm_model *avg_model,
            struct svm_model *sd_model,
#endif
            int *underflow,
            FILE *output){

  /* fill "c", "fML" and "f3" arrays and return  optimal energy */

  int   i, j, k, length, energy, maxdist;
  int   **c, **fML, *f3, **ggg;
  int   decomp, new_fML;
  int   no_close, type, type_2, tt, with_gquad, dangle_model, noLP, noGUclosure, turn;
  int   *rtype;
  int   fij;
  int   lind;

  int   *cc = NULL;        /* linear array for calculating canonical structures */
  int   *cc1 = NULL;       /*   "     "        */
  int   *Fmi = NULL;       /* holds row i of fML (avoids jumps in memory) */
  int   *DMLi = NULL;      /* DMLi[j] holds MIN(fML[i,k]+fML[k+1,j])  */
  int   *DMLi1 = NULL;     /*             MIN(fML[i+1,k]+fML[k+1,j])  */
  int   *DMLi2 = NULL;     /*             MIN(fML[i+2,k]+fML[k+1,j])  */

  short         *S, *S1;
  char          *string, **ptype, *prev;
  vrna_param_t  *P;
  vrna_md_t     *md;


  string        = vc->sequence;
  length        = vc->length;
  S             = vc->sequence_encoding2;
  S1            = vc->sequence_encoding;
  ptype         = vc->ptype_local;
  maxdist       = vc->window_size;
  P             = vc->params;
  md            = &(P->model_details);
  dangle_model  = md->dangles;
  with_gquad    = md->gquad;
  noLP          = md->noLP;
  noGUclosure   = md->noGUclosure;
  turn          = md->min_loop_size;
  rtype         = &(md->rtype[0]);

  prev          = NULL;

  c           = vc->matrices->c_local;
  fML         = vc->matrices->fML_local;
  f3          = vc->matrices->f3_local;
  ggg         = vc->matrices->ggg_local;

  cc    = (int *)   vrna_alloc(sizeof(int)   *(maxdist+5));
  cc1   = (int *)   vrna_alloc(sizeof(int)   *(maxdist+5));
  Fmi   = (int *)   vrna_alloc(sizeof(int)   *(maxdist+5));
  DMLi  = (int *)   vrna_alloc(sizeof(int)   *(maxdist+5));
  DMLi1 = (int *)   vrna_alloc(sizeof(int)   *(maxdist+5));
  DMLi2 = (int *)   vrna_alloc(sizeof(int)   *(maxdist+5));


  for (j=0; j<maxdist+5; j++)
    Fmi[j]=DMLi[j]=DMLi1[j]=DMLi2[j]=INF;
  for (j=length; j>length-maxdist-4; j--) {
    for (i=(length-maxdist-4>0)?length-maxdist-4:1 ; i<j; i++)
      c[i][j-i] = fML[i][j-i] = INF;
  }

  if(with_gquad){
    vrna_gquad_mx_local_update(vc, length - maxdist - 4);
    ggg = vc->matrices->ggg_local;
  }

  for (i = length-turn-1; i >= 1; i--) { /* i,j in [1..length] */
    for (j = i+turn+1; j <= length && j <= i+maxdist; j++) {
      int p, q;
      type = ptype[i][j-i];

      no_close = (((type==3)||(type==4))&&noGUclosure);

      if (type) {   /* we have a pair */
        int new_c=0, stackEnergy=INF;
        /* hairpin ----------------------------------------------*/

        new_c = (no_close) ? FORBIDDEN : E_Hairpin(j-i-1, type, S1[i+1], S1[j-1], string+i-1, P);

        /*--------------------------------------------------------
          check for elementary structures involving more than one
          closing pair.
          --------------------------------------------------------*/

        for (p = i+1; p <= MIN2(j-2-turn,i+MAXLOOP+1) ; p++){
          int minq = j-i+p-MAXLOOP-2;
          if (minq<p+1+turn) minq = p+1+turn;
          for (q = minq; q < j; q++) {
            type_2 = ptype[p][q-p];

            if (type_2==0) continue;
            type_2 = rtype[type_2];

            if (noGUclosure)
              if (no_close||(type_2==3)||(type_2==4))
                if ((p>i+1)||(q<j-1)) continue;  /* continue unless stack */

            energy = E_IntLoop(p-i-1, j-q-1, type, type_2, S1[i+1], S1[j-1], S1[p-1], S1[q+1],P);
            new_c = MIN2(new_c, energy + c[p][q-p]);
            if ((p==i+1)&&(j==q+1)) stackEnergy = energy; /* remember stack energy */
          } /* end q-loop */
        } /* end p-loop */

        /* multi-loop decomposition ------------------------*/
        if (!no_close) {
          decomp  = DMLi1[j-1-(i+1)];
          tt      = rtype[type];
          switch(dangle_model){
            /* no dangle_model */
            case 0:   decomp += E_MLstem(tt, -1, -1, P);
                      break;
            /* double dangle_model */
            case 2:   decomp += E_MLstem(tt, S1[j-1], S1[i+1], P);
                      break;
            /* normal dangle_model, aka dangle_model = 1 */
            default:  decomp += E_MLstem(tt, -1, -1, P);
                      decomp = MIN2(decomp, DMLi2[j-1-(i+2)] + E_MLstem(tt, -1, S1[i+1], P) + P->MLbase);
                      decomp = MIN2(decomp, DMLi2[j-2-(i+2)] + E_MLstem(tt, S1[j-1], S1[i+1], P) + 2*P->MLbase);
                      decomp = MIN2(decomp, DMLi1[j-2-(i+1)] + E_MLstem(tt, S1[j-1], -1, P) + P->MLbase);
                      break;
          }
          new_c = MIN2(new_c, decomp + P->MLclosing);
        }

        /* coaxial stacking of (i.j) with (i+1.k) or (k+1.j-1) */

        if (dangle_model==3) {
          decomp = INF;
          for (k = i+2+turn; k < j-2-turn; k++) {
            type_2 = ptype[i+1][k-i-1]; type_2 = rtype[type_2];
            if (type_2)
              decomp = MIN2(decomp, c[i+1][k-i-1]+P->stack[type][type_2]+
                            fML[k+1][j-1-k-1]);
            type_2 = ptype[k+1][j-1-k-1]; type_2 = rtype[type_2];
            if (type_2)
              decomp = MIN2(decomp, c[k+1][j-1-k-1]+P->stack[type][type_2]+
                            fML[i+1][k-i-1]);
          }
          /* no TermAU penalty if coax stack */
          decomp += 2*P->MLintern[1] + P->MLclosing;
          new_c = MIN2(new_c, decomp);
        }

        if(with_gquad){
          /* include all cases where a g-quadruplex may be enclosed by base pair (i,j) */
          if (!no_close) {
            tt = rtype[type];
            energy = E_GQuad_IntLoop_L(i, j, type, S1, ggg, maxdist, P);
            new_c = MIN2(new_c, energy);
          }
        }

        new_c = MIN2(new_c, cc1[j-1-(i+1)]+stackEnergy);
        cc[j-i] = new_c;
        if (noLP)
          c[i][j-i] = cc1[j-1-(i+1)]+stackEnergy;
        else
          c[i][j-i] = cc[j-i];

      } /* end >> if (pair) << */

      else c[i][j-i] = INF;

      /* done with c[i,j], now compute fML[i,j] */
      /* free ends ? -----------------------------------------*/
      new_fML = INF;
      switch(dangle_model){
        /* no dangle_model */
        case 0:   new_fML = fML[i+1][j-i-1] + P->MLbase;
                  new_fML = MIN2(new_fML, fML[i][j-1-i] + P->MLbase);
                  new_fML = MIN2(new_fML, c[i][j-i] + E_MLstem(type, -1, -1, P));
                  break;
        /* double dangle_model */
        case 2:   new_fML = fML[i+1][j-i-1] + P->MLbase;
                  new_fML = MIN2(fML[i][j-1-i] + P->MLbase, new_fML);
                  new_fML = MIN2(new_fML,  c[i][j-i] + E_MLstem(type, (i>1) ? S1[i-1] : -1, (j<length) ? S1[j+1] : -1, P));
                  break;
        /* normal dangle_model, aka dangle_model = 1 */
        default:  /* i unpaired */
                  new_fML = fML[i+1][j-i-1] + P->MLbase;
                  /* j unpaired */
                  new_fML = MIN2(new_fML, fML[i][j-1-i] + P->MLbase);
                  /* i,j */
                  if(type) new_fML = MIN2(new_fML, c[i][j-i] + E_MLstem(type, -1, -1, P));
                  /* i+1,j */
                  tt = ptype[i+1][j-i-1];
                  if(tt) new_fML = MIN2(new_fML, c[i+1][j-i-1] + E_MLstem(tt, S1[i], -1, P) + P->MLbase);
                  /* i, j-1 */
                  tt = ptype[i][j-1-i];
                  if(tt) new_fML = MIN2(new_fML, c[i][j-1-i] + E_MLstem(tt, -1, S1[j], P) + P->MLbase);
                  /* i+1,j-1 */
                  tt = ptype[i+1][j-1-i-1];
                  if(tt) new_fML = MIN2(new_fML, c[i+1][j-1-i-1] + E_MLstem(tt, S1[i], S1[j], P) + 2*P->MLbase);
                  break;
      }

      if(with_gquad){
        new_fML = MIN2(new_fML, ggg[i][j - i] + E_MLstem(0, -1, -1, P));
      }

      /* modular decomposition -------------------------------*/
      for (decomp = INF, k = i+1+turn; k <= j-2-turn; k++)
        decomp = MIN2(decomp, Fmi[k-i]+fML[k+1][j-k-1]);

      DMLi[j-i] = decomp;               /* store for use in ML decompositon */
      new_fML   = MIN2(new_fML, decomp);

      /* coaxial stacking */
      if (dangle_model==3) {
        /* additional ML decomposition as two coaxially stacked helices */
        for (decomp = INF, k = i+1+turn; k <= j-2-turn; k++) {
          type = ptype[i][k-i]; type = rtype[type];
          type_2 = ptype[k+1][j-k-1]; type_2 = rtype[type_2];
          if (type && type_2)
            decomp = MIN2(decomp,
                          c[i][k-i]+c[k+1][j-k-1]+P->stack[type][type_2]);
        }

        decomp += 2*P->MLintern[1];          /* no TermAU penalty if coax stack */
#if 0
        /* This is needed for Y shaped ML loops with coax stacking of
           interior pairts, but backtracking will fail if activated */
        DMLi[j-i] = MIN2(DMLi[j-i], decomp);
        DMLi[j-i] = MIN2(DMLi[j-i], DMLi[j-1-i]+P->MLbase);
        DMLi[j-i] = MIN2(DMLi[j-i], DMLi1[j-(i+1)]+P->MLbase);
        new_fML = MIN2(new_fML, DMLi[j-i]);
#endif
        new_fML = MIN2(new_fML, decomp);
      }
      fML[i][j-i] = Fmi[j-i] = new_fML;     /* substring energy */
    } /* for (j...) */

    /* calculate energies of 5' and 3' fragments */
    {
      static int do_backtrack = 0, prev_i=0;
      char *ss=NULL;
      double prevz = 0.;

      /* first case: i stays unpaired */
      f3[i] = f3[i+1];

      /* next all cases where i is paired */
      switch(dangle_model){
        /* dont use dangling end and mismatch contributions at all */
        case 0:   for(j=i+turn+1; j<length && j<=i+maxdist; j++){
                    type = ptype[i][j-i];

                    if(with_gquad){
                      f3[i] = MIN2(f3[i], f3[j+1] + ggg[i][j-i]);
                    }

                    if(type)
                      f3[i] = MIN2(f3[i], f3[j+1] + c[i][j-i] + E_ExtLoop(type, -1, -1, P));
                  }
                  if(length<=i+maxdist){
                    j=length;

                    if(with_gquad){
                      f3[i] = MIN2(f3[i], ggg[i][j-i]);
                    }

                    type = ptype[i][j-i];
                    if(type)
                      f3[i] = MIN2(f3[i], c[i][j-i] + E_ExtLoop(type, -1, -1, P));
                  }
                  break;
        /* always use dangle_model on both sides */
        case 2:   for(j=i+turn+1; j<length && j<=i+maxdist; j++){
                    type = ptype[i][j-i];

                    if(with_gquad){
                      if(ggg[i][j-i] != INF)
                        f3[i] = MIN2(f3[i], f3[j+1] + ggg[i][j-i]);
                    }

                    if(type)
                      f3[i] = MIN2(f3[i], f3[j+1] + c[i][j-i] + E_ExtLoop(type, (i>1) ? S1[i-1] : -1, S1[j+1], P));
                  }
                  if(length<=i+maxdist){
                    j=length;

                    if(with_gquad){
                      f3[i] = MIN2(f3[i], ggg[i][j-i]);
                    }

                    type = ptype[i][j-i];
                    if(type)
                      f3[i] = MIN2(f3[i], c[i][j-i] + E_ExtLoop(type, (i>1) ? S1[i-1] : -1, -1, P));
                  }
                  break;
        /* normal dangle_model, aka dangle_model = 1 */
        default:  for(j=i+turn+1; j<length && j<=i+maxdist; j++){
                    type = ptype[i][j-i];

                    if(with_gquad){
                      f3[i] = MIN2(f3[i], f3[j+1] + ggg[i][j-i]);
                    }

                    if(type){
                      f3[i] = MIN2(f3[i], f3[j+1] + c[i][j-i] + E_ExtLoop(type, -1, -1, P));
                      f3[i] = MIN2(f3[i], ((j+2<=length) ? f3[j+2] : 0) + c[i][j-i] + E_ExtLoop(type, -1, S1[j+1], P));
                    }
                    type = ptype[i+1][j-i-1];
                    if(type){
                      f3[i] = MIN2(f3[i], f3[j+1] + c[i+1][j-i-1] + E_ExtLoop(type, S1[i], -1, P));
                      f3[i] = MIN2(f3[i], ((j + 1 < length) ? f3[j+2] : 0) + c[i+1][j-i-1] + E_ExtLoop(type, S1[i], S1[j+1], P));
                    }
                  }
                  if(length<=i+maxdist){
                    j     = length;

                    if(with_gquad){
                      f3[i] = MIN2(f3[i], ggg[i][j-i]);
                    }

                    type  = ptype[i][j-i];
                    if(type)
                      f3[i] = MIN2(f3[i], c[i][j-i] + E_ExtLoop(type, -1, -1, P));
                    type  = ptype[i+1][j-i-1];
                    if(type)
                      f3[i] = MIN2(f3[i], c[i+1][j-i-1] + E_ExtLoop(type, S1[i], -1, P));
                  }
                  break;
      } /* switch(dangle_model)... */

      /* backtrack partial structure */
      if (f3[i] < f3[i+1]){
        do_backtrack=1;
      }
      else if (do_backtrack) {
        int pairpartner; /*i+1?? is paired with pairpartner*/
        int cc;
        int traced2=0;
        fij = f3[i+1];
        lind=i+1;
        /*start "short" backtrack*/

        /*get paired base*/
        while(fij==f3[lind+1])
          lind++;

        /*get pairpartner*/
        for (pairpartner = lind + turn; pairpartner <= lind + maxdist; pairpartner++){
          type = ptype[lind][pairpartner-lind];
          switch(dangle_model){
            case 0:   if(type){
                        cc = c[lind][pairpartner-lind] + E_ExtLoop(type, -1, -1, P);
                        if(fij == cc + f3[pairpartner + 1])
                          traced2 = 1;
                      }
                      else if(with_gquad) {
                        cc = ggg[lind][pairpartner-lind];
                        if(fij == cc + f3[pairpartner + 1])
                          traced2 = 1;
                      }

                      break;
            case 2:   if(type){
                        cc = c[lind][pairpartner-lind] + E_ExtLoop(type, (lind > 1) ? S1[lind-1] : -1, (pairpartner < length) ? S1[pairpartner+1] : -1, P);
                        if(fij == cc + f3[pairpartner + 1])
                          traced2 = 1;
                      }
                      else if(with_gquad){
                        cc = ggg[lind][pairpartner-lind];
                        if(fij == cc + f3[pairpartner + 1])
                          traced2 = 1;
                      }

                      break;
            default:  if(type){
                        cc = c[lind][pairpartner-lind] + E_ExtLoop(type, -1, -1, P);
                        if(fij == cc + f3[pairpartner + 1]){
                          traced2 = 1;
                          break;
                        }
                        else if(pairpartner < length){
                          cc = c[lind][pairpartner-lind] + E_ExtLoop(type, -1, S1[pairpartner+1], P);
                          if(fij == cc + f3[pairpartner + 2]){
                            traced2 = 1;
                            break;
                          }
                        }
                      }
                      else if(with_gquad){
                        cc = ggg[lind][pairpartner-lind];
                        if(fij == cc + f3[pairpartner + 1])
                          traced2 = 1;
                      }

                      type = ptype[lind+1][pairpartner-lind-1];
                      if(type){
                        cc = c[lind+1][pairpartner-(lind+1)] + E_ExtLoop(type, S1[lind], -1, P);
                        if(fij == cc + f3[pairpartner+1]){
                          traced2 = 1;
                          break;
                        }
                        else if(pairpartner < length){
                          cc = c[lind+1][pairpartner-(lind+1)] + E_ExtLoop(type, S1[lind], S1[pairpartner+1], P);
                          if(fij == cc + f3[pairpartner+2])
                            traced2 = 1;
                        }
                      }
                      break;
          }
          if(traced2) break;
        }
        if (!traced2) vrna_message_error("backtrack failed in short backtrack 1");
        if (zsc){
#ifdef USE_SVM
          int info_avg;
          double average_free_energy;
          double sd_free_energy;
          double my_z;
          int *AUGC = get_seq_composition(S, lind-1, MIN2((pairpartner+1),length), length);
          /*\svm*/
          average_free_energy = avg_regression(AUGC[0], AUGC[1], AUGC[2], AUGC[3], AUGC[4], avg_model, &info_avg);
          if (info_avg == 0)  {
            double difference;
            double min_sd = minimal_sd(AUGC[0],AUGC[1],AUGC[2],AUGC[3],AUGC[4]);
            difference=(fij-f3[pairpartner+1])/100.-average_free_energy;
            if ( difference - ( min_z * min_sd ) <= 0.0001 ) {
              sd_free_energy = sd_regression(AUGC[0],AUGC[1],AUGC[2],AUGC[3],AUGC[4],sd_model);
              my_z=difference/sd_free_energy;
              if (my_z<=min_z){
                ss =  backtrack(vc, lind, pairpartner+1);
                if (prev) {
                  if ((i+strlen(ss)<prev_i+strlen(prev)) ||
                      strncmp(ss+prev_i-i,prev,strlen(prev))) { /* ss does not contain prev */
                    if (dangle_model==2)
                      fprintf(output, ".%s (%6.2f) %4d z= %.3f\n", prev, (f3[prev_i]-f3[prev_i+strlen(prev)-1])/100., prev_i-1, prevz);
                    else
                      fprintf(output, "%s (%6.2f) %4d z=%.3f\n ", prev, (f3[prev_i]-f3[prev_i+strlen(prev)])/100., prev_i, prevz);
                  }
                  free(prev);
                }
                prev=ss; prev_i = lind; prevz=my_z;
              }
            }

          }
          free(AUGC);
          do_backtrack=0;
#endif
        }
        else {
          /* original code for Lfold*/
          ss =  backtrack(vc, lind , pairpartner+1);
          if (prev) {
            if ((i+strlen(ss)<prev_i+strlen(prev)) || strncmp(ss+prev_i-i,prev,strlen(prev))){
              /* ss does not contain prev */
              if (dangle_model==2){
                fprintf(output, ".%s (%6.2f) %4d\n", prev, (f3[prev_i]-f3[prev_i+strlen(prev)-1])/100., prev_i-1);
              } else
                fprintf(output, "%s (%6.2f) %4d\n", prev, (f3[prev_i]-f3[prev_i+strlen(prev)])/100., prev_i);
            }
            free(prev);
          }
          prev=ss;
          prev_i = lind;
          do_backtrack=0;
        }
      }
      if (i==1) {
        if (prev) {
          if(zsc) {
            if (dangle_model==2)
              fprintf(output, ".%s (%6.2f) %4d z= %.2f\n", prev, (f3[prev_i]-f3[prev_i+strlen(prev)-1])/100., prev_i-1, prevz);
           else
              fprintf(output, "%s (%6.2f) %4dz= %.2f \n", prev, (f3[prev_i]-f3[prev_i+strlen(prev)])/100., prev_i, prevz);
          }
          else {
            if (dangle_model==2)
              fprintf(output, ".%s (%6.2f) %4d\n", prev, (f3[prev_i]-f3[prev_i+strlen(prev)-1])/100., prev_i-1);
            else
              fprintf(output, "%s (%6.2f) %4d\n", prev, (f3[prev_i]-f3[prev_i+strlen(prev)])/100., prev_i);
          }
          free(prev); prev=NULL;
        } else if ((f3[i]<0) && (!zsc)) do_backtrack=1;

        if (do_backtrack) {
          int pairpartner; /*i+1?? is paired with pairpartner*/
          int cc;
          double average_free_energy;
          double sd_free_energy;
          int info_avg;
          double my_z;
          int traced2 = 0;
          fij = f3[i];
          lind=i;
          while(fij==f3[lind+1]) lind++;
          /*get pairpartner*/
          for(pairpartner = lind + turn; pairpartner <= lind + maxdist; pairpartner++){
            type = ptype[lind][pairpartner-lind];
            switch(dangle_model){
              case 0:   if(type){
                          cc = c[lind][pairpartner-lind] + E_ExtLoop(type, -1, -1, P);
                          if(fij == cc + f3[pairpartner + 1])
                            traced2 = 1;
                        }
                        else if(with_gquad){
                          cc = ggg[lind][pairpartner-lind];
                          if(fij == cc + f3[pairpartner + 1])
                            traced2 = 1;
                        }

                        break;
              case 2:   if(type){
                          cc = c[lind][pairpartner-lind] + E_ExtLoop(type, (lind > 1) ? S1[lind-1] : -1, (pairpartner < length) ? S1[pairpartner+1] : -1, P);
                          if(fij == cc + f3[pairpartner + 1])
                            traced2 = 1;
                        }
                        else if(with_gquad){
                          cc = ggg[lind][pairpartner-lind];
                          if(fij == cc + f3[pairpartner + 1])
                            traced2 = 1;
                        }

                        break;
              default:  if(type){
                          cc = c[lind][pairpartner-lind] + E_ExtLoop(type, -1, -1, P);
                          if(fij == cc + f3[pairpartner + 1]){
                            traced2 = 1;
                            break;
                          }
                          else if(pairpartner < length){
                            cc = c[lind][pairpartner-lind] + E_ExtLoop(type, -1, S1[pairpartner + 1], P);
                            if(fij == cc + f3[pairpartner + 1]){
                              traced2 = 1;
                              break;
                            }
                          }
                        }
                        else if(with_gquad){
                          cc = ggg[lind][pairpartner-lind];
                          if(fij == cc + f3[pairpartner + 1])
                            traced2 = 1;
                        }

                        type = ptype[lind+1][pairpartner-lind-1];
                        if(type){
                          cc = c[lind+1][pairpartner-(lind+1)] + E_ExtLoop(type, S1[lind], -1, P);
                          if(fij == cc + f3[pairpartner+1]){
                            traced2 = 1;
                            break;
                          }
                          else if (pairpartner < length){
                            cc = c[lind+1][pairpartner-(lind+1)] + E_ExtLoop(type, S1[lind], S1[pairpartner+1], P);
                            if(fij == cc + f3[pairpartner + 2]){
                              traced2 =1;
                              break;
                            }
                          }
                        }
            }
            if(traced2) break;
          }
          if (!traced2) vrna_message_error("backtrack failed in short backtrack 2");

          if(zsc){
#ifdef USE_SVM
            int *AUGC = get_seq_composition(S, lind-1, MIN2((pairpartner+1),length), length);
            average_free_energy = avg_regression(AUGC[0],AUGC[1],AUGC[2],AUGC[3],AUGC[4],avg_model,&info_avg);
            if (info_avg == 0)  {
              double difference;
              double min_sd = minimal_sd(AUGC[0],AUGC[1],AUGC[2],AUGC[3],AUGC[4]);
              difference=(fij-f3[pairpartner+1])/100.-average_free_energy;
              if ( difference - ( min_z * min_sd ) <= 0.0001 ) {
                sd_free_energy = sd_regression(AUGC[0],AUGC[1],AUGC[2],AUGC[3],AUGC[4],sd_model);
                my_z=difference/sd_free_energy;
                if (my_z<=min_z){
                  ss =  backtrack(vc, lind , pairpartner+1);
                  fprintf(output, "%s (%6.2f) %4d z= %.2f\n", ss, (f3[lind]-f3[lind+strlen(ss)-1])/100., lind, my_z);
                }
              }
            }
            free(AUGC);
#endif
          }
          else {
            ss =  backtrack(vc, lind , pairpartner+1);
            if (dangle_model==2)
              fprintf(output, "%s (%6.2f) %4d\n", ss, (f3[lind]-f3[lind+strlen(ss)-1])/100., 1);
            else
              fprintf(output, "%s (%6.2f) %4d\n", ss, (f3[lind]-f3[lind+strlen(ss)])/100., 1);
            free(ss);
          }
        }
        do_backtrack=0;
      }
    }
    {
      int ii, *FF; /* rotate the auxilliary arrays */

      /* check for values close to integer underflow */
      if(INT_CLOSE_TO_UNDERFLOW(f3[i])){
        /* correct f3 free energies and increase underflow counter */
        int cnt, cnt2;
        for(cnt=i; cnt <= length && cnt <= lind + maxdist + 2; cnt++) {
          f3[cnt] -= UNDERFLOW_CORRECTION;
        }
        (*underflow)++;
      }

      FF = DMLi2; DMLi2 = DMLi1; DMLi1 = DMLi; DMLi = FF;
      FF = cc1; cc1=cc; cc=FF;
      for(j = 0; j < maxdist + 5; j++){
        cc[j] = Fmi[j] = DMLi[j] = INF;
      }

      /*
        rotate the DP matrices
        NOTE: here we rotate them only locally, i.e. their
        actual configuration within vc remains intact
      */
      if( i + maxdist + 4 <= length ){
        c[i - 1]                = c[i + maxdist + 4];
        c[i + maxdist + 4]      = NULL;
        fML[i - 1]              = fML[i + maxdist + 4];
        fML[i + maxdist + 4]    = NULL;
        ptype[i - 1]            = ptype[i + maxdist + 4];
        ptype[i + maxdist + 4]  = NULL;
        if( i > 1 ){
          make_ptypes(vc, i - 1);
          if(with_gquad){
            vrna_gquad_mx_local_update(vc, i - 1);
            ggg = vc->matrices->ggg_local;
          }
        }
        for(ii = 0; ii < maxdist + 5; ii++){
          c[i - 1][ii]    = INF;
          fML[i - 1][ii]  = INF;
        }
      }

    }
  }

  free(cc);
  free(cc1);
  free(Fmi);
  free(DMLi);
  free(DMLi1);
  free(DMLi2);

  return f3[1];
}

PRIVATE char *
backtrack(vrna_fold_compound_t *vc,
          int start,
          int maxdist){

  /*------------------------------------------------------------------
    trace back through the "c", "f3" and "fML" arrays to get the
    base pairing list. No search for equivalent structures is done.
    This is fast, since only few structure elements are recalculated.
    ------------------------------------------------------------------*/
  sect          sector[MAXSECTORS];   /* backtracking sectors */
  int           i, j, k, length, energy, newX, no_close, type, type_2, tt, s=0;
  int           with_gquad, bt_type, turn, dangle_model, noLP, noGUclosure, *rtype;
  int           **c, **fML, *f3, **ggg;
  char          *string, *structure, **ptype;
  short         *S, *S1;
  vrna_param_t  *P;
  vrna_md_t     *md;

  string        = vc->sequence;
  length        = vc->length;
  S             = vc->sequence_encoding2;
  S1            = vc->sequence_encoding;
  ptype         = vc->ptype_local;
  P             = vc->params;
  md            = &(P->model_details);
  dangle_model  = md->dangles;
  noLP          = md->noLP;
  noGUclosure   = md->noGUclosure;
  with_gquad    = md->gquad;
  bt_type       = md->backtrack_type;
  turn          = md->min_loop_size;
  rtype         = &(md->rtype[0]);

  c       = vc->matrices->c_local;
  fML     = vc->matrices->fML_local;
  f3      = vc->matrices->f3_local;
  ggg     = vc->matrices->ggg_local;

  /* length = strlen(string); */
  sector[++s].i = start;
  sector[s].j   = MIN2(length, maxdist+1);
  sector[s].ml  = (bt_type=='M') ? 1 : ((bt_type=='C')?2:0);

  structure = (char *) vrna_alloc((MIN2(length-start, maxdist)+3)*sizeof(char));
  for (i=0; i<=MIN2(length-start, maxdist); i++) structure[i] = '-';

  while (s>0) {
    int ml, fij, cij, traced, i1, j1, mm, mm5, mm3, mm53, p, q, jj=0, gq=0;
    int canonical = 1;     /* (i,j) closes a canonical structure */
    i  = sector[s].i;
    j  = sector[s].j;
    ml = sector[s--].ml;   /* ml is a flag indicating if backtracking is to
                              occur in the fML- (1) or in the f-array (0) */
    if (ml==2) {
      structure[i-start] = '(';
      structure[j-start] = ')';
      goto repeat1;
    }

    if (j < i + turn + 1) continue; /* no more pairs in this interval */

    fij = (ml)? fML[i][j-i] : f3[i];

    if (ml == 0) { /* backtrack in f3 */

      if (fij == f3[i+1]) {
        sector[++s].i = i+1;
        sector[s].j   = j;
        sector[s].ml  = ml;
        continue;
      }
      /* i or i+1 is paired. Find pairing partner */
      switch(dangle_model){
        case 0:   for(traced = 0, k=j; k>i+turn; k--){

                    if(with_gquad){
                      if(fij == ggg[i][k-i] + f3[k+1]){
                        /* found the decomposition */
                        traced = i; jj = k + 1; gq = 1;
                        break;
                      }
                    }

                    jj    = k+1;
                    type  = ptype[i][k-i];
                    if(type)
                      if(fij == c[i][k-i] + E_ExtLoop(type, -1, -1, P) + f3[k+1]){
                        traced = i;
                        break;
                      }
                  }
                  break;
        case 2:   for(traced = 0, k=j; k>i+turn; k--){

                    if(with_gquad){
                      if(fij == ggg[i][k-i] + f3[k+1]){
                        /* found the decomposition */
                        traced = i; jj = k + 1; gq = 1;
                        break;
                      }
                    }

                    jj    = k+1;
                    type  = ptype[i][k-i];
                    if(type)
                      if(fij == c[i][k-i] + E_ExtLoop(type, (i>1) ? S1[i-1] : -1, (k<length) ? S1[k+1] : -1, P) + f3[k+1]){
                        traced = i;
                        break;
                      }
                  }
                  break;
        default:  for(traced = 0,k=j; k>i+turn; k--){

                    if(with_gquad){
                      if(fij == ggg[i][k-i] + f3[k+1]){
                        /* found the decomposition */
                        traced = i; jj = k + 1; gq = 1;
                        break;
                      }
                    }

                    jj = k+1;
                    type = ptype[i+1][k-(i+1)];
                    if(type){
                      if(fij == c[i+1][k-(i+1)] + E_ExtLoop(type, S1[i], -1, P) + f3[k+1]){
                        traced=i+1;
                      }
                      if(k < length){
                        if(fij == c[i+1][k-(i+1)] + E_ExtLoop(type, S1[i], S1[k+1], P) + f3[k+2]){
                          traced  = i+1;
                          jj      = k+2;
                        }
                      }
                    }
                    type = ptype[i][k-i];
                    if(type){
                      if(fij == c[i][k-i] + E_ExtLoop(type, -1, -1, P) + f3[k+1]){
                        traced = i;
                      }
                      if(k<length){
                        if(fij == c[i][k-i] + E_ExtLoop(type, -1, S1[k+1], P) + f3[k+2]){
                          traced  = i;
                          jj      = k+2;
                        }
                      }
                    }
                    if(traced) break;
                  }
                  break;
      } /* switch(dangle_model)...*/

      if (!traced) vrna_message_error("backtrack failed in f3");
      if (j==length) { /* backtrack only one component, unless j==length */
        sector[++s].i = jj;
        sector[s].j   = j;
        sector[s].ml  = ml;
      }
      i=traced; j=k;

      if(with_gquad && gq){
        /* goto backtrace of gquadruplex */
        goto repeat_gquad;
      }

      structure[i-start] = '('; structure[j-start] = ')';
      if (((jj==j+2) || (dangle_model==2)) && (j < length)) structure[j+1-start] = '.';
      goto repeat1;
    }
    else { /* trace back in fML array */
      if (fML[i][j-1-i]+P->MLbase == fij) {  /* 3' end is unpaired */
        sector[++s].i = i;
        sector[s].j   = j-1;
        sector[s].ml  = ml;
        continue;
      }
      if (fML[i+1][j-(i+1)]+P->MLbase == fij) { /* 5' end is unpaired */
        sector[++s].i = i+1;
        sector[s].j   = j;
        sector[s].ml  = ml;
        continue;
      }

      if(with_gquad){
        if(fij == ggg[i][j-i] + E_MLstem(0, -1, -1, P)){
          /* go to backtracing of quadruplex */
          goto repeat_gquad;
        }
      }

      switch(dangle_model){
        case 0:   tt = ptype[i][j-i];
                  if(fij == c[i][j-i] + E_MLstem(tt, -1, -1, P)){
                    structure[i-start] = '(';
                    structure[j-start] = ')';
                    goto repeat1;
                  }
                  break;
        case 2:   tt = ptype[i][j-i];
                  if(fij == c[i][j-i] + E_MLstem(tt, (i>1) ? S1[i-1] : -1, (j < length) ? S1[j+1] : -1, P)){
                    structure[i-start] = '(';
                    structure[j-start] = ')';
                    goto repeat1;
                  }
                  break;
        default:  tt = ptype[i][j-i];
                  if(fij == c[i][j-i] + E_MLstem(tt, -1, -1, P)){
                    structure[i-start] = '(';
                    structure[j-start] = ')';
                    goto repeat1;
                  }
                  tt = ptype[i+1][j-(i+1)];
                  if(fij == c[i+1][j-(i+1)] + E_MLstem(tt, S1[i], -1, P) + P->MLbase){
                    structure[++i-start] = '(';
                    structure[j-start] = ')';
                    goto repeat1;
                  }
                  tt = ptype[i][j-1-i];
                  if(fij == c[i][j-1-i] + E_MLstem(tt, -1, S1[j], P) + P->MLbase){
                    structure[i-start] = '(';
                    structure[--j-start] = ')';
                    goto repeat1;
                  }
                  tt = ptype[i+1][j-1-(i+1)];
                  if(fij == c[i+1][j-1-(i+1)] + E_MLstem(tt, S1[i], S1[j], P) + 2*P->MLbase){
                    structure[++i-start] = '(';
                    structure[--j-start] = ')';
                    goto repeat1;
                  }
                  break;
      } /* switch(dangle_model)... */

      /* modular decomposition */
      for (k = i+1+turn; k <= j-2-turn; k++)
        if (fij == (fML[i][k-i]+fML[k+1][j-(k+1)]))
          break;

      if ((dangle_model==3)&&(k>j-2-turn)) { /* must be coax stack */
        ml = 2;
        for (k = i+1+turn; k <= j-2-turn; k++) {
          type = ptype[i][k-i];  type= rtype[type];
          type_2 = ptype[k+1][j-(k+1)]; type_2= rtype[type_2];
          if (type && type_2)
            if (fij == c[i][k-i]+c[k+1][j-(k+1)]+P->stack[type][type_2]+
                       2*P->MLintern[1])
              break;
        }
      }

      sector[++s].i = i;
      sector[s].j   = k;
      sector[s].ml  = ml;
      sector[++s].i = k+1;
      sector[s].j   = j;
      sector[s].ml  = ml;

      if (k>j-2-turn) vrna_message_error("backtrack failed in fML");
      continue;
    }

  repeat1:

    /*----- begin of "repeat:" -----*/
    if (canonical)  cij = c[i][j-i];

    type = ptype[i][j-i];


    if (noLP)
      if (cij == c[i][j-i]) {
        /* (i.j) closes canonical structures, thus
           (i+1.j-1) must be a pair                */
        type_2 = ptype[i+1][j-1-(i+1)]; type_2 = rtype[type_2];
        cij -= P->stack[type][type_2];
        structure[i+1-start] = '('; structure[j-1-start] = ')';
        i++; j--;
        canonical=0;
        goto repeat1;
      }
    canonical = 1;


    no_close = (((type==3)||(type==4))&&noGUclosure);
    if (no_close) {
      if (cij == FORBIDDEN) continue;
    } else
      if (cij == E_Hairpin(j-i-1, type, S1[i+1], S1[j-1],string+i-1, P))
        continue;

    for (p = i+1; p <= MIN2(j-2-turn,i+MAXLOOP+1); p++) {
      int minq;
      minq = j-i+p-MAXLOOP-2;
      if (minq<p+1+turn) minq = p+1+turn;
      for (q = j-1; q >= minq; q--) {

        type_2 = ptype[p][q-p];
        if (type_2==0) continue;
        type_2 = rtype[type_2];
        if (noGUclosure)
          if (no_close||(type_2==3)||(type_2==4))
            if ((p>i+1)||(q<j-1)) continue;  /* continue unless stack */

        /* energy = oldLoopEnergy(i, j, p, q, type, type_2); */
        energy = E_IntLoop(p-i-1, j-q-1, type, type_2, S1[i+1], S1[j-1], S1[p-1], S1[q+1],P);

        newX = energy+c[p][q-p];
        traced = (cij == newX);
        if (traced) {
          structure[p-start] = '(';
          structure[q-start] = ')';
          i = p, j = q;
          goto repeat1;
        }
      }
    }

    /* end of repeat: --------------------------------------------------*/

    /* (i.j) must close a multi-loop */
    tt = rtype[type];
    i1 = i+1; j1 = j-1;

    if(with_gquad){
      /*
        The case that is handled here actually resembles something like
        an interior loop where the enclosing base pair is of regular
        kind and the enclosed pair is not a canonical one but a g-quadruplex
        that should then be decomposed further...
      */
      if(backtrack_GQuad_IntLoop_L(cij, i, j, type, S, ggg, maxdist, &p, &q, P)){
        i = p; j = q;
        goto repeat_gquad;
      }
    }

    sector[s+1].ml  = sector[s+2].ml = 1;

    switch(dangle_model){
      case 0:   mm = P->MLclosing + E_MLstem(tt, -1, -1, P);
                for(k = i+2+turn; k < j-2-turn; k++){
                  if(cij == fML[i+1][k-(i+1)] + fML[k+1][j-1-(k+1)] + mm)
                    break;
                }
                break;
      case 2:   mm = P->MLclosing + E_MLstem(tt, S1[j-1], S1[i+1], P);
                for(k = i+2+turn; k < j-2-turn; k++){
                  if(cij == fML[i+1][k-(i+1)] + fML[k+1][j-1-(k+1)] + mm)
                    break;
                }
                break;
      default:  mm    = P->MLclosing + E_MLstem(tt, -1, -1, P);
                mm5   = P->MLclosing + E_MLstem(tt, S1[j-1], -1, P) + P->MLbase;
                mm3   = P->MLclosing + E_MLstem(tt, -1, S1[i+1], P) + P->MLbase;
                mm53  = P->MLclosing + E_MLstem(tt, S1[j-1], S1[i+1], P) + 2*P->MLbase;
                for(k = i+2+turn; k < j-2-turn; k++){
                  if(cij == fML[i+1][k-(i+1)] + fML[k+1][j-1-(k+1)] + mm)
                    break;
                  else if(cij == fML[i+2][k-(i+2)] + fML[k+1][j-1-(k+1)] + mm3){
                    i1 = i+2;
                    break;
                  }
                  else if(cij == fML[i+1][k-(i+1)] + fML[k+1][j-2-(k+1)] + mm5){
                    j1 = j-2;
                    break;
                  }
                  else if(cij == fML[i+2][k-(i+2)] + fML[k+1][j-2-(k+1)] + mm53){
                    i1 = i+2;
                    j1 = j-2;
                    break;
                  }
                  /* coaxial stacking of (i.j) with (i+1.k) or (k.j-1) */
                  /* use MLintern[1] since coax stacked pairs don't get TerminalAU */
                  if (dangle_model==3) {
                    int en;
                    type_2 = ptype[i+1][k-(i+1)]; type_2 = rtype[type_2];
                    if (type_2) {
                      en = c[i+1][k-(i+1)]+P->stack[type][type_2]+fML[k+1][j-1-(k+1)];
                      if (cij == en+2*P->MLintern[1]+P->MLclosing) {
                        ml = 2;
                        sector[s+1].ml  = 2;
                        break;
                      }
                    }
                    type_2 = ptype[k+1][j-1-(k+1)]; type_2 = rtype[type_2];
                    if (type_2) {
                      en = c[k+1][j-1-(k+1)]+P->stack[type][type_2]+fML[i+1][k-(i+1)];
                      if (cij == en+2*P->MLintern[1]+P->MLclosing) {
                        sector[s+2].ml = 2;
                        break;
                      }
                    }
                  }
                }
                break;
    } /* switch(dangle_model)... */

    if (k<=j-3-turn) { /* found the decomposition */
      sector[++s].i = i1;
      sector[s].j   = k;
      sector[++s].i = k+1;
      sector[s].j   = j1;
    } else {
#if 0
      /* Y shaped ML loops fon't work yet */
      if (dangle_model==3) {
        /* (i,j) must close a Y shaped ML loop with coax stacking */
        if (cij ==  fML[i+1][j-2-(i+2)] + mm + d3 + d5 + P->MLbase + P->MLbase) {
          i1 = i+2;
          j1 = j-2;
        } else if (cij ==  fML[i+1][j-2-(i+1)] + mm + d5 + P->MLbase)
          j1 = j-2;
        else if (cij ==  fML[i+2][j-1-(i+2)] + mm + d3 + P->MLbase)
          i1 = i+2;
        else /* last chance */
          if (cij != fML[i+1][j-1-(i+1)] + mm + P->MLbase)
            fprintf(stderr,  "backtracking failed in repeat");
        /* if we arrive here we can express cij via fML[i1,j1]+dangle_model */
        sector[++s].i = i1;
        sector[s].j   = j1;
      }
      else
#endif
        vrna_message_error("backtracking failed in repeat");
    }

    continue; /* this is a workarround to not accidentally proceed in the following block */

  repeat_gquad:
    /*
      now we do some fancy stuff to backtrace the stacksize and linker lengths
      of the g-quadruplex that should reside within position i,j
    */
    {
      int l[3], L, a;
      L = -1;

      get_gquad_pattern_mfe(S, i, j, P, &L, l);
      if(L != -1){
        /* fill the G's of the quadruplex into the structure string */
        for(a=0;a<L;a++){
          structure[i+a-start] = '+';
          structure[i+L+l[0]+a-start] = '+';
          structure[i+L+l[0]+L+l[1]+a-start] = '+';
          structure[i+L+l[0]+L+l[1]+L+l[2]+a-start] = '+';
        }
        goto repeat_gquad_exit;
      }
      vrna_message_error("backtracking failed in repeat_gquad");
    }
  repeat_gquad_exit:
    __asm("nop");

  }

  for (i=strlen(structure)-1; i>0 && structure[i] == '-'; i--)
    structure[i] = '\0';
  for (;i>=0; i--)
   if (structure[i]=='-') structure[i]='.';

  return structure;
}

PRIVATE void
make_ptypes(vrna_fold_compound_t *vc, int i){

  int       j, k, type, n, maxdist, turn, noLP;
  short     *S;
  char      **ptype;
  vrna_md_t *md;

  n       = (int)vc->length;
  S       = vc->sequence_encoding2;
  ptype   = vc->ptype_local;
  maxdist = vc->window_size;
  md      = &(vc->params->model_details);
  turn    = md->min_loop_size;
  noLP    = md->noLP;

  for(k = turn + 1; k < maxdist; k++){
    j = i + k;
    if (j > n)
      break;
    type = md->pair[S[i]][S[j]];

    if(noLP && type){
      if(!ptype[i + 1][j - 1 - i - 1])
        if(j == n || i == 1 || (!md->pair[S[i - 1]][S[j + 1]]))
          type = 0;
    }
    ptype[i][j - i] = type;
  }
}

/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/

#ifdef  VRNA_BACKWARD_COMPAT

PUBLIC float Lfold( const char *string,
                    char *structure,
                    int window_size){

  float               energy;
  vrna_fold_compound_t  *vc;
  vrna_md_t           md;

  set_model_details(&md);

  md.window_size = window_size;
  md.max_bp_span = window_size;

  vc  = vrna_fold_compound(string, &md, VRNA_OPTION_WINDOW);

  energy = wrap_Lfold(vc, 0, 0.0, NULL);

  vrna_fold_compound_free(vc);

  return energy;
}

PUBLIC float
Lfoldz( const char *string,
        char *structure,
        int window_size,
        int zsc,
        double min_z){

  float               energy;
  vrna_fold_compound_t  *vc;
  vrna_md_t           md;

  set_model_details(&md);

  md.window_size = window_size;
  md.max_bp_span = window_size;

  vc  = vrna_fold_compound(string, &md, VRNA_OPTION_WINDOW);

#ifndef USE_SVM
  zsc = 0;  /* deactivate z-scoring if no compiled-in svm support is available */
#endif

  energy = wrap_Lfold(vc, zsc, min_z, NULL);

  vrna_fold_compound_free(vc);

  return energy;
}

#endif
cofold.c/       0           0     0     644     34580     `
/*
                  minimum free energy
                  RNA secondary structure prediction

                  c Ivo Hofacker, Chrisoph Flamm
                  original implementation by
                  Walter Fontana

                  Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>

#include "utils.h"
#include "energy_par.h"
#include "fold_vars.h"
#include "params.h"
#include "subopt.h"
#include "fold.h"
#include "loop_energies.h"
#include "gquad.h"
#include "cofold.h"

#ifdef  VRNA_BACKWARD_COMPAT

#ifdef _OPENMP
#include <omp.h>
#endif

#endif

#define MAXSECTORS        500     /* dimension for a backtrack array */
#define ON_SAME_STRAND(I,J,C)  (((I)>=(C))||((J)<(C)))

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/


/*
#################################
# PRIVATE VARIABLES             #
#################################
*/

#ifdef  VRNA_BACKWARD_COMPAT

/* some backward compatibility stuff */
PRIVATE int                 backward_compat           = 0;
PRIVATE vrna_fold_compound_t  *backward_compat_compound = NULL;

PRIVATE float   mfe1, mfe2;       /* minimum free energies of the monomers */

#ifdef _OPENMP

#pragma omp threadprivate(mfe1, mfe2, backward_compat_compound, backward_compat)

#endif

#endif

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/

PRIVATE void  backtrack(sect bt_stack[], vrna_bp_stack_t *bp_list, vrna_fold_compound_t *vc);
PRIVATE int   fill_arrays(vrna_fold_compound_t *vc, int zuker);
PRIVATE void  free_end(int *array, int i, int start, vrna_fold_compound_t *vc);
PRIVATE void  doubleseq(vrna_fold_compound_t *vc);  /* do magic */
PRIVATE void  halfseq(vrna_fold_compound_t *vc);    /* undo magic */

#ifdef  VRNA_BACKWARD_COMPAT

/* wrappers for old API compatibility */
PRIVATE void      wrap_array_export(int **f5_p,int **c_p,int **fML_p,int **fM1_p,int **fc_p,int **indx_p,char **ptype_p);
PRIVATE float     wrap_cofold(const char *string,char *structure,vrna_param_t *parameters,int is_constrained);
PRIVATE SOLUTION *wrap_zukersubopt( const char *string,vrna_param_t *parameters);

#endif

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PUBLIC float
vrna_cofold(const char *seq,
            char *structure){

  float                 mfe;
  vrna_fold_compound_t  *vc;
  vrna_md_t             md;

  vrna_md_set_default(&md);
  md.min_loop_size = 0;  /* set min loop length to 0 */

  /* get compound structure */
  vc = vrna_fold_compound(seq, &md, 0);

  mfe = vrna_mfe_dimer(vc, structure);

  vrna_fold_compound_free(vc);

  return mfe;
}

PUBLIC float
vrna_mfe_dimer(vrna_fold_compound_t  *vc,
            char                *structure){

  int     length, energy;
  char    *s;
  sect    bt_stack[MAXSECTORS]; /* stack of partial structures for backtracking */
  vrna_bp_stack_t   *bp;

  length = (int) vc->length;

  vc->sequence_encoding[0] = vc->sequence_encoding2[0]; /* store length at pos. 0 in S1 too */

  vrna_fold_compound_prepare(vc, VRNA_OPTION_MFE | VRNA_OPTION_HYBRID);

  /* call user-defined recursion status callback function */
  if(vc->stat_cb)
    vc->stat_cb(VRNA_STATUS_MFE_PRE, vc->auxdata);

  energy = fill_arrays(vc, 0);

  /* call user-defined recursion status callback function */
  if(vc->stat_cb)
    vc->stat_cb(VRNA_STATUS_MFE_POST, vc->auxdata);

  if(structure && vc->params->model_details.backtrack){
    bp = (vrna_bp_stack_t *)vrna_alloc(sizeof(vrna_bp_stack_t) * (4*(1+length/2))); /* add a guess of how many G's may be involved in a G quadruplex */

    backtrack(bt_stack, bp, vc);

    s = vrna_db_from_bp_stack(bp, length);
    strncpy(structure, s, length + 1);
    free(s);

#ifdef  VRNA_BACKWARD_COMPAT

    /*
    *  Backward compatibility:
    *  This block may be removed if deprecated functions
    *  relying on the global variable "base_pair" vanish from within the package!
    */
    {
      if(base_pair) free(base_pair);
      base_pair = bp;
    }

#endif

  }

  if (vc->params->model_details.backtrack_type=='C')
    return (float) vc->matrices->c[vc->jindx[length]+1]/100.;
  else if (vc->params->model_details.backtrack_type=='M')
    return (float) vc->matrices->fML[vc->jindx[length]+1]/100.;
  else
    return (float) energy/100.;
}

PRIVATE int
fill_arrays(vrna_fold_compound_t  *vc,
            int                 zuker){

  /* fill "c", "fML" and "f5" arrays and return  optimal energy */

  int   i, j, length, energy;
  int   cp, uniq_ML;
  int   no_close, type, maxj, *indx;
  int   *my_f5, *my_c, *my_fML, *my_fM1, *my_fc;
  int   *cc, *cc1;  /* auxilary arrays for canonical structures     */
  int   *Fmi;       /* holds row i of fML (avoids jumps in memory)  */
  int   *DMLi;      /* DMLi[j] holds  MIN(fML[i,k]+fML[k+1,j])      */
  int   *DMLi1;     /*                MIN(fML[i+1,k]+fML[k+1,j])    */
  int   *DMLi2;     /*                MIN(fML[i+2,k]+fML[k+1,j])    */

  int   dangle_model, noGUclosure, noLP, hc_decompose, turn;
  char              *ptype, *hard_constraints;
  vrna_param_t      *P;
  vrna_mx_mfe_t     *matrices;
  vrna_hc_t         *hc;

  length            = (int)vc->length;
  ptype             = vc->ptype;
  indx              = vc->jindx;
  P                 = vc->params;
  dangle_model      = P->model_details.dangles;
  noGUclosure       = P->model_details.noGUclosure;
  noLP              = P->model_details.noLP;
  uniq_ML           = P->model_details.uniq_ML;
  hc                = vc->hc;
  hard_constraints  = hc->matrix;
  matrices          = vc->matrices;
  my_f5             = matrices->f5;
  my_c              = matrices->c;
  my_fML            = matrices->fML;
  my_fM1            = matrices->fM1;
  my_fc             = matrices->fc;
  cp                = vc->cutpoint;
  turn              = P->model_details.min_loop_size;

  /* allocate memory for all helper arrays */
  cc    = (int *) vrna_alloc(sizeof(int)*(length + 2));
  cc1   = (int *) vrna_alloc(sizeof(int)*(length + 2));
  Fmi   = (int *) vrna_alloc(sizeof(int)*(length + 1));
  DMLi  = (int *) vrna_alloc(sizeof(int)*(length + 1));
  DMLi1 = (int *) vrna_alloc(sizeof(int)*(length + 1));
  DMLi2 = (int *) vrna_alloc(sizeof(int)*(length + 1));


  /* hard code min_loop_size to 0, since we can not be sure yet that this is already the case */
  turn = 0;

  for (j=1; j<=length; j++) {
    Fmi[j]=DMLi[j]=DMLi1[j]=DMLi2[j]=INF;
    my_fc[j]=0;
  }

  for (j = 1; j<=length; j++)
    for (i=1; i<=j; i++) {
      my_c[indx[j]+i] = my_fML[indx[j]+i] = INF;
      if (uniq_ML) my_fM1[indx[j]+i] = INF;
    }

  for (i = length-turn-1; i >= 1; i--) { /* i,j in [1..length] */

    maxj=(zuker)? (MIN2(i+cp-1,length)):length;
    for (j = i+turn+1; j <= maxj; j++) {
      int ij;
      ij            = indx[j]+i;
      type          = (unsigned char)ptype[ij];
      hc_decompose  = hard_constraints[ij];
      energy        = INF;

      no_close = (((type==3)||(type==4))&&noGUclosure);

      if (hc_decompose) {   /* we have a pair */
        int new_c = INF;

        if(!no_close){
          /* check for hairpin loop */
          energy  = vrna_E_hp_loop(vc, i, j);
          new_c   = MIN2(new_c, energy);

          /* check for multibranch loops */
          energy  = vrna_E_mb_loop_fast(vc, i, j, DMLi1, DMLi2);
          new_c   = MIN2(new_c, energy);
        }

        if (dangle_model==3) { /* coaxial stacking */
          energy  = E_mb_loop_stack(i, j, vc);
          new_c   = MIN2(new_c, energy);
        }

        /* check for interior loops */
        energy = vrna_E_int_loop(vc, i, j);
        new_c = MIN2(new_c, energy);

        /* remember stack energy for --noLP option */
        if(noLP){
          if (ON_SAME_STRAND(i,i+1,cp) && ON_SAME_STRAND(j-1,j,cp)){
            int stackEnergy = vrna_E_stack(vc, i, j);
            new_c = MIN2(new_c, cc1[j-1]+stackEnergy);
            my_c[ij] = cc1[j-1]+stackEnergy;
          } else { /* currently we don't allow stacking over the cut point */
            my_c[ij] = FORBIDDEN;
          }
          cc[j] = new_c;
        } else {
          my_c[ij] = new_c;
        }
      } /* end >> if (pair) << */

      else my_c[ij] = INF;

      /* done with c[i,j], now compute fML[i,j] */
      /* free ends ? -----------------------------------------*/

      my_fML[ij] = vrna_E_ml_stems_fast(vc, i, j, Fmi, DMLi);

      if(uniq_ML){  /* compute fM1 for unique decomposition */
        my_fM1[ij] = E_ml_rightmost_stem(i, j, vc);
      }

    }

    if (i==cp)
      for (j=i; j<=maxj; j++)
        free_end(my_fc, j, cp, vc);
    if (i<cp)
      free_end(my_fc,i,cp-1, vc);


    {
      int *FF; /* rotate the auxilliary arrays */
      FF = DMLi2; DMLi2 = DMLi1; DMLi1 = DMLi; DMLi = FF;
      FF = cc1; cc1=cc; cc=FF;
      for (j=1; j<=maxj; j++) {cc[j]=Fmi[j]=DMLi[j]=INF; }
    }
  }

  /* calculate energies of 5' and 3' fragments */

  for (i=1; i<=length; i++)
    free_end(my_f5, i, 1, vc);

  if (cp>0) {
    mfe1  = my_f5[cp-1];
    mfe2  = my_fc[length];
    /* add DuplexInit, check whether duplex*/
    for (i=cp; i<=length; i++) {
      my_f5[i] = MIN2(my_f5[i]+P->DuplexInit, my_fc[i]+my_fc[1]);
    }
  }

  energy = my_f5[length];
  if (cp<1) mfe1=mfe2=energy;

  /* clean up memory */
  free(cc);
  free(cc1);
  free(Fmi);
  free(DMLi);
  free(DMLi1);
  free(DMLi2);

  return energy;
}

PRIVATE void
backtrack_co( sect bt_stack[],
              vrna_bp_stack_t *bp_list,
              int s,
              int b, /* b=0: start new structure, b \ne 0: add to existing structure */
              vrna_fold_compound_t *vc) {

  /*------------------------------------------------------------------
    trace back through the "c", "fc", "f5" and "fML" arrays to get the
    base pairing list. No search for equivalent structures is done.
    This is fast, since only few structure elements are recalculated.
    ------------------------------------------------------------------*/

  int   i, j, ij, k, length, energy, en, newX, ml0, ml5, ml3, ml53, no_close, type, type_2, tt;
  char  *string         = vc->sequence;
  vrna_param_t  *P      = vc->params;
  int     *indx         = vc->jindx;
  char    *ptype        = vc->ptype;

  short *S1             = vc->sequence_encoding;
  short *S              = vc->sequence_encoding2;
  int   dangle_model    = P->model_details.dangles;
  int   noLP            = P->model_details.noLP;
  int   noGUclosure     = P->model_details.noGUclosure;
  int   with_gquad      = P->model_details.gquad;
  int   turn            = P->model_details.min_loop_size;
  int   *rtype          = &(P->model_details.rtype[0]);
  char  backtrack_type  = P->model_details.backtrack_type;
  int   cp              = vc->cutpoint;
  vrna_hc_t  *hc        = vc->hc;
  vrna_sc_t  *sc        = vc->sc;
  char      *hard_constraints  = hc->matrix;

  /* the folding matrices */
  int   *my_f5, *my_c, *my_fML, *my_fc, *my_ggg;

  length  = vc->length;
  my_f5   = vc->matrices->f5;
  my_c    = vc->matrices->c;
  my_fML  = vc->matrices->fML;
  my_fc   = vc->matrices->fc;
  my_ggg  = vc->matrices->ggg;

  /* int   b=0;*/

  /* hard code min_loop_size to 0, since we can not be sure yet that this is already the case */
  turn = 0;

  length = strlen(string);
  if (s==0) {
    bt_stack[++s].i = 1;
    bt_stack[s].j   = length;
    bt_stack[s].ml  = (backtrack_type=='M') ? 1 : ((backtrack_type=='C')?2:0);
  }
  while (s>0) {
    int ml, fij, fi, cij, traced, i1, j1, mm, p, q, jj=0, gq=0;
    int canonical = 1;     /* (i,j) closes a canonical structure */

    /* pop one element from stack */
    i  = bt_stack[s].i;
    j  = bt_stack[s].j;
    ml = bt_stack[s--].ml;

    switch(ml){
      /* backtrack in f5 */
      case 0: {
                int p, q;
                if(vrna_BT_ext_loop_f5(vc, &j, &p, &q, bp_list, &b)){
                  if(j > 0){
                    bt_stack[++s].i = 1;
                    bt_stack[s].j   = j;
                    bt_stack[s].ml  = 0;
                  }
                  if(p > 0){
                    i = p;
                    j = q;
                    goto repeat1;
                  }

                  continue;
                } else {
                  fprintf(stderr, "%s\n", string);
                  vrna_message_error("backtrack failed in f5");
                }
              }
              break;

      /* true multi-loop backtrack in fML */
      case 1: {
                int p, q, comp1, comp2;
                if(vrna_BT_mb_loop_split(vc, &i, &j, &p, &q, &comp1, &comp2, bp_list, &b)){
                  if(i > 0){
                    bt_stack[++s].i = i;
                    bt_stack[s].j   = j;
                    bt_stack[s].ml  = comp1;
                  }
                  if(p > 0){
                    bt_stack[++s].i = p;
                    bt_stack[s].j   = q;
                    bt_stack[s].ml  = comp2;
                  }

                  continue;
                } else {
                  fprintf(stderr, "%s\n", string);
                  vrna_message_error("backtrack failed in fML");
                }
              }
              break;

      case 2: bp_list[++b].i = i;
              bp_list[b].j   = j;
              goto repeat1;

      /* backtrack fake-multi loop parts */
      case 3: case 4:
              {
                int lower, k, p, q;
                p = i;
                q = j;
                lower = (i < cp) ? 1 : 0;

                if(vrna_BT_mb_loop_fake(vc, &k, &i, &j, bp_list, &b)){
                  if(k > 0){
                    bt_stack[++s].i = (lower) ? k : p;
                    bt_stack[s].j   = (lower) ? q : k;
                    bt_stack[s].ml  = ml;
                  }
                  if(i > 0){
                    goto repeat1;
                  }

                  continue;
                } else {
                  fprintf(stderr, "%s\n", string);
                  vrna_message_error("backtrack failed in fc");
                }
              }
              break;
    } /* end of switch(ml) */

  repeat1:

    /*----- begin of "repeat:" -----*/
    ij = indx[j]+i;

    if (canonical)
      cij = my_c[ij];

    type = ptype[ij];

    if (noLP)
      if(vrna_BT_stack(vc, &i, &j, &cij, bp_list, &b)){
        canonical = 0;
        goto repeat1;
    }

    canonical = 1;

    no_close = (((type==3)||(type==4))&&noGUclosure);
    if (no_close) {
      if (cij == FORBIDDEN) continue;
    } else {
      if(vrna_BT_hp_loop(vc, i, j, cij, bp_list, &b))
        continue;
    }

    if(vrna_BT_int_loop(vc, &i, &j, cij, bp_list, &b)){
      if(i < 0)
        continue;
      else
        goto repeat1;
    }

    /* (i.j) must close a fake or true multi-loop */
    int comp1, comp2;

    if(vrna_BT_mb_loop(vc, &i, &j, &k, cij, &comp1, &comp2)){
      bt_stack[++s].i = i;
      bt_stack[s].j   = k;
      bt_stack[s].ml  = comp1;
      bt_stack[++s].i = k + 1;
      bt_stack[s].j   = j;
      bt_stack[s].ml  = comp2;
    } else {
      vrna_message_error("backtracking failed in repeat");
    }

    /* end of repeat: --------------------------------------------------*/

  } /* end >> while (s>0) << */

  bp_list[0].i = b;    /* save the total number of base pairs */
}

PRIVATE void
free_end( int *array,
          int i,
          int start,
          vrna_fold_compound_t *vc){

  int inc, type, energy, en, length, j, left, right, cp, dangle_model, with_gquad, *indx, *c, *ggg, turn;
  vrna_param_t  *P;
  short         *S1;
  char          *ptype, *hard_constraints;
  vrna_mx_mfe_t *matrices;
  vrna_hc_t     *hc;
  vrna_sc_t     *sc;

  cp            = vc->cutpoint;
  P             = vc->params;
  dangle_model  = P->model_details.dangles;
  with_gquad    = P->model_details.gquad;
  turn          = P->model_details.min_loop_size;
  inc           = (i>start)? 1:-1;
  length        = (int)vc->length;
  S1            = vc->sequence_encoding;
  ptype         = vc->ptype;
  indx          = vc->jindx;
  matrices      = vc->matrices;
  c             = matrices->c;
  ggg           = matrices->ggg;
  hc            = vc->hc;
  sc            = vc->sc;
  hard_constraints  = hc->matrix;

  if(hc->up_ext[i]){
    if (i==start) array[i]=0;
    else array[i] = array[i-inc];
    if(sc){
      if(sc->energy_up)
        array[i] += sc->energy_up[i][1];
    }
  } else
    array[i] = INF;

  if (inc>0) {
    left = start; right=i;
  } else {
    left = i; right = start;
  }

  /* hard code min_loop_size to 0, since we can not be sure yet that this is already the case */
  turn = 0;

  for (j=start; inc*(i-j)>turn; j+=inc) {
    int ii, jj;
    short si, sj;
    if (i>j) { ii = j; jj = i;} /* inc>0 */
    else     { ii = i; jj = j;} /* inc<0 */
    type = ptype[indx[jj]+ii];
    if(hard_constraints[indx[jj]+ii] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){

      if(type == 0)
        type = 7;

      si = (ii>1)       && ON_SAME_STRAND(ii-1,ii,cp) ? S1[ii-1] : -1;
      sj = (jj<length)  && ON_SAME_STRAND(jj,jj+1,cp) ? S1[jj+1] : -1;
      energy = c[indx[jj]+ii];
      if(energy != INF){
        switch(dangle_model){
          case 0:   if(array[j-inc] != INF){
                      en = array[j-inc] + energy + E_ExtLoop(type, -1, -1, P);
                      array[i] = MIN2(array[i], en);
                    }
                    break;
          case 2:   if(array[j-inc] != INF){
                      en = array[j-inc] + energy + E_ExtLoop(type, si, sj, P);
                      array[i] = MIN2(array[i], en);
                    }
                    break;
          default:  if(array[j-inc] != INF){
                      en = array[j-inc] + energy + E_ExtLoop(type, -1, -1, P);
                      array[i] = MIN2(array[i], en);
                    }
                    if(inc > 0){
                      if(j > left){
                        if(hc->up_ext[ii-1]){
                          if(array[j-2] != INF){
                            en = array[j-2] + energy + E_ExtLoop(type, si, -1, P);
                            if(sc)
                              if(sc->energy_up)
                                en += sc->energy_up[ii-1][1];

                            array[i] = MIN2(array[i], en);
                          }
                        }
                      }
                    } else if(j < right){
                      if(hc->up_ext[jj+1]){
                        if(array[j+2] != INF){
                          en = array[j+2] + energy + E_ExtLoop(type, -1, sj, P);
                          if(sc)
                            if(sc->energy_up)
                              en += sc->energy_up[jj+1][1];

                          array[i] = MIN2(array[i], en);
                        }
                      }
                    }
                    break;
        }
      }
    }

    if(with_gquad){
      if(ON_SAME_STRAND(ii, jj,cp))
        if(array[j-inc] != INF)
          array[i] = MIN2(array[i], array[j-inc] + ggg[indx[jj]+ii]);
    }

    if (dangle_model%2==1) {
      /* interval ends in a dangle (i.e. i-inc is paired) */
      if (i>j) { ii = j; jj = i-1;} /* inc>0 */
      else     { ii = i+1; jj = j;} /* inc<0 */

      if (!(hard_constraints[indx[jj]+ii] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP))
        continue;

      type = ptype[indx[jj]+ii];

      if(type == 0)
        type = 7;

      si = (ii > left)  && ON_SAME_STRAND(ii-1,ii,cp) ? S1[ii-1] : -1;
      sj = (jj < right) && ON_SAME_STRAND(jj,jj+1,cp) ? S1[jj+1] : -1;
      energy = c[indx[jj]+ii];
      if(energy != INF){
        if(inc>0){
          if(hc->up_ext[jj-1]){
            if(array[j-inc] != INF){
              en = array[j - inc] + energy + E_ExtLoop(type, -1, sj, P);
              if(sc)
                if(sc->energy_up)
                  en += sc->energy_up[jj+1][1];

              array[i] = MIN2(array[i], en);
            }
          }
        } else {
          if(hc->up_ext[ii-1]){
            if(array[j - inc] != INF){
              en = array[j - inc] + energy + E_ExtLoop(type, si, -1, P);
              if(sc)
                if(sc->energy_up)
                  en += sc->energy_up[ii-1][1];

              array[i] = MIN2(array[i], en);
            }
          }
        }
        if(j!= start){ /* dangle_model on both sides */
          if(hc->up_ext[jj-1] && hc->up_ext[ii-1]){
            if(array[j-2*inc] != INF){
              en = array[j-2*inc] + energy + E_ExtLoop(type, si, sj, P);
              if(sc)
                if(sc->energy_up)
                  en += sc->energy_up[ii-1][1] + sc->energy_up[jj+1][1];

              array[i] = MIN2(array[i], en);
            }
          }
        }
      }
    }
  }
}

PRIVATE void
backtrack(sect bt_stack[],
          vrna_bp_stack_t *bp_list,
          vrna_fold_compound_t *vc){

  /*routine to call backtrack_co from 1 to n, backtrack type??*/
  backtrack_co(bt_stack, bp_list, 0,0, vc);
}

PRIVATE void
doubleseq(vrna_fold_compound_t *vc){

  unsigned int  length;

  length  = vc->length;

  /* do some magic to re-use cofold code */
  vc->sequence  = vrna_realloc(vc->sequence, sizeof(char)*(2*length+2));
  memcpy(vc->sequence+length, vc->sequence, sizeof(char) * length);
  vc->sequence[2*length] = '\0';
  vc->length    = (unsigned int)strlen(vc->sequence);
  vc->cutpoint  = length+1;

  vc->sequence_encoding = vrna_realloc(vc->sequence_encoding, sizeof(short)*(vc->length + 2));
  memcpy(vc->sequence_encoding+length+1, vc->sequence_encoding+1, sizeof(short)*length);
  vc->sequence_encoding[0] = vc->sequence_encoding[vc->length];
  vc->sequence_encoding[vc->length+1] = vc->sequence_encoding[1];

  vc->sequence_encoding2 = vrna_realloc(vc->sequence_encoding2, sizeof(short)*(vc->length + 2));
  memcpy(vc->sequence_encoding2 + length + 1, vc->sequence_encoding2 + 1, sizeof(short)*length);
  vc->sequence_encoding2[0] = vc->length;
  vc->sequence_encoding2[vc->length+1] = 0;

  free(vc->ptype);
  vc->ptype = vrna_ptypes(vc->sequence_encoding2, &(vc->params->model_details));
  free(vc->iindx);
  vc->iindx = vrna_idx_row_wise(vc->length);
  free(vc->jindx);
  vc->jindx = vrna_idx_col_wise(vc->length);

  vrna_hc_init(vc);

  /* add DP matrices */
  vrna_mx_mfe_add(vc, VRNA_MX_DEFAULT, 0);
}

PRIVATE void
halfseq(vrna_fold_compound_t *vc){

  unsigned int halflength;

  halflength = vc->length/2;

  vc->sequence = vrna_realloc(vc->sequence, sizeof(char)*(halflength + 1));
  vc->sequence[halflength] = '\0';
  vc->length = (unsigned int)strlen(vc->sequence);
  vc->cutpoint = -1;

  vc->sequence_encoding = vrna_realloc(vc->sequence_encoding, sizeof(short)*(vc->length + 2));
  vc->sequence_encoding[0] = vc->sequence_encoding[vc->length];
  vc->sequence_encoding[vc->length+1] = vc->sequence_encoding[1];

  vc->sequence_encoding2 = vrna_realloc(vc->sequence_encoding2, sizeof(short)*(vc->length + 2));
  vc->sequence_encoding2[0] = vc->length;
  vc->sequence_encoding2[vc->length+1] = 0;

  free(vc->ptype);
  vc->ptype = vrna_ptypes(vc->sequence_encoding2, &(vc->params->model_details));
  free(vc->iindx);
  vc->iindx = vrna_idx_row_wise(vc->length);
  free(vc->jindx);
  vc->jindx = vrna_idx_col_wise(vc->length);

  vrna_hc_init(vc);

  /* add DP matrices */
  vrna_mx_mfe_add(vc, VRNA_MX_DEFAULT, 0);
}

typedef struct{
  int i;
  int j;
  int e;
  int idxj;
} zuker_pair;

PRIVATE int comp_pair(const void *A, const void *B) {
  zuker_pair *x,*y;
  int ex, ey;
  x = (zuker_pair *) A;
  y = (zuker_pair *) B;
  ex = x->e;
  ey = y->e;
  if (ex>ey) return 1;
  if (ex<ey) return -1;
  return (x->idxj + x->i - y->idxj + y->i);
}

PUBLIC SOLUTION *
vrna_subopt_zuker(vrna_fold_compound_t *vc){

/* Compute zuker suboptimal. Here, we're abusing the cofold() code
   "double" sequence, compute dimerarray entries, track back every base pair.
   This is slightly wasteful compared to the normal solution */

  char          *structure, *mfestructure, **todo, *ptype;
  int           i, j, counter, num_pairs, psize, p, *indx, *c, turn;
  unsigned int  length, doublelength;
  float         energy;
  SOLUTION      *zukresults;
  vrna_bp_stack_t         *bp_list;
  zuker_pair              *pairlist;
  sect          bt_stack[MAXSECTORS]; /* stack of partial structures for backtracking */
  vrna_mx_mfe_t *matrices;
  vrna_md_t     *md;

  md                = &(vc->params->model_details);
  turn              = md->min_loop_size;

  /* do some magic to re-use cofold code although vc is single sequence */
  md->min_loop_size = 0;
  doubleseq(vc);

  vrna_fold_compound_prepare(vc, VRNA_OPTION_MFE | VRNA_OPTION_HYBRID);

  doublelength    = vc->length;
  length          = doublelength/2;
  indx            = vc->jindx;
  ptype           = vc->ptype;
  matrices        = vc->matrices;
  c               = matrices->c;
  num_pairs       = counter = 0;
  mfestructure    = (char *) vrna_alloc((unsigned) doublelength+1);
  structure       = (char *) vrna_alloc((unsigned) doublelength+1);
  zukresults      = (SOLUTION *)vrna_alloc(((length*(length-1))/2)*sizeof(SOLUTION));
  mfestructure[0] = '\0';

  /* store length at pos. 0 */
  vc->sequence_encoding[0] = vc->sequence_encoding2[0];

  /* get mfe and do forward recursion */
  (void)fill_arrays(vc, 1);

  psize     = length;
  pairlist  = (zuker_pair *) vrna_alloc(sizeof(zuker_pair)*(psize+1));
  bp_list   = (vrna_bp_stack_t *) vrna_alloc(sizeof(vrna_bp_stack_t) * (1 + length/2));
  todo      = (char **) vrna_alloc(sizeof(char *)*(length+1));
  for (i=1; i<length; i++) {
    todo[i] = (char *) vrna_alloc(sizeof(char)*(length+1));
  }

  /* Make a list of all base pairs */
  for (i=1; i<length; i++) {
    for (j=i+turn+1/*??*/; j<=length; j++) {
      if (ptype[indx[j]+i]==0) continue;
      if (num_pairs>=psize) {
        psize = 1.2*psize + 32;
        pairlist = vrna_realloc(pairlist, sizeof(zuker_pair)*(psize+1));
      }
      pairlist[num_pairs].i       = i;
      pairlist[num_pairs].j       = j;
      pairlist[num_pairs].e       = c[indx[j]+i]+c[indx[i+length]+j];
      pairlist[num_pairs++].idxj  = indx[j];

      todo[i][j]=1;
    }
  }

  qsort(pairlist, num_pairs, sizeof(zuker_pair), comp_pair);

  for (p=0; p<num_pairs; p++) {
    i=pairlist[p].i;
    j=pairlist[p].j;
    if (todo[i][j]) {
      int   k;
      char  *sz;
      bt_stack[1].i   = i;
      bt_stack[1].j   = j;
      bt_stack[1].ml  = 2;
      backtrack_co(bt_stack, bp_list, 1,0, vc);
      bt_stack[1].i   = j;
      bt_stack[1].j   = i + length;
      bt_stack[1].ml  = 2;
      backtrack_co(bt_stack, bp_list, 1,bp_list[0].i, vc);
      energy = pairlist[p].e;
      sz = vrna_db_from_bp_stack(bp_list, length);
      zukresults[counter].energy      = energy;
      zukresults[counter++].structure = sz;
      for (k = 1; k <= bp_list[0].i; k++) { /* mark all pairs in structure as done */
        int x,y;
        x=bp_list[k].i;
        y=bp_list[k].j;
        if (x>length) x-=length;
        if (y>length) y-=length;
        if (x>y) {
          int temp;
          temp=x; x=y; y=temp;
        }
        todo[x][y] = 0;
      }
    }
  }

#ifdef  VRNA_BACKWARD_COMPAT

  /*
  *  Backward compatibility:
  *  This block may be removed if deprecated functions
  *  relying on the global variable "base_pair" vanish from within the package!
  */
  {
    if(base_pair) free(base_pair);
    base_pair = bp_list;
  }

#endif

  /* clean up */
  free(pairlist);
  for (i=1; i<length; i++)
    free(todo[i]);
  free(todo);
  free(structure);
  free(mfestructure);

  /* undo magic */
  halfseq(vc);
  md->min_loop_size = turn;

  return zukresults;
}

/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/

#ifdef  VRNA_BACKWARD_COMPAT

PRIVATE void
wrap_array_export(int **f5_p,
                  int **c_p,
                  int **fML_p,
                  int **fM1_p,
                  int **fc_p,
                  int **indx_p,
                  char **ptype_p){

  /* make the DP arrays available to routines such as subopt() */
  if(backward_compat_compound){
    *f5_p     = backward_compat_compound->matrices->f5;
    *c_p      = backward_compat_compound->matrices->c;
    *fML_p    = backward_compat_compound->matrices->fML;
    *fM1_p    = backward_compat_compound->matrices->fM1;
    *fc_p     = backward_compat_compound->matrices->fc;
    *indx_p   = backward_compat_compound->jindx;
    *ptype_p  = backward_compat_compound->ptype;
  }
}

/*--------------------------------------------------------------------------*/

PRIVATE float
wrap_cofold(const char *string,
            char *structure,
            vrna_param_t *parameters,
            int is_constrained){

  unsigned int        length;
  char                *seq;
  vrna_fold_compound_t  *vc;
  vrna_param_t        *P;
  float               mfe;

  vc      = NULL;
  length  = strlen(string);

#ifdef _OPENMP
/* Explicitly turn off dynamic threads */
  omp_set_dynamic(0);
#endif

  /* we need the parameter structure for hard constraints */
  if(parameters)
    P = vrna_params_copy(parameters);
  else{
    vrna_md_t md;
    set_model_details(&md);
    md.temperature = temperature;
    P = vrna_params(&md);
  }
  P->model_details.min_loop_size = 0;  /* set min loop length to 0 */

  /* dirty hack to reinsert the '&' according to the global variable 'cut_point' */
  seq = vrna_cut_point_insert(string, cut_point);

  /* get compound structure */
  vc = vrna_fold_compound(seq, &(P->model_details), 0);

  if(parameters){ /* replace params if necessary */
    free(vc->params);
    vc->params = P;
  } else {
    free(P);
  }

  /* handle hard constraints in pseudo dot-bracket format if passed via simple interface */
  if(is_constrained && structure){
    unsigned int constraint_options = 0;
    constraint_options |= VRNA_CONSTRAINT_DB
                          | VRNA_CONSTRAINT_DB_PIPE
                          | VRNA_CONSTRAINT_DB_DOT
                          | VRNA_CONSTRAINT_DB_X
                          | VRNA_CONSTRAINT_DB_ANG_BRACK
                          | VRNA_CONSTRAINT_DB_RND_BRACK
                          | VRNA_CONSTRAINT_DB_INTRAMOL
                          | VRNA_CONSTRAINT_DB_INTERMOL;

    vrna_constraints_add(vc, (const char *)structure, constraint_options);
  }

  if(backward_compat_compound)
    vrna_fold_compound_free(backward_compat_compound);

  backward_compat_compound  = vc;
  backward_compat           = 1;

  /* cleanup */
  free(seq);

  return vrna_mfe_dimer(vc, structure);
}

PRIVATE SOLUTION *
wrap_zukersubopt( const char *string,
                  vrna_param_t *parameters){

  unsigned int        length;
  char                *doubleseq;
  vrna_fold_compound_t  *vc;
  vrna_param_t        *P;

  vc      = NULL;
  length  = (int)strlen(string);

#ifdef _OPENMP
/* Explicitly turn off dynamic threads */
  omp_set_dynamic(0);
#endif

  /* we need the parameter structure for hard constraints */
  if(parameters)
    P = vrna_params_copy(parameters);
  else{
    vrna_md_t md;
    set_model_details(&md);
    md.temperature = temperature;
    P = vrna_params(&md);
  }
  P->model_details.min_loop_size = 0;  /* set min loop length to 0 */

  doubleseq = (char *)vrna_alloc((2*length+2)*sizeof(char));
  strcpy(doubleseq,string);
  doubleseq[length] = '&';
  strcat(doubleseq, string);

  /* get compound structure */
  vc = vrna_fold_compound(doubleseq, &(P->model_details), 0);

  if(parameters){ /* replace params if necessary */
    free(vc->params);
    vc->params = P;
  } else {
    free(P);
  }

  if(backward_compat_compound)
    vrna_fold_compound_free(backward_compat_compound);

  backward_compat_compound  = vc;
  backward_compat           = 1;

  /* cleanup */
  free(doubleseq);

  return vrna_subopt_zuker(vc);
}

PUBLIC void
initialize_cofold(int length){ /* DO NOTHING */ }

PUBLIC void
free_co_arrays(void){

  if(backward_compat_compound && backward_compat){
    vrna_fold_compound_free(backward_compat_compound);
    backward_compat_compound  = NULL;
    backward_compat           = 0;
  }
}


/*--------------------------------------------------------------------------*/

PUBLIC void
export_cofold_arrays_gq(int **f5_p,
                        int **c_p,
                        int **fML_p,
                        int **fM1_p,
                        int **fc_p,
                        int **ggg_p,
                        int **indx_p,
                        char **ptype_p){

  /* make the DP arrays available to routines such as subopt() */
  wrap_array_export(f5_p, c_p, fML_p, fM1_p, fc_p, indx_p, ptype_p);
  if(backward_compat_compound){
    *ggg_p = backward_compat_compound->matrices->ggg;
  }
}

PUBLIC void
export_cofold_arrays( int **f5_p,
                      int **c_p,
                      int **fML_p,
                      int **fM1_p,
                      int **fc_p,
                      int **indx_p,
                      char **ptype_p){

  wrap_array_export(f5_p, c_p, fML_p, fM1_p, fc_p, indx_p, ptype_p);
}

PUBLIC float
cofold( const char *string,
        char *structure){

  return wrap_cofold(string, structure, NULL, fold_constrained);
}

PUBLIC float
cofold_par( const char *string,
            char *structure,
            vrna_param_t *parameters,
            int is_constrained){

  return wrap_cofold(string, structure, parameters, is_constrained);
}

PUBLIC SOLUTION *
zukersubopt(const char *string) {

  return wrap_zukersubopt(string, NULL);
}

PUBLIC SOLUTION *
zukersubopt_par(const char *string,
                vrna_param_t *parameters){

  return wrap_zukersubopt(string, parameters);
}

PUBLIC void
update_cofold_params(void){

  vrna_fold_compound_t *v;
  
  if(backward_compat_compound && backward_compat){
    vrna_md_t md;
    v = backward_compat_compound;

    if(v->params)
      free(v->params);

    set_model_details(&md);
    v->params = vrna_params(&md);
  }
}

PUBLIC void
update_cofold_params_par(vrna_param_t *parameters){

  vrna_fold_compound_t *v;
  
  if(backward_compat_compound && backward_compat){
    v = backward_compat_compound;

    if(v->params)
      free(v->params);

    if(parameters){
      v->params = vrna_params_copy(parameters);
    } else {
      vrna_md_t md;
      set_model_details(&md);
      md.temperature = temperature;
      v->params = vrna_params(&md);
    }
  }
}

PUBLIC void get_monomere_mfes(float *e1, float *e2) {
  /*exports monomere free energies*/
  *e1 = mfe1;
  *e2 = mfe2;
}

#endif
part_func_co.c/ 0           0     0     644     43409     `
/*
                  partiton function for RNA secondary structures

                  Ivo L Hofacker
                  Stephan Bernhart
                  Ronny Lorenz
                  Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <float.h>    /* #defines FLT_MAX ... */
#include <limits.h>

#include "utils.h"
#include "structure_utils.h"
#include "energy_par.h"
#include "fold_vars.h"
#include "PS_dot.h"
#include "params.h"
#include "loop_energies.h"
#include "part_func.h"
#include "part_func_co.h"

#ifdef _OPENMP
#include <omp.h>
#endif

#define ON_SAME_STRAND(I,J,C)  (((I)>=(C))||((J)<(C)))

/* #define SAME_STRAND(I,J) (((J)<cut_point)||((I)>=cut_point2)||(((I)>=cut_point)&&((J)<cut_point2)))
 */

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/
int     mirnatog      = 0;
double  F_monomer[2]  = {0,0}; /* free energies of the two monomers */

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/

/* some backward compatibility stuff */
PRIVATE vrna_fold_compound_t  *backward_compat_compound = NULL;
PRIVATE int                 backward_compat           = 0;

#ifdef _OPENMP

#pragma omp threadprivate(backward_compat_compound, backward_compat)

#endif


/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/
PRIVATE void    pf_co(vrna_fold_compound_t *vc);
PRIVATE void    pf_co_bppm(vrna_fold_compound_t *vc, char *structure);
PRIVATE double  *Newton_Conc(double ZAB, double ZAA, double ZBB, double concA, double concB,double* ConcVec);
PRIVATE vrna_dimer_pf_t wrap_co_pf_fold(char *sequence,
                                char *structure,
                                vrna_exp_param_t *parameters,
                                int calculate_bppm,
                                int is_constrained);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

/*
*****************************************
* BEGIN backward compatibility wrappers *
*****************************************
*/

PRIVATE vrna_dimer_pf_t
wrap_co_pf_fold(char *sequence,
                char *structure,
                vrna_exp_param_t *parameters,
                int calculate_bppm,
                int is_constrained){

  int                 length;
  char                *seq;
  vrna_fold_compound_t  *vc;
  vrna_md_t           md;

  vc      = NULL;
  length  = strlen(sequence);

  /* we need vrna_exp_param_t datastructure to correctly init default hard constraints */
  if(parameters)
    md = parameters->model_details;
  else{
    set_model_details(&md); /* get global default parameters */
  }
  md.compute_bpp    = calculate_bppm;
  md.min_loop_size  = 0;

  seq = (char *)vrna_alloc(sizeof(char) * (length + 2));
  if(cut_point > -1){
    int i;
    for(i = 0; i < cut_point-1; i++)
      seq[i] = sequence[i];
    seq[i] = '&';
    for(;i<(int)length;i++)
      seq[i+1] = sequence[i];
  } else { /* this ensures the allocation of all cofold matrices via vrna_fold_compound_t */
    free(seq);
    seq = strdup(sequence);
  }

  vc = vrna_fold_compound(seq, &md, VRNA_OPTION_PF | VRNA_OPTION_HYBRID);

  if(is_constrained && structure){
    unsigned int constraint_options = 0;
    constraint_options |= VRNA_CONSTRAINT_DB
                          | VRNA_CONSTRAINT_DB_PIPE
                          | VRNA_CONSTRAINT_DB_DOT
                          | VRNA_CONSTRAINT_DB_X
                          | VRNA_CONSTRAINT_DB_ANG_BRACK
                          | VRNA_CONSTRAINT_DB_RND_BRACK;

    vrna_constraints_add(vc, (const char *)structure, constraint_options);
  }

  if(backward_compat_compound)
    vrna_fold_compound_free(backward_compat_compound);

  backward_compat_compound = vc;
  backward_compat           = 1;
  iindx = backward_compat_compound->iindx;

  free(seq);
  return vrna_pf_dimer(vc, structure);
}

/*
*****************************************
* END backward compatibility wrappers   *
*****************************************
*/

PUBLIC vrna_dimer_pf_t
vrna_pf_dimer(vrna_fold_compound_t *vc,
              char *structure){

  int             n;
  FLT_OR_DBL      Q;
  vrna_dimer_pf_t         X;
  double          free_energy;
  char            *sequence;
  vrna_md_t       *md;
  vrna_exp_param_t  *params;
  vrna_mx_pf_t      *matrices;

  vrna_fold_compound_prepare(vc, VRNA_OPTION_PF | VRNA_OPTION_HYBRID);

  params    = vc->exp_params;
  n         = vc->length;
  md        = &(params->model_details);
  matrices  = vc->exp_matrices;
  sequence  = vc->sequence;

#ifdef _OPENMP
/* Explicitly turn off dynamic threads */
  omp_set_dynamic(0);
#endif

#ifdef SUN4
  nonstandard_arithmetic();
#else
#ifdef HP9
  fpsetfastmode(1);
#endif
#endif

  /* call user-defined recursion status callback function */
  if(vc->stat_cb)
    vc->stat_cb(VRNA_STATUS_PF_PRE, vc->auxdata);

  pf_co(vc);

  /* call user-defined recursion status callback function */
  if(vc->stat_cb)
    vc->stat_cb(VRNA_STATUS_PF_POST, vc->auxdata);

  if (md->backtrack_type=='C')
    Q = matrices->qb[vc->iindx[1]-n];
  else if (md->backtrack_type=='M')
    Q = matrices->qm[vc->iindx[1]-n];
  else Q = matrices->q[vc->iindx[1]-n];

  /* ensemble free energy in Kcal/mol */
  if (Q<=FLT_MIN)
    fprintf(stderr, "pf_scale too large\n");
  free_energy = (-log(Q)-n*log(params->pf_scale))*params->kT/1000.0;
  /* in case we abort because of floating point errors */
  if (n>1600) fprintf(stderr, "free energy = %8.2f\n", free_energy);
  /*probability of molecules being bound together*/

  /*Computation of "real" Partition function*/
  /*Need that for concentrations*/
  if (vc->cutpoint > 0){
    double kT, QAB, QToT, Qzero;
    kT = params->kT/1000.0;
    Qzero = matrices->q[vc->iindx[1] - n];
    QAB = (matrices->q[vc->iindx[1] - n]- matrices->q[vc->iindx[1] - (vc->cutpoint - 1)] * matrices->q[vc->iindx[vc->cutpoint] - n]) * params->expDuplexInit;
    /*correction for symmetry*/
    if((n - (vc->cutpoint - 1) * 2) == 0){
      if((strncmp(sequence, sequence + vc->cutpoint - 1, vc->cutpoint - 1)) == 0){
        QAB/=2;
      }
    }

    QToT    = matrices->q[vc->iindx[1] - (vc->cutpoint - 1)] * matrices->q[vc->iindx[vc->cutpoint] - n] + QAB;
    X.FAB   = -kT * (log(QToT) + n * log(params->pf_scale));
    X.F0AB  = -kT * (log(Qzero)+ n * log(params->pf_scale));
    X.FcAB  = (QAB>1e-17) ? -kT * (log(QAB) + n * log(params->pf_scale)) : 999;
    X.FA    = -kT * (log(matrices->q[vc->iindx[1] - (vc->cutpoint - 1)]) + (vc->cutpoint - 1) * log(params->pf_scale));
    X.FB    = -kT * (log(matrices->q[vc->iindx[vc->cutpoint] - n]) + (n - vc->cutpoint + 1) * log(params->pf_scale));

    /* printf("QAB=%.9f\tQtot=%.9f\n",QAB/scale[n],QToT/scale[n]);*/
  }
  else {
    X.FA    = X.FB = X.FAB = X.F0AB = free_energy;
    X.FcAB  = 0;
  }

  /* backtracking to construct binding probabilities of pairs*/
  if(md->compute_bpp){
    pf_co_bppm(vc, structure);
    /*
    *  Backward compatibility:
    *  This block may be removed if deprecated functions
    *  relying on the global variable "pr" vanish from within the package!
    */
    pr = vc->exp_matrices->probs;
    /*
    {
      if(pr) free(pr);
      pr = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL) * ((n+1)*(n+2)/2));
      memcpy(pr, probs, sizeof(FLT_OR_DBL) * ((n+1)*(n+2)/2));
    }
    */
  }

#ifdef SUN4
  standard_arithmetic();
#else
#ifdef HP9
  fpsetfastmode(0);
#endif
#endif

  return X;
}

/* forward recursion of pf cofolding */
PRIVATE void
pf_co(vrna_fold_compound_t *vc){

  int               n, i,j,k,l, ij, kl, u,u1,u2,ii, type, type_2, tt, cp, turn, maxk, minl;
  FLT_OR_DBL        *qqm = NULL, *qqm1 = NULL, *qq = NULL, *qq1 = NULL;
  FLT_OR_DBL        temp, q_temp, Qmax=0;
  FLT_OR_DBL        qbt1, *tmp;
  FLT_OR_DBL        *q, *qb, *qm, *qm1;
  FLT_OR_DBL        *scale;
  FLT_OR_DBL        *expMLbase;
  short             *S1;
  int               *my_iindx, *jindx;
  char              *ptype, *sequence;
  vrna_md_t         *md;
  vrna_hc_t         *hc;
  vrna_sc_t         *sc;
  FLT_OR_DBL        expMLclosing;
  int               noGUclosure;
  double            max_real;
  int               *rtype;
  vrna_exp_param_t  *pf_params;
  vrna_mx_pf_t      *matrices;
  int               hc_decompose;
  char              *hard_constraints;
  int               *hc_up_ext;
  int               *hc_up_hp;
  int               *hc_up_int;
  int               *hc_up_ml;

  sequence          = vc->sequence;
  S1                = vc->sequence_encoding;
  n                 = vc->length;
  cp                = vc->cutpoint;
  my_iindx          = vc->iindx;
  jindx             = vc->jindx;
  ptype             = vc->ptype;
  pf_params         = vc->exp_params;
  md                = &(pf_params->model_details);
  rtype             = &(md->rtype[0]);
  hc                = vc->hc;
  sc                = vc->sc;
  expMLclosing      = pf_params->expMLclosing;
  noGUclosure       = md->noGUclosure;
  matrices          = vc->exp_matrices;
  turn              = md->min_loop_size;

  q                 = matrices->q;
  qb                = matrices->qb;
  qm                = matrices->qm;
  qm1               = matrices->qm1;
  scale             = matrices->scale;
  expMLbase         = matrices->expMLbase;

  hard_constraints  = hc->matrix;
  hc_up_ext         = hc->up_ext;
  hc_up_hp          = hc->up_hp;
  hc_up_int         = hc->up_int;
  hc_up_ml          = hc->up_ml;

  max_real          = (sizeof(FLT_OR_DBL) == sizeof(float)) ? FLT_MAX : DBL_MAX;

  /* allocate memory for helper arrays */
  qq        = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));
  qq1       = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));
  qqm       = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));
  qqm1      = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));

  /* hard code min_loop_size to 0, since we can not be sure yet that this is already the case */
  turn = 0;

  /*array initialization ; qb,qm,q
    qb,qm,q (i,j) are stored as ((n+1-i)*(n-i) div 2 + n+1-j */

  /* for (d=0; d<=TURN; d++) */
  for (i=1; i<=n/*-d*/; i++) {
      ij      = my_iindx[i]-i;
      if(hc_up_ext[i]){
        q[ij] = scale[1];

        if(sc){
          if(sc->exp_energy_up)
            q[ij] *= sc->exp_energy_up[i][1];
          if(sc->exp_f)
            q[ij] *= sc->exp_f(i, i, i, i, VRNA_DECOMP_EXT_UP, sc->data);
        }
      } else {
        q[ij] = 0.;
      }

      qb[ij]  = qm[ij] = 0.0;
    }

  for (i=0; i<=n; i++)
    qq[i] = qq1[i] = qqm[i] = qqm1[i] = 0;

  for (j = turn + 2; j <= n; j++) {
    for (i = j - turn - 1; i >= 1; i--) {
      /* construction of partition function of segment i,j */
      /* firstly that given i binds j : qb(i,j) */
      u             = j - i - 1;
      ij            = my_iindx[i] - j;
      type          = (unsigned char)ptype[jindx[j] + i];
      hc_decompose  = hard_constraints[jindx[j] + i];
      qbt1          = 0;
      q_temp        = 0.;

      if(hc_decompose){
        /* process hairpin loop(s) */
        qbt1 += vrna_exp_E_hp_loop(vc, i, j);
        qbt1 += vrna_exp_E_int_loop(vc, i, j);
        qbt1 += vrna_exp_E_mb_loop_fast(vc, i, j, qqm1);

        /*qc contribution*/
        if (!ON_SAME_STRAND(i,j,cp)){
          tt = rtype[type];

          if(tt == 0)
            tt = 7;

          temp=q[my_iindx[i+1]-(cp-1)]*q[my_iindx[cp]-(j-1)];
          if ((j==cp)&&(i==cp-1)) temp=scale[2];
          else if (i==cp-1) temp=q[my_iindx[cp]-(j-1)]*scale[1];
          else if (j==cp) temp=q[my_iindx[i+1]-(cp-1)]*scale[1];
          if (j>cp) temp*=scale[1];
          if (i<cp-1) temp*=scale[1];
          temp  *=  exp_E_ExtLoop(tt, ON_SAME_STRAND(j-1,j,cp) ? S1[j-1] : -1, ON_SAME_STRAND(i,i+1,cp) ? S1[i+1] : -1, pf_params);
          qbt1  +=  temp;
        }
        qb[ij] = qbt1;
      } else  /* end if allowed to be paired */
        qb[ij] = 0.0;

      /* construction of qqm matrix containing final stem
         contributions to multiple loop partition function
         from segment i,j */
      qqm[i] = 0.;

      if(hc_up_ml[j]){
        if (ON_SAME_STRAND(j-1,j,cp)) {
          q_temp  =  qqm1[i] * expMLbase[1];

          if(sc){
            if(sc->exp_energy_up)
              q_temp *= sc->exp_energy_up[j][1];

            if(sc->exp_f)
              q_temp *= sc->exp_f(i, j, i, j-1, VRNA_DECOMP_ML_ML, sc->data);
          }

          qqm[i] = q_temp;
        }
      }

      if(hc_decompose & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC){
        if(ON_SAME_STRAND(i-1,i,cp) && ON_SAME_STRAND(j,j+1,cp)){
          tt = type;

          if(tt == 0)
            tt = 7;

          qbt1    =   qb[ij];
          qbt1    *=  exp_E_MLstem(tt, (i>1) ? S1[i-1] : -1, (j<n) ? S1[j+1] : -1, pf_params);
          if(sc){
            if(sc->exp_f)
              q_temp *= sc->exp_f(i, j, i, j, VRNA_DECOMP_ML_STEM, sc->data);
          }
          qqm[i]  +=  qbt1;
        }
      }

      if (qm1) qm1[jindx[j]+i] = qqm[i]; /* for stochastic backtracking */


      /*construction of qm matrix containing multiple loop
        partition function contributions from segment i,j */
      temp  = 0.0;
      kl = my_iindx[i] - j + 1; /* ii-k=[i,k-1] */
      for (k=j; k>i; k--, kl++){
        if (ON_SAME_STRAND(k-1,k,cp)){
          q_temp = qm[kl] * qqm[k];

          if(sc){
            if(sc->exp_f)
              q_temp *= sc->exp_f(i, j, k-1, k, VRNA_DECOMP_ML_ML_ML, sc->data);
          }

          temp += q_temp;
        }
      }

      maxk = MIN2(i+hc_up_ml[i], j);
      ii = 1; /* length of unpaired stretch */
      for (k=i+1; k<=maxk; k++, ii++){
        if (ON_SAME_STRAND(i,k,cp)){
          q_temp = expMLbase[ii] * qqm[k];

          if(sc){
            if(sc->exp_energy_up)
              q_temp *= sc->exp_energy_up[i][ii];

            if(sc->exp_f)
              q_temp *= sc->exp_f(i, j, k, j, VRNA_DECOMP_ML_ML, sc->data);
          }

          temp += q_temp;
        }
      }

      qm[ij] = (temp + qqm[i]);

      /*auxiliary matrix qq for cubic order q calculation below */
      qbt1 = 0.;

      if(hc_decompose & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
        tt = type;

        if(tt == 0)
          tt = 7;

        qbt1 =  qb[ij]
                * exp_E_ExtLoop(tt, ((i>1)&&(ON_SAME_STRAND(i-1,i,cp))) ? S1[i-1] : -1, ((j<n)&&(ON_SAME_STRAND(j,j+1,cp))) ? S1[j+1] : -1, pf_params);
        if(sc){
          if(sc->exp_f)
            qbt1 *= sc->exp_f(i, j, i, j, VRNA_DECOMP_EXT_STEM, sc->data);
        }
     }

      if(hc_up_ext[j]){
        q_temp = qq1[i] * scale[1];

        if(sc){
          if(sc->exp_energy_up)
            q_temp *= sc->exp_energy_up[j][1];

          if(sc->exp_f)
            q_temp *= sc->exp_f(i, j, i, j-1, VRNA_DECOMP_EXT_EXT, sc->data);
        }

        qbt1 += q_temp;
      }
      qq[i] = qbt1;

       /*construction of partition function for segment i,j */
      temp = qq[i];

      /* the whole stretch [i,j] is unpaired */
      if(hc_up_ext[i] >= (j-i+1)){
        q_temp = 1.0 * scale[j-i+1];

        if(sc){
          if(sc->exp_energy_up)
            q_temp *= sc->exp_energy_up[i][j-i+1];

          if(sc->exp_f)
            q_temp *= sc->exp_f(i, j, i, j, VRNA_DECOMP_EXT_UP, sc->data);
        }

        temp += q_temp;
      }

      kl = my_iindx[i] - i;
      for (k=i; k<j; k++, kl--){
        q_temp = q[kl] * qq[k+1];

        if(sc){
          if(sc->exp_f)
            q_temp *= sc->exp_f(i, j, k, k+1, VRNA_DECOMP_EXT_EXT_EXT, sc->data);
        }

        temp += q_temp;
      }
      q[ij] = temp;
      if (temp>Qmax) {
        Qmax = temp;
        if (Qmax>max_real/10.)
          fprintf(stderr, "Q close to overflow: %d %d %g\n", i,j,temp);
      }
      if (temp>=max_real) {
        PRIVATE char msg[128];
        snprintf(msg, 127, "overflow in co_pf_fold while calculating q[%d,%d]\n"
                "use larger pf_scale", i,j);
        vrna_message_error(msg);
      }
    }
    tmp = qq1;  qq1 =qq;  qq =tmp;
    tmp = qqm1; qqm1=qqm; qqm=tmp;
  }

  /* clean up */
  free(qq);
  free(qq1);
  free(qqm);
  free(qqm1);

}

/* backward recursion of pf cofolding */
PRIVATE void
pf_co_bppm(vrna_fold_compound_t *vc, char *structure){

  int               n, i,j,k,l, ij, kl, ii, ll, lj, u1, u2, type, type_2, tt, turn, ov=0, *my_iindx, *jindx, cp;
  FLT_OR_DBL        temp, Qmax=0, prm_MLb, tmp2, ppp;
  FLT_OR_DBL        prmt,prmt1, *expMLbase;
  FLT_OR_DBL        *tmp;
  FLT_OR_DBL        expMLclosing, *probs, *q1k, *qln, *q, *qb, *qm, *scale;
  double            max_real;
  vrna_exp_param_t  *pf_params;
  vrna_md_t         *md;
  short             *S,*S1;
  char              *ptype;
  vrna_hc_t         *hc;
  vrna_sc_t         *sc;
  vrna_mx_pf_t      *matrices;
  char              *sequence;
  char              *hard_constraints;
  int               *hc_up_ext;
  int               *hc_up_hp;
  int               *hc_up_int;
  int               *hc_up_ml;
  int               *rtype;

  sequence          = vc->sequence;
  n                 = vc->length;
  cp                = vc->cutpoint;
  pf_params         = vc->exp_params;
  md                = &(pf_params->model_details);
  expMLclosing      = pf_params->expMLclosing;
  S                 = vc->sequence_encoding2;
  S1                = vc->sequence_encoding;
  jindx             = vc->jindx;
  my_iindx          = vc->iindx;
  ptype             = vc->ptype;
  rtype             = &(md->rtype[0]);
  turn              = md->min_loop_size;

  matrices          = vc->exp_matrices;
  probs             = matrices->probs;
  scale             = matrices->scale;
  q1k               = matrices->q1k;
  qln               = matrices->qln;
  q                 = matrices->q;
  qb                = matrices->qb;
  qm                = matrices->qm;
  expMLbase         = matrices->expMLbase;

  hc                = vc->hc;
  sc                = vc->sc;

  hard_constraints  = hc->matrix;
  hc_up_ext         = hc->up_ext;
  hc_up_hp          = hc->up_hp;
  hc_up_int         = hc->up_int;
  hc_up_ml          = hc->up_ml;

  /* hard code min_loop_size to 0, since we can not be sure yet that this is already the case */
  turn = 0;

  max_real      = (sizeof(FLT_OR_DBL) == sizeof(float)) ? FLT_MAX : DBL_MAX;

  /* backtracking to construct binding probabilities of pairs*/
  if ((S != NULL) && (S1 != NULL)) {
    FLT_OR_DBL   *Qlout, *Qrout;
    FLT_OR_DBL *prm_l  = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));
    FLT_OR_DBL *prm_l1 = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));
    FLT_OR_DBL *prml   = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));

    Qmax  = 0;
    Qrout = (FLT_OR_DBL *)vrna_alloc(sizeof(FLT_OR_DBL) * (n+2));
    Qlout = (FLT_OR_DBL *)vrna_alloc(sizeof(FLT_OR_DBL) * (cp+2));

    for (k=1; k<=n; k++) {
      q1k[k] = q[my_iindx[1] - k];
      qln[k] = q[my_iindx[k] - n];
    }
    q1k[0] = 1.0;
    qln[n+1] = 1.0;

    /* 1. exterior pair i,j and initialization of pr array */
    for (i=1; i<=n; i++) {
      for (j=i; j<=MIN2(i + turn, n); j++)
        probs[my_iindx[i]-j] = 0;

      for (j = i + turn + 1; j <= n; j++){
        ij = my_iindx[i]-j;
        if((hard_constraints[jindx[j] + i] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP) && (qb[ij] > 0.)){
          type  = ptype[jindx[j] + i];

          if(type == 0)
            type = 7;

          probs[ij] = q1k[i-1]*qln[j+1]/q1k[n];
          probs[ij] *= exp_E_ExtLoop(type, ((i>1)&&(ON_SAME_STRAND(i-1,i,cp))) ? S1[i-1] : -1, ((j<n)&&(ON_SAME_STRAND(j,j+1,cp))) ? S1[j+1] : -1, pf_params);
          if(sc){
            if(sc->exp_f){
              probs[ij] *= sc->exp_f(1, n, i, j, VRNA_DECOMP_EXT_STEM_OUTSIDE, sc->data);
            }
          }
        } else
          probs[ij] = 0;
      }
    }

    for(l = n; l > turn + 1; l--){

      /* 2. bonding k,l as substem of 2:loop enclosed by i,j */
      for(k = 1; k < l - turn; k++){
        kl      = my_iindx[k]-l;
        type_2  = (unsigned char)ptype[jindx[l] + k];
        type_2  = rtype[type_2];

        if(qb[kl]==0.) continue;

        if(hard_constraints[jindx[l] + k] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP_ENC){

          if(type_2 == 0)
            type_2 = 7;

          for(i = MAX2(1, k - MAXLOOP - 1); i <= k - 1; i++){
            u1 = k - i - 1;
            if(hc_up_int[i+1] < u1) continue;

            for(j = l + 1; j <= MIN2(l + MAXLOOP - k + i + 2, n); j++){
              u2 = j-l-1;
              if(hc_up_int[l+1] < u2) break;

              ij = my_iindx[i] - j;
              if(hard_constraints[jindx[j] + i] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP){

                if ((ON_SAME_STRAND(i,k,cp)) && (ON_SAME_STRAND(l,j,cp))){
                  type = (unsigned char)ptype[jindx[j] + i];
                  if(probs[ij] > 0){

                    if(type == 0)
                      type = 7;

                    tmp2  = probs[ij]
                            * scale[u1 + u2 + 2]
                            * exp_E_IntLoop(u1, u2, type, type_2, S1[i+1], S1[j-1], S1[k-1], S1[l+1], pf_params);

                    if(sc){
                      if(sc->exp_energy_up)
                        tmp2 *=   sc->exp_energy_up[i+1][u1]
                                * sc->exp_energy_up[l+1][u2];

                      if(sc->exp_energy_bp)
                        tmp2 *=   sc->exp_energy_bp[ij];

                      if(sc->exp_energy_stack){
                        if((i+1 == k) && (j-1 == l)){
                          tmp2 *=   sc->exp_energy_stack[i]
                                  * sc->exp_energy_stack[k]
                                  * sc->exp_energy_stack[l]
                                  * sc->exp_energy_stack[j];
                        }
                      }

                      if(sc->exp_f)
                        tmp2 *= sc->exp_f(i, j, k, l, VRNA_DECOMP_PAIR_IL, sc->data);
                    }

                    probs[kl] += tmp2;
                  }
                }
              }
            }
          }
        }
      }

      /* 3. bonding k,l as substem of multi-loop enclosed by i,j */
      prm_MLb = 0.;
      if((l < n) && (ON_SAME_STRAND(l, l + 1, cp)))
        for (k = 2; k < l - turn; k++) {
          kl    = my_iindx[k] - l;
          i     = k - 1;
          prmt  = prmt1 = 0.0;

          ii    = my_iindx[i];     /* ii-j=[i,j]     */
          ll    = my_iindx[l+1];   /* ll-j=[l+1,j] */
          tt    = (unsigned char)ptype[jindx[l+1] + i];
          tt    = rtype[tt];
          if (ON_SAME_STRAND(i,k,cp)){
            if(hard_constraints[jindx[l+1] + i] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP){

              if(tt == 0)
                tt = 7;

              prmt1 = probs[ii-(l+1)]
                      * expMLclosing
                      * exp_E_MLstem(tt, S1[l], S1[i+1], pf_params);

              if(sc){
                /* which decompositions are covered here? => (i, l+1) -> enclosing pair, (k,l) -> enclosed pair, */
                if(sc->exp_energy_bp)
                  prmt1 *= sc->exp_energy_bp[ii - (l+1)];

/*
                if(sc->exp_f)
                  prmt1 *= sc->exp_f(i, l+1, k, l, , sc->data);
*/
              }
            }
            ij = my_iindx[i] - (l+2);
            lj = my_iindx[l+1]-(l+1);

            for(j = l + 2; j <= n; j++, ij--, lj--){
              if(hard_constraints[jindx[j] + i] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP){
                if (ON_SAME_STRAND(j-1,j,cp)){ /*??*/
                  tt    =   (unsigned char)ptype[jindx[j] + i];
                  tt    =   rtype[tt];

                  if(tt == 0)
                    tt = 7;

                  /* which decomposition is covered here? =>
                    i + 1 = k < l < j:
                    (i,j)       -> enclosing pair
                    (k, l)      -> enclosed pair
                    (l+1, j-1)  -> multiloop part with at least one stem
                  */
                  ppp = probs[ii-j]
                        * exp_E_MLstem(tt, S1[j-1], S1[i+1], pf_params)
                        * qm[ll-(j-1)];

                  if(sc){
                    if(sc->exp_energy_bp)
                      ppp *= sc->exp_energy_bp[ij];
/*
                    if(sc->exp_f)
                      ppp *= sc->exp_f(i, j, l+1, j-1, , sc->data);
*/
                  }
                  prmt += ppp;
                }
              }
            }
          }
          prmt *= expMLclosing;

          tt        =   ptype[jindx[l] + k];

          prml[ i]  =   prmt;

          /* l+1 is unpaired */
          if(hc->up_ml[l+1]){
            ppp = prm_l1[i] * expMLbase[1];
            if(sc){
              if(sc->exp_energy_up)
                ppp *= sc->exp_energy_up[l+1][1];

/*
              if(sc_exp_f)
                ppp *= sc->exp_f(, sc->data);
*/
            }
            prm_l[i] = ppp + prmt1;
          } else {
            prm_l[i] = prmt1;
          }

          /* i is unpaired */
          if(hc->up_ml[i]){
            ppp = prm_MLb*expMLbase[1];
            if(sc){
              if(sc->exp_energy_up)
                ppp *= sc->exp_energy_up[i][1];

/*
              if(sc->exp_f)
                ppp *= sc->exp_f(, sc->data);
*/
            }

            prm_MLb = ppp + prml[i];
            /* same as:    prm_MLb = 0;
               for (i=1; i<=k-1; i++) prm_MLb += prml[i]*expMLbase[k-i-1]; */

          } else {
            prm_MLb = prml[i];
          }
          prml[i] = prml[ i] + prm_l[i];

          if (qb[kl] == 0.) continue;

          if(hard_constraints[jindx[l] + k] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC){
            temp = prm_MLb;

            for (i=1;i<=k-2; i++) {
              if ((ON_SAME_STRAND(i,i+1,cp)) && (ON_SAME_STRAND(k-1,k,cp))){
                temp += prml[i]*qm[my_iindx[i+1] - (k-1)];
              }
            }

            if(tt == 0)
              tt = 7;

            temp *= exp_E_MLstem( tt,
                                  ((k>1) && ON_SAME_STRAND(k-1,k,cp)) ? S1[k-1] : -1,
                                  ((l<n) && ON_SAME_STRAND(l,l+1,cp)) ? S1[l+1] : -1,
                                  pf_params) * scale[2];
            probs[kl] += temp;

            if (probs[kl]>Qmax) {
              Qmax = probs[kl];
              if (Qmax>max_real/10.)
                fprintf(stderr, "P close to overflow: %d %d %g %g\n",
                        i, j, probs[kl], qb[kl]);
            }
            if (probs[kl]>=max_real) {
              ov++;
              probs[kl]=FLT_MAX;
            }
          }
        } /* end for (k=..) multloop*/
      else  /* set prm_l to 0 to get prm_l1 to be 0 */
        for (i=0; i<=n; i++) prm_l[i]=0;

      tmp = prm_l1; prm_l1=prm_l; prm_l=tmp;

      /*computation of .(..(...)..&..). type features?*/
      if (cp<=0) continue;            /* no .(..(...)..&..). type features*/
      if ((l==n)||(l<=2)) continue;   /* no .(..(...)..&..). type features*/
      /*new version with O(n^3)??*/
      if (l>cp) {
        if (l<n) {
          int t,kt;
          for (t=n; t>l; t--) {
            for (k=1; k<cp; k++) {
              kt    = my_iindx[k]-t;
              type  = rtype[(unsigned char)ptype[jindx[t] + k]];

              if(type == 0)
                type = 7;

              temp  = probs[kt]
                      * exp_E_ExtLoop(type, S1[t-1], (ON_SAME_STRAND(k,k+1,cp)) ? S1[k+1] : -1, pf_params)
                      * scale[2];

              if (l+1<t)
                temp    *=  q[my_iindx[l+1]-(t-1)];

              if (ON_SAME_STRAND(k,k+1,cp))
                temp    *=  q[my_iindx[k+1]-(cp-1)];

              Qrout[l]  +=  temp;
            }
          }
        }
        for (k=l-1; k>=cp; k--) {
          if (qb[my_iindx[k]-l]) {
            kl        =   my_iindx[k]-l;
            type      =   ptype[jindx[l] + k];
            temp      =   Qrout[l];

            if(type == 0)
              type = 7;

            temp      *=  exp_E_ExtLoop(type, (k>cp) ? S1[k-1] : -1, (l < n) ? S1[l+1] : -1, pf_params);
            if (k>cp)
              temp    *=  q[my_iindx[cp]-(k-1)];
            probs[kl] +=  temp;
          }
        }
      }
      else if (l==cp ) {
        int t, sk,s;
        for (t=2; t<cp;t++) {
          for (s=1; s<t; s++) {
            for (k=cp; k<=n; k++) {
              sk=my_iindx[s]-k;
              if (qb[sk]) {
                type      =   rtype[(unsigned char)ptype[jindx[k] + s]];

                if(type == 0)
                  type = 7;

                temp      =   probs[sk]
                              * exp_E_ExtLoop(type, (ON_SAME_STRAND(k-1,k,cp)) ? S1[k-1] : -1, S1[s+1], pf_params)
                              * scale[2];
                if (s+1<t)
                  temp    *=  q[my_iindx[s+1]-(t-1)];
                if (ON_SAME_STRAND(k-1,k,cp))
                  temp    *=  q[my_iindx[cp]-(k-1)];
                Qlout[t]  +=  temp;
              }
            }
          }
        }
      }
      else if (l<cp) {
        for (k=1; k<l; k++) {
          if (qb[my_iindx[k]-l]) {
            type    =   ptype[jindx[l] + k];
            temp    =   Qlout[k];

            if(type == 0)
              type = 7;

            temp    *=  exp_E_ExtLoop(type, (k>1) ? S1[k-1] : -1, (l<(cp-1)) ? S1[l+1] : -1, pf_params);
            if (l+1<cp)
              temp  *=  q[my_iindx[l+1]-(cp-1)];
            probs[my_iindx[k]-l]  +=  temp;
          }
        }
      }
    }  /* end for (l=..)   */
    free(Qlout);
    free(Qrout);
    for (i=1; i<=n; i++)
      for (j=i+turn+1; j<=n; j++) {
        ij        =   my_iindx[i]-j;
        probs[ij] *=  qb[ij];
      }

    if (structure!=NULL){
      char *s = vrna_db_from_probs(probs, (unsigned int)n);
      memcpy(structure, s, n);
      structure[n] = '\0';
      free(s);
    }

    /* clean up */
    free(prm_l);
    free(prm_l1);
    free(prml);

  }   /* end if (do_backtrack)*/

  if (ov>0) fprintf(stderr, "%d overflows occurred while backtracking;\n"
                    "you might try a smaller pf_scale than %g\n",
                    ov, pf_params->pf_scale);
}

PUBLIC void
vrna_pf_dimer_probs(double FAB,
                    double FA,
                    double FB,
                    vrna_plist_t *prAB,
                    const vrna_plist_t *prA,
                    const vrna_plist_t *prB,
                    int Alength,
                    const vrna_exp_param_t *exp_params) {

  /*computes binding probabilities and dimer free energies*/
  int         i, j;
  double      pAB;
  double      mykT;
  const vrna_plist_t *lp2;
  vrna_plist_t       *lp1;
  int         offset;

  mykT = exp_params->kT/1000.;

  /* pair probabilities in pr are relative to the null model (without DuplexInit) */

  /*Compute probabilities pAB, pAA, pBB*/

  pAB = 1. - exp((1/mykT)*(FAB-FA-FB));

  /* compute pair probabilities given that it is a dimer */
  /* AB dimer */
  offset  = 0;
  lp2     = prA;
  if (pAB>0)
    for (lp1=prAB; lp1->j>0; lp1++) {
      float pp=0;
      i = lp1->i;
      j = lp1->j;
      while (offset+lp2->i < i && lp2->i>0) lp2++;
      if (offset+lp2->i == i)
        while ((offset+lp2->j) < j  && (lp2->j>0)) lp2++;
      if (lp2->j == 0) {lp2=prB; offset=Alength;}/* jump to next list */
      if ((offset+lp2->i==i) && (offset+lp2->j ==j)) {
        pp = lp2->p;
        lp2++;
      }
      lp1->p=(lp1->p-(1-pAB)*pp)/pAB;
      if(lp1->p < 0.){
        vrna_message_warning("vrna_co_pf_probs: numeric instability detected, probability below zero!");
        lp1->p = 0.;
      }
    }

  return;
}

PRIVATE double *
Newton_Conc(double KAB,
            double KAA,
            double KBB,
            double concA,
            double concB,
            double* ConcVec){

  double  TOL, EPS, xn, yn, det, cA, cB;
  int     i;

  i       = 0;
  /*Newton iteration for computing concentrations*/
  cA      = concA;
  cB      = concB;
  TOL     = 1e-6; /*Tolerance for convergence*/
  ConcVec = (double*)vrna_alloc(5*sizeof(double)); /* holds concentrations */
  do {
    /* det = (4.0 * KAA * cA + KAB *cB + 1.0) * (4.0 * KBB * cB + KAB *cA + 1.0) - (KAB *cB) * (KAB *cA); */
    det = 1 + 16. *KAA*KBB*cA*cB + KAB*(cA+cB) + 4.*KAA*cA + 4.*KBB*cB + 4.*KAB*(KBB*cB*cB + KAA*cA*cA);
    /* xn  = ( (2.0 * KBB * cB*cB + KAB *cA *cB + cB - concB) * (KAB *cA) -
       (2.0 * KAA * cA*cA + KAB *cA *cB + cA - concA) * (4.0 * KBB * cB + KAB *cA + 1.0) ) /det; */
    xn  = ( (2.0 * KBB * cB*cB + cB - concB) * (KAB *cA) - KAB*cA*cB*(4. * KBB*cB + 1.) -
	    (2.0 * KAA * cA*cA + cA - concA) * (4.0 * KBB * cB + KAB *cA + 1.0) ) /det;
    /* yn  = ( (2.0 * KAA * cA*cA + KAB *cA *cB + cA - concA) * (KAB *cB) -
       (2.0 * KBB * cB*cB + KAB *cA *cB + cB - concB) * (4.0 * KAA * cA + KAB *cB + 1.0) ) /det; */
    yn  = ( (2.0 * KAA * cA*cA + cA - concA) * (KAB *cB) - KAB*cA*cB*(4. * KAA*cA + 1.) -
            (2.0 * KBB * cB*cB + cB - concB) * (4.0 * KAA * cA + KAB *cB + 1.0) ) /det;
    EPS = fabs(xn/cA) + fabs(yn/cB);
    cA += xn;
    cB += yn;
    i++;
    if (i>10000) {
      fprintf(stderr, "Newton did not converge after %d steps!!\n",i);
      break;
    }
  } while(EPS>TOL);

  ConcVec[0] = cA*cB*KAB ;/*AB concentration*/
  ConcVec[1] = cA*cA*KAA ;/*AA concentration*/
  ConcVec[2] = cB*cB*KBB ;/*BB concentration*/
  ConcVec[3] = cA;        /* A concentration*/
  ConcVec[4] = cB;        /* B concentration*/

  return ConcVec;
}

PUBLIC vrna_dimer_conc_t *
vrna_pf_dimer_concentrations(double FcAB,
                              double FcAA,
                              double FcBB,
                              double FEA,
                              double FEB,
                              const double *startconc,
                              const vrna_exp_param_t *exp_params){

  /*takes an array of start concentrations, computes equilibrium concentrations of dimers, monomers, returns array of concentrations in strucutre vrna_dimer_conc_t*/
  double            *ConcVec;
  int               i;
  vrna_dimer_conc_t *Concentration;
  double            KAA, KAB, KBB, kT;

  kT            = exp_params->kT/1000.;
  Concentration = (vrna_dimer_conc_t *)vrna_alloc(20*sizeof(vrna_dimer_conc_t));
 /* Compute equilibrium constants */
  /* again note the input free energies are not from the null model (without DuplexInit) */

  KAA = exp(( 2.0 * FEA - FcAA)/kT);
  KBB = exp(( 2.0 * FEB - FcBB)/kT);
  KAB = exp(( FEA + FEB - FcAB)/kT);
  /* printf("Kaa..%g %g %g\n", KAA, KBB, KAB); */
  for (i=0; ((startconc[i]!=0)||(startconc[i+1]!=0));i+=2) {
    ConcVec                 = Newton_Conc(KAB, KAA, KBB, startconc[i], startconc[i+1], ConcVec);
    Concentration[i/2].A0   = startconc[i];
    Concentration[i/2].B0   = startconc[i+1];
    Concentration[i/2].ABc  = ConcVec[0];
    Concentration[i/2].AAc  = ConcVec[1];
    Concentration[i/2].BBc  = ConcVec[2];
    Concentration[i/2].Ac   = ConcVec[3];
    Concentration[i/2].Bc   = ConcVec[4];

    if (!(((i+2)/2)%20))  {
      Concentration = (vrna_dimer_conc_t *)vrna_realloc(Concentration,((i+2)/2+20)*sizeof(vrna_dimer_conc_t));
    }
    free(ConcVec);
  }

  return Concentration;
}


#if 0
/*
  stochastic backtracking in pf_fold arrays
  returns random structure S with Boltzman probabilty
  p(S) = exp(-E(S)/kT)/Z
*/
PRIVATE void
backtrack_qm1(vrna_fold_compound_t *vc,
              int i,
              int j,
              char *pstruc){

  /* i is paired to l, i<l<j; backtrack in qm1 to find l */
  int           ii, l, type, *jindx, *my_iindx, *rtype, turn;
  double        qt, r;
  FLT_OR_DBL    *qm, *qm1, *qb, *expMLbase;
  short         *S1;
  char          *ptype;
  vrna_md_t     *md;

  vrna_exp_param_t  *pf_params;
  vrna_mx_pf_t      *matrices;

  pf_params     = vc->exp_params;
  md            = &(pf_params->model_details);
  S1            = vc->sequence_encoding;
  ptype         = vc->ptype;
  rtype         = &(md->rtype[0]);
  turn          = md->min_loop_size;

  matrices      = vc->exp_matrices;
  qb            = matrices->qb;
  qm            = matrices->qm;
  qm1           = matrices->qm1;
  expMLbase     = matrices->expMLbase;

  jindx         = vc->jindx;
  my_iindx      = vc->iindx;

  r   = vrna_urn() * qm1[jindx[j]+i];
  ii  = my_iindx[i];
  for (qt=0., l=i+turn+1; l<=j; l++) {
    type = ptype[jindx[l] + i];
    if (type)
      qt +=  qb[ii-l]*exp_E_MLstem(type, S1[i-1], S1[l+1], pf_params) * expMLbase[j-l];
    if (qt>=r) break;
  }
  if (l>j) vrna_message_error("backtrack failed in qm1");
  backtrack(vc, i,l, pstruc);
}

PRIVATE void
backtrack(vrna_fold_compound_t *vc,
          int i,
          int j,
          char *pstruc){

  int           *jindx, *my_iindx, *rtype, turn;
  FLT_OR_DBL    *qm, *qm1, *qb, *expMLbase, *scale;
  vrna_exp_param_t  *pf_params;
  vrna_mx_pf_t      *matrices;
  short         *S1;
  char          *ptype, *sequence;
  int           noGUclosure;
  vrna_md_t     *md;

  sequence      = vc->sequence;
  pf_params     = vc->exp_params;
  md            = &(pf_params->model_details);
  S1            = vc->sequence_encoding;
  ptype         = vc->ptype;
  rtype         = &(md->rtype[0]);
  turn          = md->min_loop_size;

  matrices      = vc->exp_matrices;
  qb            = matrices->qb;
  qm            = matrices->qm;
  qm1           = matrices->qm1;
  expMLbase     = matrices->expMLbase;
  scale         = matrices->scale;
  jindx         = vc->jindx;
  my_iindx      = vc->iindx;
  noGUclosure   = pf_params->model_details.noGUclosure;

  do {
    double r, qbt1;
    int k, l, type, u, u1;

    pstruc[i-1] = '('; pstruc[j-1] = ')';

    r     = vrna_urn() * qb[my_iindx[i]-j];
    type  = ptype[jindx[j] + i];
    u     = j - i - 1;
    /*hairpin contribution*/
    if (((type==3)||(type==4))&&noGUclosure) qbt1 = 0;
    else
      qbt1 = exp_E_Hairpin(u, type, S1[i+1], S1[j-1], sequence+i-1, pf_params)*scale[u+2];

    if (qbt1>r) return; /* found the hairpin we're done */

    for (k=i+1; k<=MIN2(i+MAXLOOP+1,j-turn-2); k++) {
      u1 = k-i-1;
      for (l=MAX2(k+turn+1,j-1-MAXLOOP+u1); l<j; l++) {
        int type_2;
        type_2 = ptype[jindx[l] + k];
        if (type_2) {
          type_2  =   rtype[type_2];
          qbt1    +=  qb[my_iindx[k]-l] *
            exp_E_IntLoop(u1, j-l-1, type, type_2,
                          S1[i+1], S1[j-1], S1[k-1], S1[l+1], pf_params)*scale[u1+j-l+1];
        }
        if (qbt1 > r) break;
      }
      if (qbt1 > r) break;
    }
    if (l<j) {
      i=k; j=l;
    }
    else break;
  } while (1);

  /* backtrack in multi-loop */
  {
    double r, qt;
    int k, ii, jj;

    i++; j--;
    /* find the first split index */
    ii = my_iindx[i]; /* ii-j=[i,j] */
    jj = jindx[j]; /* jj+i=[j,i] */
    for (qt=0., k=i+1; k<j; k++) qt += qm[ii-(k-1)]*qm1[jj+k];
    r = vrna_urn() * qt;
    for (qt=0., k=i+1; k<j; k++) {
      qt += qm[ii-(k-1)]*qm1[jj+k];
      if (qt>=r) break;
    }
    if (k>=j) vrna_message_error("backtrack failed, can't find split index ");

    backtrack_qm1(vc, k, j, pstruc);

    j = k-1;
    while (j>i) {
      /* now backtrack  [i ... j] in qm[] */
      jj  = jindx[j];
      ii  = my_iindx[i];
      r   = vrna_urn() * qm[ii - j];
      qt  = qm1[jj+i]; k=i;
      if (qt<r)
        for (k=i+1; k<=j; k++) {
          qt += (qm[ii-(k-1)]+expMLbase[k-i])*qm1[jj+k];
          if (qt >= r) break;
        }
      if (k>j) vrna_message_error("backtrack failed in qm");

      backtrack_qm1(vc, k,j, pstruc);

      if (k<i+turn) break; /* no more pairs */
      r = vrna_urn() * (qm[ii-(k-1)] + expMLbase[k-i]);
      if (expMLbase[k-i] >= r) break; /* no more pairs */
      j = k-1;
    }
  }
}

#endif

/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/

PUBLIC vrna_dimer_pf_t
co_pf_fold(char *sequence, char *structure){

  return wrap_co_pf_fold(sequence, structure, NULL, do_backtrack, fold_constrained);
}

PUBLIC vrna_dimer_pf_t
co_pf_fold_par( char *sequence,
                char *structure,
                vrna_exp_param_t *parameters,
                int calculate_bppm,
                int is_constrained){

  return wrap_co_pf_fold(sequence, structure, parameters, calculate_bppm, is_constrained);
}


PUBLIC vrna_plist_t *
get_plist(vrna_plist_t *pl,
          int length,
          double cut_off){

  int i, j,n, count, *my_iindx;

  my_iindx = backward_compat_compound->iindx;
  /*get pair probibilities out of pr array*/
  count=0;
  n=2;
  for (i=1; i<length; i++) {
    for (j=i+1; j<=length; j++) {
      if (pr[my_iindx[i]-j]<cut_off) continue;
      if (count==n*length-1) {
        n*=2;
        pl=(vrna_plist_t *)vrna_realloc(pl,n*length*sizeof(vrna_plist_t));
      }
      pl[count].i=i;
      pl[count].j=j;
      pl[count++].p=pr[my_iindx[i]-j];
      /*      printf("gpl: %2d %2d %.9f\n",i,j,pr[my_iindx[i]-j]);*/
    }
  }
  pl[count].i=0;
  pl[count].j=0; /*->??*/
  pl[count++].p=0.;
  pl=(vrna_plist_t *)vrna_realloc(pl,(count)*sizeof(vrna_plist_t));
  return pl;
}

PUBLIC void
compute_probabilities(double FAB,
                      double FA,
                      double FB,
                      vrna_plist_t *prAB,
                      vrna_plist_t *prA,
                      vrna_plist_t *prB,
                      int Alength) {

  if(backward_compat_compound && backward_compat){
    vrna_pf_dimer_probs(FAB, FA, FB, prAB, (const vrna_plist_t *)prA, (const vrna_plist_t *)prB, Alength, (const vrna_exp_param_t *)backward_compat_compound->exp_params);
  }
}

PUBLIC vrna_dimer_conc_t *
get_concentrations( double FcAB,
                    double FcAA,
                    double FcBB,
                    double FEA,
                    double FEB,
                    double *startconc){

  return vrna_pf_dimer_concentrations(FcAB, FcAA, FcBB, FEA, FEB, (const double *)startconc, (const vrna_exp_param_t *)backward_compat_compound->exp_params);
}

PUBLIC void
init_co_pf_fold(int length){

 /* DO NOTHING */
}

PUBLIC void
free_co_pf_arrays(void){

  if(backward_compat_compound && backward_compat){
    vrna_fold_compound_free(backward_compat_compound);
    backward_compat_compound  = NULL;
    backward_compat           = 0;
  }
}

PUBLIC FLT_OR_DBL *
export_co_bppm(void){

  if(backward_compat_compound)
    return backward_compat_compound->exp_matrices->probs;
  else
    return NULL;
}

/*----------------------------------------------------------------------*/
PUBLIC void
update_co_pf_params(int length){

  if(backward_compat_compound && backward_compat){
    vrna_md_t         md;
    set_model_details(&md);
    vrna_exp_params_reset(backward_compat_compound, &md);

    /* compatibility with RNAup, may be removed sometime */
    pf_scale = backward_compat_compound->exp_params->pf_scale;
  }
}

PUBLIC void
update_co_pf_params_par(int length,
                        vrna_exp_param_t *parameters){

  if(backward_compat_compound && backward_compat){
    vrna_md_t         md;
    if(parameters){
      vrna_exp_params_subst(backward_compat_compound, parameters);
    } else {
      set_model_details(&md);
      vrna_exp_params_reset(backward_compat_compound, &md);
    }

    /* compatibility with RNAup, may be removed sometime */
    pf_scale = backward_compat_compound->exp_params->pf_scale;
  }
}


ProfileAln.c/   0           0     0     644     7452      `
/*
   Fast, but crude, pairwise structural Alignments of RNA sequences

   Possible structures of each RNA are encoded in a linear
   "probability profile", by computing for each base the probability
   of being unpaired, or paired upstream or downstream. These profiles
   can be aligned using standard string alignment.

   The is an extension of the old method in ProfileDist.c with the
   following changes:
   - use sequence as well as structure profile for scoring
   - use similarity alignment instead of distance (maybe add local alinment)
   - use affine gap costs

	  C Ivo L Hofacker, Vienna RNA Package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <float.h>
#include "dist_vars.h"
#include "fold_vars.h"
#include "part_func.h"
#include "utils.h"
#include "profiledist.h"
#include "ProfileAln.h"


#define EQUAL(x,y)     (fabs((x)-(y)) <= fabs(x)*2*FLT_EPSILON)

PRIVATE int *alignment[2];

PRIVATE void    sprint_aligned_bppm(const float *T1, const char *seq1,
				    const float *T2, const char *seq2);
PRIVATE double  PrfEditScore(const float *p1, const float *p2,
			     char c1, char c2);
PRIVATE double  average(double x, double y);

PRIVATE double  open=-1.5, ext=-0.666;  /* defaults from clustalw */
PRIVATE double  seqw=0.5;
PRIVATE int     free_ends=1;            /* whether to use free end gaps */

/*---------------------------------------------------------------------------*/

PRIVATE float **newmat(int l1, int l2) {
  float **a;
  int i;
  a = (float **) vrna_alloc((l1+1)*sizeof(float *));
  for (i=0; i<=l1; i++) a[i] = (float *) vrna_alloc((l2+1)*sizeof(float));
  return a;
}

PUBLIC float profile_aln(const float *T1, const char *seq1,
			 const float *T2, const char *seq2)
{
  /* align the 2 probability profiles T1, T2 */
  /* This is like a Needleman-Wunsch alignment, with affine gap-costs
     ala Gotoh. The score looks at both seq and pair profile */

  float  **S, **E, **F, tot_score;
  int    i, j, length1, length2;

  length1 = strlen(seq1);
  length2 = strlen(seq2);
  S = newmat(length1, length2);
  E = newmat(length1, length2);
  F = newmat(length1, length2);

  E[0][0] = F[0][0] = open - ext;
  S[0][0] = 0;
  for (i=1; i<=length1; i++) F[i][0] = -9999; /* impossible */
  for (j=1; j<=length2; j++) E[0][j] = -9999; /* impossible */
  if (!free_ends) {
    for (i=1; i<=length1; i++) S[i][0] = E[i][0] = E[i-1][0] +ext;
    for (j=1; j<=length2; j++) S[0][j] = F[0][j] = F[0][j-1] +ext;
  }

  for (i=1; i<=length1; i++) {
    for (j=1; j<=length2; j++) {
      float M;
      E[i][j] = MAX2(E[i-1][j]+ext, S[i-1][j]+open);
      F[i][j] = MAX2(F[i][j-1]+ext, S[i][j-1]+open);
      M = S[i-1][j-1] + PrfEditScore(T1+3*i,T2+3*j, seq1[i-1], seq2[j-1]);
      S[i][j] = MAX3(M, E[i][j], F[i][j]);
    }
  }

  if (edit_backtrack) {
    double score=0;
    char state = 'S';
    int pos, i,j;
    alignment[0] = (int *) vrna_alloc((length1+length2+1)*sizeof(int));
    alignment[1] = (int *) vrna_alloc((length1+length2+1)*sizeof(int));

    pos = length1+length2;
    i   = length1;
    j   = length2;

    tot_score = S[length1][length2];

    if (free_ends) {
      /* find starting point for backtracking,
	 search for highest entry in last row or column */
      int imax=0;
      for (i=1; i<=length1; i++) {
	if (S[i][length2]>score) {
	  score=S[i][length2];
	  imax=i;
	}
      }
      for (j=1; j<=length2; j++) {
	if (S[length1][j]>score) {
	  score=S[length1][j];
	  imax=-j;
	}
      }
      if (imax<0) {
	for (j=length2; j> -imax; j--) {
	  alignment[0][pos] = 0;
	  alignment[1][pos--] = j;
	}
	i=length1;
      } else {
	for (i=length1; i>imax; i--) {
	  alignment[0][pos] = i;
	  alignment[1][pos--] = 0;
	}
	j=length2;
      }
      tot_score=score;
    }

    while (i>0 && j>0) {
      switch (state) {
      case 'E':
	score = E[i][j];
	alignment[0][pos] = i;
	alignment[1][pos--] = 0;
	if (EQUAL(score, S[i-1][j] + open)) state = 'S';
	i--;
	break;
      case 'F':
	score = F[i][j];
	alignment[0][pos] = 0;
	alignment[1][pos--] = j;
	if (EQUAL(score, S[i][j-1] + open)) state = 'S';
	j--;
	break;
      case 'S':
	score = S[i][j];
	if (EQUAL(score, E[i][j])) state = 'E';
	else if (EQUAL(score, F[i][j])) state = 'F';
	else if (EQUAL(score, S[i-1][j-1] +
		       PrfEditScore(T1+3*i,T2+3*j, seq1[i-1], seq2[j-1]))) {
	  alignment[0][pos] = i;
	  alignment[1][pos--] = j;
	  i--; j--;
	}
	else vrna_message_error("backtrack of alignment failed");
	break;
      }
    }

    for (; j>0; j--) {
      alignment[0][pos] = 0;
      alignment[1][pos--] = j;
    }
    for (; i>0; i--) {
      alignment[0][pos] = i;
      alignment[1][pos--] = 0;
    }

    for(i=pos+1; i<=length1+length2; i++){
      alignment[0][i-pos] = alignment[0][i];
      alignment[1][i-pos] = alignment[1][i];
    }
    alignment[0][0] = length1+length2-pos;   /* length of alignment */

    sprint_aligned_bppm(T1,seq1, T2,seq2);
    free(alignment[0]);
    free(alignment[1]);
  }
  for (i=0; i<=length1; i++) {
    free(S[i]); free(E[i]); free(F[i]);
  }
  free(S); free(E); free(F);

  return tot_score;
}


/*---------------------------------------------------------------------------*/
PRIVATE inline double average(double x, double y) {
  /*
     As in Bonhoeffer et al (1993) 'RNA Multi Structure Landscapes',
     Eur. Biophys. J. 22: 13-24 we have chosen  the geometric mean.
  */
  return (float) sqrt(x*y);
}

PRIVATE double PrfEditScore(const float *p1, const float *p2, char c1, char c2)
{
  double  score;
  int    k;

  for(score=0.,k=0; k<3; k++)
    score += average(p1[k],p2[k]);

  score *= (1- seqw);
  if (c1==c2) score +=  seqw;
  else if (((c1=='A') && (c2=='G')) ||
	   ((c1=='G') && (c2=='A')) ||
	   ((c1=='C') && (c2=='U')) ||
	   ((c1=='U') && (c2=='C')))
    score += 0.5*seqw;
  else score -= 0.9*seqw;
  return score;
}

/*---------------------------------------------------------------------------*/

PRIVATE void sprint_aligned_bppm(const float *T1, const char *seq1,
				 const float *T2, const char *seq2) {
   int     i, length;
   length = alignment[0][0];
   for (i=0; i<4; i++) {
     if (aligned_line[i] != NULL) free(aligned_line[i]);
     aligned_line[i] = (char *) vrna_alloc((length+1)*sizeof(char));
   }
   for(i=1; i<=length; i++){
      if (alignment[0][i]==0)
	aligned_line[0][i-1] = aligned_line[2][i-1] = '_';
      else {
	aligned_line[0][i-1] = vrna_bpp_symbol(T1+alignment[0][i]*3);
	aligned_line[2][i-1] = seq1[alignment[0][i]-1];
      }
      if (alignment[1][i]==0)
	aligned_line[1][i-1] = aligned_line[3][i-1] = '_';
      else {
	aligned_line[1][i-1] = vrna_bpp_symbol(T2+alignment[1][i]*3);
	aligned_line[3][i-1] = seq2[alignment[1][i]-1];
      }
   }
}

PUBLIC int set_paln_params(double gap_open, double gap_ext,
			   double seq_weight, int freeends) {
  open = (gap_open>0) ? -gap_open : gap_open;
  ext = (gap_ext>0) ? -gap_ext : gap_ext;
  if (open > ext) fprintf(stderr, "Gap extension penalty is smaller than "
			  "gap open. Do you realy want this?\n");
  seqw = seq_weight;
  if (seqw<0) {
    seqw = 0;
    fprintf(stderr, "Sequence weight set to 0 (must be in [0..1])\n");
  } else
  if (seqw>1) {
    seqw = 1;
    fprintf(stderr, "Sequence weight set to 1 (must be in [0..1])\n");
  }
  free_ends = (freeends) ? 1 : 0;
  return 0;
}

/*---------------------------------------------------------------------------*/
duplex.c/       0           0     0     644     17012     `
/*
           compute the duplex structure of two RNA strands,
                allowing only inter-strand base pairs.
         see cofold() for computing hybrid structures without
                             restriction.

                             Ivo Hofacker
                          Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include "utils.h"
#include "energy_par.h"
#include "fold_vars.h"
#include "fold.h"
#include "pair_mat.h"
#include "params.h"
#include "alifold.h"
#include "subopt.h"
#include "loop_energies.h"
#include "duplex.h"

#ifdef _OPENMP
#include <omp.h>
#endif

#define STACK_BULGE1  1     /* stacking energies for bulges of size 1 */
#define NEW_NINIO     1     /* new asymetry penalty */
#define MAXSECTORS    500   /* dimension for a backtrack array */
#define LOCALITY      0.    /* locality parameter for base-pairs */
#define UNIT 100
#define MINPSCORE -2 * UNIT
#define NONE -10000         /* score for forbidden pairs */



/*
#################################
# GLOBAL VARIABLES              #
#################################
*/
/*
#################################
# PRIVATE VARIABLES             #
#################################
*/
PRIVATE vrna_param_t  *P  = NULL;
PRIVATE int     **c = NULL;                  /* energy array, given that i-j pair */
PRIVATE short   *S1 = NULL, *SS1 = NULL, *S2 = NULL, *SS2 = NULL;
PRIVATE int     n1,n2;                /* sequence lengths */

#ifdef _OPENMP

/* NOTE: all variables are assumed to be uninitialized if they are declared as threadprivate
*/
#pragma omp threadprivate(P, c, S1, SS1, S2, SS2, n1, n2)

#endif

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/
PRIVATE duplexT duplexfold_cu(const char *s1, const char *s2, int clean_up);
PRIVATE duplexT aliduplexfold_cu(const char *s1[], const char *s2[], int clean_up);
PRIVATE char    *backtrack(int i, int j);
PRIVATE char    *alibacktrack(int i, int j, const short **S1, const short **S2);
PRIVATE int     compare(const void *sub1, const void *sub2);
PRIVATE int     covscore(const int *types, int n_seq);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PUBLIC duplexT duplexfold(const char *s1, const char *s2){
  return duplexfold_cu(s1, s2, 1);
}

PRIVATE duplexT duplexfold_cu(const char *s1, const char *s2, int clean_up){
  int i, j, Emin=INF, i_min=0, j_min=0;
  char *struc;
  duplexT mfe;
  vrna_md_t md;

  n1 = (int) strlen(s1);
  n2 = (int) strlen(s2);

  set_model_details(&md);
  if ((!P) || (fabs(P->temperature - temperature)>1e-6)) {
    if(P)
      free(P);
    P = vrna_params(&md);
    make_pair_matrix();
  }

  c = (int **) vrna_alloc(sizeof(int *) * (n1+1));
  for (i=1; i<=n1; i++) c[i] = (int *) vrna_alloc(sizeof(int) * (n2+1));

  S1  = encode_sequence(s1, 0);
  S2  = encode_sequence(s2, 0);
  SS1 = encode_sequence(s1, 1);
  SS2 = encode_sequence(s2, 1);

  for (i=1; i<=n1; i++) {
    for (j=n2; j>0; j--) {
      int type, type2, E, k,l;
      type = pair[S1[i]][S2[j]];
      c[i][j] = type ? P->DuplexInit : INF;
      if (!type) continue;
      c[i][j] += E_ExtLoop(type, (i>1) ? SS1[i-1] : -1, (j<n2) ? SS2[j+1] : -1, P);
      for (k=i-1; k>0 && k>i-MAXLOOP-2; k--) {
        for (l=j+1; l<=n2; l++) {
          if (i-k+l-j-2>MAXLOOP) break;
          type2 = pair[S1[k]][S2[l]];
          if (!type2) continue;
          E = E_IntLoop(i-k-1, l-j-1, type2, rtype[type],
                            SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1], P);
          c[i][j] = MIN2(c[i][j], c[k][l]+E);
        }
      }
      E = c[i][j];
      E += E_ExtLoop(rtype[type], (j > 1) ? SS2[j-1] : -1, (i<n1) ? SS1[i+1] : -1, P);
      if (E<Emin) {
        Emin=E; i_min=i; j_min=j;
      }
    }
  }

  struc = backtrack(i_min, j_min);
  if (i_min<n1) i_min++;
  if (j_min>1 ) j_min--;

  mfe.i = i_min;
  mfe.j = j_min;
  mfe.energy = (float) Emin/100.;
  mfe.structure = struc;
  if(clean_up) {
    for (i=1; i<=n1; i++) free(c[i]);
    free(c);
    free(S1);
    free(S2);
    free(SS1);
    free(SS2);
  }
  return mfe;
}

PUBLIC duplexT *duplex_subopt(const char *s1, const char *s2, int delta, int w) {
  int i,j, n1, n2, thresh, E, n_subopt=0, n_max;
  char *struc;
  duplexT mfe;
  duplexT *subopt;

  n_max=16;
  subopt = (duplexT *) vrna_alloc(n_max*sizeof(duplexT));
  mfe = duplexfold_cu(s1, s2, 0);
  free(mfe.structure);

  thresh = (int) mfe.energy*100+0.1 + delta;
  n1 = strlen(s1); n2=strlen(s2);
  for (i=n1; i>0; i--) {
    for (j=1; j<=n2; j++) {
      int type, ii,jj, Ed;
      type = pair[S2[j]][S1[i]];
      if (!type) continue;
      E = Ed = c[i][j];
      Ed += E_ExtLoop(type, (j>1) ? SS2[j-1] : -1, (i<n1) ? SS1[i+1] : -1, P);
      if (Ed>thresh) continue;
      /* too keep output small, remove hits that are dominated by a
         better one close (w) by. For simplicity we do test without
         adding dangles, which is slightly inaccurate.
      */
      for (ii=MAX2(i-w,1); (ii<=MIN2(i+w,n1)) && type; ii++) {
        for (jj=MAX2(j-w,1); jj<=MIN2(j+w,n2); jj++)
          if (c[ii][jj]<E) {type=0; break;}
      }
      if (!type) continue;

      struc = backtrack(i,j);
      fprintf(stderr, "%d %d %d\n", i,j,E);
      if (n_subopt+1>=n_max) {
        n_max *= 2;
        subopt = (duplexT *) vrna_realloc(subopt, n_max*sizeof(duplexT));
      }
      subopt[n_subopt].i = MIN2(i+1,n1);
      subopt[n_subopt].j = MAX2(j-1,1);
      subopt[n_subopt].energy = Ed * 0.01;
      subopt[n_subopt++].structure = struc;
    }
  }
  /* free all static globals */
  for (i=1; i<=n1; i++) free(c[i]);
  free(c);
  free(S1); free(S2); free(SS1); free(SS2);

  if (subopt_sorted) qsort(subopt, n_subopt, sizeof(duplexT), compare);
  subopt[n_subopt].i =0;
  subopt[n_subopt].j =0;
  subopt[n_subopt].structure = NULL;
  return subopt;
}

PRIVATE char *backtrack(int i, int j) {
  /* backtrack structure going backwards from i, and forwards from j
     return structure in bracket notation with & as separator */
  int k, l, type, type2, E, traced, i0, j0;
  char *st1, *st2, *struc;

  st1 = (char *) vrna_alloc(sizeof(char)*(n1+1));
  st2 = (char *) vrna_alloc(sizeof(char)*(n2+1));

  i0=MIN2(i+1,n1); j0=MAX2(j-1,1);

  while (i>0 && j<=n2) {
    E = c[i][j]; traced=0;
    st1[i-1] = '(';
    st2[j-1] = ')';
    type = pair[S1[i]][S2[j]];
    if (!type) vrna_message_error("backtrack failed in fold duplex");
    for (k=i-1; k>0 && k>i-MAXLOOP-2; k--) {
      for (l=j+1; l<=n2; l++) {
        int LE;
        if (i-k+l-j-2>MAXLOOP) break;
        type2 = pair[S1[k]][S2[l]];
        if (!type2) continue;
        LE = E_IntLoop(i-k-1, l-j-1, type2, rtype[type],
                       SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1], P);
        if (E == c[k][l]+LE) {
          traced=1;
          i=k; j=l;
          break;
        }
      }
      if (traced) break;
    }
    if (!traced) {
      E -= E_ExtLoop(type, (i>1) ? SS1[i-1] : -1, (j<n2) ? SS2[j+1] : -1, P);
      if (E != P->DuplexInit) {
        vrna_message_error("backtrack failed in fold duplex");
      } else break;
    }
  }
  if (i>1)  i--;
  if (j<n2) j++;

  struc = (char *) vrna_alloc(i0-i+1+j-j0+1+2);
  for (k=MAX2(i,1); k<=i0; k++) if (!st1[k-1]) st1[k-1] = '.';
  for (k=j0; k<=j; k++) if (!st2[k-1]) st2[k-1] = '.';
  strcpy(struc, st1+MAX2(i-1,0)); strcat(struc, "&");
  strcat(struc, st2+j0-1);

  /* printf("%s %3d,%-3d : %3d,%-3d\n", struc, i,i0,j0,j);  */
  free(st1); free(st2);

  return struc;
}

/*------------------------------------------------------------------------*/

PRIVATE int compare(const void *sub1, const void *sub2) {
  int d;
  if (((duplexT *) sub1)->energy > ((duplexT *) sub2)->energy)
    return 1;
  if (((duplexT *) sub1)->energy < ((duplexT *) sub2)->energy)
    return -1;
  d = ((duplexT *) sub1)->i - ((duplexT *) sub2)->i;
  if (d!=0) return d;
  return  ((duplexT *) sub1)->j - ((duplexT *) sub2)->j;
}

/*---------------------------------------------------------------------------*/

PUBLIC duplexT aliduplexfold(const char *s1[], const char *s2[]){
  return aliduplexfold_cu(s1, s2, 1);
}

PRIVATE duplexT aliduplexfold_cu(const char *s1[], const char *s2[], int clean_up) {
  int i, j, s, n_seq, Emin=INF, i_min=0, j_min=0;
  char *struc;
  duplexT mfe;
  short **S1, **S2;
  int *type;
  vrna_md_t md;
  n1 = (int) strlen(s1[0]);
  n2 = (int) strlen(s2[0]);

  for (s=0; s1[s]!=NULL; s++);
  n_seq = s;
  for (s=0; s2[s]!=NULL; s++);
  if (n_seq != s) vrna_message_error("unequal number of sequences in aliduplexfold()\n");

  set_model_details(&md);
  if ((!P) || (fabs(P->temperature - temperature)>1e-6)) {
    if(P)
      free(P);
    P = vrna_params(&md);
    make_pair_matrix();
  }

  c = (int **) vrna_alloc(sizeof(int *) * (n1+1));
  for (i=1; i<=n1; i++) c[i] = (int *) vrna_alloc(sizeof(int) * (n2+1));

  S1 = (short **) vrna_alloc((n_seq+1)*sizeof(short *));
  S2 = (short **) vrna_alloc((n_seq+1)*sizeof(short *));
  for (s=0; s<n_seq; s++) {
    if (strlen(s1[s]) != n1) vrna_message_error("uneqal seqence lengths");
    if (strlen(s2[s]) != n2) vrna_message_error("uneqal seqence lengths");
    S1[s] = encode_sequence(s1[s], 0);
    S2[s] = encode_sequence(s2[s], 0);
  }
  type = (int *) vrna_alloc(n_seq*sizeof(int));

  for (i=1; i<=n1; i++) {
    for (j=n2; j>0; j--) {
      int k,l,E,psc;
      for (s=0; s<n_seq; s++) {
        type[s] = pair[S1[s][i]][S2[s][j]];
      }
      psc = covscore(type, n_seq);
      for (s=0; s<n_seq; s++) if (type[s]==0) type[s]=7;
      c[i][j] = (psc>=MINPSCORE) ? (n_seq*P->DuplexInit) : INF;
      if (psc<MINPSCORE) continue;
      for(s=0; s<n_seq;s++){
        c[i][j] += E_ExtLoop(type[s], (i>1) ? S1[s][i-1] : -1, (j<n2) ? S2[s][j+1] : -1, P);
      }
      for (k=i-1; k>0 && k>i-MAXLOOP-2; k--) {
        for (l=j+1; l<=n2; l++) {
          int type2;
          if (i-k+l-j-2>MAXLOOP) break;
          if (c[k][l]>INF/2) continue;
          for (E=s=0; s<n_seq; s++) {
            type2 = pair[S1[s][k]][S2[s][l]];
            if (type2==0) type2=7;
            E += E_IntLoop(i-k-1, l-j-1, type2, rtype[type[s]],
                           S1[s][k+1], S2[s][l-1], S1[s][i-1], S2[s][j+1], P);
          }
          c[i][j] = MIN2(c[i][j], c[k][l]+E);
        }
      }
      c[i][j] -= psc;
      E = c[i][j];
      for (s=0; s<n_seq; s++) {
        E += E_ExtLoop(rtype[type[s]], (j>1) ? S2[s][j-1] : -1, (i<n1) ? S1[s][i+1] : -1, P);
      }
      if (E<Emin) {
        Emin=E; i_min=i; j_min=j;
      }
    }
  }

  struc = alibacktrack(i_min, j_min, (const short **)S1,(const short **)S2);
  if (i_min<n1) i_min++;
  if (j_min>1 ) j_min--;

  mfe.i = i_min;
  mfe.j = j_min;
  mfe.energy = (float) (Emin/(100.*n_seq));
  mfe.structure = struc;
  if (clean_up){
    for (i=1; i<=n1; i++) free(c[i]);
    free(c);
  }
  for (s=0; s<n_seq; s++) {
    free(S1[s]); free(S2[s]);
  }
  free(S1);
  free(S2);
  free(type);
  return mfe;
}

PUBLIC duplexT *aliduplex_subopt(const char *s1[], const char *s2[], int delta, int w) {
  int i,j, n1, n2, thresh, E, n_subopt=0, n_max, s, n_seq, *type;
  char *struc;
  duplexT mfe;
  duplexT *subopt;
  short **S1, **S2;

  n_max=16;
  subopt = (duplexT *) vrna_alloc(n_max*sizeof(duplexT));
  mfe = aliduplexfold_cu(s1, s2, 0);
  free(mfe.structure);

  for (s=0; s1[s]!=NULL; s++);
  n_seq = s;

  thresh =  (int) ((mfe.energy*100. + delta)*n_seq +0.1);
  n1 = strlen(s1[0]); n2=strlen(s2[0]);
  S1 = (short **) vrna_alloc((n_seq+1)*sizeof(short *));
  S2 = (short **) vrna_alloc((n_seq+1)*sizeof(short *));
  for (s=0; s<n_seq; s++) {
    if (strlen(s1[s]) != n1) vrna_message_error("uneqal seqence lengths");
    if (strlen(s2[s]) != n2) vrna_message_error("uneqal seqence lengths");
    S1[s] = encode_sequence(s1[s], 0);
    S2[s] = encode_sequence(s2[s], 0);
  }
  type = (int *) vrna_alloc(n_seq*sizeof(int));

  for (i=n1; i>0; i--) {
    for (j=1; j<=n2; j++) {
      int ii, jj, skip, Ed, psc;

      for (s=0; s<n_seq; s++) {
        type[s] = pair[S2[s][j]][S1[s][i]];
      }
      psc = covscore(type, n_seq);
      for (s=0; s<n_seq; s++) if (type[s]==0) type[s]=7;
      if (psc<MINPSCORE) continue;
      E = Ed = c[i][j];
      for  (s=0; s<n_seq; s++) {
        Ed += E_ExtLoop(type[s], (j>1) ? S2[s][j-1] : -1, (i<n1) ? S1[s][i+1] : -1, P);
      }
      if (Ed>thresh) continue;
      /* too keep output small, skip hits that are dominated by a
         better one close (w) by. For simplicity we don't take dangels
         into account here, thus the heuristic is somewhat inaccurate.
      */
      for (skip=0, ii=MAX2(i-w,1); (ii<=MIN2(i+w,n1)) && type; ii++) {
        for (jj=MAX2(j-w,1); jj<=MIN2(j+w,n2); jj++)
          if (c[ii][jj]<E) {skip=1; break;}
      }
      if (skip) continue;
      struc = alibacktrack(i,j,(const short **)S1, (const short **)S2);
      fprintf(stderr, "%d %d %d\n", i,j,E);
      if (n_subopt+1>=n_max) {
        n_max *= 2;
        subopt = (duplexT *) vrna_realloc(subopt, n_max*sizeof(duplexT));
      }
      subopt[n_subopt].i = MIN2(i+1,n1);
      subopt[n_subopt].j = MAX2(j-1,1);
      subopt[n_subopt].energy = Ed * 0.01/n_seq;
      subopt[n_subopt++].structure = struc;
    }
  }

  for (i=1; i<=n1; i++) free(c[i]);
  free(c);
  for (s=0; s<n_seq; s++) {
    free(S1[s]); free(S2[s]);
  }
  free(S1); free(S2); free(type);

  if (subopt_sorted) qsort(subopt, n_subopt, sizeof(duplexT), compare);
  subopt[n_subopt].i =0;
  subopt[n_subopt].j =0;
  subopt[n_subopt].structure = NULL;
  return subopt;
}

PRIVATE char *alibacktrack(int i, int j, const short **S1, const short **S2) {
  /* backtrack structure going backwards from i, and forwards from j
     return structure in bracket notation with & as separator */
  int k, l, *type, type2, E, traced, i0, j0, s, n_seq;
  char *st1, *st2, *struc;

  n1 = (int) S1[0][0];
  n2 = (int) S2[0][0];

  for (s=0; S1[s]!=NULL; s++);
  n_seq = s;
  for (s=0; S2[s]!=NULL; s++);
  if (n_seq != s) vrna_message_error("unequal number of sequences in alibacktrack()\n");

  st1 = (char *) vrna_alloc(sizeof(char)*(n1+1));
  st2 = (char *) vrna_alloc(sizeof(char)*(n2+1));
  type = (int *) vrna_alloc(n_seq*sizeof(int));

  i0=MIN2(i+1,n1); j0=MAX2(j-1,1);

  while (i>0 && j<=n2) {
    int psc;
    E = c[i][j]; traced=0;
    st1[i-1] = '(';
    st2[j-1] = ')';
    for (s=0; s<n_seq; s++) {
      type[s] = pair[S1[s][i]][S2[s][j]];
    }
    psc = covscore(type, n_seq);
    for (s=0; s<n_seq; s++) if (type[s]==0) type[s] = 7;
    E += psc;
    for (k=i-1; k>0 && k>i-MAXLOOP-2; k--) {
      for (l=j+1; l<=n2; l++) {
        int LE;
        if (i-k+l-j-2>MAXLOOP) break;
        if (c[k][l]>INF/2) continue;
        for (s=LE=0; s<n_seq; s++) {
          type2 = pair[S1[s][k]][S2[s][l]];
          if (type2==0) type2=7;
          LE += E_IntLoop(i-k-1, l-j-1, type2, rtype[type[s]],
                           S1[s][k+1], S2[s][l-1], S1[s][i-1], S2[s][j+1], P);
        }
        if (E == c[k][l]+LE) {
          traced=1;
          i=k; j=l;
          break;
        }
      }
      if (traced) break;
    }
    if (!traced) {
      for (s=0; s<n_seq; s++) {
        E -= E_ExtLoop(type[s], (i>1) ? S1[s][i-1] : -1, (j<n2) ? S2[s][j+1] : -1, P);
      }
      if (E != n_seq*P->DuplexInit) {
        vrna_message_error("backtrack failed in aliduplex");
      } else break;
    }
  }
  if (i>1)  i--;
  if (j<n2) j++;

  struc = (char *) vrna_alloc(i0-i+1+j-j0+1+2);
  for (k=MAX2(i,1); k<=i0; k++) if (!st1[k-1]) st1[k-1] = '.';
  for (k=j0; k<=j; k++) if (!st2[k-1]) st2[k-1] = '.';
  strcpy(struc, st1+MAX2(i-1,0)); strcat(struc, "&");
  strcat(struc, st2+j0-1);

  /* printf("%s %3d,%-3d : %3d,%-3d\n", struc, i,i0,j0,j);  */
  free(st1); free(st2); free(type);

  return struc;
}


PRIVATE int covscore(const int *types, int n_seq) {
  /* calculate co-variance bonus for a pair depending on  */
  /* compensatory/consistent mutations and incompatible seqs */
  /* should be 0 for conserved pairs, >0 for good pairs      */
  int k,l,s,score, pscore;
  int dm[7][7]={{0,0,0,0,0,0,0}, /* hamming distance between pairs */
                {0,0,2,2,1,2,2} /* CG */,
                {0,2,0,1,2,2,2} /* GC */,
                {0,2,1,0,2,1,2} /* GU */,
                {0,1,2,2,0,2,1} /* UG */,
                {0,2,2,1,2,0,2} /* AU */,
                {0,2,2,2,1,2,0} /* UA */};

  int pfreq[8]={0,0,0,0,0,0,0,0};
  for (s=0; s<n_seq; s++)
    pfreq[types[s]]++;

  if (pfreq[0]*2>n_seq) return NONE;
  for (k=1,score=0; k<=6; k++) /* ignore pairtype 7 (gap-gap) */
    for (l=k+1; l<=6; l++)
      /* scores for replacements between pairtypes    */
      /* consistent or compensatory mutations score 1 or 2  */
      score += pfreq[k]*pfreq[l]*dm[k][l];

  /* counter examples score -1, gap-gap scores -0.25   */
  pscore = cv_fact *
    ((UNIT*score)/n_seq - nc_fact*UNIT*(pfreq[0] + pfreq[7]*0.25));
  return pscore;
}
alifold.c/      0           0     0     644     5993      `
/*
                  minimum free energy folding
                  for a set of aligned sequences

                  c Ivo Hofacker

                  Vienna RNA package
*/

/**
*** \file alifold.c
**/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>

#include "fold_vars.h"
#include "data_structures.h"
#include "mfe.h"
#include "fold.h"
#include "eval.h"
#include "utils.h"
#include "energy_par.h"
#include "params.h"
#include "ribo.h"
#include "gquad.h"
#include "alifold.h"
#include "aln_util.h"
#include "loop_energies.h"

#ifdef _OPENMP
#include <omp.h>
#endif

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/

/* some backward compatibility stuff */
PRIVATE vrna_fold_compound_t  *backward_compat_compound = NULL;
PRIVATE int                 backward_compat           = 0;

#ifdef _OPENMP

#pragma omp threadprivate(backward_compat_compound, backward_compat)

#endif

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/

PRIVATE float   wrap_alifold( const char **strings,
                              char *structure,
                              vrna_param_t *parameters,
                              int is_constrained,
                              int is_circular);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PUBLIC float
vrna_alifold( const char **strings,
              char *structure){

  float                 mfe;
  vrna_fold_compound_t  *vc;
  vrna_md_t             md;

  vrna_md_set_default(&md);

  vc  = vrna_fold_compound_comparative(strings, &md, VRNA_OPTION_DEFAULT);
  mfe = vrna_mfe(vc, structure);

  vrna_fold_compound_free(vc);

  return mfe;
}

PUBLIC float
vrna_circalifold( const char **sequences,
                  char *structure){

  float                 mfe;
  vrna_fold_compound_t  *vc;
  vrna_md_t             md;

  vrna_md_set_default(&md);
  md.circ = 1;

  vc  = vrna_fold_compound_comparative(sequences, &md, VRNA_OPTION_DEFAULT);
  mfe = vrna_mfe(vc, structure);

  vrna_fold_compound_free(vc);

  return mfe;
}


PRIVATE float
wrap_alifold( const char **strings,
              char *structure,
              vrna_param_t *parameters,
              int is_constrained,
              int is_circular){

  vrna_fold_compound_t  *vc;
  vrna_param_t        *P;

#ifdef _OPENMP
/* Explicitly turn off dynamic threads */
  omp_set_dynamic(0);
#endif

  /* we need the parameter structure for hard constraints */
  if(parameters){
    P = vrna_params_copy(parameters);
  } else {
    vrna_md_t md;
    set_model_details(&md);
    md.temperature = temperature;
    P = vrna_params(&md);
  }
  P->model_details.circ = is_circular;

  vc = vrna_fold_compound_comparative(strings, &(P->model_details), VRNA_OPTION_DEFAULT);

  if(parameters){ /* replace params if necessary */
    free(vc->params);
    vc->params = P;
  } else {
    free(P);
  }

  /* handle hard constraints in pseudo dot-bracket format if passed via simple interface */
  if(is_constrained && structure)
    vrna_constraints_add(vc, (const char *)structure, VRNA_CONSTRAINT_DB_DEFAULT);

  if(backward_compat_compound && backward_compat)
    vrna_fold_compound_free(backward_compat_compound);

  backward_compat_compound  = vc;
  backward_compat           = 1;

  return vrna_mfe(vc, structure);
}


/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/

#ifdef  VRNA_BACKWARD_COMPAT

PUBLIC void
free_alifold_arrays(void){

  if(backward_compat_compound && backward_compat){
    vrna_fold_compound_free(backward_compat_compound);
    backward_compat_compound  = NULL;
    backward_compat           = 0;
  }
}

PUBLIC float
alifold(const char **strings,
        char *structure){

  return wrap_alifold(strings, structure, NULL, fold_constrained, 0);
}

PUBLIC float circalifold( const char **strings,
                          char *structure) {

  return wrap_alifold(strings, structure, NULL, fold_constrained, 1);
}

PUBLIC void 
update_alifold_params(void){

  vrna_fold_compound_t *v;

  if(backward_compat_compound && backward_compat){
    v = backward_compat_compound;

    if(v->params)
      free(v->params);

    vrna_md_t md;
    set_model_details(&md);
    v->params = vrna_params(&md);
  }
}

PUBLIC float
energy_of_ali_gquad_structure(const char **sequences,
                              const char *structure,
                              int n_seq,
                              float *energy){

  unsigned int  n;
  short         *pt;
  int           *loop_idx;

  if(sequences[0] != NULL){
    
    vrna_fold_compound_t  *vc;

    vrna_md_t md;
    set_model_details(&md);
    md.gquad = 1;

    vc = vrna_fold_compound_comparative(sequences, &md, VRNA_OPTION_EVAL_ONLY);

    energy[0] = vrna_eval_structure(vc, structure);
    energy[1] = vrna_eval_covar_structure(vc, structure);

    vrna_fold_compound_free(vc);
  }
  else vrna_message_error("energy_of_alistruct(): no sequences in alignment!");

  return energy[0];

}

PUBLIC  float
energy_of_alistruct(const char **sequences,
                    const char *structure,
                    int n_seq,
                    float *energy){

  short         *pt;

  if(sequences[0] != NULL){
    vrna_fold_compound_t  *vc;

    vrna_md_t md;
    set_model_details(&md);

    vc = vrna_fold_compound_comparative(sequences, &md, VRNA_OPTION_EVAL_ONLY);

    energy[0] = vrna_eval_structure(vc, structure);
    energy[1] = vrna_eval_covar_structure(vc, structure);

    vrna_fold_compound_free(vc);
  }
  else vrna_message_error("energy_of_alistruct(): no sequences in alignment!");

  return energy[0];
}

#endif

alipfold.c/     0           0     0     644     9530      `
/*
                  partiton function and base pair probabilities
                  for RNA secvondary structures
                  of a set of aligned sequences

                  Ivo L Hofacker
                  Vienna RNA package
*/

/**
*** \file alipfold.c
**/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <float.h>    /* #defines FLT_MIN */
#include <limits.h>

#include "utils.h"
#include "energy_par.h"
#include "fold_vars.h"
#include "PS_dot.h"
#include "ribo.h"
#include "params.h"
#include "loop_energies.h"
#include "eval.h"
#include "mfe.h"
#include "part_func.h"
#include "structure_utils.h"
#include "alifold.h"

#ifdef _OPENMP
#include <omp.h>
#endif

/*
#################################
# PUBLIC GLOBAL VARIABLES       #
#################################
*/

/*
#################################
# PRIVATE GLOBAL VARIABLES      #
#################################
*/

/* some backward compatibility stuff */
PRIVATE vrna_fold_compound_t  *backward_compat_compound = NULL;
PRIVATE int                   backward_compat           = 0;

#ifdef _OPENMP

#pragma omp threadprivate(backward_compat_compound, backward_compat)

#endif

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/

PRIVATE float     wrap_alipf_fold(const char **sequences,
                                  char *structure,
                                  plist **pl,
                                  vrna_exp_param_t *parameters,
                                  int calculate_bppm,
                                  int is_constrained,
                                  int is_circular);



/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PUBLIC float
vrna_pf_alifold(const char **strings,
                char *structure,
                vrna_plist_t **pl){

  float                 free_energy;
  double                mfe;
  vrna_fold_compound_t  *vc;
  vrna_md_t             md;

  vrna_md_set_default(&md);

  /* no need to backtrack MFE structure */
  md.backtrack = 0;

  if(!pl){ /* no need for pair probability computations if we do not store them somewhere */
    md.compute_bpp = 0;
  }

  vc  = vrna_fold_compound_comparative(strings, &md, VRNA_OPTION_DEFAULT);
  mfe = (double)vrna_pf(vc, structure);
  vrna_exp_params_rescale(vc, &mfe);
  free_energy = vrna_pf(vc, structure);

  /* fill plist */
  if(pl){
    *pl = vrna_plist_from_probs(vc, /*cut_off:*/ 1e-6);
  }

  vrna_fold_compound_free(vc);

  return free_energy;
}

PUBLIC float
vrna_pf_circalifold(const char **sequences,
                    char *structure,
                    vrna_plist_t **pl){

  float                 free_energy;
  double                mfe;
  vrna_fold_compound_t  *vc;
  vrna_md_t             md;

  vrna_md_set_default(&md);
  md.circ = 1;

  /* no need to backtrack MFE structure */
  md.backtrack = 0;

  if(!pl){ /* no need for pair probability computations if we do not store them somewhere */
    md.compute_bpp = 0;
  }

  vc  = vrna_fold_compound_comparative(sequences, &md, VRNA_OPTION_DEFAULT);
  mfe = (double)vrna_mfe(vc, structure);
  vrna_exp_params_rescale(vc, &mfe);
  free_energy = vrna_pf(vc, structure);

  /* fill plist */
  if(pl){
    *pl = vrna_plist_from_probs(vc, /*cut_off:*/ 1e-6);
  }

  vrna_fold_compound_free(vc);

  return free_energy;
}



/*-----------------------------------------------------------------*/
PRIVATE float
wrap_alipf_fold(const char **sequences,
                char *structure,
                plist **pl,
                vrna_exp_param_t *parameters,
                int calculate_bppm,
                int is_constrained,
                int is_circular){

  int                 n_seq;
  float               free_energy;
  vrna_fold_compound_t  *vc;
  vrna_exp_param_t    *exp_params;

  if(sequences == NULL) return 0.;

  for(n_seq=0;sequences[n_seq];n_seq++); /* count the sequences */
  
  vc                  = NULL;

  /* we need vrna_exp_param_t datastructure to correctly init default hard constraints */
  if(parameters)
    exp_params = vrna_exp_params_copy(parameters);
  else{
    vrna_md_t md;
    set_model_details(&md); /* get global default parameters */
    exp_params = vrna_exp_params_comparative(n_seq, &md);
  }
  exp_params->model_details.circ        = is_circular;
  exp_params->model_details.compute_bpp = calculate_bppm;

  vc = vrna_fold_compound_comparative(sequences, &(exp_params->model_details), VRNA_OPTION_PF);

  if(parameters){ /* replace exp_params if necessary */
    free(vc->exp_params);
    vc->exp_params = exp_params;
  } else {
    free(exp_params);
  }
  vc->exp_params->pf_scale = pf_scale;

  if(is_constrained && structure){
    unsigned int constraint_options = 0;
    constraint_options |= VRNA_CONSTRAINT_DB
                          | VRNA_CONSTRAINT_DB_PIPE
                          | VRNA_CONSTRAINT_DB_DOT
                          | VRNA_CONSTRAINT_DB_X
                          | VRNA_CONSTRAINT_DB_ANG_BRACK
                          | VRNA_CONSTRAINT_DB_RND_BRACK;

    vrna_constraints_add(vc, (const char *)structure, constraint_options);
  }

  if(backward_compat_compound && backward_compat_compound)
    vrna_fold_compound_free(backward_compat_compound);

  backward_compat_compound  = vc;
  iindx                     = backward_compat_compound->iindx;
  backward_compat           = 1;

  free_energy = vrna_pf(vc, structure);
  
  /* fill plist */
  if(pl && calculate_bppm){
    *pl = vrna_plist_from_probs(vc, /*cut_off:*/ 1e-6);
  }

  return free_energy;
}

/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/

PUBLIC float
alipf_fold( const char **sequences,
                  char *structure,
                  plist **pl){

  return wrap_alipf_fold(sequences, structure, pl, NULL, do_backtrack, fold_constrained, 0);
}

PUBLIC float
alipf_circ_fold(const char **sequences,
                      char *structure,
                      plist **pl){

  return wrap_alipf_fold(sequences, structure, pl, NULL, do_backtrack, fold_constrained, 1);
}

PUBLIC float
alipf_fold_par( const char **sequences,
                char *structure,
                plist **pl,
                vrna_exp_param_t *parameters,
                int calculate_bppm,
                int is_constrained,
                int is_circular){

  return wrap_alipf_fold(sequences, structure, pl, parameters, calculate_bppm, is_constrained, is_circular);
}

PUBLIC FLT_OR_DBL *
alipf_export_bppm(void){

  if(backward_compat_compound)
    if(backward_compat_compound->exp_matrices)
      if(backward_compat_compound->exp_matrices->probs)
        return backward_compat_compound->exp_matrices->probs;

  return NULL;
}

PUBLIC FLT_OR_DBL *
export_ali_bppm(void){

  if(backward_compat_compound)
    if(backward_compat_compound->exp_matrices)
      if(backward_compat_compound->exp_matrices->probs)
        return backward_compat_compound->exp_matrices->probs;

  return NULL;
}

/*brauch ma nurnoch pscores!*/
PUBLIC char *
alipbacktrack(double *prob){

  if(backward_compat_compound)
    if(backward_compat_compound->exp_matrices){
      vrna_exp_param_t *params = backward_compat_compound->exp_params;
      int n     = backward_compat_compound->length;
      int n_seq = backward_compat_compound->n_seq;
      int *idx  = backward_compat_compound->iindx;
      double Q  = (double)backward_compat_compound->exp_matrices->q[idx[1]-n];
      char *s   = vrna_pbacktrack(backward_compat_compound);
      double e  = (double)vrna_eval_structure(backward_compat_compound, s);
      e        -= (double)vrna_eval_covar_structure(backward_compat_compound, s);
      double fe = (-log(Q)-n*log(params->pf_scale))*params->kT/(1000.0 * n_seq);
      *prob     = exp((fe - e)/params->kT);
      return s;
    }
  return NULL;
}

/*-------------------------------------------------------------------------*/
/* make arrays used for alipf_fold available to other routines */
PUBLIC int
get_alipf_arrays( short ***S_p,
                  short ***S5_p,
                  short ***S3_p,
                  unsigned short ***a2s_p,
                  char ***Ss_p,
                  FLT_OR_DBL **qb_p,
                  FLT_OR_DBL **qm_p,
                  FLT_OR_DBL **q1k_p,
                  FLT_OR_DBL **qln_p,
                  short **pscore_p) {

  if(backward_compat_compound){
    if(backward_compat_compound->exp_matrices)
      if(backward_compat_compound->exp_matrices->qb){
        *S_p      = backward_compat_compound->S;
        *S5_p     = backward_compat_compound->S5;
        *S3_p     = backward_compat_compound->S3;
        *a2s_p    = backward_compat_compound->a2s;
        *Ss_p     = backward_compat_compound->Ss;
        *qb_p     = backward_compat_compound->exp_matrices->qb;
        *qm_p     = backward_compat_compound->exp_matrices->qm;
        *q1k_p    = backward_compat_compound->exp_matrices->q1k;
        *qln_p    = backward_compat_compound->exp_matrices->qln;
        *pscore_p = backward_compat_compound->pscore_pf_compat;
        return 1;
      }
  }
  return 0;
}

PUBLIC void
free_alipf_arrays(void){

  if(backward_compat_compound && backward_compat){
    vrna_fold_compound_free(backward_compat_compound);
    backward_compat_compound  = NULL;
    backward_compat           = 0;
    iindx                     = NULL;
  }
}
aln_util.c/     0           0     0     644     12207     `
/*
                               aln_util.c
               Helper functions frelated to alignments
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <time.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

#include "utils.h"
#include "fold_vars.h"
#include "pair_mat.h"
#include "aln_util.h"

#define MAX_NUM_NAMES    500
int read_clustal(FILE *clust, char *AlignedSeqs[], char *names[]) {
   char *line, name[100]="", *seq;
   int  n, nn=0, num_seq = 0, i;

   if ((line=get_line(clust)) == NULL) {
     fprintf(stderr, "Empty CLUSTAL file\n"); return 0;
   }

   if ((strncmp(line,"CLUSTAL", 7) !=0) && (!strstr(line,"STOCKHOLM"))) {
     fprintf(stderr, "This doesn't look like a CLUSTAL/STOCKHOLM file, sorry\n");
     free(line); return 0;
   }
   free(line);
   line = get_line(clust);

   while (line!=NULL) {
    if(strncmp(line, "//", 2) == 0){
      free(line);
      break;
    }

    if (((n=strlen(line))<4) || isspace((int)line[0])) {
      /* skip non-sequence line */
      free(line); line = get_line(clust);
      nn=0; /* reset seqence number */
      continue;
    }
    /* skip comments */
    if(line[0] == '#'){
      free(line);
      line = get_line(clust);
      continue;
    }

     seq = (char *) vrna_alloc( (n+1)*sizeof(char) );
     sscanf(line,"%99s %s", name, seq);

    for(i=0;i<strlen(seq);i++){
      if(seq[i] == '.') seq[i] = '-'; /* replace '.' gaps by '-' */
      /* comment the next line and think about something more difficult to deal with
         lowercase sequence letters if you really want to */
      seq[i] = toupper(seq[i]);
    }

     if (nn == num_seq) { /* first time */
       names[nn] = strdup(name);
       AlignedSeqs[nn] = strdup(seq);
     }
     else {
       if (strcmp(name, names[nn])!=0) {
         /* name doesn't match */
         fprintf(stderr,
                 "Sorry, your file is messed up (inconsitent seq-names)\n");
         free(line); free(seq);
         return 0;
       }
       AlignedSeqs[nn] = (char *)
         vrna_realloc(AlignedSeqs[nn], strlen(seq)+strlen(AlignedSeqs[nn])+1);
       strcat(AlignedSeqs[nn], seq);
     }
     nn++;
     if (nn>num_seq) num_seq = nn;
     free(seq);
     free(line);
     if (num_seq>=MAX_NUM_NAMES) {
       fprintf(stderr, "Too many sequences in CLUSTAL/STOCKHOLM file");
       return 0;
     }

     line = get_line(clust);
   }

   AlignedSeqs[num_seq] = NULL;
   names[num_seq] = NULL;
   if (num_seq == 0) {
     fprintf(stderr, "No sequences found in CLUSTAL/STOCKHOLM file\n");
     return 0;
   }
   n = strlen(AlignedSeqs[0]);
   for (nn=1; nn<num_seq; nn++) {
     if (strlen(AlignedSeqs[nn])!=n) {
       fprintf(stderr, "Sorry, your file is messed up.\n"
               "Unequal lengths!\n\n");
       return 0;
     }
   }

   fprintf(stderr, "%d sequences; length of alignment %d.\n", nn, n);
   return num_seq;
}

char *consensus(const char *AS[]) {
  /* simple consensus sequence (most frequent character) */
  char *string;
  int i,n;
  n = strlen(AS[0]);
  string = (char *) vrna_alloc((n+1)*sizeof(char));
  for (i=0; i<n; i++) {
    int s,c,fm, freq[8] = {0,0,0,0,0,0,0,0};
    for (s=0; AS[s]!=NULL; s++)
      freq[encode_char(AS[s][i])]++;
    for (s=c=fm=0; s<8; s++) /* find the most frequent char */
      if (freq[s]>fm) {c=s, fm=freq[c];}
    if (s>4) s++; /* skip T */
    string[i]=Law_and_Order[c];
  }
  return string;
}

/* IUP nucleotide classes indexed by a bit string of the present bases */
/* A C AC G AG CG ACG U AU CU ACU GU AGU CGU ACGU */
static char IUP[17] = "-ACMGRSVUWYHKDBN";
char *consens_mis(const char*AS[]) {
  /* MIS displays the 'most informative sequence' (Freyhult et al 2004),
     elements in columns with frequency greater than the background
     frequency are projected into iupac notation. Columns where gaps are
     over-represented are in lower case. */

  char *cons;
  int i, s, n, N, c;
  int bgfreq[8] = {0,0,0,0,0,0,0,0};

  n = strlen(AS[0]);
  for (N=0; AS[N]!=NULL; N++);
  cons = (char *) vrna_alloc((n+1)*sizeof(char));

  for (i=0; i<n; i++)
    for (s=0; s<N; s++) {
      c = encode_char(AS[s][i]);
      if (c>4) c=5;
      bgfreq[c]++;
    }

  for (i=0; i<n; i++) {
    int freq[8] = {0,0,0,0,0,0,0,0};
    int code = 0;
    for (s=0; s<N; s++) {
      c = encode_char(AS[s][i]);
      if (c>4) c=5;
      freq[c]++;
    }
    for (c=4; c>0; c--) {
      code <<=1;
      if (freq[c]*n>=bgfreq[c]) code++;
    }
    cons[i] = IUP[code];
    if (freq[0]*n>bgfreq[0])
      cons[i] = tolower(IUP[code]);
  }
  return cons;
}

PUBLIC char *
get_ungapped_sequence(const char *seq){

  char  *tmp_sequence, *b;
  int   i;

  tmp_sequence = strdup(seq);

  b = tmp_sequence;
  i = 0;
  do{
    if((*b=='-')||(*b=='_')||(*b=='~')||(*b=='.')) continue;
    tmp_sequence[i] = *b;
    i++;
  }while(*(++b));

  tmp_sequence = (char *)vrna_realloc(tmp_sequence, (i+1)*sizeof(char));
  tmp_sequence[i] = '\0';

  return tmp_sequence;
}

PUBLIC int
vrna_aln_mpi( char *Alseq[],
              int n_seq,
              int length,
              int *mini){

  int   i, j, k, pairnum = 0, sumident = 0;
  float ident = 0, minimum = 1.;

  for(j=0; j<n_seq-1; j++)
    for(k=j+1; k<n_seq; k++) {
      ident=0;
      for (i=1; i<=length; i++){
        if (Alseq[k][i]==Alseq[j][i]) ident++;
        pairnum++;
      }
      if ((ident/length)<minimum) minimum=ident/(float)length;
      sumident+=ident;
    }
  mini[0]=(int)(minimum*100.);
  if (pairnum>0)   return (int) (sumident*100/pairnum);
  else return 0;

}

/*---------------------------------------------------------------------------*/
PRIVATE int
compare_pinfo(const void *pi1,
              const void *pi2){

  vrna_pinfo_t *p1, *p2;
  int  i, nc1, nc2;
  p1 = (vrna_pinfo_t *)pi1;  p2 = (vrna_pinfo_t *)pi2;
  for (nc1=nc2=0, i=1; i<=6; i++) {
    if (p1->bp[i]>0) nc1++;
    if (p2->bp[i]>0) nc2++;
  }
  /* sort mostly by probability, add
     epsilon * comp_mutations/(non-compatible+1) to break ties */
  return (p1->p + 0.01*nc1/(p1->bp[0]+1.)) <
         (p2->p + 0.01*nc2/(p2->bp[0]+1.)) ? 1 : -1;
}

PUBLIC vrna_pinfo_t *
vrna_aln_pinfo( vrna_fold_compound_t *vc,
                const char *structure,
                double threshold){

  int i,j, num_p=0, max_p = 64;
  vrna_pinfo_t *pi;
  double *duck, p;
  short *ptable = NULL;

  short **S = vc->S;
  char **AS = vc->sequences;
  int n_seq = vc->n_seq;
  int n     = vc->length;
  int         *my_iindx = vc->iindx;
  FLT_OR_DBL  *probs    = vc->exp_matrices->probs;
  vrna_md_t   *md = &(vc->exp_params->model_details);

  max_p = 64; pi = vrna_alloc(max_p*sizeof(vrna_pinfo_t));
  duck =  (double *) vrna_alloc((n+1)*sizeof(double));
  if(structure)
    ptable = vrna_ptable(structure);

  for (i=1; i<n; i++)
    for (j=i+TURN+1; j<=n; j++) {
      if ((p=probs[my_iindx[i]-j])>=threshold) {
        duck[i] -=  p * log(p);
        duck[j] -=  p * log(p);

        int type, s;
        pi[num_p].i   = i;
        pi[num_p].j   = j;
        pi[num_p].p   = p;
        pi[num_p].ent = duck[i]+duck[j]-p*log(p);

        for (type=0; type<8; type++) pi[num_p].bp[type]=0;
        for (s=0; s<n_seq; s++) {
          type = md->pair[S[s][i]][S[s][j]];
          if(S[s][i]==0 && S[s][j]==0) type = 7; /* gap-gap  */
          if ((AS[s][i-1] == '-')||(AS[s][j-1] == '-')) type = 7;
          if ((AS[s][i-1] == '~')||(AS[s][j-1] == '~')) type = 7;
          pi[num_p].bp[type]++;
        }
        if(ptable)
          pi[num_p].comp = (ptable[i] == j) ? 1:0;

        num_p++;
        if (num_p>=max_p) {
          max_p *= 2;
          pi = vrna_realloc(pi, max_p * sizeof(vrna_pinfo_t));
        }
      }
    }
  free(duck);
  pi = vrna_realloc(pi, (num_p+1)*sizeof(vrna_pinfo_t));
  pi[num_p].i=0;
  qsort(pi, num_p, sizeof(vrna_pinfo_t), compare_pinfo );

  free(ptable);
  return pi;
}

/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/

PUBLIC int
get_mpi(char *Alseq[],
        int n_seq,
        int length,
        int *mini){

  return vrna_aln_mpi(Alseq, n_seq, length, mini);
}

PUBLIC void
alloc_sequence_arrays(const char **sequences,
                      short ***S,
                      short ***S5,
                      short ***S3,
                      unsigned short ***a2s,
                      char ***Ss,
                      int circ){

  unsigned int s, n_seq, length;
  if(sequences[0] != NULL){
    length = strlen(sequences[0]);
    for (s=0; sequences[s] != NULL; s++);
    n_seq = s;
    *S    = (short **)          vrna_alloc((n_seq+1) * sizeof(short *));
    *S5   = (short **)          vrna_alloc((n_seq+1) * sizeof(short *));
    *S3   = (short **)          vrna_alloc((n_seq+1) * sizeof(short *));
    *a2s  = (unsigned short **) vrna_alloc((n_seq+1) * sizeof(unsigned short *));
    *Ss   = (char **)           vrna_alloc((n_seq+1) * sizeof(char *));
    for (s=0; s<n_seq; s++) {
      if(strlen(sequences[s]) != length) vrna_message_error("uneqal seqence lengths");
      (*S5)[s]  = (short *)         vrna_alloc((length + 2) * sizeof(short));
      (*S3)[s]  = (short *)         vrna_alloc((length + 2) * sizeof(short));
      (*a2s)[s] = (unsigned short *)vrna_alloc((length + 2) * sizeof(unsigned short));
      (*Ss)[s]  = (char *)          vrna_alloc((length + 2) * sizeof(char));
      (*S)[s]   = (short *)         vrna_alloc((length + 2) * sizeof(short));
      encode_ali_sequence(sequences[s], (*S)[s], (*S5)[s], (*S3)[s], (*Ss)[s], (*a2s)[s], circ);
    }
    (*S5)[n_seq]  = NULL;
    (*S3)[n_seq]  = NULL;
    (*a2s)[n_seq] = NULL;
    (*Ss)[n_seq]  = NULL;
    (*S)[n_seq]   = NULL;
  }
  else vrna_message_error("alloc_sequence_arrays: no sequences in the alignment!");
}

PUBLIC void
free_sequence_arrays( unsigned int n_seq,
                      short ***S,
                      short ***S5,
                      short ***S3,
                      unsigned short ***a2s,
                      char ***Ss){

  unsigned int s;
  for (s=0; s<n_seq; s++) {
    free((*S)[s]);
    free((*S5)[s]);
    free((*S3)[s]);
    free((*a2s)[s]);
    free((*Ss)[s]);
  }
  free(*S);   *S    = NULL;
  free(*S5);  *S5   = NULL;
  free(*S3);  *S3   = NULL;
  free(*a2s); *a2s  = NULL;
  free(*Ss);  *Ss   = NULL;
}

PUBLIC void
encode_ali_sequence(const char *sequence,
                    short *S,
                    short *s5,
                    short *s3,
                    char *ss,
                    unsigned short *as,
                    int circular){

  unsigned int i,l;
  unsigned short p;
  l     = strlen(sequence);
  S[0]  = (short) l;
  s5[0] = s5[1] = 0;

  /* make numerical encoding of sequence */
  for(i=1; i<=l; i++){
    short ctemp;
    ctemp=(short) encode_char(toupper(sequence[i-1]));
    S[i]= ctemp ;
  }

  if (oldAliEn){
    /* use alignment sequences in all energy evaluations */
    ss[0]=sequence[0];
    for(i=1; i<l; i++){
      s5[i] = S[i-1];
      s3[i] = S[i+1];
      ss[i] = sequence[i];
      as[i] = i;
    }
    ss[l]   = sequence[l];
    as[l]   = l;
    s5[l]   = S[l-1];
    s3[l]   = 0;
    S[l+1]  = S[1];
    s5[1]   = 0;
    if (circular) {
      s5[1]   = S[l];
      s3[l]   = S[1];
      ss[l+1] = S[1];
    }
  }
  else{
    if(circular){
      for(i=l; i>0; i--){
        char c5;
        c5 = sequence[i-1];
        if ((c5=='-')||(c5=='_')||(c5=='~')||(c5=='.')) continue;
        s5[1] = S[i];
        break;
      }
      for (i=1; i<=l; i++) {
        char c3;
        c3 = sequence[i-1];
        if ((c3=='-')||(c3=='_')||(c3=='~')||(c3=='.')) continue;
        s3[l] = S[i];
        break;
      }
    }
    else  s5[1]=s3[l]=0;

    for(i=1,p=0; i<=l; i++){
      char c5;
      c5 = sequence[i-1];
      if ((c5=='-')||(c5=='_')||(c5=='~')||(c5=='.'))
        s5[i+1]=s5[i];
      else { /* no gap */
        ss[p++]=sequence[i-1]; /*start at 0!!*/
        s5[i+1]=S[i];
      }
      as[i]=p;
    }
    for (i=l; i>=1; i--) {
      char c3;
      c3 = sequence[i-1];
      if ((c3=='-')||(c3=='_')||(c3=='~')||(c3=='.'))
        s3[i-1]=s3[i];
      else
        s3[i-1]=S[i];
    }
  }
}


LPfold.c/       0           0     0     644     46001     `
/*
  local pair probabilities for RNA secondary structures

  Stephan Bernhart, Ivo L Hofacker
  Vienna RNA package
*/
/*
  todo: compute energy z-score for each window

*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <float.h>    /* #defines FLT_MAX ... */
#include "utils.h"
#include "energy_par.h"
#include "fold_vars.h"
#include "pair_mat.h"
#include "PS_dot.h"
#include "part_func.h"
#include "params.h"
#include "loop_energies.h"
#include "LPfold.h"
#include "Lfold.h"

#ifdef _OPENMP
#include <omp.h>
#endif


#define ISOLATED  256.0

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/

PRIVATE float       cutoff;
PRIVATE int         num_p=0; /* for counting basepairs in pairlist pl, can actually be moved into pfl_fold */
PRIVATE FLT_OR_DBL  *expMLbase=NULL;
PRIVATE FLT_OR_DBL  **q=NULL, **qb=NULL, **qm=NULL, *qqm=NULL, *qqm1=NULL, *qq=NULL, *qq1=NULL, **pR=NULL, **qm2=NULL, **QI5=NULL,  **q2l=NULL, **qmb=NULL;/*,**QI3,*/
PRIVATE FLT_OR_DBL  *prml=NULL, *prm_l=NULL, *prm_l1=NULL, *q1k=NULL, *qln=NULL;
PRIVATE FLT_OR_DBL  *scale=NULL;
PRIVATE char        **ptype=NULL; /* precomputed array of pair types */
PRIVATE int         *jindx=NULL;
PRIVATE int         *my_iindx=NULL;
PRIVATE vrna_exp_param_t   *pf_params=NULL;
PRIVATE short       *S=NULL, *S1=NULL;
PRIVATE int         ulength;
PRIVATE int         pUoutput;
PRIVATE double      alpha = 1.0;

#ifdef _OPENMP

/* NOTE: all variables are assumed to be uninitialized if they are declared as threadprivate
*/
#pragma omp threadprivate(cutoff, num_p, scale, ptype, jindx, my_iindx, pf_params,\
                          expMLbase, q, qb, qm, qqm, qqm1, qq, qq1, pR, qm2, QI5, q2l, qmb,\
                          prml, prm_l, prm_l1, q1k, qln,\
                          S, S1, ulength, pUoutput, alpha)

#endif

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/

PRIVATE void  init_partfunc_L(int length, vrna_exp_param_t *parameters);
PRIVATE void  get_arrays_L(unsigned int length);
PRIVATE void  free_pf_arrays_L(void);
PRIVATE void  scale_pf_params(unsigned int length, vrna_exp_param_t *parameters);
PRIVATE void  GetPtype(int j, int pairsize, const short *S, int n);
PRIVATE void  FreeOldArrays(int i);
PRIVATE void  GetNewArrays(int j, int winSize);
PRIVATE void  printpbar(FLT_OR_DBL **prb,int winSize, int i, int n);
PRIVATE plist *get_deppp(plist *pl, int start, int pairsize, int length);
PRIVATE plist *get_plistW(plist *pl, int length, int start, FLT_OR_DBL **Tpr, int winSize);
PRIVATE void  print_plist(int length, int start, FLT_OR_DBL **Tpr, int winSize, FILE *fp);
PRIVATE void  compute_pU(int k, int ulength, double **pU, int winSize, int n, char *sequence);
PRIVATE void  putoutpU(double **pU,int k, int ulength, FILE *fp);
/*PRIVATE void make_ptypes(const short *S, const char *structure);*/

PRIVATE void putoutpU_splitup(double **pUx, int k, int ulength, FILE *fp, char ident);
PRIVATE void compute_pU_splitup(int k, int ulength, double **pU,  double **pUO, double **pUH, double **pUI, double **pUM, int winSize,int n, char *sequence);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PRIVATE void init_partfunc_L(int length, vrna_exp_param_t *parameters){
  if (length<1) vrna_message_error("init_partfunc_L: length must be greater 0");
#ifdef _OPENMP
/* Explicitly turn off dynamic threads */
  omp_set_dynamic(0);
  free_pf_arrays_L(); /* free previous allocation */
#else
  free_pf_arrays_L(); /* free previous allocation */
#endif

#ifdef SUN4
  nonstandard_arithmetic();
#else
#ifdef HP9
  fpsetfastmode(1);
#endif
#endif
  make_pair_matrix();
  get_arrays_L((unsigned) length);
  scale_pf_params((unsigned) length, parameters);

}

PRIVATE void get_arrays_L(unsigned int length){
  /*arrays in 2 dimensions*/

  q         = (FLT_OR_DBL **) vrna_alloc(sizeof(FLT_OR_DBL *)*(length+1));
  qb        = (FLT_OR_DBL **) vrna_alloc(sizeof(FLT_OR_DBL *)*(length+1));
  qm        = (FLT_OR_DBL **) vrna_alloc(sizeof(FLT_OR_DBL *)*(length+1));
  pR        = (FLT_OR_DBL **) vrna_alloc(sizeof(FLT_OR_DBL *)*(length+1));
  q1k       = (FLT_OR_DBL *)  vrna_alloc(sizeof(FLT_OR_DBL)  *(length+1));
  qln       = (FLT_OR_DBL *)  vrna_alloc(sizeof(FLT_OR_DBL)  *(length+2));
  qq        = (FLT_OR_DBL *)  vrna_alloc(sizeof(FLT_OR_DBL)  *(length+2));
  qq1       = (FLT_OR_DBL *)  vrna_alloc(sizeof(FLT_OR_DBL)  *(length+2));
  qqm       = (FLT_OR_DBL *)  vrna_alloc(sizeof(FLT_OR_DBL)  *(length+2));
  qqm1      = (FLT_OR_DBL *)  vrna_alloc(sizeof(FLT_OR_DBL)  *(length+2));
  prm_l     = (FLT_OR_DBL *)  vrna_alloc(sizeof(FLT_OR_DBL)  *(length+2));
  prm_l1    = (FLT_OR_DBL *)  vrna_alloc(sizeof(FLT_OR_DBL)  *(length+2));
  prml      = (FLT_OR_DBL *)  vrna_alloc(sizeof(FLT_OR_DBL)  *(length+2));
  expMLbase = (FLT_OR_DBL *)  vrna_alloc(sizeof(FLT_OR_DBL)  *(length+1));
  scale     = (FLT_OR_DBL *)  vrna_alloc(sizeof(FLT_OR_DBL)  *(length+1));
  ptype     = (char **)       vrna_alloc(sizeof(char *)      *(length+2));

  if (ulength>0) {
    /* QI3 = (FLT_OR_DBL **) vrna_alloc((length+1)*sizeof(FLT_OR_DBL *));*/
    QI5 = (FLT_OR_DBL **) vrna_alloc((length+1)*sizeof(FLT_OR_DBL *));
    qmb = (FLT_OR_DBL **) vrna_alloc((length+1)*sizeof(FLT_OR_DBL *));
    qm2 = (FLT_OR_DBL **) vrna_alloc((length+1)*sizeof(FLT_OR_DBL *));
    q2l = (FLT_OR_DBL **) vrna_alloc((length+1)*sizeof(FLT_OR_DBL *));
  }
  my_iindx  = vrna_idx_row_wise(length);
  iindx     = vrna_idx_row_wise(length); /* for backward compatibility and Perl wrapper */
  jindx     = vrna_idx_col_wise(length);
}

PRIVATE void free_pf_arrays_L(void){
  if(q)         free(q);
  if(qb)        free(qb);
  if(qm)        free(qm);
  if(pR)        free(pR);
  if(qm2)       free(qm2);
  if(qq)        free(qq);
  if(qq1)       free(qq1);
  if(qqm)       free(qqm);
  if(qqm1)      free(qqm1);
  if(q1k)       free(q1k);
  if(qln)       free(qln);
  if(prm_l)     free(prm_l);
  if(prm_l1)    free(prm_l1);
  if(prml)      free(prml);
  if(expMLbase) free(expMLbase);
  if(scale)     free(scale);
  if(my_iindx)  free(my_iindx);
  if(iindx)     free(iindx); /* for backward compatibility and Perl wrapper */
  if(jindx)     free(jindx);
  if(ptype)     free(ptype);
  if(QI5)       free(QI5);
  if(qmb)       free(qmb);
  if(q2l)       free(q2l);
  if(pf_params) free(pf_params);

  q = qb = qm = pR = QI5 = qmb = qm2 = q2l = NULL;
  qq = qq1 = qqm = qqm1 = q1k = qln = prml = prm_l = prm_l1 = expMLbase = NULL;
  my_iindx = jindx = iindx = NULL;
  pf_params = NULL;
  ptype     = NULL;
  scale = NULL;

#ifdef SUN4
  standard_arithmetic();
#else
#ifdef HP9
  fpsetfastmode(0);
#endif
#endif

}

PUBLIC void update_pf_paramsLP(int length){
  update_pf_paramsLP_par(length, NULL);
}

PUBLIC void update_pf_paramsLP_par(int length, vrna_exp_param_t *parameters){
  init_partfunc_L(length, parameters);
}

PUBLIC plist *pfl_fold( char *sequence,
                        int winSize,
                        int pairSize,
                        float cutoffb,
                        double **pU,
                        plist **dpp2,
                        FILE *pUfp,
                        FILE *spup){
  return pfl_fold_par(sequence, winSize, pairSize, cutoffb, pU, dpp2, pUfp, spup, NULL);
}

PUBLIC plist *pfl_fold_par( char *sequence,
                            int winSize,
                            int pairSize,
                            float cutoffb,
                            double **pU,
                            plist **dpp2,
                            FILE *pUfp,
                            FILE *spup,
                            vrna_exp_param_t *parameters){

  int         n, m, i, j, k, l, u, u1, type, type_2, tt, ov, do_dpp, simply_putout, noGUclosure;
  double      max_real;
  FLT_OR_DBL  temp, Qmax, prm_MLb, prmt, prmt1, qbt1, *tmp, expMLclosing;
  plist       *dpp, *pl;
  int split=0;

  ov            = 0;
  Qmax          = 0;
  do_dpp        = 0;
  simply_putout = 0;
  dpp           = NULL;
  pl            = NULL;
  pUoutput      = 0;
  ulength       = 0;
  cutoff        = cutoffb;

  if(pU != NULL)  ulength       = (int)pU[0][0]+0.49;
  if(spup !=NULL) simply_putout = 1; /*can't have one without the other*/
  if(pUfp!=NULL)  pUoutput      = 1;
  else if((pUoutput)&&(ulength!=0)){
    fprintf(stderr, "There was a problem with non existing File Pointer for unpaireds, terminating process\n");
    return pl;
  }
  dpp = *dpp2;
  if(dpp !=NULL)  do_dpp=1;

  n = (int) strlen(sequence);
  if (n<TURN+2) return 0;

  /* always init everything since all global static variables are uninitialized when entering a thread */
  init_partfunc_L(n, parameters);

  expMLclosing  = pf_params->expMLclosing;
  noGUclosure   = pf_params->model_details.noGUclosure;


  max_real = (sizeof(FLT_OR_DBL) == sizeof(float)) ? FLT_MAX : DBL_MAX;

  S   = encode_sequence(sequence, 0);
  S1  = encode_sequence(sequence, 1);

  /*  make_ptypes(S, structure); das machmadochlieber lokal, ey!*/

  /*here, I allocate memory for pU, if has to be saved, I allocate all in one go,
    if pU is put out and freed, I only allocate what I really need*/

  if (ulength>0){
    if (pUoutput) {
      for (i=1; i<=ulength; i++) pU[i]=(double *)vrna_alloc((MAX2(MAXLOOP,ulength)+2)*sizeof(double));
    }
    else {
      for (i=1; i<=n; i++) pU[i]=(double *)vrna_alloc((MAX2(MAXLOOP,ulength)+2)*sizeof(double));
     }
  }

  /*array initialization ; qb,qm,q
    qb,qm,q (i,j) are stored as ((n+1-i)*(n-i) div 2 + n+1-j */
  num_p = 0;
  pl    = (plist *)vrna_alloc(1000*sizeof(plist));


  /*ALWAYS q[i][j] => i>j!!*/
  for (j=1; j<MIN2(TURN+2,n); j++) { /*allocate start*/
    GetNewArrays(j, winSize);
    GetPtype(j,pairSize,S,n);
    for (i=1; i<=j; i++) q[i][j]=scale[(j-i+1)];
  }
  for (j=TURN+2;j<=n+winSize; j++) {
    if (j<=n) {
      GetNewArrays(j, winSize);
      GetPtype(j,pairSize,S,n);
      for (i=MAX2(1,j-winSize); i<=j/*-TURN*/; i++)
        q[i][j]=scale[(j-i+1)];
      for (i=j-TURN-1;i>=MAX2(1,(j-winSize+1)); i--) {
        /* construction of partition function of segment i,j*/
        /*firstly that given i bound to j : qb(i,j) */
        u = j-i-1;
        type = ptype[i][j];
        if (type!=0) {
          /*hairpin contribution*/
          if (((type==3)||(type==4))&&noGUclosure) qbt1 = 0;
          else
            qbt1 = exp_E_Hairpin(u, type, S1[i+1], S1[j-1], sequence+i-1, pf_params) * scale[u+2];

          /* interior loops with interior pair k,l */
          for (k=i+1; k<=MIN2(i+MAXLOOP+1,j-TURN-2); k++) {
            u1 = k-i-1;
            for (l=MAX2(k+TURN+1,j-1-MAXLOOP+u1); l<j; l++) {
              type_2 = ptype[k][l];
              if (type_2) {
                type_2 = rtype[type_2];
                qbt1 += qb[k][l] *
                  exp_E_IntLoop(u1, j-l-1, type, type_2,
                                S1[i+1], S1[j-1], S1[k-1], S1[l+1], pf_params) * scale[k-i+j-l];
              }
            }
          }
          /*multiple stem loop contribution*/
          temp = 0.0;
          for (k=i+2; k<=j-1; k++) temp += qm[i+1][k-1]*qqm1[k];
          tt = rtype[type];
          qbt1 += temp * expMLclosing * exp_E_MLstem(tt, S1[j-1], S1[i+1], pf_params) * scale[2];

          qb[i][j] = qbt1;
        } /* end if (type!=0) */
        else qb[i][j] = 0.0;

        /* construction of qqm matrix containing final stem
           contributions to multiple loop partition function
           from segment i,j */
        qqm[i] = qqm1[i]*expMLbase[1];
        if (type) {
          qbt1 = qb[i][j] * exp_E_MLstem(type, (i>1) ? S1[i-1] : -1, (j<n) ? S1[j+1] : -1, pf_params);
          qqm[i] += qbt1;
        }

        /*construction of qm matrix containing multiple loop
          partition function contributions from segment i,j */
        temp = 0.0;
        /*ii = my_iindx[i];   ii-k=[i,k-1] */
        /*new qm2 computation done here*/
        for (k=i+1; k<=j; k++) temp += (qm[i][k-1])*qqm[k];
        if (ulength>0) qm2[i][j]=temp;/*new qm2 computation done here*/
        for (k=i+1; k<=j; k++) temp += expMLbase[k-i] * qqm[k];
        qm[i][j] = (temp + qqm[i]);

        /*auxiliary matrix qq for cubic order q calculation below */
        qbt1 = qb[i][j];
        if (type) {
          qbt1 *= exp_E_ExtLoop(type, (i>1) ? S1[i-1] : -1, (j < n) ? S1[j+1] : -1, pf_params);
        }
        qq[i] = qq1[i]*scale[1] + qbt1;

        /*construction of partition function for segment i,j */
        temp = 1.0*scale[1+j-i] + qq[i];
        for (k=i; k<=j-1; k++) temp += q[i][k]*qq[k+1];
        q[i][j] = temp;

        if (temp>Qmax) {
          Qmax = temp;
          if (Qmax>max_real/10.)
            fprintf(stderr, "Q close to overflow: %d %d %g\n", i,j,temp);
        }
        if (temp>=max_real) {
          PRIVATE char msg[128];
          snprintf(msg, 128, "overflow in pf_fold while calculating q[%d,%d]\n"
                  "use larger pf_scale", i,j);
          vrna_message_error(msg);
        }
      } /*end for i*/
      tmp = qq1;  qq1 =qq;  qq =tmp;
      tmp = qqm1; qqm1=qqm; qqm=tmp;
    }

    /* just as a general service, I save here the free energy of the windows
       no output is generated, however,...
    */
    if ((j>=winSize) && (j<=n) && (ulength) && !(pUoutput)) {
      double Fwindow=0.;
      Fwindow=(-log(q[j-winSize+1][j])-winSize*log(pf_params->pf_scale))*pf_params->kT/1000.0;

      pU[j][0]=Fwindow;
      /*
      if (ulength>=winSize)
        pU[j][winSize]=scale[winSize]/q[j-winSize+1][j];
      */
    }
    if (j>winSize) {
      Qmax=0;
      /* i=j-winSize; */
      /* initialize multiloopfs */
      for (k=j-winSize; k<=MIN2(n,j); k++) {
        prml[k]=0;
        prm_l[k]=0;
        /*        prm_l1[k]=0;  others stay*/
      }
      prm_l1[j-winSize]=0;
      k=j-winSize;
      for (l=k+TURN+1; l<=MIN2(n,k+winSize-1); l++) {
        int a;
        pR[k][l] = 0; /* set zero at start */
        type=ptype[k][l];
        if (qb[k][l]==0) continue;

        for (a=MAX2(1,l-winSize+2); a<MIN2(k,n-winSize+2);a++)
          pR[k][l]+=q[a][k-1]*q[l+1][a+winSize-1]/q[a][a+winSize-1];

        if (l-k+1==winSize)
          pR[k][l]+=1./q[k][l];
        else {
          if (k+winSize-1<=n)          /* k outermost */
            pR[k][l]+=q[l+1][k+winSize-1]/q[k][k+winSize-1];
          if (l-winSize+1>=1)  /*l outermost*/
            pR[k][l]+=q[l-winSize+1][k-1]/q[l-winSize+1][l];
        }
        pR[k][l] *= exp_E_ExtLoop(type, (k>1) ? S1[k-1] : -1, (l<n) ? S1[l+1] : -1, pf_params);

        type_2 = ptype[k][l];
        type_2 = rtype[type_2];

        for (i=MAX2(MAX2(l-winSize+1,k-MAXLOOP-1),1); i<=k-1; i++) {
          for (m=l+1; m<=MIN2(MIN2(l+ MAXLOOP -k+i+2,i+winSize-1),n); m++) {
            type = ptype[i][m];
            if ((pR[i][m]>0))
              pR[k][l] += pR[i][m]*exp_E_IntLoop(k-i-1, m-l-1, type, type_2,
                                                 S1[i+1], S1[m-1], S1[k-1], S1[l+1], pf_params) * scale[k-i+m-l];
          }
        }
        if (ulength) { /* NOT IF WITHIN INNER LOOP */
          for (i=MAX2(MAX2(l-winSize+1,k-MAXLOOP-1),1); i<=k-1; i++) {
            for (m=l+1; m<=MIN2(MIN2(l+ MAXLOOP -k+i+2,i+winSize-1),n); m++) {
              type = ptype[i][m];
              if ((pR[i][m]>0)){
                temp=pR[i][m]*qb[k][l]*exp_E_IntLoop(k-i-1, m-l-1, type, type_2,
                                                     S1[i+1], S1[m-1], S1[k-1], S1[l+1], pf_params) * scale[k-i+m-l];
                QI5[l][m-l-1]+=temp;
                QI5[i][k-i-1]+=temp;
              }
            }
           }
        }
      }
      /* 3. bonding k,l as substem of multi-loop enclosed by i,m */
      prm_MLb = 0.;
      if(k>1) /*sonst nix!*/
        for (l=MIN2(n-1,k+winSize-2); l>=k+TURN+1; l--) { /* opposite direction */
          m=l+1;
          prmt = prmt1 = 0.0;
          tt = ptype[k-1][m]; tt=rtype[tt];
          prmt1 = pR[k-1][m] * expMLclosing * exp_E_MLstem(tt, S1[l], S1[k], pf_params);
          for (i=MAX2(1,l-winSize+2); i<k-1/*TURN*/; i++) {
            tt = ptype[i][m]; tt = rtype[tt];
            prmt += pR[i][m] * exp_E_MLstem(tt, S1[m-1], S1[i+1], pf_params) * qm[i+1][k-1];
          }
          tt = ptype[k][l];
          prmt *= expMLclosing;
          prml[ m] = prmt;
          prm_l[m] = prm_l1[m]*expMLbase[1]+prmt1;

          prm_MLb = prm_MLb*expMLbase[1] + prml[m];
          /* same as:    prm_MLb = 0;
             for (i=n; i>k; i--)  prm_MLb += prml[i]*expMLbase[k-i-1];
          */
          prml[m] = prml[ m] + prm_l[m];

          if (qb[k][l] == 0.) continue;

          temp = prm_MLb;

          if (ulength) {
            double dang;
            /* coefficient for computations of unpairedarrays */
            dang  =   qb[k][l] * exp_E_MLstem(tt, S1[k-1], S1[l+1], pf_params) * scale[2];
            for (m=MIN2(k+winSize-2,n);m>=l+2; m--){
              qmb[l][m-l-1] +=  prml[m]*dang;
              q2l[l][m-l-1] +=  (prml[m]-prm_l[m])*dang;
            }
          }

          for (m=MIN2(k+winSize-2,n);m>=l+2; m--)
            temp += prml[m]*qm[l+1][m-1];

          temp      *= exp_E_MLstem(tt, (k>1) ? S1[k-1] : -1, (l<n) ? S1[l+1] : -1, pf_params) * scale[2];
          pR[k][l]  += temp;

          if (pR[k][l]>Qmax) {
            Qmax = pR[k][l];
            if (Qmax>max_real/10.)
              fprintf(stderr, "P close to overflow: %d %d %g %g\n",
                      i, m, pR[k][l], qb[k][l]);
          }
          if (pR[k][l]>=max_real) {
            ov++;
            pR[k][l]=FLT_MAX;
          }

        } /* end for (l=..) */
      tmp = prm_l1; prm_l1=prm_l; prm_l=tmp;

      /* end for (l=..)   */
      if ((ulength)&&(k-MAXLOOP-1>0)){
        /* if (pUoutput) pU[k-MAXLOOP-1]=(double *)vrna_alloc((ulength+2)*sizeof(double)); */
        if(split){ /*generate the new arrays, if you want them somewhere else, you have to generate them and overgive them ;)*/
          double **pUO;
          double **pUI;
          double **pUM;
          double **pUH;
          pUO= (double **)  vrna_alloc((n+1)*sizeof(double *));
          pUI= (double **)  vrna_alloc((n+1)*sizeof(double *));
          pUM= (double **)  vrna_alloc((n+1)*sizeof(double *));
          pUH= (double **)  vrna_alloc((n+1)*sizeof(double *));
          if (pUoutput) {
            for (i=1; i<=ulength; i++) {
              pUH[i]=(double *)vrna_alloc((MAX2(MAXLOOP,ulength)+2)*sizeof(double));
              pUI[i]=(double *)vrna_alloc((MAX2(MAXLOOP,ulength)+2)*sizeof(double));
              pUO[i]=(double *)vrna_alloc((MAX2(MAXLOOP,ulength)+2)*sizeof(double));
              pUM[i]=(double *)vrna_alloc((MAX2(MAXLOOP,ulength)+2)*sizeof(double));
            }
          }
          //dont want to have that yet?
          /*  else {
            for (i=1; i<=n; i++) pU[i]=(double *)vrna_alloc((MAX2(MAXLOOP,ulength)+2)*sizeof(double));
            }*/
          compute_pU_splitup(k-MAXLOOP-1,ulength,pU,pUO,pUH, pUI, pUM, winSize, n, sequence);
          if (pUoutput) {
            putoutpU_splitup(pUO,k-MAXLOOP-1, ulength, pUfp,'E');
            putoutpU_splitup(pUH,k-MAXLOOP-1, ulength, pUfp,'H');
            putoutpU_splitup(pUI,k-MAXLOOP-1, ulength, pUfp,'I');
            putoutpU_splitup(pUM,k-MAXLOOP-1, ulength, pUfp,'M');
          }
        }
        else {
        compute_pU(k-MAXLOOP-1,ulength,pU, winSize, n, sequence);

        /* here, we put out and free pUs not in use any more (hopefully) */
        if (pUoutput)
          putoutpU(pU,k-MAXLOOP-1, ulength, pUfp);
      }
      }

      if (j-(2*winSize+MAXLOOP+1)>0) {
        printpbar(pR,winSize,j-(2*winSize+MAXLOOP+1),n);
        if (simply_putout) {
          print_plist(n, j-(2*winSize+MAXLOOP+1), pR, winSize, spup);
        }
        else{
          pl=get_plistW(pl, n, j-(2*winSize+MAXLOOP+1), pR, winSize);
        }
        if (do_dpp)dpp=get_deppp(dpp,j-(2*winSize-MAXLOOP),pairSize, n);
        FreeOldArrays(j-(2*winSize+MAXLOOP+1));
      }
    }   /* end if (do_backtrack)*/

  }/* end for j */

  /* finish output and free */
  for (j=MAX2(1,n-MAXLOOP); j<=n;j++) {
    /* if (pUoutput) pU[j]=(double *)vrna_alloc((ulength+2)*sizeof(double)); */
    if (ulength) compute_pU(j,ulength,pU, winSize, n, sequence);
    /*here, we put out and free pUs not in use any more (hopefully)*/
    if (pUoutput) putoutpU(pU,j, ulength, pUfp);
  }
  for (j=MAX2(n-winSize-MAXLOOP,1); j<=n; j++) {
    printpbar(pR,winSize,j,n);
    if (simply_putout) {
      print_plist(n, j, pR, winSize, spup);
    }
    else {
      pl=get_plistW(pl, n, j, pR, winSize);
    }
    if ((do_dpp)&&j<n) dpp=get_deppp(dpp,j,pairSize, n);
    FreeOldArrays(j);
  }
  /* free_pf_arrays_L(); */
  free(S);
  free(S1);
  S = S1 = NULL;
  if (ov>0) fprintf(stderr, "%d overflows occurred while backtracking;\n"
                    "you might try a smaller pf_scale than %g\n",
                    ov, pf_params->pf_scale);
  *dpp2=dpp;

  return pl;
}

PRIVATE void scale_pf_params(unsigned int length, vrna_exp_param_t *parameters){
  unsigned int i;
  double  kT, scaling_factor;

  if(pf_params) free(pf_params);

  if(parameters){
    pf_params = vrna_exp_params_copy(parameters);
  } else {
    vrna_md_t  md;
    set_model_details(&md);
    pf_params = vrna_exp_params(&md);
  }

  scaling_factor = pf_params->pf_scale;
  kT = pf_params->kT;   /* kT in cal/mol  */

   /* scaling factors (to avoid overflows) */
  if (scaling_factor == -1) { /* mean energy for random sequences: 184.3*length cal */
    scaling_factor = exp(-(-185+(pf_params->temperature-37.)*7.27)/kT);
    if (scaling_factor<1) scaling_factor=1;
    pf_params->pf_scale = scaling_factor;
  }
  scale[0] = 1.;
  scale[1] = 1./scaling_factor;
  expMLbase[0] = 1;
  expMLbase[1] = pf_params->expMLbase/scaling_factor;
  for (i=2; i<=length; i++) {
    scale[i] = scale[i/2]*scale[i-(i/2)];
    expMLbase[i] = pow(pf_params->expMLbase, (double)i) * scale[i];
  }
}

PRIVATE void printpbar(FLT_OR_DBL **prb,int winSize, int i, int n) {
  int j;
  int howoften=0; /* how many samples do we have for this pair */
  int pairdist;

  for (j=i+TURN; j<MIN2(i+winSize,n+1); j++) {
    pairdist=(j-i+1);
    /*4cases*/
    howoften=MIN2(winSize-pairdist+1,i); /*pairdist,start*/
    howoften=MIN2(howoften,n-j+1);       /*end*/
    howoften=MIN2(howoften,n-winSize+1); /*windowsize*/
    prb[i][j] *= qb[i][j]/howoften;
  }
  return;
}

PRIVATE void FreeOldArrays(int i) {
  /*free arrays no longer needed*/
  free(pR[i]+i);
  free(q[i]+i);
  free(qb[i]+i);
  free(qm[i]+i);
  if (ulength!=0) {
    free(qm2[i]+i);
    free(QI5[i]);
    free(qmb[i]);
    free(q2l[i]);
  }
  free(ptype[i]+i);
  return;
}

PRIVATE void GetNewArrays(int j, int winSize) {
  /*allocate new part of arrays*/
  pR[j]=(FLT_OR_DBL *)vrna_alloc((winSize+1)*sizeof(FLT_OR_DBL));
  pR[j]-=j;
  q[j]=(FLT_OR_DBL *)vrna_alloc((winSize+1)*sizeof(FLT_OR_DBL));
  q[j]-=j;
  qb[j]=(FLT_OR_DBL *)vrna_alloc((winSize+1)*sizeof(FLT_OR_DBL));
  qb[j]-=j;
  qm[j]=(FLT_OR_DBL *)vrna_alloc((winSize+1)*sizeof(FLT_OR_DBL));
  qm[j]-=j;
  if (ulength!=0) {
    qm2[j]=(FLT_OR_DBL *)vrna_alloc((winSize+1)*sizeof(FLT_OR_DBL));
    qm2[j]-=j;
    QI5[j]=(FLT_OR_DBL *)vrna_alloc((winSize+1)*sizeof(FLT_OR_DBL));
    qmb[j]=(FLT_OR_DBL *)vrna_alloc((winSize+1)*sizeof(FLT_OR_DBL));
    q2l[j]=(FLT_OR_DBL *)vrna_alloc((winSize+1)*sizeof(FLT_OR_DBL));
  }
  ptype[j]=(char *)vrna_alloc((winSize+1)*sizeof(char));
  ptype[j]-=j;
  return;
}


PRIVATE void GetPtype(int i, int winSize,const short *S,int n) {
  /*make new entries in ptype array*/
  int j;
  int type;
  for (j=i; j<=MIN2(i+winSize,n); j++) {
    type = pair[S[i]][S[j]];
    ptype[i][j] = (char) type;
  }
  return;
}


PRIVATE plist *get_plistW(plist *pl, int length,
                                 int start, FLT_OR_DBL **Tpr, int winSize) {
  /* get pair probibilities out of pr array */
  int  j,  max_p;
  max_p=1000;
  while (max_p<num_p)
    max_p*=2;

  for (j=start+1; j<=MIN2(start+winSize, length); j++) {
    if (Tpr[start][j]<cutoff) continue;
    if (num_p==max_p-1) {
      max_p*=2;
      pl=(plist *)vrna_realloc(pl,max_p*sizeof(plist));
    }
    pl[num_p].i=start;
    pl[num_p].j=j;
    pl[num_p++].p=Tpr[start][j];
  }

  /* mark end of data with zeroes */
  pl[num_p].i=0;
  pl[num_p].j=0;
  pl[num_p].p=0.;
  /* pl=(plist *)vrna_realloc(pl,(count)*sizeof(plist)); */
  return pl;
}


PRIVATE plist *get_deppp(plist *pl, int start, int pairsize, int length) {
  /* compute dependent pair probabilities */
  int i, j, count=0;
  double tmp;
  plist *temp;
  temp=(plist *)vrna_alloc(pairsize*sizeof(plist)); /* holds temporary deppp */
  for (j=start+TURN; j<MIN2(start+pairsize,length); j++) {

    if ((qb[start][j]*qb[start-1][(j+1)])>10e-200) {
      int type=ptype[start-1][j+1];
      int type_2=rtype[(unsigned char)ptype[start][j]];
      tmp=qb[start][j]/qb[start-1][(j+1)]*exp_E_IntLoop(0, 0, type, type_2,
                                                        S1[start], S1[j], S1[start-1], S1[j+1], pf_params) * scale[2];
       temp[count].i=start;
      temp[count].j=j;
      temp[count++].p=tmp;
    }
  }
  /* write it to list of deppps */
  for (i=0; pl[i].i!=0; i++);
  pl=(plist *)vrna_realloc(pl,(i+count+1)*sizeof(plist));
  for (j=0; j<count; j++) {
    pl[i+j].i=temp[j].i;
    pl[i+j].j=temp[j].j;
    pl[i+j].p=temp[j].p;
  }
  pl[i+count].i=0;
  pl[i+count].j=0;
  pl[i+count].p=0;
  free(temp);
  return pl;
}


PRIVATE void print_plist(int length,int start, FLT_OR_DBL **Tpr, int winSize, FILE *fp) {
  /* print out of pr array, do not save */
  int  j;


  for (j=start+1; j<=MIN2(start+winSize, length); j++) {
    if (Tpr[start][j]<cutoff) continue;
    fprintf(fp,"%d  %d  %g\n",start,j,Tpr[start][j]);
  }

  /* mark end of data with zeroes */

  return ;
}

PRIVATE void compute_pU(int k, int ulength, double **pU, int winSize,int n, char *sequence) {
/*  here, we try to add a function computing all unpaired probabilities starting at some i,
    going down to $unpaired, to be unpaired, i.e. a list with entries from 1 to unpaired for
    every i, with the probability of a stretch of length x, starting at i-x+1, to be unpaired
*/
  int startu;
  int i5;
  int j3, len, obp;
  double temp;
  double *QBE;
  FLT_OR_DBL  expMLclosing      = pf_params->expMLclosing;

  QBE=(double *) vrna_alloc((MAX2(ulength,MAXLOOP)+2)*sizeof(double));

  /* first, we will */
  /* for k<=ulength, pU[k][k]=0, because no bp can enclose it */
  if (pUoutput&&k+ulength<=n)  pU[k+ulength]=(double *)vrna_alloc((ulength+2)*sizeof(double));
  /*compute pu[k+ulength][ulength] */
   for (i5=MAX2(k+ulength-winSize+1,1);i5<=k;i5++) {
    for (j3=k+ulength+1; j3<=MIN2(n,i5+winSize-1); j3++) {
      /*  if (k>400) {
        printf("i%d j%d  ",i5,j3);
        fflush(stdout);
        } */
      if (ptype[i5][j3]!=0) {/**/
        /* (.. >-----|..........)
          i5  j     j+ulength  j3              */
        /*Multiloops*/
        temp = (i5<k) ? qm2[i5+1][k] * expMLbase[j3-k-1] : 0.; /* (..{}{}-----|......) */

        if(j3-1>k+ulength)
          temp  +=  qm2[k+ulength+1][j3-1] * expMLbase[k+ulength-i5]; /* (..|-----|{}{}) */

        if((i5<k)&&(j3-1>k+ulength))
          temp  +=  qm[i5+1][k] * qm[k+ulength+1][j3-1] * expMLbase[ulength]; /* ({}|-----|{}) */

        /* add dangles, multloopclosing etc. */
        temp  *=  exp_E_MLstem(rtype[(unsigned char)ptype[i5][j3]], S1[j3-1], S1[i5+1], pf_params) * scale[2] * expMLclosing;
        /*add hairpins*/
        temp  +=  exp_E_Hairpin(j3-i5-1, ptype[i5][j3], S1[i5+1], S1[j3-1], sequence+i5-1, pf_params) * scale[j3-i5+1];
        /*add outer probability*/
        temp *= pR[i5][j3];
        pU[k+ulength][ulength] += temp;

      }
    }
   }
   /* code doubling to avoid if within loop */
#if 0
  /*initialization for interior loops,
    it is not recomended to have verysmall ulengths!!*/
  if (ulength<MAXLOOP) {
    int k5;
    int l3;
    int outype;
    /* kl bp is 5' */
    /* MAXLOOP>((l5-k5-1)+(j3-l3-1)
      k-winSize+ulength<i5<k-TURN-1;
      k+ulength<j3<=k+MAXLOOP+1
      if i then use l3, it is easier by far:
      j3-MAXLOOP<=l3<=k
      i5<k5<k-TURN k5<=i5+l3+2+MAXLOOP-j3
      k5+TURN<l3<=k
    */
    for (i5=MAX2(k+ulength-winSize,1);i5<k-TURN-1;i5++) {

      for (j3=k+ulength+1; j3<=MIN2(n,MIN2(i5+winSize-1,k+MAXLOOP+1)); j3++) {
        double temp=0;
        if (outype=ptype[i5][j3]>0) /* oder so halt */
          for (l3=MAX2(i5+TURN+1,j3-MAXLOOP-1); l3<=k; l3++){
            for (k5=i5+1; k5<=MIN2(l3-TURN-1,MAXLOOP+i5+l3+2-j3); k5++){
              if (ptype[k5][l3]) {
                temp+= qb[k5][l3]*expLoopEnergy(k5-i5-1, j3-l3-1, outype, rtype[ptype[k5][l3]], S1[i5+1], S1[j3-1], S1[k5-1], S1[l3+1]);
              }
            }
          }
        temp*=pR[i5][j3];
        pU[k+ulength][ulength]+= temp;
      }
    }
    /* kl bp is 3' */
    /*
      k+ulength-MAXLOOP<=i5<=k
      k+ulength+1+TURN<j3<i5+winSize
      k+ulength+1<=k5<i5+MAXLOOP+2 || k5<j3-TURN
      k5<l3<j3 || j3-k5-i5-2-ML<=l3<j3
    */
    for (i5=MAX2(1,MAX2(k+ulength-winSize,k+ulength-MAXLOOP));i5<=k; i5++){
      for (j3=k+ulength+TURN+2; j3<MIN2(n+1,i5+winSize); j3++) {
        double temp = 0;
        if (outype=ptype[i5][j3]>0) /* oder so halt */
          for (k5=k+ulength+1; k5<MIN2(j3-TURN-1,i5+MAXLOOP+2); k5++) {
            for (l3=MAX2(k5+TURN+1,j3+k5-i5-2-MAXLOOP); l3<j3; l3++) {
              if (ptype[k5][l3])
                temp += qb[k5][l3]*expLoopEnergy(k5-i5-1, j3-l3-1, outype, rtype[ptype[k5][l3]], S1[i5+1], S1[j3-1], S1[k5-1], S1[l3+1]);
            }
          }
        temp*=pR[i5][j3];
        pU[k+ulength][ulength]+= temp;
      }
    }
  }
  /* Add up Is QI5[l][m-l-1] QI3 */
  /* Add up Interior loop terms */
  temp=0.;

  for (len=winSize; len>=ulength; len--) temp+=QI3[k][len];
  for (;len>0; len--) {
    temp += QI3[k][len];
    QBE[len] += temp;
  }
#endif
  temp=0.;
  for (len=winSize; len>=MAX2(ulength,MAXLOOP); len--) temp+=QI5[k][len];
  for (;len>0; len--) {
    temp += QI5[k][len];
    QBE[len] += temp;  /* replace QBE with QI */
  }
  /* Add Hairpinenergy to QBE */
  temp=0.;
  for(obp = MIN2(n, k + winSize - 1); obp > k + ulength; obp--)
    if(ptype[k][obp])
      temp += pR[k][obp] * exp_E_Hairpin(obp-k-1, ptype[k][obp], S1[k+1], S1[obp-1], sequence+k-1, pf_params) * scale[obp-k+1];
  for(obp = MIN2(n, MIN2(k + winSize - 1, k + ulength)); obp > k + 1; obp--){
    if (ptype[k][obp])
      temp += pR[k][obp] * exp_E_Hairpin(obp-k-1, ptype[k][obp], S1[k+1], S1[obp-1], sequence+k-1, pf_params) * scale[obp-k+1];
    QBE[obp-k-1] += temp;  /* add hairpins to QBE (all in one array) */
  }
  /* doubling the code to get the if out of the loop */

  /* Add up Multiloopterms  qmb[l][m]+=prml[m]*dang;
    q2l[l][m]+=(prml[m]-prm_l[m])*dang; */

  temp=0.;
  for(len = winSize; len >= ulength; len--)
    temp += q2l[k][len] * expMLbase[len];
  for( ; len > 0; len--){
    temp += q2l[k][len] * expMLbase[len];
    QBE[len] += temp; /* add (()()____) type cont. to I3 */
  }
  for(len = 1; len < ulength; len++){
    for(obp = k + len + TURN; obp <= MIN2(n, k + winSize - 1); obp++){
      /* add (()___()) */
      QBE[len] += qmb[k][obp-k-1] * qm[k+len+1/*2*/][obp-1] * expMLbase[len];
    }
  }
  for (len=1; len<ulength; len++) {
    for (obp=k+len+TURN+TURN; obp<=MIN2(n,k+winSize-1); obp++) {
      if (ptype[k][obp]) {
        temp      =   exp_E_MLstem(rtype[(unsigned char)ptype[k][obp]], S1[obp-1], S1[k+1], pf_params) * scale[2] * expMLbase[len] * expMLclosing; /* k:obp */
        QBE[len]  +=  pR[k][obp] * temp * qm2[k+len+1][obp-1]; /* add (___()()) */
      }
    }
  }
  /* After computing all these contributions in QBE[len], that k is paired
    and the unpaired stretch is AT LEAST len long, we start to add that to
    the old unpaired thingies; */
  for(len = 1; len < MIN2(MAX2(ulength, MAXLOOP), n - k); len++){
    pU[k+len][len] += pU[k+len][len+1] + QBE[len];
  }

  /*open chain*/
  if ((ulength>=winSize)&&(k>=ulength)) {
    pU[k][winSize]=scale[winSize]/q[k-winSize+1][k];
  }
  /* now the not enclosed by any base pair terms for whatever it is we do not need anymore...
    ... which should be e.g; k, again */
  for(startu = MIN2(ulength, k); startu > 0; startu--){
    temp=0.;
    for(i5 = MAX2(1, k - winSize + 2); i5 <= MIN2(k - startu, n - winSize + 1); i5++){
      temp += q[i5][k - startu] * q[k + 1][i5 + winSize - 1] * scale[startu]/q[i5][i5 + winSize - 1];
    }
    /* the 2 Cases where the borders are on the edge of the interval */
    if((k >= winSize) && (startu + 1 <= winSize))
      temp += q[k - winSize + 1][k - startu]*scale[startu]/q[k - winSize + 1][k];
    if((k <= n - winSize+ startu) && (k - startu >= 0) && (k < n) && (startu + 1 <= winSize))
      temp += q[k + 1][k - startu + winSize] * scale[startu] / q[k - startu + 1][k - startu + winSize];

    /* Divide by number of possible windows */
    pU[k][startu] += temp;
    {
      int leftmost, rightmost;

      leftmost      = MAX2(1, k - winSize + 1);
      rightmost     = MIN2(n - winSize + 1, k - startu + 1);
      pU[k][startu] /= (rightmost - leftmost + 1);
    }
  }
  free(QBE);
  return;
}


PRIVATE void putoutpU(double **pUx, int k, int ulength, FILE *fp) {
  /*put out unpaireds for k, and free pU[k], make sure we don't need pU[k] any more!!*/
  /*could use that for hairpins, also!*/
  int i;
  fprintf(fp,"%d\t",k);
  for (i=1; i<=MIN2(ulength,k); i++) {
    fprintf(fp,"%.5g\t",pUx[k][i]);
  }
  fprintf(fp,"\n");
  free(pUx[k]);
}
PRIVATE void putoutpU_splitup(double **pUx, int k, int ulength, FILE *fp, char ident) {
  /*put out unpaireds for k, and free pU[k], make sure we don't need pU[k] any more!!*/
  /*could use that for hairpins, also!*/
  int i;
  fprintf(fp,"%d\t",k);
  for (i=1; i<=MIN2(ulength,k); i++) {
    fprintf(fp,"%.5g\t",pUx[k][i]);
  }
  fprintf(fp,"\t%c\n",ident);
  free(pUx[k]);
}

PUBLIC void putoutpU_prob(double **pU,int length, int ulength, FILE *fp, int energies) {
  putoutpU_prob_par(pU, length, ulength, fp, energies, pf_params);
}


PUBLIC void putoutpU_prob_par(double **pU,int length, int ulength, FILE *fp, int energies, vrna_exp_param_t *parameters){
  /*put out unpaireds */
  int i,k;
  double kT = parameters->kT/1000.0;
  double temp;
  if (energies) fprintf(fp,"#opening energies\n #i$\tl=");
  else  fprintf(fp,"#unpaired probabilities\n #i$\tl=");
  for (i=1; i<=ulength; i++) {
    fprintf(fp,"%d\t", i);
  }
  fprintf(fp,"\n");

  for (k=1; k<=length; k++){
    fprintf(fp,"%d\t",k);
    for (i=1; i<=ulength; i++) {
      if (i>k) {
        fprintf(fp,"NA\t");
        continue;
      }
      if (energies) temp=-log(pU[k][i])*kT;
      else temp=pU[k][i];
      fprintf(fp,"%.7g\t",temp);
    }
    fprintf(fp,"\n");
    free(pU[k]);
  }
  fflush(fp);
}

PUBLIC void putoutpU_prob_bin(double **pU,int length, int ulength, FILE *fp, int energies) {
  putoutpU_prob_bin_par(pU, length, ulength, fp, energies, pf_params);
}

PUBLIC void putoutpU_prob_bin_par(double **pU,int length, int ulength, FILE *fp, int energies, vrna_exp_param_t *parameters) {

  /*put out unpaireds */
  int i,k;
  double kT= parameters->kT/1000.0;
  int *p;
  p = (int*) vrna_alloc(sizeof(int)*1);
  /* write first line */
  p[0]=ulength; /* u length */
  fwrite(p,sizeof(int),1,fp);
  p[0]=length; /* seq length */
  fwrite(p,sizeof(int),1,fp);
  for (k=3; k<=(length+20); k++){ /* all the other lines are set to 1000000 because we are at ulength=0 */
    p[0]=1000000;
    fwrite(p,sizeof(int),1,fp);
  }
  /* data */
  for (i=1; i<=ulength; i++) {
    for (k=1; k<=11; k++){/* write first ten entries to 1000000 */
      p[0]=1000000;
      fwrite(p,sizeof(int),1,fp);
    }
    for (k=1; k<=length; k++){/* write data now */
      if (i>k) {
        p[0]=1000000;         /* check if u > pos */
        fwrite(p,sizeof(int),1,fp);
        continue;
      }
      else{
        p[0]= (int) rint(100 *(-log(pU[k][i])*kT));
        fwrite(p,sizeof(int),1,fp);
      }
    }
    for (k=1; k<=9; k++){/* finish by writing the last 10 entries */
      p[0]=1000000;
      fwrite(p,sizeof(int),1,fp);
    }
  }
  /* free pU array; */
  for (k=1; k<=length; k++){
    free(pU[k]);
  }
  free(p);
  fflush(fp);
}


/*
 Here: Space for questions...
*/
PRIVATE void compute_pU_splitup(int k, int ulength, double **pU,  double **pUO, double **pUH, double **pUI, double **pUM, int winSize,int n, char *sequence) {
/*  here, we try to add a function computing all unpaired probabilities starting at some i,
    going down to $unpaired, to be unpaired, i.e. a list with entries from 1 to unpaired for
    every i, with the probability of a stretch of length x, starting at i-x+1, to be unpaired
*/
  int startu;
  int i5;
  int j3, len, obp;
  double temp;
  double *QBE;
  double *QBI;
  double *QBM;
  double *QBH;
  
  FLT_OR_DBL  expMLclosing      = pf_params->expMLclosing;

  QBE=(double *) vrna_alloc((MAX2(ulength,MAXLOOP)+2)*sizeof(double));
  QBM=(double *) vrna_alloc((MAX2(ulength,MAXLOOP)+2)*sizeof(double));
  QBI=(double *) vrna_alloc((MAX2(ulength,MAXLOOP)+2)*sizeof(double));
  QBH=(double *) vrna_alloc((MAX2(ulength,MAXLOOP)+2)*sizeof(double));

  /* first, we will */
  /* for k<=ulength, pU[k][k]=0, because no bp can enclose it */
  if (pUoutput&&k+ulength<=n)  pU[k+ulength]=(double *)vrna_alloc((ulength+2)*sizeof(double));
  /*compute pu[k+ulength][ulength] */
   for (i5=MAX2(k+ulength-winSize+1,1);i5<=k;i5++) {
    for (j3=k+ulength+1; j3<=MIN2(n,i5+winSize-1); j3++) {
      /*  if (k>400) {
        printf("i%d j%d  ",i5,j3);
        fflush(stdout);
        } */
      if (ptype[i5][j3]!=0) {/**/
        /* (.. >-----|..........)
          i5  j     j+ulength  j3              */
        /*Multiloops*/
        temp = (i5<k) ? qm2[i5+1][k] * expMLbase[j3-k-1] : 0.; /* (..{}{}-----|......) */

        if(j3-1>k+ulength)
          temp  +=  qm2[k+ulength+1][j3-1] * expMLbase[k+ulength-i5]; /* (..|-----|{}{}) */

        if((i5<k)&&(j3-1>k+ulength))
          temp  +=  qm[i5+1][k] * qm[k+ulength+1][j3-1] * expMLbase[ulength]; /* ({}|-----|{}) */

        /* add dangles, multloopclosing etc. */
        temp  *=  exp_E_MLstem(rtype[(unsigned char)ptype[i5][j3]], S1[j3-1], S1[i5+1], pf_params) * scale[2] * expMLclosing;
        /*add hairpins*/
        temp  +=  exp_E_Hairpin(j3-i5-1, ptype[i5][j3], S1[i5+1], S1[j3-1], sequence+i5-1, pf_params) * scale[j3-i5+1];
        /*add outer probability*/
        temp *= pR[i5][j3];
        pU[k+ulength][ulength] += temp;

      }
    }
   }
   /* code doubling to avoid if within loop */
  temp=0.;
  for (len=winSize; len>=MAX2(ulength,MAXLOOP); len--) temp+=QI5[k][len];
  for (;len>0; len--) {
    temp += QI5[k][len];
    QBI[len] += temp; 
    QBE[len] += temp;  /* replace QBE with QI */
  }
  /* Add Hairpinenergy to QBE */
  temp=0.;
  for(obp = MIN2(n, k + winSize - 1); obp > k + ulength; obp--)
    if(ptype[k][obp])
      temp += pR[k][obp] * exp_E_Hairpin(obp-k-1, ptype[k][obp], S1[k+1], S1[obp-1], sequence+k-1, pf_params) * scale[obp-k+1];
  for(obp = MIN2(n, MIN2(k + winSize - 1, k + ulength)); obp > k + 1; obp--){
    if (ptype[k][obp])
      temp += pR[k][obp] * exp_E_Hairpin(obp-k-1, ptype[k][obp], S1[k+1], S1[obp-1], sequence+k-1, pf_params) * scale[obp-k+1];
    QBH[obp-k-1] += temp;
    QBE[obp-k-1] += temp;  /* add hairpins to QBE (all in one array) */
  }
  /* doubling the code to get the if out of the loop */

  /* Add up Multiloopterms  qmb[l][m]+=prml[m]*dang;
    q2l[l][m]+=(prml[m]-prm_l[m])*dang; */

  temp=0.;
  for(len = winSize; len >= ulength; len--)
    temp += q2l[k][len] * expMLbase[len];
  for( ; len > 0; len--){
    temp += q2l[k][len] * expMLbase[len];
    QBM[len] += temp; 
    QBE[len] += temp; /* add (()()____) type cont. to I3 */
  }
  for(len = 1; len < ulength; len++){
    for(obp = k + len + TURN; obp <= MIN2(n, k + winSize - 1); obp++){
      /* add (()___()) */
      QBM[len] += qmb[k][obp-k-1] * qm[k+len+1/*2*/][obp-1] * expMLbase[len];
      QBE[len] += qmb[k][obp-k-1] * qm[k+len+1/*2*/][obp-1] * expMLbase[len];
    }
  }
  for (len=1; len<ulength; len++) {
    for (obp=k+len+TURN+TURN; obp<=MIN2(n,k+winSize-1); obp++) {
      if (ptype[k][obp]) {
        temp      =   exp_E_MLstem(rtype[(unsigned char)ptype[k][obp]], S1[obp-1], S1[k+1], pf_params) * scale[2] * expMLbase[len] * expMLclosing; /* k:obp */
        QBE[len]  +=  pR[k][obp] * temp * qm2[k+len+1][obp-1]; /* add (___()()) */
        QBM[len]  +=  pR[k][obp] * temp * qm2[k+len+1][obp-1]; /* add (___()()) */
      }
    }
  }
  /* After computing all these contributions in QBE[len], that k is paired
    and the unpaired stretch is AT LEAST len long, we start to add that to
    the old unpaired thingies; */
  for(len = 1; len < MIN2(MAX2(ulength, MAXLOOP), n - k); len++){
    pU[k+len][len] += pU[k+len][len+1] + QBE[len];
    pUH[k+len][len] += pUH[k+len][len+1] + QBH[len];
    pUM[k+len][len] += pUM[k+len][len+1] + QBM[len];
    pUI[k+len][len] += pUI[k+len][len+1] + QBI[len];
    
  }

  /* open chain */
  if ((ulength>=winSize)&&(k>=ulength)) {
    pUO[k][winSize]=scale[winSize]/q[k-winSize+1][k];
  }
  /*open chain*/
  if ((ulength>=winSize)&&(k>=ulength)) {
    pU[k][winSize]=scale[winSize]/q[k-winSize+1][k];
  }
  /* now the not enclosed by any base pair terms for whatever it is we do not need anymore...
    ... which should be e.g; k, again */
  for(startu = MIN2(ulength, k); startu > 0; startu--){
    temp=0.;
    for(i5 = MAX2(1, k - winSize + 2); i5 <= MIN2(k - startu, n - winSize + 1); i5++){
      temp += q[i5][k - startu] * q[k + 1][i5 + winSize - 1] * scale[startu]/q[i5][i5 + winSize - 1];
    }
    /* the 2 Cases where the borders are on the edge of the interval */
    if((k >= winSize) && (startu + 1 <= winSize))
      temp += q[k - winSize + 1][k - startu]*scale[startu]/q[k - winSize + 1][k];
    if((k <= n - winSize+ startu) && (k - startu >= 0) && (k < n) && (startu + 1 <= winSize))
      temp += q[k + 1][k - startu + winSize] * scale[startu] / q[k - startu + 1][k - startu + winSize];

    /* Divide by number of possible windows */
    pU[k][startu] += temp;
    pUO[k][startu] += temp;
    
    {
      int leftmost, rightmost;

      leftmost      = MAX2(1, k - winSize + 1);
      rightmost     = MIN2(n - winSize + 1, k - startu + 1);
      pU[k][startu] /= (rightmost - leftmost + 1);
      /*Do we want to make a distinction between those?*/
      pUH[k][startu] /= (rightmost - leftmost + 1);
      pUO[k][startu] /= (rightmost - leftmost + 1);
      pUI[k][startu] /= (rightmost - leftmost + 1);
      pUM[k][startu] /= (rightmost - leftmost + 1);
    }
  }
  free(QBE);
  free(QBI);
  free(QBH);
  free(QBM);
  return;
}
PUBLIC void putoutpU_prob_splitup(double **pU, double **pUO, double **pUH, double **pUI, double **pUM, int length, int ulength, FILE *fp, int energies) {
  /*put out unpaireds */
  int i,k;
  double kT= (temperature+K0)*GASCONST/1000.0;
  double temp;
  if (energies) fprintf(fp,"#opening energies\n #i$\tl=");
  else  fprintf(fp,"#unpaired probabilities\n #i$\tl=");
  
  fprintf(fp,"Total\n");
  for (i=1; i<=ulength; i++) {
    fprintf(fp,"%d\t", i);
  }
  fprintf(fp,"\n");

  for (k=1; k<=length; k++){
    fprintf(fp,"%d\t",k);
    for (i=1; i<=ulength; i++) {
      if (i>k) {
        fprintf(fp,"NA\t");
        continue;
      }
      if (energies) temp=-log(pU[k][i])*kT;
      else temp=pU[k][i];
      fprintf(fp,"%.7g\t",temp);
    }
    fprintf(fp,"\tT\n");
    free(pU[k]);
  }
  fprintf(fp,"\n###################################################################\nHairpin\n");
  for (i=1; i<=ulength; i++) {
    fprintf(fp,"%d\t", i);
  }
  fprintf(fp,"\n");

  for (k=1; k<=length; k++){
    fprintf(fp,"%d\t",k);
    for (i=1; i<=ulength; i++) {
      if (i>k) {
        fprintf(fp,"NA\t");
        continue;
      }
      if (energies) temp=-log(pUH[k][i])*kT;
      else temp=pUH[k][i];
      fprintf(fp,"%.7g\t",temp);
    }
    fprintf(fp,"\tH\n");
    free(pUH[k]);
  }
  fprintf(fp,"\n###################################################################\nInterior\n");
  for (i=1; i<=ulength; i++) {
    fprintf(fp,"%d\t", i);
  }
  fprintf(fp,"\n");

  for (k=1; k<=length; k++){
    fprintf(fp,"%d\t",k);
    for (i=1; i<=ulength; i++) {
      if (i>k) {
        fprintf(fp,"NA\t");
        continue;
      }
      if (energies) temp=-log(pUI[k][i])*kT;
      else temp=pUI[k][i];
      fprintf(fp,"%.7g\t",temp);
    }
    fprintf(fp,"\tI\n");
    free(pUI[k]);
  }
  fprintf(fp,"\n###################################################################\nMultiloop\n");
  for (i=1; i<=ulength; i++) {
    fprintf(fp,"%d\t", i);
  }
  fprintf(fp,"\n");

  for (k=1; k<=length; k++){
    fprintf(fp,"%d\t",k);
    for (i=1; i<=ulength; i++) {
      if (i>k) {
        fprintf(fp,"NA\t");
        continue;
      }
      if (energies) temp=-log(pUM[k][i])*kT;
      else temp=pUM[k][i];
      fprintf(fp,"%.7g\t",temp);
    }
    fprintf(fp,"\tM\n");
    free(pUM[k]);
  }
  fprintf(fp,"\n###################################################################\nExterior\n");
  for (i=1; i<=ulength; i++) {
    fprintf(fp,"%d\t", i);
  }
  fprintf(fp,"\t E\n");

  for (k=1; k<=length; k++){
    fprintf(fp,"%d\t",k);
    for (i=1; i<=ulength; i++) {
      if (i>k) {
        fprintf(fp,"NA\t");
        continue;
      }
      if (energies) temp=-log(pUO[k][i])*kT;
      else temp=pUO[k][i];
      fprintf(fp,"%.7g\t",temp);
    }
    fprintf(fp,"\n");
    free(pU[k]);
  }
  fflush(fp);
}


/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/

PUBLIC void init_pf_foldLP(int length){ /* DO NOTHING */}


string_utils.c/ 0           0     0     644     3411      `
/*
                               string_utils.c

                 c  Ivo L Hofacker and Walter Fontana
                          Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>
#include <time.h>
#include <string.h>
#include <sys/types.h>
#include <stdint.h>

#include "utils.h"
#include "string_utils.h"

#ifndef HAVE_STRDUP
char *strdup(const char *s) {
  char *dup;

  dup = vrna_alloc(strlen(s)+1);
  strcpy(dup, s);
  return(dup);
}
#endif


PUBLIC char *
vrna_random_string(int l, const char symbols[]){

  char *r;
  int   i, rn, base;

  base = (int) strlen(symbols);
  r = (char *) vrna_alloc(sizeof(char)*(l+1));

  for (i = 0; i < l; i++) {
    rn = (int) (vrna_urn()*base);  /* [0, base-1] */
    r[i] = symbols[rn];
  }
  r[l] = '\0';
  return r;
}

/*-----------------------------------------------------------------*/

PUBLIC int
vrna_hamming_distance(const char *s1,
                      const char *s2){

  int h=0;

  for (; *s1 && *s2; s1++, s2++)
    if (*s1 != *s2) h++;
  return h;
}

PUBLIC int
vrna_hamming_distance_bound(const char *s1,
                            const char *s2,
                            int boundary){

  int h=0;

  for (; *s1 && *s2 && boundary; s1++, s2++, boundary--)
    if (*s1 != *s2) h++;
  return h;
}

PUBLIC  void
vrna_seq_toRNA(char *sequence){

  unsigned int i;
  if(sequence){
    for(i = 0; sequence[i]; i++){
      if(sequence[i] == 'T') sequence[i] = 'U';
      if(sequence[i] == 't') sequence[i] = 'u';
    }
  }
}

PUBLIC void
vrna_seq_toupper(char *sequence){

  unsigned int i;
  if(sequence){
    for(i=0;sequence[i];i++)
      sequence[i] = toupper(sequence[i]);
  }
}

PUBLIC char *
vrna_cut_point_insert(const char *string,
                      int cp){

  char *ctmp;
  int len;

  if(cp > 0){
    len = strlen(string);
    ctmp = (char *)vrna_alloc((len+2) * sizeof(char));
    /* first sequence */
    (void) strncpy(ctmp, string, cp-1);
    /* spacer */
    ctmp[cp-1] = '&';
    /* second sequence */
    (void) strcat(ctmp, string+cp-1);
  } else {
    ctmp = strdup(string);
  }
  return ctmp;
}

PUBLIC char *
vrna_cut_point_remove(const char *string,
                      int *cp){

  char *pos, *copy = NULL;

  *cp = -1;

  if(string){
    copy = (char *) vrna_alloc(strlen(string)+1);
    (void) sscanf(string, "%s", copy);
    pos = strchr(copy, '&');
    if (pos) {
      *cp = (int)(pos - copy) + 1;
      if (*cp >= strlen(copy)) *cp = -1;
      if (strchr(pos+1, '&')) vrna_message_error("more than one cut-point in input");
      for (;*pos;pos++) *pos = *(pos+1); /* splice out the & */
    }
  }

  return copy;
}

#ifdef  VRNA_BACKWARD_COMPAT

/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/

PUBLIC void
str_uppercase(char *sequence){

  vrna_seq_toupper(sequence);
}

PUBLIC void
str_DNA2RNA(char *sequence){

  vrna_seq_toRNA(sequence);
}

PUBLIC char *
random_string(int l, const char symbols[]){

  return vrna_random_string(l, symbols);
}

PUBLIC int
hamming(const char *s1,
        const char *s2){

  return vrna_hamming_distance(s1, s2);
}

PUBLIC int
hamming_bound(const char *s1,
              const char *s2,
              int boundary){

  return vrna_hamming_distance_bound(s1, s2, boundary);
}

#endif

part_func_up.c/ 0           0     0     644     50300     `
/*
                  partiton function for RNA secondary structures

                  Ivo L Hofacker

                  Vienna RNA package
*/
/*
  $Log: part_func_up.c,v $
  Revision 1.4  2008/07/04 14:27:36  ivo
  Modify output (again)

  Revision 1.3  2008/05/08 14:11:55  ivo
  minor output changes

  Revision 1.2  2007/12/13 10:19:54  ivo
  major RNAup update from Ulli

  Revision 1.1  2007/04/30 15:13:13  ivo
  merge RNAup into package

  Revision 1.11  2006/07/17 11:11:43  ulim
  removed all globals from fold_vars.h,c, cleaned code

  Revision 1.10  2006/07/12 09:19:29  ulim
  global variables w, incr3 and incr5 are now local

  Revision 1.9  2006/07/11 12:45:02  ulim
  remove redundancy in function pf_interact(...)

  Revision 1.8  2006/03/08 15:26:37  ulim
  modified -o[1|2], added meaningful default

  Revision 1.5  2006/01/23 11:27:04  ulim
  include file into new package version. cleaned it

  Revision 1.2  2005/07/29 15:13:37  ulim
  put the function, calculating the probability of an unpaired region in
  an RNA and the function calculating the prob. of interaction between 2 RNAs
  in a seperate file (pf_two.c)

  Revision 1.1  2005/07/26 13:27:12  ulim
  Initial revision

  Revision 1.2  2005/07/01 13:14:57  ulim
  fixed error in scaling, included new commandline options -incr5, -incr3 to
  allow a variable number of unpaired positions 5' and 3' of the site of
  interaction between the two RNAs

  Revision 1.1  2005/04/19 08:16:38  ulim
  Initial revision
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <float.h>    /* #defines FLT_MAX ... */
#include <unistd.h>
#include "fold.h"
#include "utils.h"
#include "energy_par.h"
#include "fold_vars.h"
#include "pair_mat.h"
#include "params.h"
#include "part_func.h"
#include "loop_energies.h"
#include "part_func_up.h"
#include "duplex.h"


#define CO_TURN 0
#define ZERO(A) (fabs(A) < DBL_EPSILON)
#define EQUAL(A,B) (fabs((A)-(B)) < 1000*DBL_EPSILON)
#define ISOLATED  256.0
/* #define NUMERIC 1 */

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/
PRIVATE short       *S=NULL, *S1=NULL, *SS=NULL, *SS2=NULL;
PRIVATE vrna_exp_param_t   *Pf = NULL;/* use this structure for all the exp-arrays*/
PRIVATE FLT_OR_DBL  *qb=NULL, *qm=NULL, *prpr=NULL; /* add arrays for pf_unpaired()*/
PRIVATE FLT_OR_DBL  *probs=NULL;
PRIVATE FLT_OR_DBL  *q1k=NULL, *qln=NULL;
PRIVATE double      *qqm2=NULL, *qq_1m2=NULL, *qqm=NULL, *qqm1=NULL;
PRIVATE FLT_OR_DBL  *scale=NULL, *expMLbase=NULL;
PRIVATE char        *ptype=NULL; /* precomputed array of pair types */
PRIVATE int         init_length;  /* length in last call to init_pf_fold()*/
PRIVATE double      init_temp; /* temperature in last call to scale_pf_params */
PRIVATE int         *my_iindx = NULL;
/* make iptypes array for intermolecular constrains (ipidx for indexing)*/


/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/
PRIVATE pu_out      *get_u_vals(pu_contrib *p_c,
                                int **unpaired_values,
                                char *select_contrib);

PRIVATE int         plot_free_pu_out( pu_out* res,
                                      interact *pint,
                                      char *ofile,
                                      char *head);

PRIVATE void        scale_stru_pf_params(unsigned int length);

PRIVATE void        init_pf_two(int length);

PRIVATE void        scale_int(const char *s,
                              const char *sl,
                              double *sc_int);

PRIVATE void        encode_seq( const char *s1,
                                const char *s2);

PRIVATE constrain   *get_ptypes_up(char *S,
                                const char *structure);

PRIVATE void        get_up_arrays(unsigned int length);

PRIVATE void        free_up_arrays(void);

PRIVATE void        set_encoded_seq(const char *sequence,
                                    short **S,
                                    short **S1);

PRIVATE void        get_interact_arrays(unsigned int n1,
                                        unsigned int n2,
                                        pu_contrib *p_c,
                                        pu_contrib *p_c2,
                                        int w,
                                        int incr5,
                                        int incr3,
                                        double ***p_c_S,
                                        double ***p_c2_S);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PUBLIC pu_contrib *get_pu_contrib_struct(unsigned int n, unsigned int w){
  unsigned int i;
  pu_contrib  *pu = (pu_contrib *)vrna_alloc(sizeof(pu_contrib));
  pu->length      = n;
  pu->w           = w;
  /* contributions to probability of being unpaired witihin a(n)
   H hairpin,
   I interior loop,
   M muliloop,
   E exterior loop*/
  /* pu_test->X[i][j] where i <= j and i [1...n], j = [1...w[ */
  pu->H           = (double **)vrna_alloc(sizeof(double *) * (n + 1));
  pu->I           = (double **)vrna_alloc(sizeof(double *) * (n + 1));
  pu->M           = (double **)vrna_alloc(sizeof(double *) * (n + 1));
  pu->E           = (double **)vrna_alloc(sizeof(double *) * (n + 1));
  for(i=0;i<=n;i++){
    pu->H[i]  = (double *)vrna_alloc(sizeof(double) * (w + 1));
    pu->I[i]  = (double *)vrna_alloc(sizeof(double) * (w + 1));
    pu->M[i]  = (double *)vrna_alloc(sizeof(double) * (w + 1));
    pu->E[i]  = (double *)vrna_alloc(sizeof(double) * (w + 1));
  }
  return pu;
}

PUBLIC  void
free_pu_contrib(pu_contrib *pu){

  free_pu_contrib_struct(pu);
}

PUBLIC  void
free_pu_contrib_struct(pu_contrib *pu){

  unsigned int i;
  if(pu != NULL){
    for(i=0;i<=pu->length;i++){
      free(pu->H[i]);
      free(pu->I[i]);
      free(pu->M[i]);
      free(pu->E[i]);
    }
    free(pu->H);
    free(pu->I);
    free(pu->M);
    free(pu->E);
    free(pu);
  }
}

/* you have to call pf_fold(sequence, structure); befor pf_unstru */
PUBLIC pu_contrib *pf_unstru(char *sequence, int w){
  int           n, i, j, v, k, l, o, p, ij, kl, po, u, u1, d, type, type_2, tt;
  unsigned int  size;
  double        temp, tqm2;
  double        qbt1, *tmp, sum_l, *sum_M;
  double        *store_H, *store_Io, **store_I2o; /* hairp., interior contribs */
  double        *store_M_qm_o,*store_M_mlbase;    /* multiloop contributions */
  pu_contrib    *pu_test;

  sum_l           = 0.0;
  temp            = 0;
  n               = (int) strlen(sequence);
  sum_M           = (double *)  vrna_alloc((n+1) * sizeof(double));
  pu_test         = get_pu_contrib_struct((unsigned)n, (unsigned)w);
  size            = ((n+1)*(n+2))>>1;

  get_up_arrays((unsigned) n);
  init_pf_two(n);

  /* init everything */
  for (d=0; d<=TURN; d++)
    for (i=1; i<=n-d; i++){
      j=i+d;
      ij = my_iindx[i]-j;
      if(d < w) {
        pu_test->H[i][d]=pu_test->I[i][d]=pu_test->M[i][d]=pu_test->E[i][d]=0.;
      }
    }


  for (i=0; i<size; i++)
    prpr[i]= probs[i];

  sum_M[0] = 0.;
  for (i=1; i<=n; i++){
    /* set auxillary arrays to 0, reuse qqm and qqm1, reuse qqm2 and qq_1m2*/
    sum_M[i] = qqm[i] = qqm1[i] = qqm2[i] = qq_1m2[i] = 0;
    for (j=i+TURN+1; j<=n; j++){
      ij = my_iindx[i]-j;
      /* i need the part_func of all structures outside bp[ij] */
      if(qb[ij] > 0.0) prpr[ij]= (probs[ij]/qb[ij]);
    }
  }

  /* alloc even more memory */
  store_I2o = (double **)vrna_alloc(sizeof(double *) * (n + 1)); /* for p,k */
  for(i=0;i<=n;i++)
    store_I2o[i] = (double *)vrna_alloc(sizeof(double) * (MAXLOOP + 2));

  /* expMLbase[i-p]*dangles_po */
  store_M_mlbase = (double *)vrna_alloc(sizeof(double) * (size + 1));

  /* 2. exterior bp (p,o) encloses unpaired region [i,i+w[*/
  for (o=TURN+2;o<=n; o++) {
    double sum_h;
    /*allocate space for arrays to store different contributions to H, I & M */
    store_H       = (double *)vrna_alloc(sizeof(double) * (o+2));
    /* unpaired between ]l,o[ */
    store_Io      = (double *)vrna_alloc(sizeof(double) * (o+2));
    /* qm[p+1,i-1]*dangles_po */
    store_M_qm_o  = (double *)vrna_alloc(sizeof(double) * (n+1));

    for (p=o-TURN-1; p>=1; p--) {
      /* construction of partition function of segment [p,o], given that
         an unpaired region [i,i+w[ exists within [p,o] */
      u = o-p-1;
      po = my_iindx[p]-o;
      type = ptype[po];
      if(type){

        /*hairpin contribution*/
        if (((type==3)||(type==4))&&no_closingGU)
          temp = 0.;
        else
          temp = prpr[po] * exp_E_Hairpin(u, type, S1[p+1], S1[o-1], sequence+p-1, Pf) * scale[u+2];
        /* all H contribs are collect for the longest unpaired region */
        store_H[p+1] = temp;

        /* interior loops with interior pair k,l and an unpaired region of
         length w between p and k || l and o*/
        for (k=p+1; k<=MIN2(p+MAXLOOP+1,o-TURN-2); k++) {
          u1    = k-p-1;
          sum_l = 0.;
          for (l=MAX2(k+TURN+1,o-1-MAXLOOP+u1); l<o; l++) {
            kl      = my_iindx[k]-l;
            type_2  = ptype[kl];
            if((l+1) < o) store_Io[l+1] += sum_l;

            temp=0.;
            if (type_2){
              type_2 = rtype[type_2];
              temp = prpr[po] * qb[kl] * exp_E_IntLoop(u1, o-l-1, type, type_2, S1[p+1], S1[o-1], S1[k-1], S1[l+1], Pf) *scale[u1+o-l+1];
              if((l+1) < o) store_Io[l+1] += temp; /* unpaired region between ]l,o[ */
              sum_l += temp;
            } /* end of if pair(k,l) */
          } /* end of l */
          /* unpaired in region ]p,k[  */
          for(i=p+1;i <= k-1;i++)
            store_I2o[i][MIN2(w-1,k-i-1)] += sum_l;
        } /* end of k */
      } /*end of if(type) test for bp (p,o) */

      /* multiple stem loop contribution
         calculate qm2[my_iindx[i]-j] in the course of the calculation
         of the multiple stem loop contribution:
         advantage: you save memory:
         instead of a (n+1)*n array for qqm2 you only need 2*n arrays
         disadvantage: you have to use two times the op-loop for the full
         multiloop contribution
         first op-loop: index o goes from 1...n and
                        index p from o-TURN-1 ... 1
         second op-loop: index o goes from n...1 and
                         index p from o+TURN+1 ... n !!
         HERE index o goes from 1...n and index p o-TURN-1 ... 1 ,
         we calculate the contributions to multiple stem loop
         where exp(i+w-1-p)*(qqm2 values between i+w and o-1)
         AND qm[iindex[p+1]-(i-1)]*exp(beta*w)*qm[iindex[i+w]-(o-1)]
         you have to recalculate of qqm matrix containing final stem
         contributions to multiple loop partition function
         from segment p,o */

      /* recalculate qqm[]
         qqm[p] := (contribution with exact one loop in region (p,o)*/
      qqm[p]  = qqm1[p] * expMLbase[1];
      if(type){
        qbt1    =   qb[po] * exp_E_MLstem(type, (p>1) ? S1[p-1] : -1, (o<n) ? S1[o+1] : -1, Pf);
        qqm[p]  +=  qbt1;
        /* reverse dangles for prpr[po]*... */
        temp    =   0.;
        tt      =   rtype[type];
        temp    =   prpr[po] * exp_E_MLstem(tt, S1[o-1], S1[p+1], Pf) * scale[2] * Pf->expMLclosing;
        for(i=p+1; i < o; i++) {
          int p1i = (p+1) < (i-1)  ? my_iindx[p+1]-(i-1)  : 0;
          /*unpaired region expMLbase[i-p] left of structured
            region qq_1m2[i+1]*/
          /* @expMLbase:  note distance of i-p == i-(p+1)+1 */
          store_M_mlbase[my_iindx[p+1]-i] += expMLbase[i-p] * temp * qq_1m2[i+1];
          /* structured region qm[p1i] left of unpaired region */
          /* contribition for unpaired region is added after the p-loop */
          store_M_qm_o[i] += qm[p1i] * temp;
        } /*end of for i ... */
      }

      for(tqm2 = 0., i=p+1; i < o; i++)
        tqm2  +=  qm[my_iindx[p]-i] * qqm[i+1];

      /* qqm2[p] contrib with at least 2 loops in region (p,o) */
      qqm2[p] = tqm2;
    } /* end for (p=..) */

    for(sum_h = 0., i=1; i < o; i++) {
      int max_v, vo;
      sum_h +=  store_H[i];
      max_v =   MIN2(w-1,o-i-1);
      for(v=max_v; v >= 0; v--){
        /* Hairpins */
        pu_test->H[i][v] += sum_h;/* store_H[i][v] + store_H[i][max_v]; */
        /* Interior loops: unpaired region between  ]l,o[ calculated here !*/
        /* unpaired region between ]p,k[ collected after after o-loop */
        if(v <= MIN2(max_v,MAXLOOP)) {
          pu_test->I[i][v] += store_Io[i]; /* ]l,o[ */
        }
        /* Multiloops:*/
        /* unpaired region [i,v] between structured regions ]p,i[ and ]v,o[. */
        /* store_M_qm_o[i] = part. funct over all structured regions ]p,i[ */
        vo = (i+v+1) <= (o-1) ? my_iindx[i+v+1]-(o-1): 0;
        pu_test->M[i][v] += store_M_qm_o[i]*expMLbase[v+1]*qm[vo];
      }
    }
    tmp = qqm1; qqm1=qqm; qqm=tmp;
    tmp = qqm2; qqm2=qq_1m2; qq_1m2=tmp;

    free(store_Io);
    free(store_H);
    free(store_M_qm_o);
  }/* end for (o=..) */

  for(i=1; i < n; i++) {
    int     max_v;
    double  sum_iv;
    sum_iv  = 0.;
    max_v   = MIN2(w-1,n-i);
    for(v=n; v >=0; v--) {
      if(v <= MIN2(max_v,MAXLOOP)) {
        /* all unpaired regions [i,v] between p and k in interior loops */
        /* notice v runs from max_v -> 0, sum_iv sums all int. l. contribs */
        /* for each x, v < x =< max_v, since they contribute to [i,v] */
        sum_iv            += store_I2o[i][v];
        pu_test->I[i][v]  += sum_iv;
      }
      /* all unpaired region [i,v] for a fixed v, given that */
      /* region ]v,o[ contains at least 2 structures qq_1m2[v+1]; */
      if(v >= i) {
        sum_M[v] += store_M_mlbase[my_iindx[i]-v];
        if(v-i<=max_v) {
          pu_test->M[i][v-i] += sum_M[v];
        }
      }
    }
  }

  for(i=0;i<=n;i++) {
    free(store_I2o[i]);
  }
  free(store_I2o);

  for (i=1; i<=n; i++) {
    /* set auxillary arrays to 0 */
    qqm[i] = qqm1[i] = qqm2[i] = qq_1m2[i] = 0;
  }

  /* 2. exterior bp (p,o) encloses unpaired region [i,j]
     HERE index o goes from n...1 and index p from o+TURN+1 ... n,
     that is, we add the one multiloop contribution that we
     could not calculate before  */

/* is free'ing plus allocating faster than looping over all entries an setting them to 0? */
#if 0
  free(store_M_mlbase);
  store_M_mlbase = (double *) vrna_alloc(sizeof(double) * (size + 1));
#else
  /* this should be the fastest way to set everything to 0 */
  memset(store_M_mlbase, 0, sizeof(double) * (size + 1));
#endif

  for (o=n-TURN-1;o>=1; o--) {
    for (p=o+TURN+1; p<=n; p++) {
      po    = my_iindx[o]-p;
      type  = ptype[po];
      /* recalculate of qqm matrix containing final stem
         contributions to multiple loop partition function
         from segment [o,p] */
      qqm[p] = qqm1[p] * expMLbase[1];
      if (type) {
        qbt1 = qb[po];
        qbt1 *= exp_E_MLstem(type, (o>1) ? S1[o-1] : -1, (p<n) ? S1[p+1] : -1, Pf);
        qqm[p] += qbt1;
        /* revers dangles for prpr[po]...  */
        temp=0.;
        tt=rtype[type];
        temp = prpr[po]*exp_E_MLstem(tt, S1[p-1], S1[o+1], Pf) * Pf->expMLclosing * scale[2];
      }
      tqm2=0.;
      for(i=o+1; i < p; i++) {
        tqm2+=qqm[i]*qm[my_iindx[i+1]-p];

        if(type !=0) {
          /* structured region qq_1m2[i-1] left of unpaired r. expMLbase[p-i]*/
          /* @expMLbase:  note distance of p-i == p+1-i+1 */
           store_M_mlbase[my_iindx[i]-p+1] +=  qq_1m2[i-1]*expMLbase[p-i]*temp;
        }
      }/*end of for i ....*/
      qqm2[p] = tqm2;
    }/* end for (p=..) */
    tmp = qqm1; qqm1=qqm; qqm=tmp;
    tmp = qqm2; qqm2=qq_1m2; qq_1m2=tmp;
  }/* end for (o=..) */
  /* now collect the missing multiloop contributions */
  for(i=0;i<=n;i++) { sum_M[i]=0.; }
  for(i=1; i<=n;i++) {
    int v_max = MIN2(w-1,n-i);
    for(v=n; v>=i; v--){
      sum_M[i]  += store_M_mlbase[my_iindx[i]-v];
      if ((v-i <= v_max) ) {
        pu_test->M[i][v-i] += sum_M[i];
      }
    }
  }

  /* 1. region [i,j] exterior to all loops */
  for (i=1; i<=n; i++) {
    for(j=i; j<MIN2(i+w,n+1);j++){
      ij=my_iindx[i]-j;
      temp=q1k[i-1]*1*scale[j-i+1]*qln[j+1]/q1k[n];
      pu_test->E[i][j-i]+=temp;

    }
  }

  free(sum_M);
  free(store_M_mlbase);
  free_up_arrays();
  return pu_test;
}


PRIVATE void  get_interact_arrays(unsigned int n1,
                                  unsigned int n2,
                                  pu_contrib *p_c,
                                  pu_contrib *p_c2,
                                  int w,
                                  int incr5,
                                  int incr3,
                                  double ***p_c_S,
                                  double ***p_c2_S){

  unsigned int i;
  int pc_size, j;
  *p_c_S = (double **)vrna_alloc(sizeof(double *)*(n1+1));

  for (i=1; i<=n1; i++){
    pc_size = MIN2((w + incr5 + incr3), (int)n1);
    (*p_c_S)[i] = (double *)vrna_alloc(sizeof(double) * (pc_size + 1));
    for (j=0; j < pc_size; j++)
      (*p_c_S)[i][j] = p_c->H[i][j] + p_c->I[i][j] + p_c->M[i][j] + p_c->E[i][j];
  }

  if(p_c2 != NULL){
    (*p_c2_S) = (double **)vrna_alloc(sizeof(double *) * (n2 + 1));
    for (i=1; i<=n2; i++){
      pc_size = MIN2(w, (int)n2);
      (*p_c2_S)[i]  = (double *)vrna_alloc(sizeof(double) * (pc_size + 2));
      for (j=0; j < pc_size; j++)
        (*p_c2_S)[i][j] = p_c2->H[i][j] + p_c2->I[i][j] + p_c2->M[i][j] + p_c2->E[i][j];
    }
  }
}

/*------------------------------------------------------------------------*/
/* s1 is the longer seq */
PUBLIC interact *pf_interact( const char *s1,
                              const char *s2,
                              pu_contrib *p_c,
                              pu_contrib *p_c2,
                              int w,
                              char *cstruc,
                              int incr3,
                              int incr5){

  int         i, j, k,l,n1,n2,add_i5,add_i3, pc_size;
  double      temp, Z, rev_d, E, Z2,**p_c_S, **p_c2_S, int_scale;
  FLT_OR_DBL  ****qint_4, **qint_ik;
  /* PRIVATE double **pint; array for pf_up() output */
  interact    *Int;
  double      G_min, G_is,Gi_min;
  int         gi,gj,gk,gl,ci,cj,ck,cl,prev_k,prev_l;
  FLT_OR_DBL  **int_ik;
  double      Z_int, temp_int, temppfs;
  double      const_scale, const_T;
  constrain   *cc = NULL;  /* constrains for cofolding */
  char        *Seq, *i_long,*i_short,*pos=NULL; /* short seq appended to long one */
  /* int ***pu_jl; */ /* positions of interaction in the short RNA */

  G_min = G_is = Gi_min = 100.0;
  gi = gj = gk = gl = ci = cj = ck = cl = 0;

  n1      = (int) strlen(s1);
  n2      = (int) strlen(s2);
  prev_k  = 1;
  prev_l  = n2;

  i_long  = (char *) vrna_alloc(sizeof(char)*(n1+1));
  i_short = (char *) vrna_alloc(sizeof(char)*(n2+1));
  Seq     = (char *) vrna_alloc(sizeof(char)*(n1+n2+2));

  strcpy(Seq,s1);
  strcat(Seq,s2);

  set_encoded_seq(s1, &S, &S1);
  set_encoded_seq(s2, &SS, &SS2);

  cc = get_ptypes_up(Seq,cstruc);

  get_interact_arrays(n1, n2, p_c, p_c2, w, incr5, incr3, &p_c_S, &p_c2_S);

  /*array for pf_up() output */
  Int = (interact *) vrna_alloc(sizeof(interact)*1);
  Int->Pi = (double *) vrna_alloc(sizeof(double)*(n1+2));
  Int->Gi = (double *) vrna_alloc(sizeof(double)*(n1+2));

  /* use a different scaling for pf_interact*/
  scale_int(s2, s1, &int_scale);

  /* set the global scale array and the global variable pf_scale to the
     values used to scale the interaction, keep their former values !! */
  temppfs = pf_scale;
  pf_scale = int_scale;

  /* in order to scale expLoopEnergy correctly call*/
  /* we also pass twice the seq-length to avoid bogus access to scale[] array */
  scale_stru_pf_params((unsigned) 2*n1);

  qint_ik = (FLT_OR_DBL **) vrna_alloc(sizeof(FLT_OR_DBL *) * (n1+1));
  for (i=1; i<=n1; i++) {
    qint_ik[i] = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL) * (n1+1));
  }
/* int_ik */
  int_ik = (FLT_OR_DBL **) vrna_alloc(sizeof(FLT_OR_DBL *) * (n1+1));
  for (i=1; i<=n1; i++) {
    int_ik[i] = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL) * (n1+1));
  }
  Z_int=0.;
  /*  Gint = ( -log(int_ik[gk][gi])-( ((int) w/2)*log(pf_scale)) )*((Pf->temperature+K0)*GASCONST/1000.0); */
  const_scale = ((int) w/2)*log(pf_scale);
  const_T = (Pf->kT/1000.0);
  encode_seq(s1, s2);
  /* static  short *S~S1, *S1~SS1, *SS~S2, *SS2; */
  for (i=0; i<=n1; i++) {
    Int->Pi[i]=Int->Gi[i]=0.;
  }
  E=0.;
  Z=0.;

  if ( fold_constrained && cstruc != NULL) {
    pos = strchr(cstruc,'|');
    if(pos) {
      ci=ck=cl=cj=0;
      /* long seq              & short seq
         .........||..|||||....&....||||...  w = maximal interaction length
                 ck       ci       cj  cl    */
      strncpy(i_long,cstruc,n1);
      i_long[n1] = '\0';
      strncpy(i_short,&cstruc[n1],n2);
      i_short[n2] ='\0';
      pos = strchr(i_long,'|');
      if(pos) ck = (int) (pos-i_long)+1; /* k */
      pos = strrchr(i_long,'|');
      if(pos) ci = (int) (pos-i_long)+1; /* i */
      pos = strrchr(i_short,'|');
      if(pos) cl = (int) (pos-i_short)+1; /* l */
      pos = strchr(i_short,'|');
      if(pos) cj = (int) (pos-i_short)+1; /* j */

      if(ck > 0 && ci > 0 && ci-ck+1 > w) {
        fprintf(stderr, "distance between constrains in longer seq, %d, larger than -w = %d",ci-ck+1,w);
        vrna_message_error("pf_interact: could not satisfy all constraints");
      }
      if(cj > 0 && cl > 0 && cl-cj+1 > w) {
        fprintf(stderr, "distance between constrains in shorter seq, %d, larger than -w = %d",cl-cj+1,w);
        vrna_message_error("pf_interact: could not satisfy all constraints");
      }
    }

  } else if ( fold_constrained && cstruc == NULL) {
    vrna_message_error("option -C selected, but no constrained structure given\n");
  }
  if(fold_constrained) pos = strchr(cstruc,'|');

  /*  qint_4[i][j][k][l] contribution that region (k-i) in seq1 (l=n1)
      is paired to region (l-j) in seq 2(l=n2) that is
      a region closed by bp k-l  and bp i-j */
  qint_4 = (FLT_OR_DBL ****) vrna_alloc(sizeof(FLT_OR_DBL ***) * (n1+1));

  /* qint_4[i][j][k][l] */
  for (i=1; i<=n1; i++) {
    int end_k;
    end_k = i-w;
    if(fold_constrained && pos && ci) end_k= MAX2(i-w, ci-w);
    /* '|' constrains for long sequence: index i from 1 to n1 (5' to 3')*/
    /* interaction has to include 3' most '|' constrain, ci */
    if(fold_constrained && pos && ci && i==1 && i<ci)
      i= ci-w+1 > 1 ? ci-w+1 : 1;
    /* interaction has to include 5' most '|' constrain, ck*/
    if(fold_constrained && pos && ck && i > ck+w-1) break;

    /* note: qint_4[i] will be freed before we allocate qint_4[i+1] */
    qint_4[i] = (FLT_OR_DBL ***) vrna_alloc(sizeof(FLT_OR_DBL **) * (n2+1));
    for (j=n2; j>0; j--) {
      qint_4[i][j] = (FLT_OR_DBL **) vrna_alloc(sizeof(FLT_OR_DBL*) * (w+1));
      for (k=0; k<=w; k++) {
        qint_4[i][j][k] = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL) * (w+1));
      }
    }

     prev_k=1;
    for (j=n2; j>0; j--) {
      int type, type2,end_l;
      end_l = j+w;
      if(fold_constrained && pos && ci) end_l= MIN2(cj+w,j+w);
      /* '|' constrains for short sequence: index j from n2 to 1 (3' to 5')*/
      /* interaction has to include 5' most '|' constrain, cj */
      if(fold_constrained && pos && cj && j==n2 && j>cj)
        j = cj+w-1 > n2 ? n2 : cj+w-1;
      /* interaction has to include 3' most '|' constrain, cl*/
      if(fold_constrained && pos && cl && j < cl-w+1) break;
      type = cc->ptype[cc->indx[i]-(n1+j)];
      qint_4[i][j][0][0] = type ? Pf->expDuplexInit : 0;

      if (!type) continue;
      qint_4[i][j][0][0] *= exp_E_ExtLoop(type, (i>1) ? S1[i-1] : -1, (j<n2) ? SS2[j+1] : -1, Pf);

      rev_d = exp_E_ExtLoop(rtype[type], (j>1) ? SS2[j-1] : -1, (i<n1) ? S1[i+1] : -1, Pf);

      /* add inc5 and incr3 */
      if((i-incr5) > 0 ) add_i5=i-incr5;
      else add_i5=1;
      add_i3=incr3;
      pc_size = MIN2((w+incr3+incr5),n1);
      if(incr3 < pc_size) add_i3=incr3;
      else add_i3=pc_size-1;

      /* only one bp (no interior loop) */
      if(p_c2 == NULL) {/* consider only structure of longer seq. */
        qint_ik[i][i]+=qint_4[i][j][0][0]*rev_d*p_c_S[add_i5][add_i3]*scale[((int) w/2)];
        Z+=qint_4[i][j][0][0]*rev_d*p_c_S[add_i5][add_i3]*scale[((int) w/2)];
      } else {/* consider structures of both seqs. */
        qint_ik[i][i]+=qint_4[i][j][0][0]*rev_d*p_c_S[add_i5][add_i3]*p_c2_S[j][0]*scale[((int) w/2)];
        Z+=qint_4[i][j][0][0]*rev_d*p_c_S[add_i5][add_i3]*p_c2_S[j][0]*scale[((int) w/2)];
      }

/* int_ik */
      /* check deltaG_ges = deltaG_int + deltaG_unstr; */
      int_ik[i][i]+=qint_4[i][j][0][0]*rev_d*scale[((int) w/2)];
      Z_int+=qint_4[i][j][0][0]*rev_d*scale[((int) w/2)];
      temp_int=0.;

      temp=0.;
      prev_l = n2;
      for (k=i-1; k>end_k && k>0; k--) {
        if (fold_constrained && pos && cstruc[k-1] == '|' && k > prev_k)
          prev_k=k;
        for (l=j+1; l< end_l && l<=n2; l++) {
          int a,b,ia,ib,isw;
          double scalew, tt, intt;

          type2 = cc->ptype[cc->indx[k]-(n1+l)];
          /* '|' : l HAS TO be paired: not pair (k,x) where x>l allowed */
          if(fold_constrained && pos && cstruc[n1+l-1] == '|' && l < prev_l)
            prev_l=l; /*break*/
          if(fold_constrained && pos && (k<=ck || i>=ci) && !type2) continue;
          if(fold_constrained && pos && ((cstruc[k-1] == '|') || (cstruc[n1+l-1] == '|')) && !type2) break;

          if (!type2) continue;
          /* to save memory keep only qint_4[i-w...i][][][] in memory
             use indices qint_4[i][j][a={0,1,...,w-1}][b={0,1,...,w-1}] */
          a=i-k;/* k -> a from 1...w-1*/
          b=l-j;/* l -> b from 1...w-1 */

          /* scale everything to w/2 */
          isw = ((int) w/2);
          if ((a+b) < isw ){
            scalew = ( scale[isw - (a+b)] );
          } else if ( (a+b) > isw ) {
            scalew = 1/( scale[(a+b) - isw] );
          } else {
            scalew = 1;
          }

          if (i-k+l-j-2<=MAXLOOP) {
            if(k >= prev_k && l <= prev_l) { /* don't violate constrains */
              E = exp_E_IntLoop(i-k-1,l-j-1, type2, rtype[type],
                                S1[k+1], SS2[l-1], S1[i-1], SS2[j+1], Pf) *
                                scale[i-k+l-j]; /* add *scale[u1+u2+2] */

              qint_4[i][j][a][b] += ( qint_4[k][l][0][0]*E);

              /* use ia and ib to go from a....w-1 and from b....w-1  */
              ia=ib=1;
              while((a+ia)<w && i-(a+ia)>=1 && (b+ib)<w && (j+b+ib)<=n2) {
                int iaa,ibb;

                qint_4[i][j][a+ia][b+ib] += qint_4[k][l][ia][ib]*E;

                iaa=ia+1;
                while(a+iaa<w && i-(a+iaa)>=1) {
                  qint_4[i][j][a+iaa][b+ib] += qint_4[k][l][iaa][ib]*E;
                  ++iaa;
                }

                ibb=ib+1;
                while( (b+ibb)<w && (j+b+ibb)<=n2 ) {
                  qint_4[i][j][a+ia][b+ibb] += qint_4[k][l][ia][ibb]*E;
                  ++ibb;
                }
                ++ia;
                ++ib;
              }
            }
          }
          /* '|' constrain in long sequence */
          /* collect interactions starting before 5' most '|' constrain */
          if ( fold_constrained && pos && ci && i < ci) continue;
          /* collect interactions ending after 3' most '|' constrain*/
          if ( fold_constrained && pos && ck &&  k > ck) continue;
          /* '|' constrain in short sequence */
          /* collect interactions starting before 5' most '|' constrain */
          if ( fold_constrained && pos && cj && j > cj) continue;
          /* collect interactions ending after 3' most '|' constrain*/
          if ( fold_constrained && pos && cl && l < cl) continue;

          /* scale everything to w/2*/
          /* qint_ik[k][i] all interactions where k and i both are paired */
          /* substract incr5 from k */
          if(k-incr5 > 0) add_i5=k-incr5;
          else add_i5=1;
          /* add incr3 to i */
          pc_size = MIN2((w+incr3+incr5),n1);
          if(i-k+incr3 < pc_size) add_i3=i-k+incr3;
          else add_i3=pc_size-1;

          if(p_c2 == NULL) {/* consider only structure of longer seq. */
            tt = qint_4[i][j][a][b]*p_c_S[add_i5][add_i3]*scalew*rev_d;
          } else { /* consider structures of both seqs. */
            tt = qint_4[i][j][a][b]*p_c_S[add_i5][add_i3]*p_c2_S[j][b]*scalew*rev_d;
          }
          temp+= tt;
          qint_ik[k][i]+= tt;
          /* int_ik */
          /* check deltaG_ges = deltaG_int + deltaG_unstr; */
          intt = qint_4[i][j][a][b]*scalew*rev_d;
          temp_int += intt;
          int_ik[k][i]+= intt;
          G_is = (-log(tt)-const_scale)*(const_T);
          if (G_is < G_min || EQUAL(G_is,G_min)) {
            G_min = G_is;
            Gi_min =(-log(intt)-const_scale)*(const_T);
            gi=i;
            gj=j;
            gk=k;
            gl=l;
          }
        }
      }
      Z+=temp;
      /* int_ik */
      Z_int+=temp_int;
    }

    /* free qint_4 values not needed any more */
    if(i > w) {
      int bla;
      bla=i-w;
      if (fold_constrained && pos && ci && i-w < ci-w+1) continue;
      if (fold_constrained && pos && ci) bla = MAX2(ci-w+1,i-w);
      for (j=n2; j>0; j--) {
        for (k=0; k<=w; k++){
          free(qint_4[bla][j][k]);
        }
        free(qint_4[bla][j]);
      }
      free(qint_4[bla]);
      qint_4[bla] = NULL;
    }
  }


  Z2=0.0;
  for (i=1; i<=n1; i++) {
    for (k=i; k<=n1 && k<i+w; k++) {
      Z2+=qint_ik[i][k];
      for(l=i;l<=k;l++) {
        /* Int->Pi[l]: prob that position l is within a paired region */
        /* qint_ik[i][k] as well as Z are scaled to scale[((int) w/2) */
        Int->Pi[l]+=qint_ik[i][k]/Z;
        /* Int->Gi[l]: minimal delta G at position [l] */
        Int->Gi[l]=MIN2(Int->Gi[l],
                       ( -log(qint_ik[i][k])-( ((int) w/2)*log(pf_scale)) )*
                       (Pf->kT/1000.0) );
      }
    }
  }
  if(n1 > w){
    int start_i,end_i;
    start_i = n1-w+1;
    end_i=n1;
    if (fold_constrained && pos && ci) {
      /* a break in the k loop might result in unfreed values */
      start_i = ci-w+1 < n1-w+1 ? ci-w+1 : n1-w+1;
      start_i = start_i > 0 ? start_i : 1;
      /* start_i = ck; */
      end_i = ck+w-1 > n1 ? n1 : ck+w-1;
    }
    for (i=start_i; i<=end_i; i++) {
      if(qint_4[i] == NULL ) continue;
      for (j=n2; j>0; j--) {
        for (k=0; k<=w; k++) {
          free(qint_4[i][j][k]);
        }
        free(qint_4[i][j]);
      }
      free(qint_4[i]);
    }
    free(qint_4);
  } else {
    int start_i,end_i;
    start_i = 1;
    end_i=n1;
    if (fold_constrained && pos) {
      start_i = ci-w+1 > 0 ? ci-w+1 : 1;
      end_i = ck+w-1 > n1 ? n1 : ck+w-1;
    }

    for (i=start_i; i<=end_i; i++) {
      for (j=n2; j>0; j--) {
        for (k=0; k<=w; k++) {
          free(qint_4[i][j][k]);
        }
        free(qint_4[i][j]);
      }
      free(qint_4[i]);
    }
    free(qint_4);
  }
  if(fold_constrained && (gi==0 || gk==0 ||  gl==0 || gj==0)) {
    vrna_message_error("pf_interact: could not satisfy all constraints");
  }
  /* fill structure interact */
  Int->length = n1;
  Int->i = gi;
  Int->j = gj;
  Int->k = gk;
  Int->l = gl;
  Int->Gikjl = G_min;
  Int->Gikjl_wo = Gi_min;

  free(i_long);
  free(i_short);

  for (i=1; i<=n1; i++) {
    free(int_ik[i]);
  }
  free(int_ik);
  for (i=1; i<=n1; i++) {
    free(qint_ik[i]);
  }
  free(qint_ik);

  /* reset the global variables pf_scale and scale to their original values */
  pf_scale = temppfs;/* reset pf_scale */
  scale_stru_pf_params((unsigned) n1);/* reset the scale array */
  free_pf_arrays(); /* for arrays for pf_fold(...) */

  if(expMLbase != NULL) {
    free(expMLbase);
    expMLbase = NULL;
  }
  if(scale != NULL) {
    free(scale);
    scale = NULL;
  }
  for (i=1; i<=n1; i++) {
    free(p_c_S[i]);
  }
  free(p_c_S);
  if(p_c2 != NULL) {
    for (i=1; i<=n2; i++) {
      free(p_c2_S[i]);
    }
    free(p_c2_S);
  }
  free(Seq);
  free(cc->indx);
  free(cc->ptype);
  free(cc);
  return(Int);
}
/*------------------------------------------------------------------------*/
/* use an extra scale for pf_interact, here sl is the longer sequence */
PRIVATE void scale_int(const char *s, const char *sl, double *sc_int){
  int       n,nl;
  duplexT   mfe;
  double    kT;

  n         = strlen(s);
  nl        = strlen(sl);

  free(expMLbase);
  free(scale);

  expMLbase = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*((nl+1)*2));
  scale     = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*((nl+1)*2));

  /* use RNA duplex to get a realistic estimate for the best possible
     interaction energy between the short RNA s and its target sl */
  mfe = duplexfold(s,sl);

  kT = Pf->kT/1000.0;   /* in Kcal */

  /* sc_int is similar to pf_scale: i.e. one time the scale */
  *sc_int = exp(-(mfe.energy)/kT/n);

  /* free the structure returned by duplexfold */
  free(mfe.structure);
}

/*----------------------------------------------------------------------*/
/* init_pf_two(n) :gets the arrays, that you need, from part_func.c */
/* get_pf_arrays(&S, &S1, &ptype, &qb, &qm, &q1k, &qln);*/
/* init_pf_fold(), update_pf_params, encode_char(), make_ptypes() are called by pf_fold() */
PRIVATE void init_pf_two(int length){
#ifdef SUN4
  nonstandard_arithmetic();
#else
#ifdef HP9
  fpsetfastmode(1);
#endif
#endif
  make_pair_matrix();

  /* gets the arrays, that we need, from part_func.c */
  if(!get_pf_arrays(&S, &S1, &ptype, &qb, &qm, &q1k, &qln))
    vrna_message_error("init_pf_two: pf_fold() has to be called before calling pf_unstru()\n");
  /* get a pointer to the base pair probs */
  probs = export_bppm();

  scale_stru_pf_params((unsigned) length);

  init_length=length;
  if(init_temp != Pf->temperature)
    vrna_message_error("init_pf_two: inconsistency with temperature");
}

PRIVATE void  get_up_arrays(unsigned int length){
  unsigned int l1 = length + 1;
  unsigned int l2 = length + 2;
  prpr      = (FLT_OR_DBL *)vrna_alloc(sizeof(FLT_OR_DBL)  * ((l1*l2)>>1));
  expMLbase = (FLT_OR_DBL *)vrna_alloc(sizeof(FLT_OR_DBL)  * l2);
  scale     = (FLT_OR_DBL *)vrna_alloc(sizeof(FLT_OR_DBL)  * l2);
  qqm2      = (double *)    vrna_alloc(sizeof(double)      * l2);
  qq_1m2    = (double *)    vrna_alloc(sizeof(double)      * l2);
  qqm       = (double *)    vrna_alloc(sizeof(double)      * l2);
  qqm1      = (double *)    vrna_alloc(sizeof(double)      * l2);
  my_iindx  = vrna_idx_row_wise(length);
}

PRIVATE void  free_up_arrays(void){
  if(prpr       != NULL){ free(prpr);       prpr      = NULL;}
  if(expMLbase  != NULL){ free(expMLbase);  expMLbase = NULL;}
  if(scale      != NULL){ free(scale);      scale     = NULL;}
  if(qqm        != NULL){ free(qqm);        qqm       = NULL;}
  if(qqm1       != NULL){ free(qqm1);       qqm1      = NULL;}
  if(qqm2       != NULL){ free(qqm2);       qqm2      = NULL;}
  if(qq_1m2     != NULL){ free(qq_1m2);     qq_1m2    = NULL;}
  if(my_iindx   != NULL){ free(my_iindx);   my_iindx  = NULL;}
}

PUBLIC void free_interact(interact *pin) {
  if(S != NULL && pin != NULL){
    free(S);
    S=NULL;
  }
  if(S1 != NULL && pin != NULL){
    free(S1);
    S1=NULL;
  }
  if(pin != NULL){
    free(pin->Pi);
    free(pin->Gi);
    free(pin);
    pin=NULL;
  }
}
/*---------------------------------------------------------------------------*/

PRIVATE void encode_seq(const char *s1, const char *s2) {
  unsigned int i,l;

  l = strlen(s1);
  /* S and S1 are freed by free_pf_arrays(); ! */
  S = (short *) vrna_alloc(sizeof(short)*(l+1));
  S1= (short *) vrna_alloc(sizeof(short)*(l+1));
  /* S1 exists only for the special X K and I bases and energy_set!=0 */
  S[0] = l;
  for (i=1; i<=l; i++) { /* make numerical encoding of sequence */
    S[i]= (short) encode_char(toupper(s1[i-1]));
    S1[i] = alias[S[i]];   /* for mismatches of nostandard bases */
  }
  if(s2 != NULL) {
    l = strlen(s2);
    /* SS2 exists only for the special X K and I bases and energy_set!=0 */
    SS[0] = l;
    for (i=1; i<=l; i++) { /* make numerical encoding of sequence */
      SS[i]= (short) encode_char(toupper(s2[i-1]));
      SS2[i] = alias[SS[i]];   /* for mismatches of nostandard bases */
    }
  }
}

/*-------------------------------------------------------------------------*/
 /* scale energy parameters and pre-calculate Boltzmann weights:
  most of this is done in structure Pf see params.c,h (function:
  get_scaled_pf_parameters(), only arrays scale and expMLbase are handled here*/
PRIVATE void scale_stru_pf_params(unsigned int length)
{
  unsigned int i;
  double  kT;


  /* Do this only at the first call for get_scaled_pf_parameters()
     and/or if temperature has changed*/
  if(init_temp != temperature) {
    if(Pf) free(Pf);
    vrna_md_t   md;
    set_model_details(&md);
    Pf=vrna_exp_params(&md);
  }

  init_temp = Pf->temperature;

  kT = Pf->kT;   /* kT in cal/mol  */

   /* scaling factors (to avoid overflows) */
  if (pf_scale == -1) { /* mean energy for random sequences: 184.3*length cal */
    pf_scale = exp(-(-185+(Pf->temperature-37.)*7.27)/kT);
    if (pf_scale<1) pf_scale=1;
  }
  Pf->pf_scale = pf_scale;
  scale[0] = 1.;
  scale[1] = 1./pf_scale;
  expMLbase[0] = 1;
  expMLbase[1] = Pf->expMLbase/pf_scale;
  for (i=2; i<=length+1; i++) {
    scale[i] = scale[i/2]*scale[i-(i/2)];
    expMLbase[i] = pow(Pf->expMLbase, (double)i) * scale[i];
  }
}
/*-------------------------------------------------------------------------*/
/* make a results structure containing all u-values & the header */
PUBLIC pu_out *get_u_vals(pu_contrib *p_c, int **unpaired_values, char *select_contrib) {
  int i, j, k, l, num_u_vals,count,contribs,size,w,len;
  int S,E,H,I,M;
  int off_S, off_E, off_H, off_I, off_M;
  /* double **p_cont,**p_cont_sh, dG_u; p_u AND its contributions */
  pu_out* u_results;

  len = p_c->length;

  /* number of different -u values */
  for (num_u_vals = 0, i = 1; i <= unpaired_values[0][0]; i++) {
    j = unpaired_values[i][0];
    do num_u_vals++; while(++j <= unpaired_values[i][1]);
  }
  /* check which contributions ([-c "SHIME"] ) are desired by the user,
     set the offset for each contribution */
  contribs = 0;
  S = E = H = I = M = 0;
  off_S = off_E = off_H = off_I = off_M = 0;
  if(strchr(select_contrib, 'S')) {
    S=1;
    off_S = contribs;
    ++contribs;
  }
  if(strchr(select_contrib, 'E')) {
    E=1;
    off_E = contribs;
    ++contribs;
  }
  if(strchr(select_contrib, 'H')) {
    H=1;
    off_H = contribs;
    ++contribs;
  }
  if(strchr(select_contrib, 'I')) {
    I=1;
    off_I = contribs;
    ++contribs;
  }
  if(strchr(select_contrib, 'M')) {
    M=1;
    off_M = contribs;
    ++contribs;
  }

  if(contribs > 5) {
    vrna_message_error("get_u_vals: error with contribs!");
  }
  /* allocate the results structure */
  u_results = (pu_out *) vrna_alloc(1*sizeof(pu_out));
  u_results->len = len; /* sequence length */
  /*num_u_vals differnet -u values, contribs [-c "SHIME"] */
  u_results->u_vals = num_u_vals;
  u_results->contribs = contribs;
  /* add 1 column for position within the sequence and
     add 1 column for the free energy of interaction values */
  /* header e.g. u3I (contribution for u3 interior loops */
  size = 1 + (num_u_vals*contribs) + 1;
  u_results->header = (char **) vrna_alloc((size+1)*sizeof(char*));
  for(i=0;i<(size+1);i++){
    u_results->header[i] = (char *) vrna_alloc(10*sizeof(char));
  }
  /* different free energies for all  -u and -c combinations */
  u_results->u_values = (double**) vrna_alloc((size+1) *sizeof(double*));
  for(i=0;i<(size+1);i++){
    /* position within the sequence  */
    u_results->u_values[i] = (double*) vrna_alloc((len+3)*sizeof(double));
  }
  /* write the position within the sequence in the u_results array
     at column zerro */
  sprintf(u_results->header[0],"pos");
  for(i=0;i<=len;i++){
    /* add the position*/
    u_results->u_values[0][i] = i;
  }
  /* go over the different -u values, u_vals[] listy of different -u values*/
  for (count = k = 1; k <= unpaired_values[0][0]; k++) {
    l = unpaired_values[k][0];
    do{
      int offset; /* offset for the respective -u value (depents on the number
                   of the -u value and on the numbers of contribs */

      offset = ((count - 1) * contribs) + 1; /* first colum is the position */
      /* set the current value of -u : here we call it w */
      w = l; /* set w to the actual -u value */
      if(w > len) break; /* corr caro */
      /* make the header - look which contribitions are wanted */
      if(S) sprintf(u_results->header[offset+off_S],"u%dS",w);
      if(E) sprintf(u_results->header[offset+off_E],"u%dE",w);
      if(H) sprintf(u_results->header[offset+off_H],"u%dH",w);
      if(I) sprintf(u_results->header[offset+off_I],"u%dI",w);
      if(M) sprintf(u_results->header[offset+off_M],"u%dM",w);

      if(p_c != NULL) {
        for (i=1; i<=len; i++) { /* for each position */
          /* w goes form j to i (intervall end at i) */
          for (j=i; j < MIN2((i+w),len+1); j++) { /* for each -u value < w
                                                this is not necessay ->
                                                calculate j from i and w
                                                : (j-i+1) == w */
            double blubb;
            /* if (j-i+1) == w we have the -u = w value wanted */
            if( (j-i+1) == w && i+w-1 <= len) {
              blubb = p_c->H[i][j-i]+p_c->I[i][j-i]+p_c->M[i][j-i]+p_c->E[i][j-i];

              /* printf("len %d  blubb %.3f \n",len, blubb); */
              if(S) u_results->u_values[offset+off_S][i+w-1]+=blubb;
              if(E) u_results->u_values[offset+off_E][i+w-1]+=p_c->E[i][j-i];
              if(H) u_results->u_values[offset+off_H][i+w-1]+=p_c->H[i][j-i];
              if(I) u_results->u_values[offset+off_I][i+w-1]+=p_c->I[i][j-i];
              if(M) u_results->u_values[offset+off_M][i+w-1]+=p_c->M[i][j-i];

            }
            if(i<w && (j-i+1) != w && i+w-1 > len &&  i+w-1 < len+3) {
              if(S) u_results->u_values[offset+off_S][i+w-1]=-1;
              if(E) u_results->u_values[offset+off_E][i+w-1]=-1;
              if(H) u_results->u_values[offset+off_H][i+w-1]=-1;
              if(I) u_results->u_values[offset+off_I][i+w-1]=-1;
              if(M) u_results->u_values[offset+off_M][i+w-1]=-1;
            }
          }
        }
      } else return(NULL); /* error */
      count++;
    } while(++l <= unpaired_values[k][1]);
  }
  return(u_results); /*success*/
}
/* plot the results structure */
/* when plotting the results for the target seq we add a header */
/* when plotting the results for the interaction partner u want no header,
   set s1 to NULL to avoid plotting the header */
/* currently we plot the free energies to a file: the probability of
   being unpaired for region [i,j], p_u[i,j], is related to the free
   energy to open region [i,j], dG_u[i,j] by:
   dG_u[i,j] = -log(p_u[i,j])*(temperature+K0)*GASCONST/1000.0; */
PUBLIC int plot_free_pu_out(pu_out* res, interact *pint, char *ofile, char *head) {
  int size,s,i,len;
  double dG_u;
  char nan[4], *time, dg[11];
  FILE *wastl;
  double  kT = Pf->kT;
  wastl = fopen(ofile,"a");
  if (wastl==NULL) {
    fprintf(stderr, "p_cont: can't open %s for Up_plot\n", ofile);
    return(0);
  }
  sprintf(dg,"dG");

  /* printf("T=%.16f \n(temperature+K0)*GASCONST/1000.0 = %.16f\n",temperature,(temperature+K0)*GASCONST/1000.0); */

  /* write the header of the output file:  */
  /*  # timestamp commandlineaufruf   */
  /*  # length and name of first sequence (target) */
  /*  # first seq */
  /*  # length and name of second sequence (interaction partner) */
  /*  # second seq */
  /* the next line is the output for the target: colums
     position in target | dG_unpaired values for target | interaction energy */
  /*  # pos   u1S   u1H  dg */
  /*  values for target */
  /* if -b was choosen: the next lines are the dG_unpaired values for
     the interaction partner */
  /*  # pos   u1S   u1H  */
  /*  values for the interaction partner */

  /* print header, if nh is zerro */
  if(head){
    time = vrna_time_stamp();
    fprintf(wastl,"# %s\n", time);
    fprintf(wastl,"%s\n",head);
  }
  fprintf(wastl,"# ");
  /* }  else { fprintf(wastl," "); } close if before  */
  len  = res->len;
  size = res->u_vals * res->contribs;

  sprintf(nan,"NA");
  nan[2] = '\0';

  for(i=0;i<=len; i++) {
    for(s=0;s<=size+1;s++) { /* that is for different contribution */
      if ( i== 0 && s > size && pint != NULL)
        fprintf(wastl,"%8s  ",dg);
      if(i != 0) {
        if(s>0 && s<=size) {
          if(res->u_values[s][i] > 0.0) {
            dG_u = -log(res->u_values[s][i])*kT/1000.0;
            fprintf(wastl,"%8.3f  ",dG_u);
          } else { /* no p_u value was defined print nan*/
            fprintf(wastl,"%8s  ",nan);
          }

        } else if (s > size && pint != NULL) {
          fprintf(wastl,"%8.3f  ",pint->Gi[i]);
        } else if (s == 0) {
          fprintf(wastl,"%8.0f  ",res->u_values[s][i]);
        }
      } else {
        if(s>1) {
          fprintf(wastl,"%8s  ",res->header[s]);
        } else {
          fprintf(wastl,"%7s  ",res->header[s]);
        }
      }
    }
    fprintf(wastl,"\n");
  }
  fclose(wastl);
  /*free pu_out* res */
  if(res != NULL) {
    for(i=0;i<=(size+2);i++) {
      free(res->u_values[i]);
      free(res->header[i]);
    }
    free(res->u_values);
    free(res->header);
    free(res);
    res = NULL;
  }

  return(1); /* success */
}

PUBLIC int Up_plot(pu_contrib *p_c, pu_contrib *p_c_sh, interact *pint, char *ofile, int **unpaired_values, char *select_contrib, char *head, unsigned int mode) {
  pu_out *dada;
  int ret;
  /* check what case we have */

  /* upmode = 1 only one seq */
  /* if(p_c != NULL && pint == NULL) { */
  if(mode & RNA_UP_MODE_1){
    dada = get_u_vals(p_c,unpaired_values,select_contrib);
    ret = plot_free_pu_out(dada,NULL,ofile,head);

  /* upmode > 1 cofolding */
  /* } else if (p_c != NULL && pint != NULL) { */
  } else if(mode & RNA_UP_MODE_2) {
    dada = get_u_vals(p_c,unpaired_values,select_contrib);
    ret = plot_free_pu_out(dada,pint,ofile,head);

  /* upmode = 3  cofolding*/
  /* } else if (p_c == NULL && p_c_sh != NULL) { */
  }
  if(mode & RNA_UP_MODE_3) {
    dada  = get_u_vals(p_c,unpaired_values, select_contrib);
    ret   = plot_free_pu_out(dada, pint, ofile, head);

    dada = get_u_vals(p_c_sh, unpaired_values, select_contrib);
    ret = plot_free_pu_out(dada,NULL,ofile, NULL);
  }
  return(ret);
}

/*-------------------------------------------------------------------------*/
/* copy from part_func_co.c */
PRIVATE constrain *get_ptypes_up(char *Seq, const char *structure) {
  int n,i,j,k,l, length;
  constrain *con;
  short *s, *s1;

  length = strlen(Seq);
  make_pair_matrix();
  con = (constrain *) vrna_alloc(sizeof(constrain));
  con->indx = (int *) vrna_alloc(sizeof(int)*(length+1));
  for (i=1; i<=length; i++) {
    con->indx[i] = ((length+1-i)*(length-i))/2 +length+1;
  }
  con->ptype = (char *) vrna_alloc(sizeof(char)*((length+1)*(length+2)/2));

  set_encoded_seq((const char *)Seq, &s, &s1);

  n=s[0];
  for (k=1; k<=n-CO_TURN-1; k++)
    for (l=1; l<=2; l++) {
      int type,ntype=0,otype=0;
      i=k; j = i+CO_TURN+l; if (j>n) continue;
      type = pair[s[i]][s[j]];
      while ((i>=1)&&(j<=n)) {
        if ((i>1)&&(j<n)) ntype = pair[s[i-1]][s[j+1]];
        if (noLonelyPairs && (!otype) && (!ntype))
          type = 0; /* i.j can only form isolated pairs */
        con->ptype[con->indx[i]-j] = (char) type;
        otype =  type;
        type  = ntype;
        i--; j++;
      }
    }

  if (fold_constrained&&(structure!=NULL)) {
    int hx, *stack;
    char type;
    stack = (int *) vrna_alloc(sizeof(int)*(n+1));
    for(hx=0, j=1; j<=n; j++) {
      switch (structure[j-1]) {
      case 'x': /* can't pair */
        for (l=1; l<j-CO_TURN; l++) con->ptype[con->indx[l]-j] = 0;
        for (l=j+CO_TURN+1; l<=n; l++) con->ptype[con->indx[j]-l] = 0;
        break;
      case '(':
        stack[hx++]=j;
        /* fallthrough */
      case '<': /* pairs upstream */
        break;
      case ')':
        if (hx<=0) {
          fprintf(stderr, "%s\n", structure);
          vrna_message_error("1. unbalanced brackets in constraints");
        }
        i = stack[--hx];
        type = con->ptype[con->indx[i]-j];
        /* don't allow pairs i<k<j<l */
        for (k=i; k<=j; k++)
          for (l=j; l<=n; l++) con->ptype[con->indx[k]-l] = 0;
        /* don't allow pairs k<i<l<j */
        for (k=1; k<=i; k++)
          for (l=i; l<=j; l++) con->ptype[con->indx[k]-l] = 0;
        con->ptype[con->indx[i]-j] = (type==0)?7:type;
      case '>': /* pairs downstream */
        break;
      }
    }
    if (hx!=0) {
      fprintf(stderr, "%s\n", structure);
      vrna_message_error("2. unbalanced brackets in constraint string");
    }
    free(stack);
  }
  free(s);
  free(s1);
  return con;
}
PRIVATE  void  set_encoded_seq(const char *sequence, short **S, short **S1){
  unsigned int i,l;
  l = strlen(sequence);
  if(S!= NULL){
    *S  = (short *)vrna_alloc(sizeof(short) * (l + 2));
    for(i=1; i<=l; i++) /* make numerical encoding of sequence */
      (*S)[i]= (short) encode_char(toupper(sequence[i-1]));
    (*S)[l+1] = (*S)[1];
    (*S)[0]   = (short) l;
  }
  /* S1 exists only for the special X K and I bases and energy_set!=0 */
  if(S1 != NULL){
    *S1 = (short *)vrna_alloc(sizeof(short) * (l + 2));
    for(i=1; i<=l; i++) /* make numerical encoding of sequence */
      (*S1)[i]  = alias[(short) encode_char(toupper(sequence[i-1]))]; /* for mismatches of nostandard bases */
    /* for circular folding add first base at position n+1 and last base at position 0 in S1 */
    (*S1)[l+1]  = (*S1)[1];
    (*S1)[0]    = (*S1)[l];
  }
}
ribo.c/         0           0     0     644     55914     `

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdlib.h>
#include <stdio.h>
#include "utils.h"
#include "ribo.h"

static float dm_12_5[7][7]={{0,0,0,0,0,0,0},
{0, 3.092536, 3.375764, 1.374085, 0.681999, 2.357501, 2.759147},
{0, 3.375764, 3.223949, 1.077220, 0.713622, 2.742085, 2.325847},
{0, 1.374085, 1.077220, 0.801987, -0.251514, 0.289428, 0.641530},
{0, 0.681999, 0.713622, -0.251514, 1.203844, -0.228733, 0.292522},
{0, 2.357501, 2.742085, 0.289428, -0.228733, 1.511221, 1.958625},
{0, 2.759147, 2.325847, 0.641530, 0.292522, 1.958625, 1.948208}};
static float dm_12_6[7][7]={{0,0,0,0,0,0,0},
{0, 3.092373, 3.375631, 1.374059, 0.681938, 2.357565, 2.759217},
{0, 3.375631, 3.223782, 1.077212, 0.713641, 2.742133, 2.325829},
{0, 1.374059, 1.077212, 0.801954, -0.251326, 0.289489, 0.641712},
{0, 0.681938, 0.713641, -0.251326, 1.203723, -0.228872, 0.292526},
{0, 2.357565, 2.742133, 0.289489, -0.228872, 1.511158, 1.958685},
{0, 2.759217, 2.325829, 0.641712, 0.292526, 1.958685, 1.948130}};
static float dm_12_7[7][7]={{0,0,0,0,0,0,0},
{0, 3.053179, 3.352207, 1.390738, 0.684033, 2.353429, 2.765638},
{0, 3.352207, 3.188833, 1.115659, 0.689646, 2.742801, 2.338308},
{0, 1.390738, 1.115659, 0.803823, -0.192463, 0.312652, 0.698703},
{0, 0.684033, 0.689646, -0.192463, 1.107424, -0.189709, 0.302683},
{0, 2.353429, 2.742801, 0.312652, -0.189709, 1.453439, 1.907102},
{0, 2.765638, 2.338308, 0.698703, 0.302683, 1.907102, 1.850447}};
static float dm_12_8[7][7]={{0,0,0,0,0,0,0},
{0, 3.049303, 3.270569, 1.417231, 0.666003, 2.313534, 2.891832},
{0, 3.270569, 3.186336, 1.047878, 0.717329, 2.806323, 2.360206},
{0, 1.417231, 1.047878, 0.718061, -0.168063, 0.238106, 0.821674},
{0, 0.666003, 0.717329, -0.168063, 0.995556, 0.010346, 0.171852},
{0, 2.313534, 2.806323, 0.238106, 0.010346, 1.361999, 1.906834},
{0, 2.891832, 2.360206, 0.821674, 0.171852, 1.906834, 1.745436}};
static float dm_12_9[7][7]={{0,0,0,0,0,0,0},
{0, 3.165100, 3.153340, 1.293645, 0.683711, 2.215911, 3.082474},
{0, 3.153340, 3.304615, 1.071703, 0.672898, 2.978487, 2.330174},
{0, 1.293645, 1.071703, 0.684991, -0.294258, 0.196122, 0.756948},
{0, 0.683711, 0.672898, -0.294258, 1.089387, 0.034000, 0.046088},
{0, 2.215911, 2.978487, 0.196122, 0.034000, 1.457778, 1.997389},
{0, 3.082474, 2.330174, 0.756948, 0.046088, 1.997389, 1.860867}};
static float dm_12_10[7][7]={{0,0,0,0,0,0,0},
{0, 3.316050, 3.080141, 1.198316, 0.719889, 2.155618, 3.134309},
{0, 3.080141, 3.404347, 1.108233, 0.637222, 2.938360, 2.294410},
{0, 1.198316, 1.108233, 0.657620, -0.563942, 0.269879, 0.776661},
{0, 0.719889, 0.637222, -0.563942, 1.170892, 0.077878, -0.014940},
{0, 2.155618, 2.938360, 0.269879, 0.077878, 1.631701, 2.093486},
{0, 3.134309, 2.294410, 0.776661, -0.014940, 2.093486, 2.008351}};
static float dm_12_11[7][7]={{0,0,0,0,0,0,0},
{0, 4.453617, 3.036904, 0.865118, 0.725919, 2.140436, 3.324865},
{0, 3.036904, 4.352423, 0.749665, 0.059865, 2.923511, 2.308393},
{0, 0.865118, 0.749665, 0.722300, -1.323178, 0.374187, 0.426083},
{0, 0.725919, 0.059865, -1.323178, 1.727563, -0.428759, 0.330746},
{0, 2.140436, 2.923511, 0.374187, -0.428759, 2.428389, 2.233568},
{0, 3.324865, 2.308393, 0.426083, 0.330746, 2.233568, 2.821057}};
static float dm_13_5[7][7]={{0,0,0,0,0,0,0},
{0, 2.533782, 3.282896, 1.521364, 0.752652, 2.264693, 2.589635},
{0, 3.282896, 2.711135, 0.952877, 1.215201, 2.545641, 2.334410},
{0, 1.521364, 0.952877, 0.827991, 0.183827, 0.378211, 0.794884},
{0, 0.752652, 1.215201, 0.183827, 0.819462, 0.368008, 0.475756},
{0, 2.264693, 2.545641, 0.378211, 0.368008, 1.007668, 1.732095},
{0, 2.589635, 2.334410, 0.794884, 0.475756, 1.732095, 1.315666}};
static float dm_13_6[7][7]={{0,0,0,0,0,0,0},
{0, 2.533730, 3.282872, 1.521367, 0.752640, 2.264708, 2.589641},
{0, 3.282872, 2.711079, 0.952872, 1.215222, 2.545643, 2.334410},
{0, 1.521367, 0.952872, 0.827971, 0.183877, 0.378217, 0.794922},
{0, 0.752640, 1.215222, 0.183877, 0.819423, 0.368018, 0.475753},
{0, 2.264708, 2.545643, 0.378217, 0.368018, 1.007640, 1.732099},
{0, 2.589641, 2.334410, 0.794922, 0.475753, 1.732099, 1.315634}};
static float dm_13_7[7][7]={{0,0,0,0,0,0,0},
{0, 2.517035, 3.288237, 1.534295, 0.752649, 2.264114, 2.587804},
{0, 3.288237, 2.694998, 0.956805, 1.227789, 2.542543, 2.336350},
{0, 1.534295, 0.956805, 0.820438, 0.200329, 0.379706, 0.803818},
{0, 0.752649, 1.227789, 0.200329, 0.797982, 0.376972, 0.476299},
{0, 2.264114, 2.542543, 0.379706, 0.376972, 0.988104, 1.718544},
{0, 2.587804, 2.336350, 0.803818, 0.476299, 1.718544, 1.288938}};
static float dm_13_8[7][7]={{0,0,0,0,0,0,0},
{0, 2.455141, 3.267199, 1.550791, 0.740489, 2.281213, 2.624344},
{0, 3.267199, 2.639092, 0.938981, 1.263224, 2.561521, 2.363191},
{0, 1.550791, 0.938981, 0.771171, 0.200008, 0.376450, 0.811315},
{0, 0.740489, 1.263224, 0.200008, 0.754473, 0.422913, 0.493286},
{0, 2.281213, 2.561521, 0.376450, 0.422913, 0.922402, 1.721243},
{0, 2.624344, 2.363191, 0.811315, 0.493286, 1.721243, 1.225387}};
static float dm_13_9[7][7]={{0,0,0,0,0,0,0},
{0, 2.379212, 3.195011, 1.477942, 0.732266, 2.283994, 2.699509},
{0, 3.195011, 2.577100, 0.912791, 1.272057, 2.625508, 2.371223},
{0, 1.477942, 0.912791, 0.737835, 0.193712, 0.381625, 0.838647},
{0, 0.732266, 1.272057, 0.193712, 0.719631, 0.491776, 0.516184},
{0, 2.283994, 2.625508, 0.381625, 0.491776, 0.889747, 1.759331},
{0, 2.699509, 2.371223, 0.838647, 0.516184, 1.759331, 1.193323}};
static float dm_13_10[7][7]={{0,0,0,0,0,0,0},
{0, 2.280425, 3.074698, 1.281893, 0.750335, 2.294618, 2.818548},
{0, 3.074698, 2.501446, 0.902613, 1.237324, 2.733365, 2.420051},
{0, 1.281893, 0.902613, 0.663356, 0.025119, 0.436734, 0.946242},
{0, 0.750335, 1.237324, 0.025119, 0.634862, 0.635376, 0.587841},
{0, 2.294618, 2.733365, 0.436734, 0.635376, 0.851475, 1.822634},
{0, 2.818548, 2.420051, 0.946242, 0.587841, 1.822634, 1.133656}};
static float dm_13_11[7][7]={{0,0,0,0,0,0,0},
{0, 2.049420, 3.065598, 1.147184, 0.984070, 2.286178, 2.745107},
{0, 3.065598, 2.349472, 0.907685, 1.527069, 2.637071, 2.291610},
{0, 1.147184, 0.907685, 0.583508, 0.290374, 0.432797, 0.907368},
{0, 0.984070, 1.527069, 0.290374, 0.528508, 0.783625, 0.671962},
{0, 2.286178, 2.637071, 0.432797, 0.783625, 0.749801, 1.701156},
{0, 2.745107, 2.291610, 0.907368, 0.671962, 1.701156, 0.981579}};
static float dm_13_12[7][7]={{0,0,0,0,0,0,0},
{0, 1.904683, 3.147814, 1.383470, 0.788061, 2.230640, 2.516545},
{0, 3.147814, 2.158800, 1.031644, 1.913906, 2.492254, 1.996584},
{0, 1.383470, 1.031644, 0.332441, 0.746301, 0.435514, 0.879258},
{0, 0.788061, 1.913906, 0.746301, 0.496698, 0.960208, 0.630473},
{0, 2.230640, 2.492254, 0.435514, 0.960208, 0.830695, 1.541673},
{0, 2.516545, 1.996584, 0.879258, 0.630473, 1.541673, 0.887994}};
static float dm_14_5[7][7]={{0,0,0,0,0,0,0},
{0, 2.294989, 3.205559, 1.584266, 0.734475, 2.289599, 2.535028},
{0, 3.205559, 2.485328, 0.891295, 1.466901, 2.470993, 2.328167},
{0, 1.584266, 0.891295, 0.759635, 0.320177, 0.322250, 0.907780},
{0, 0.734475, 1.466901, 0.320177, 0.770910, 0.521607, 0.411958},
{0, 2.289599, 2.470993, 0.322250, 0.521607, 0.900558, 1.829543},
{0, 2.535028, 2.328167, 0.907780, 0.411958, 1.829543, 1.149384}};
static float dm_14_6[7][7]={{0,0,0,0,0,0,0},
{0, 2.294961, 3.205540, 1.584268, 0.734469, 2.289603, 2.535026},
{0, 3.205540, 2.485292, 0.891288, 1.466911, 2.470989, 2.328168},
{0, 1.584268, 0.891288, 0.759627, 0.320205, 0.322258, 0.907802},
{0, 0.734469, 1.466911, 0.320205, 0.770895, 0.521619, 0.411961},
{0, 2.289603, 2.470989, 0.322258, 0.521619, 0.900543, 1.829549},
{0, 2.535026, 2.328168, 0.907802, 0.411961, 1.829549, 1.149367}};
static float dm_14_7[7][7]={{0,0,0,0,0,0,0},
{0, 2.284183, 3.205463, 1.589806, 0.733327, 2.290173, 2.534179},
{0, 3.205463, 2.474571, 0.891349, 1.473391, 2.469534, 2.329742},
{0, 1.589806, 0.891349, 0.754092, 0.329639, 0.323746, 0.913721},
{0, 0.733327, 1.473391, 0.329639, 0.760515, 0.527766, 0.413001},
{0, 2.290173, 2.469534, 0.323746, 0.527766, 0.890631, 1.825071},
{0, 2.534179, 2.329742, 0.913721, 0.413001, 1.825071, 1.136190}};
static float dm_14_8[7][7]={{0,0,0,0,0,0,0},
{0, 2.235726, 3.181914, 1.595503, 0.722770, 2.300997, 2.546218},
{0, 3.181914, 2.427845, 0.875999, 1.494647, 2.473461, 2.342035},
{0, 1.595503, 0.875999, 0.724803, 0.342682, 0.323718, 0.932708},
{0, 0.722770, 1.494647, 0.342682, 0.734102, 0.566070, 0.421129},
{0, 2.300997, 2.473461, 0.323718, 0.566070, 0.855249, 1.842018},
{0, 2.546218, 2.342035, 0.932708, 0.421129, 1.842018, 1.098536}};
static float dm_14_9[7][7]={{0,0,0,0,0,0,0},
{0, 2.169213, 3.125506, 1.561668, 0.710360, 2.315725, 2.570925},
{0, 3.125506, 2.366074, 0.850145, 1.506427, 2.491705, 2.351458},
{0, 1.561668, 0.850145, 0.699815, 0.342923, 0.328538, 0.974691},
{0, 0.710360, 1.506427, 0.342923, 0.708392, 0.630838, 0.430721},
{0, 2.315725, 2.491705, 0.328538, 0.630838, 0.830805, 1.888777},
{0, 2.570925, 2.351458, 0.974691, 0.430721, 1.888777, 1.064891}};
static float dm_14_10[7][7]={{0,0,0,0,0,0,0},
{0, 2.121401, 3.097557, 1.560258, 0.689908, 2.317536, 2.630291},
{0, 3.097557, 2.307448, 0.784748, 1.536794, 2.544322, 2.395549},
{0, 1.560258, 0.784748, 0.636637, 0.281228, 0.337831, 0.965036},
{0, 0.689908, 1.536794, 0.281228, 0.656827, 0.697208, 0.440900},
{0, 2.317536, 2.544322, 0.337831, 0.697208, 0.832763, 1.933003},
{0, 2.630291, 2.395549, 0.965036, 0.440900, 1.933003, 1.020585}};
static float dm_14_11[7][7]={{0,0,0,0,0,0,0},
{0, 2.073657, 3.129452, 1.652733, 0.683925, 2.335236, 2.616220},
{0, 3.129452, 2.249754, 0.745361, 1.637265, 2.557071, 2.392472},
{0, 1.652733, 0.745361, 0.597976, 0.222713, 0.343902, 0.889990},
{0, 0.683925, 1.637265, 0.222713, 0.624604, 0.786781, 0.435623},
{0, 2.335236, 2.557071, 0.343902, 0.786781, 0.831075, 1.905111},
{0, 2.616220, 2.392472, 0.889990, 0.435623, 1.905111, 0.955225}};
static float dm_14_12[7][7]={{0,0,0,0,0,0,0},
{0, 2.029277, 3.087264, 1.718185, 0.587838, 2.396044, 2.545040},
{0, 3.087264, 2.177344, 0.725318, 1.676438, 2.547083, 2.447849},
{0, 1.718185, 0.725318, 0.542734, 0.219786, 0.369477, 0.869417},
{0, 0.587838, 1.676438, 0.219786, 0.608994, 0.859758, 0.368574},
{0, 2.396044, 2.547083, 0.369477, 0.859758, 0.842019, 2.027160},
{0, 2.545040, 2.447849, 0.869417, 0.368574, 2.027160, 0.909170}};
static float dm_14_13[7][7]={{0,0,0,0,0,0,0},
{0, 2.000248, 3.122593, 1.864659, 0.494490, 2.479114, 2.554107},
{0, 3.122593, 2.129482, 0.626369, 1.637370, 2.548600, 2.565048},
{0, 1.864659, 0.626369, 0.454571, 0.172183, 0.351022, 0.794287},
{0, 0.494490, 1.637370, 0.172183, 0.671707, 0.748383, 0.198126},
{0, 2.479114, 2.548600, 0.351022, 0.748383, 0.846495, 2.353506},
{0, 2.554107, 2.565048, 0.794287, 0.198126, 2.353506, 0.877777}};
static float dm_15_5[7][7]={{0,0,0,0,0,0,0},
{0, 2.185017, 3.256348, 1.588804, 0.666905, 2.355718, 2.520031},
{0, 3.256348, 2.374070, 0.850906, 1.551282, 2.511878, 2.371123},
{0, 1.588804, 0.850906, 0.689517, 0.366678, 0.267602, 0.985305},
{0, 0.666905, 1.551282, 0.366678, 0.702683, 0.582839, 0.372196},
{0, 2.355718, 2.511878, 0.267602, 0.582839, 0.778425, 1.871858},
{0, 2.520031, 2.371123, 0.985305, 0.372196, 1.871858, 1.031343}};
static float dm_15_6[7][7]={{0,0,0,0,0,0,0},
{0, 2.184997, 3.256344, 1.588807, 0.666901, 2.355725, 2.520032},
{0, 3.256344, 2.374049, 0.850901, 1.551289, 2.511879, 2.371126},
{0, 1.588807, 0.850901, 0.689501, 0.366694, 0.267601, 0.985320},
{0, 0.666901, 1.551289, 0.366694, 0.702666, 0.582848, 0.372191},
{0, 2.355725, 2.511879, 0.267601, 0.582848, 0.778413, 1.871866},
{0, 2.520032, 2.371126, 0.985320, 0.372191, 1.871866, 1.031328}};
static float dm_15_7[7][7]={{0,0,0,0,0,0,0},
{0, 2.178225, 3.255949, 1.591734, 0.666172, 2.356327, 2.519434},
{0, 3.255949, 2.367187, 0.850656, 1.554802, 2.511035, 2.372193},
{0, 1.591734, 0.850656, 0.685901, 0.372252, 0.268459, 0.988985},
{0, 0.666172, 1.554802, 0.372252, 0.696898, 0.586767, 0.372815},
{0, 2.356327, 2.511035, 0.268459, 0.586767, 0.772770, 1.869928},
{0, 2.519434, 2.372193, 0.988985, 0.372815, 1.869928, 1.024003}};
static float dm_15_8[7][7]={{0,0,0,0,0,0,0},
{0, 2.141127, 3.237374, 1.592766, 0.658485, 2.364123, 2.524356},
{0, 3.237374, 2.330108, 0.840158, 1.565238, 2.512924, 2.380899},
{0, 1.592766, 0.840158, 0.665322, 0.384438, 0.266965, 1.010245},
{0, 0.658485, 1.565238, 0.384438, 0.677947, 0.617501, 0.377062},
{0, 2.364123, 2.512924, 0.266965, 0.617501, 0.748457, 1.886645},
{0, 2.524356, 2.380899, 1.010245, 0.377062, 1.886645, 0.998685}};
static float dm_15_9[7][7]={{0,0,0,0,0,0,0},
{0, 2.082602, 3.194686, 1.571476, 0.645533, 2.377215, 2.534602},
{0, 3.194686, 2.272916, 0.822962, 1.573341, 2.520912, 2.393028},
{0, 1.571476, 0.822962, 0.640049, 0.397585, 0.269078, 1.050093},
{0, 0.645533, 1.573341, 0.397585, 0.651218, 0.668684, 0.385365},
{0, 2.377215, 2.520912, 0.269078, 0.668684, 0.720559, 1.929423},
{0, 2.534602, 2.393028, 1.050093, 0.385365, 1.929423, 0.964692}};
static float dm_15_10[7][7]={{0,0,0,0,0,0,0},
{0, 2.011980, 3.208890, 1.586936, 0.614653, 2.410291, 2.569991},
{0, 3.208890, 2.192435, 0.783958, 1.618693, 2.560039, 2.439652},
{0, 1.586936, 0.783958, 0.566237, 0.382907, 0.271841, 1.006087},
{0, 0.614653, 1.618693, 0.382907, 0.581074, 0.728724, 0.387583},
{0, 2.410291, 2.560039, 0.271841, 0.728724, 0.689985, 1.958203},
{0, 2.569991, 2.439652, 1.006087, 0.387583, 1.958203, 0.901393}};
static float dm_15_11[7][7]={{0,0,0,0,0,0,0},
{0, 1.960846, 3.364729, 1.711101, 0.580163, 2.436976, 2.568375},
{0, 3.364729, 2.127484, 0.757940, 1.724525, 2.572193, 2.449286},
{0, 1.711101, 0.757940, 0.506015, 0.306759, 0.248888, 0.900846},
{0, 0.580163, 1.724525, 0.306759, 0.515784, 0.796313, 0.387969},
{0, 2.436976, 2.572193, 0.248888, 0.796313, 0.651734, 1.900198},
{0, 2.568375, 2.449286, 0.900846, 0.387969, 1.900198, 0.825616}};
static float dm_15_12[7][7]={{0,0,0,0,0,0,0},
{0, 1.905112, 3.368458, 1.738759, 0.521209, 2.469970, 2.532597},
{0, 3.368458, 2.057336, 0.733674, 1.764054, 2.567498, 2.475677},
{0, 1.738759, 0.733674, 0.452960, 0.356533, 0.263124, 0.915940},
{0, 0.521209, 1.764054, 0.356533, 0.468384, 0.825416, 0.393747},
{0, 2.469970, 2.567498, 0.263124, 0.825416, 0.620497, 1.933061},
{0, 2.532597, 2.475677, 0.915940, 0.393747, 1.933061, 0.776274}};
static float dm_15_13[7][7]={{0,0,0,0,0,0,0},
{0, 1.764334, 3.521734, 1.844636, 0.465089, 2.475371, 2.501349},
{0, 3.521734, 1.899254, 0.652013, 1.866354, 2.519286, 2.498764},
{0, 1.844636, 0.652013, 0.373857, 0.494613, 0.240469, 1.003296},
{0, 0.465089, 1.866354, 0.494613, 0.346332, 0.823497, 0.447243},
{0, 2.475371, 2.519286, 0.240469, 0.823497, 0.468987, 1.894554},
{0, 2.501349, 2.498764, 1.003296, 0.447243, 1.894554, 0.650703}};
static float dm_15_14[7][7]={{0,0,0,0,0,0,0},
{0, 1.753217, 3.560554, 1.890084, 0.497526, 2.482621, 2.508029},
{0, 3.560554, 1.886087, 0.571603, 1.903238, 2.518939, 2.505216},
{0, 1.890084, 0.571603, 0.375259, 0.535512, 0.227112, 1.009415},
{0, 0.497526, 1.903238, 0.535512, 0.355054, 0.732221, 0.497356},
{0, 2.482621, 2.518939, 0.227112, 0.732221, 0.453713, 1.824189},
{0, 2.508029, 2.505216, 1.009415, 0.497356, 1.824189, 0.649442}};
static float dm_16_5[7][7]={{0,0,0,0,0,0,0},
{0, 2.096356, 3.297512, 1.643277, 0.627608, 2.425850, 2.531892},
{0, 3.297512, 2.277720, 0.776768, 1.578330, 2.507998, 2.381738},
{0, 1.643277, 0.776768, 0.652789, 0.376193, 0.205475, 1.050591},
{0, 0.627608, 1.578330, 0.376193, 0.635057, 0.695045, 0.328657},
{0, 2.425850, 2.507998, 0.205475, 0.695045, 0.647026, 1.971812},
{0, 2.531892, 2.381738, 1.050591, 0.328657, 1.971812, 0.893562}};
static float dm_16_6[7][7]={{0,0,0,0,0,0,0},
{0, 2.096346, 3.297510, 1.643276, 0.627604, 2.425854, 2.531894},
{0, 3.297510, 2.277709, 0.776764, 1.578331, 2.508000, 2.381737},
{0, 1.643276, 0.776764, 0.652783, 0.376197, 0.205477, 1.050597},
{0, 0.627604, 1.578331, 0.376197, 0.635048, 0.695048, 0.328658},
{0, 2.425854, 2.508000, 0.205477, 0.695048, 0.647022, 1.971820},
{0, 2.531894, 2.381737, 1.050597, 0.328658, 1.971820, 0.893558}};
static float dm_16_7[7][7]={{0,0,0,0,0,0,0},
{0, 2.092914, 3.296980, 1.644541, 0.627228, 2.426164, 2.531487},
{0, 3.296980, 2.274181, 0.776531, 1.579823, 2.507496, 2.382211},
{0, 1.644541, 0.776531, 0.650930, 0.378902, 0.205995, 1.052513},
{0, 0.627228, 1.579823, 0.378902, 0.632483, 0.697137, 0.329046},
{0, 2.426164, 2.507496, 0.205995, 0.697137, 0.644461, 1.971311},
{0, 2.531487, 2.382211, 1.052513, 0.329046, 1.971311, 0.890302}};
static float dm_16_8[7][7]={{0,0,0,0,0,0,0},
{0, 2.073428, 3.286494, 1.644950, 0.623462, 2.430093, 2.532505},
{0, 3.286494, 2.254339, 0.771248, 1.583832, 2.507212, 2.385719},
{0, 1.644950, 0.771248, 0.640496, 0.385785, 0.205764, 1.064654},
{0, 0.623462, 1.583832, 0.385785, 0.622568, 0.714265, 0.331069},
{0, 2.430093, 2.507212, 0.205764, 0.714265, 0.632331, 1.982670},
{0, 2.532505, 2.385719, 1.064654, 0.331069, 1.982670, 0.877393}};
static float dm_16_9[7][7]={{0,0,0,0,0,0,0},
{0, 2.040939, 3.265472, 1.637410, 0.615748, 2.438042, 2.535927},
{0, 3.265472, 2.221433, 0.760900, 1.588059, 2.509252, 2.391099},
{0, 1.637410, 0.760900, 0.625103, 0.394320, 0.206172, 1.085801},
{0, 0.615748, 1.588059, 0.394320, 0.606102, 0.744667, 0.334067},
{0, 2.438042, 2.509252, 0.206172, 0.744667, 0.614764, 2.010608},
{0, 2.535927, 2.391099, 1.085801, 0.334067, 2.010608, 0.856570}};
static float dm_16_10[7][7]={{0,0,0,0,0,0,0},
{0, 1.929517, 3.299150, 1.679136, 0.598406, 2.478683, 2.546578},
{0, 3.299150, 2.091719, 0.711831, 1.702824, 2.519268, 2.443818},
{0, 1.679136, 0.711831, 0.530571, 0.408434, 0.197624, 1.036293},
{0, 0.598406, 1.702824, 0.408434, 0.495823, 0.861514, 0.331873},
{0, 2.478683, 2.519268, 0.197624, 0.861514, 0.535526, 2.017192},
{0, 2.546578, 2.443818, 1.036293, 0.331873, 2.017192, 0.751594}};
static float dm_16_11[7][7]={{0,0,0,0,0,0,0},
{0, 1.790624, 3.419792, 1.804745, 0.585040, 2.511724, 2.507394},
{0, 3.419792, 1.936325, 0.655038, 1.866549, 2.481327, 2.473116},
{0, 1.804745, 0.655038, 0.440211, 0.419147, 0.190157, 0.999819},
{0, 0.585040, 1.866549, 0.419147, 0.384589, 0.972519, 0.349591},
{0, 2.511724, 2.481327, 0.190157, 0.972519, 0.439998, 1.950823},
{0, 2.507394, 2.473116, 0.999819, 0.349591, 1.950823, 0.634690}};
static float dm_16_12[7][7]={{0,0,0,0,0,0,0},
{0, 1.738485, 3.413306, 1.823292, 0.565589, 2.524720, 2.483688},
{0, 3.413306, 1.875156, 0.624931, 1.902547, 2.464176, 2.477746},
{0, 1.823292, 0.624931, 0.407593, 0.460985, 0.201735, 1.024667},
{0, 0.565589, 1.902547, 0.460985, 0.347262, 1.021166, 0.354417},
{0, 2.524720, 2.464176, 0.201735, 1.021166, 0.409784, 1.969276},
{0, 2.483688, 2.477746, 1.024667, 0.354417, 1.969276, 0.597237}};
static float dm_16_13[7][7]={{0,0,0,0,0,0,0},
{0, 1.664768, 3.405759, 1.848635, 0.546367, 2.518192, 2.460663},
{0, 3.405759, 1.785451, 0.567988, 1.961108, 2.436129, 2.469090},
{0, 1.848635, 0.567988, 0.373320, 0.524553, 0.220489, 1.071079},
{0, 0.546367, 1.961108, 0.524553, 0.294419, 1.099707, 0.370092},
{0, 2.518192, 2.436129, 0.220489, 1.099707, 0.364109, 1.982751},
{0, 2.460663, 2.469090, 1.071079, 0.370092, 1.982751, 0.552731}};
static float dm_16_14[7][7]={{0,0,0,0,0,0,0},
{0, 1.586401, 3.322065, 1.884482, 0.570145, 2.512906, 2.427617},
{0, 3.322065, 1.692728, 0.531570, 1.996685, 2.415287, 2.448701},
{0, 1.884482, 0.531570, 0.352236, 0.601762, 0.215346, 1.113649},
{0, 0.570145, 1.996685, 0.601762, 0.269440, 1.208804, 0.368633},
{0, 2.512906, 2.415287, 0.215346, 1.208804, 0.308130, 2.023351},
{0, 2.427617, 2.448701, 1.113649, 0.368633, 2.023351, 0.509060}};
static float dm_16_15[7][7]={{0,0,0,0,0,0,0},
{0, 1.663168, 3.308261, 1.850005, 0.549647, 2.516260, 2.489382},
{0, 3.308261, 1.762303, 0.472887, 1.999308, 2.452056, 2.487940},
{0, 1.850005, 0.472887, 0.321624, 0.611101, 0.250077, 1.031153},
{0, 0.549647, 1.999308, 0.611101, 0.328556, 1.140290, 0.273025},
{0, 2.516260, 2.452056, 0.250077, 1.140290, 0.460515, 2.003803},
{0, 2.489382, 2.487940, 1.031153, 0.273025, 2.003803, 0.593446}};
static float dm_17_5[7][7]={{0,0,0,0,0,0,0},
{0, 2.007833, 3.291241, 1.663891, 0.607307, 2.464689, 2.554022},
{0, 3.291241, 2.181349, 0.736718, 1.592793, 2.504274, 2.379900},
{0, 1.663891, 0.736718, 0.616428, 0.445344, 0.161487, 1.114375},
{0, 0.607307, 1.592793, 0.445344, 0.571508, 0.773714, 0.288043},
{0, 2.464689, 2.504274, 0.161487, 0.773714, 0.544800, 2.054002},
{0, 2.554022, 2.379900, 1.114375, 0.288043, 2.054002, 0.814483}};
static float dm_17_6[7][7]={{0,0,0,0,0,0,0},
{0, 2.007829, 3.291242, 1.663892, 0.607308, 2.464688, 2.554020},
{0, 3.291242, 2.181345, 0.736719, 1.592796, 2.504272, 2.379900},
{0, 1.663892, 0.736719, 0.616427, 0.445344, 0.161487, 1.114376},
{0, 0.607308, 1.592796, 0.445344, 0.571507, 0.773715, 0.288042},
{0, 2.464688, 2.504272, 0.161487, 0.773715, 0.544799, 2.054004},
{0, 2.554020, 2.379900, 1.114376, 0.288042, 2.054004, 0.814482}};
static float dm_17_7[7][7]={{0,0,0,0,0,0,0},
{0, 2.006511, 3.290918, 1.664311, 0.607172, 2.464800, 2.553839},
{0, 3.290918, 2.179982, 0.736617, 1.593288, 2.504065, 2.380066},
{0, 1.664311, 0.736617, 0.615720, 0.446361, 0.161718, 1.115108},
{0, 0.607172, 1.593288, 0.446361, 0.570613, 0.774548, 0.288223},
{0, 2.464800, 2.504065, 0.161718, 0.774548, 0.543905, 2.053924},
{0, 2.553839, 2.380066, 1.115108, 0.288223, 2.053924, 0.813353}};
static float dm_17_8[7][7]={{0,0,0,0,0,0,0},
{0, 1.997746, 3.285639, 1.664262, 0.605619, 2.466015, 2.554194},
{0, 3.285639, 2.170945, 0.734627, 1.594479, 2.504060, 2.380880},
{0, 1.664262, 0.734627, 0.611204, 0.449825, 0.161638, 1.120324},
{0, 0.605619, 1.594479, 0.449825, 0.566330, 0.782686, 0.288928},
{0, 2.466015, 2.504060, 0.161638, 0.782686, 0.538801, 2.060339},
{0, 2.554194, 2.380880, 1.120324, 0.288928, 2.060339, 0.807944}};
static float dm_17_9[7][7]={{0,0,0,0,0,0,0},
{0, 1.982793, 3.276596, 1.661720, 0.602603, 2.468779, 2.554925},
{0, 3.276596, 2.155408, 0.730430, 1.596575, 2.504169, 2.382555},
{0, 1.661720, 0.730430, 0.603805, 0.454813, 0.162205, 1.129925},
{0, 0.602603, 1.596575, 0.454813, 0.558528, 0.796813, 0.290137},
{0, 2.468779, 2.504169, 0.162205, 0.796813, 0.530589, 2.073034},
{0, 2.554925, 2.382555, 1.129925, 0.290137, 2.073034, 0.798318}};
static float dm_17_10[7][7]={{0,0,0,0,0,0,0},
{0, 1.832394, 3.307697, 1.711062, 0.587652, 2.500571, 2.542166},
{0, 3.307697, 1.983636, 0.677419, 1.738092, 2.497012, 2.437609},
{0, 1.711062, 0.677419, 0.494725, 0.489828, 0.154804, 1.109600},
{0, 0.587652, 1.738092, 0.489828, 0.434240, 0.948956, 0.303653},
{0, 2.500571, 2.497012, 0.154804, 0.948956, 0.429058, 2.071173},
{0, 2.542166, 2.437609, 1.109600, 0.303653, 2.071173, 0.671361}};
static float dm_17_11[7][7]={{0,0,0,0,0,0,0},
{0, 1.633896, 3.402351, 1.834789, 0.578697, 2.521230, 2.483018},
{0, 3.402351, 1.765915, 0.619865, 1.929028, 2.436812, 2.470046},
{0, 1.834789, 0.619865, 0.383602, 0.561116, 0.161953, 1.095287},
{0, 0.578697, 1.929028, 0.561116, 0.306100, 1.098171, 0.336383},
{0, 2.521230, 2.436812, 0.161953, 1.098171, 0.313977, 2.003038},
{0, 2.483018, 2.470046, 1.095287, 0.336383, 2.003038, 0.532942}};
static float dm_17_12[7][7]={{0,0,0,0,0,0,0},
{0, 1.595425, 3.398979, 1.849409, 0.570570, 2.521120, 2.468389},
{0, 3.398979, 1.722025, 0.598918, 1.955315, 2.423195, 2.464611},
{0, 1.849409, 0.598918, 0.364362, 0.591967, 0.170305, 1.116927},
{0, 0.570570, 1.955315, 0.591967, 0.283012, 1.131490, 0.342010},
{0, 2.521120, 2.423195, 0.170305, 1.131490, 0.296061, 2.010796},
{0, 2.468389, 2.464611, 1.116927, 0.342010, 2.010796, 0.511111}};
static float dm_17_13[7][7]={{0,0,0,0,0,0,0},
{0, 1.549012, 3.376494, 1.861681, 0.554571, 2.504364, 2.452632},
{0, 3.376494, 1.665273, 0.557068, 1.995296, 2.410242, 2.446184},
{0, 1.861681, 0.557068, 0.344309, 0.638901, 0.190280, 1.155475},
{0, 0.554571, 1.995296, 0.638901, 0.253950, 1.182863, 0.350164},
{0, 2.504364, 2.410242, 0.190280, 1.182863, 0.281259, 2.030459},
{0, 2.452632, 2.446184, 1.155475, 0.350164, 2.030459, 0.492848}};
static float dm_17_14[7][7]={{0,0,0,0,0,0,0},
{0, 1.495463, 3.333516, 1.880225, 0.561395, 2.499855, 2.437629},
{0, 3.333516, 1.603946, 0.541227, 2.013724, 2.402244, 2.432190},
{0, 1.880225, 0.541227, 0.328083, 0.699849, 0.185966, 1.189426},
{0, 0.561395, 2.013724, 0.699849, 0.236830, 1.224252, 0.355651},
{0, 2.499855, 2.402244, 0.185966, 1.224252, 0.250988, 2.050938},
{0, 2.437629, 2.432190, 1.189426, 0.355651, 2.050938, 0.468514}};
static float dm_17_15[7][7]={{0,0,0,0,0,0,0},
{0, 1.445032, 3.277640, 1.899860, 0.579524, 2.495022, 2.453726},
{0, 3.277640, 1.540316, 0.514869, 2.009604, 2.432139, 2.400556},
{0, 1.899860, 0.514869, 0.290900, 0.783431, 0.190682, 1.228429},
{0, 0.579524, 2.009604, 0.783431, 0.228588, 1.227334, 0.350982},
{0, 2.495022, 2.432139, 0.190682, 1.227334, 0.254986, 2.050370},
{0, 2.453726, 2.400556, 1.228429, 0.350982, 2.050370, 0.451843}};
static float dm_17_16[7][7]={{0,0,0,0,0,0,0},
{0, 1.488960, 3.203613, 1.823525, 0.490317, 2.511323, 2.529750},
{0, 3.203613, 1.582014, 0.402531, 1.848617, 2.505082, 2.396065},
{0, 1.823525, 0.402531, 0.270031, 0.719134, 0.275540, 1.315131},
{0, 0.490317, 1.848617, 0.719134, 0.249862, 1.211044, 0.369940},
{0, 2.511323, 2.505082, 0.275540, 1.211044, 0.401915, 2.139891},
{0, 2.529750, 2.396065, 1.315131, 0.369940, 2.139891, 0.524210}};
static float dm_18_5[7][7]={{0,0,0,0,0,0,0},
{0, 1.959599, 3.270973, 1.671129, 0.574402, 2.470822, 2.567678},
{0, 3.270973, 2.124333, 0.699437, 1.586377, 2.503971, 2.367755},
{0, 1.671129, 0.699437, 0.602529, 0.514746, 0.131217, 1.191973},
{0, 0.574402, 1.586377, 0.514746, 0.543897, 0.783468, 0.266230},
{0, 2.470822, 2.503971, 0.131217, 0.783468, 0.523535, 2.125332},
{0, 2.567678, 2.367755, 1.191973, 0.266230, 2.125332, 0.795089}};
static float dm_18_6[7][7]={{0,0,0,0,0,0,0},
{0, 1.959599, 3.270973, 1.671129, 0.574402, 2.470822, 2.567678},
{0, 3.270973, 2.124333, 0.699437, 1.586377, 2.503971, 2.367755},
{0, 1.671129, 0.699437, 0.602529, 0.514746, 0.131217, 1.191973},
{0, 0.574402, 1.586377, 0.514746, 0.543897, 0.783468, 0.266230},
{0, 2.470822, 2.503971, 0.131217, 0.783468, 0.523535, 2.125332},
{0, 2.567678, 2.367755, 1.191973, 0.266230, 2.125332, 0.795089}};
static float dm_18_7[7][7]={{0,0,0,0,0,0,0},
{0, 1.959107, 3.270822, 1.671269, 0.574356, 2.470852, 2.567602},
{0, 3.270822, 2.123822, 0.699405, 1.586546, 2.503884, 2.367804},
{0, 1.671269, 0.699405, 0.602271, 0.515123, 0.131315, 1.192250},
{0, 0.574356, 1.586546, 0.515123, 0.543584, 0.783791, 0.266309},
{0, 2.470852, 2.503884, 0.131315, 0.783791, 0.523221, 2.125324},
{0, 2.567602, 2.367804, 1.192250, 0.266309, 2.125324, 0.794693}};
static float dm_18_8[7][7]={{0,0,0,0,0,0,0},
{0, 1.954893, 3.267998, 1.671033, 0.573675, 2.471278, 2.567651},
{0, 3.267998, 2.119451, 0.698449, 1.587072, 2.503825, 2.367971},
{0, 1.671033, 0.698449, 0.600163, 0.516924, 0.131274, 1.194926},
{0, 0.573675, 1.587072, 0.516924, 0.541618, 0.787988, 0.266654},
{0, 2.471278, 2.503825, 0.131274, 0.787988, 0.520857, 2.128706},
{0, 2.567651, 2.367971, 1.194926, 0.266654, 2.128706, 0.792170}};
static float dm_18_9[7][7]={{0,0,0,0,0,0,0},
{0, 1.945124, 3.264181, 1.671424, 0.571213, 2.472533, 2.567351},
{0, 3.264181, 2.109123, 0.695302, 1.589162, 2.502780, 2.369180},
{0, 1.671424, 0.695302, 0.595101, 0.519845, 0.132914, 1.201167},
{0, 0.571213, 1.589162, 0.519845, 0.536309, 0.796405, 0.268040},
{0, 2.472533, 2.502780, 0.132914, 0.796405, 0.515207, 2.135443},
{0, 2.567351, 2.369180, 1.201167, 0.268040, 2.135443, 0.785257}};
static float dm_18_10[7][7]={{0,0,0,0,0,0,0},
{0, 1.778806, 3.290372, 1.729008, 0.558489, 2.496256, 2.542594},
{0, 3.290372, 1.919078, 0.640136, 1.742877, 2.490111, 2.425930},
{0, 1.729008, 0.640136, 0.481526, 0.559858, 0.122004, 1.188502},
{0, 0.558489, 1.742877, 0.559858, 0.408793, 0.965121, 0.290692},
{0, 2.496256, 2.490111, 0.122004, 0.965121, 0.406294, 2.135398},
{0, 2.542594, 2.425930, 1.188502, 0.290692, 2.135398, 0.650811}};
static float dm_18_11[7][7]={{0,0,0,0,0,0,0},
{0, 1.541260, 3.359887, 1.863305, 0.552149, 2.512117, 2.465080},
{0, 3.359887, 1.659552, 0.577262, 1.954784, 2.419679, 2.467978},
{0, 1.863305, 0.577262, 0.355424, 0.658994, 0.133093, 1.173777},
{0, 0.552149, 1.954784, 0.658994, 0.268144, 1.152204, 0.340224},
{0, 2.512117, 2.419679, 0.133093, 1.152204, 0.278844, 2.069528},
{0, 2.465080, 2.467978, 1.173777, 0.340224, 2.069528, 0.496656}};
static float dm_18_12[7][7]={{0,0,0,0,0,0,0},
{0, 1.515109, 3.355111, 1.873865, 0.547484, 2.509063, 2.454676},
{0, 3.355111, 1.629923, 0.562408, 1.973041, 2.410124, 2.462343},
{0, 1.873865, 0.562408, 0.343602, 0.682667, 0.137341, 1.188539},
{0, 0.547484, 1.973041, 0.682667, 0.253609, 1.175520, 0.346154},
{0, 2.509063, 2.410124, 0.137341, 1.175520, 0.268542, 2.074538},
{0, 2.454676, 2.462343, 1.188539, 0.346154, 2.074538, 0.483464}};
static float dm_18_13[7][7]={{0,0,0,0,0,0,0},
{0, 1.473845, 3.334992, 1.883878, 0.535323, 2.497538, 2.439103},
{0, 3.334992, 1.582030, 0.528874, 2.002078, 2.397872, 2.448436},
{0, 1.883878, 0.528874, 0.327587, 0.725281, 0.148692, 1.223566},
{0, 0.535323, 2.002078, 0.725281, 0.230794, 1.216739, 0.355996},
{0, 2.497538, 2.397872, 0.148692, 1.216739, 0.256653, 2.092929},
{0, 2.439103, 2.448436, 1.223566, 0.355996, 2.092929, 0.466494}};
static float dm_18_14[7][7]={{0,0,0,0,0,0,0},
{0, 1.438699, 3.305116, 1.892865, 0.534599, 2.498865, 2.427961},
{0, 3.305116, 1.541486, 0.516396, 2.013794, 2.391791, 2.443225},
{0, 1.892865, 0.516396, 0.314606, 0.768388, 0.147398, 1.244406},
{0, 0.534599, 2.013794, 0.768388, 0.219136, 1.239877, 0.363050},
{0, 2.498865, 2.391791, 0.147398, 1.239877, 0.245018, 2.106483},
{0, 2.427961, 2.443225, 1.244406, 0.363050, 2.106483, 0.452624}};
static float dm_18_15[7][7]={{0,0,0,0,0,0,0},
{0, 1.402188, 3.243491, 1.873197, 0.523749, 2.513206, 2.440632},
{0, 3.243491, 1.493880, 0.479570, 2.003177, 2.410569, 2.437229},
{0, 1.873197, 0.479570, 0.286984, 0.854376, 0.156044, 1.259959},
{0, 0.523749, 2.003177, 0.854376, 0.211875, 1.261759, 0.358950},
{0, 2.513206, 2.410569, 0.156044, 1.261759, 0.268410, 2.128211},
{0, 2.440632, 2.437229, 1.259959, 0.358950, 2.128211, 0.448424}};
static float dm_18_16[7][7]={{0,0,0,0,0,0,0},
{0, 1.399936, 3.187488, 1.813113, 0.458372, 2.536421, 2.523106},
{0, 3.187488, 1.481063, 0.386274, 1.879206, 2.472031, 2.470590},
{0, 1.813113, 0.386274, 0.260196, 0.908918, 0.241168, 1.252977},
{0, 0.458372, 1.879206, 0.908918, 0.212976, 1.264362, 0.319339},
{0, 2.536421, 2.472031, 0.241168, 1.264362, 0.364359, 2.184745},
{0, 2.523106, 2.470590, 1.252977, 0.319339, 2.184745, 0.485249}};
static float dm_18_17[7][7]={{0,0,0,0,0,0,0},
{0, 1.267458, 3.104292, 1.954389, 0.508102, 2.474593, 2.482510},
{0, 3.104292, 1.332773, 0.384678, 1.918735, 2.426904, 2.409497},
{0, 1.954389, 0.384678, 0.231292, 1.095239, 0.222912, 1.303908},
{0, 0.508102, 1.918735, 1.095239, 0.194026, 1.349575, 0.325298},
{0, 2.474593, 2.426904, 0.222912, 1.349575, 0.302607, 2.167885},
{0, 2.482510, 2.409497, 1.303908, 0.325298, 2.167885, 0.414809}};
static float dm_19_5[7][7]={{0,0,0,0,0,0,0},
{0, 1.925029, 3.259785, 1.678082, 0.532879, 2.480385, 2.567162},
{0, 3.259785, 2.081752, 0.661029, 1.587558, 2.507624, 2.352855},
{0, 1.678082, 0.661029, 0.587688, 0.564095, 0.115803, 1.245217},
{0, 0.532879, 1.587558, 0.564095, 0.523708, 0.804297, 0.259865},
{0, 2.480385, 2.507624, 0.115803, 0.804297, 0.509191, 2.180337},
{0, 2.567162, 2.352855, 1.245217, 0.259865, 2.180337, 0.778683}};
static float dm_19_6[7][7]={{0,0,0,0,0,0,0},
{0, 1.925029, 3.259785, 1.678082, 0.532879, 2.480385, 2.567162},
{0, 3.259785, 2.081752, 0.661029, 1.587558, 2.507624, 2.352855},
{0, 1.678082, 0.661029, 0.587688, 0.564095, 0.115803, 1.245217},
{0, 0.532879, 1.587558, 0.564095, 0.523708, 0.804297, 0.259865},
{0, 2.480385, 2.507624, 0.115803, 0.804297, 0.509191, 2.180337},
{0, 2.567162, 2.352855, 1.245217, 0.259865, 2.180337, 0.778683}};
static float dm_19_7[7][7]={{0,0,0,0,0,0,0},
{0, 1.924817, 3.259699, 1.678128, 0.532863, 2.480398, 2.567133},
{0, 3.259699, 2.081532, 0.661015, 1.587619, 2.507590, 2.352872},
{0, 1.678128, 0.661015, 0.587581, 0.564243, 0.115852, 1.245339},
{0, 0.532863, 1.587619, 0.564243, 0.523585, 0.804442, 0.259908},
{0, 2.480398, 2.507590, 0.115852, 0.804442, 0.509065, 2.180349},
{0, 2.567133, 2.352872, 1.245339, 0.259908, 2.180349, 0.778524}};
static float dm_19_8[7][7]={{0,0,0,0,0,0,0},
{0, 1.921707, 3.257254, 1.677579, 0.532391, 2.480555, 2.567179},
{0, 3.257254, 2.078298, 0.660245, 1.587790, 2.507604, 2.352655},
{0, 1.677579, 0.660245, 0.586053, 0.565436, 0.115818, 1.247825},
{0, 0.532391, 1.587790, 0.565436, 0.522217, 0.807816, 0.260351},
{0, 2.480555, 2.507604, 0.115818, 0.807816, 0.507451, 2.183255},
{0, 2.567179, 2.352655, 1.247825, 0.260351, 2.183255, 0.776767}};
static float dm_19_9[7][7]={{0,0,0,0,0,0,0},
{0, 1.914948, 3.253973, 1.677337, 0.531084, 2.481010, 2.566882},
{0, 3.253973, 2.071131, 0.658362, 1.589059, 2.507048, 2.352997},
{0, 1.677337, 0.658362, 0.582634, 0.567513, 0.117022, 1.252162},
{0, 0.531084, 1.589059, 0.567513, 0.518726, 0.814061, 0.261409},
{0, 2.481010, 2.507048, 0.117022, 0.814061, 0.503793, 2.188359},
{0, 2.566882, 2.352997, 1.252162, 0.261409, 2.188359, 0.772214}};
static float dm_19_10[7][7]={{0,0,0,0,0,0,0},
{0, 1.742218, 3.274206, 1.736365, 0.520548, 2.506409, 2.538636},
{0, 3.274206, 1.874376, 0.601999, 1.751372, 2.493109, 2.410477},
{0, 1.736365, 0.601999, 0.469932, 0.605555, 0.101804, 1.237622},
{0, 0.520548, 1.751372, 0.605555, 0.394004, 0.990584, 0.288953},
{0, 2.506409, 2.493109, 0.101804, 0.990584, 0.393873, 2.187079},
{0, 2.538636, 2.410477, 1.237622, 0.288953, 2.187079, 0.636158}};
static float dm_19_11[7][7]={{0,0,0,0,0,0,0},
{0, 1.468048, 3.334714, 1.879583, 0.513847, 2.525290, 2.448642},
{0, 3.334714, 1.575000, 0.532017, 1.991892, 2.413770, 2.459092},
{0, 1.879583, 0.532017, 0.330291, 0.714265, 0.121153, 1.217842},
{0, 0.513847, 1.991892, 0.714265, 0.242569, 1.209724, 0.357392},
{0, 2.525290, 2.413770, 0.121153, 1.209724, 0.254157, 2.113204},
{0, 2.448642, 2.459092, 1.217842, 0.357392, 2.113204, 0.465079}};
static float dm_19_12[7][7]={{0,0,0,0,0,0,0},
{0, 1.447264, 3.331175, 1.887623, 0.510032, 2.522588, 2.440064},
{0, 3.331175, 1.551640, 0.520175, 2.006256, 2.406278, 2.453450},
{0, 1.887623, 0.520175, 0.321641, 0.733595, 0.124449, 1.227696},
{0, 0.510032, 2.006256, 0.733595, 0.232046, 1.228902, 0.363719},
{0, 2.522588, 2.406278, 0.124449, 1.228902, 0.246735, 2.116614},
{0, 2.440064, 2.453450, 1.227696, 0.363719, 2.116614, 0.455445}};
static float dm_19_13[7][7]={{0,0,0,0,0,0,0},
{0, 1.413676, 3.312147, 1.892690, 0.497363, 2.513815, 2.427618},
{0, 3.312147, 1.512635, 0.491529, 2.029384, 2.398107, 2.440346},
{0, 1.892690, 0.491529, 0.309708, 0.770725, 0.131677, 1.255730},
{0, 0.497363, 2.029384, 0.770725, 0.215276, 1.262537, 0.375238},
{0, 2.513815, 2.398107, 0.131677, 1.262537, 0.238420, 2.134600},
{0, 2.427618, 2.440346, 1.255730, 0.375238, 2.134600, 0.443272}};
static float dm_19_14[7][7]={{0,0,0,0,0,0,0},
{0, 1.390424, 3.289395, 1.895911, 0.494394, 2.515601, 2.419213},
{0, 3.289395, 1.485413, 0.482937, 2.038817, 2.393102, 2.437050},
{0, 1.895911, 0.482937, 0.301201, 0.802783, 0.131369, 1.267332},
{0, 0.494394, 2.038817, 0.802783, 0.208219, 1.278597, 0.381488},
{0, 2.515601, 2.393102, 0.131369, 1.278597, 0.233137, 2.145289},
{0, 2.419213, 2.437050, 1.267332, 0.381488, 2.145289, 0.435049}};
static float dm_19_15[7][7]={{0,0,0,0,0,0,0},
{0, 1.359065, 3.252756, 1.879860, 0.477404, 2.530994, 2.422584},
{0, 3.252756, 1.444344, 0.446651, 2.034691, 2.393761, 2.436293},
{0, 1.879860, 0.446651, 0.279248, 0.878068, 0.136700, 1.277241},
{0, 0.477404, 2.034691, 0.878068, 0.203105, 1.302254, 0.369173},
{0, 2.530994, 2.393761, 0.136700, 1.302254, 0.254187, 2.176724},
{0, 2.422584, 2.436293, 1.277241, 0.369173, 2.176724, 0.429742}};
static float dm_19_16[7][7]={{0,0,0,0,0,0,0},
{0, 1.319235, 3.187463, 1.883259, 0.425750, 2.549595, 2.483464},
{0, 3.187463, 1.390041, 0.356901, 1.935186, 2.431514, 2.438827},
{0, 1.883259, 0.356901, 0.250462, 1.025379, 0.218729, 1.267437},
{0, 0.425750, 1.935186, 1.025379, 0.196407, 1.314921, 0.319083},
{0, 2.549595, 2.431514, 0.218729, 1.314921, 0.318075, 2.206259},
{0, 2.483464, 2.438827, 1.267437, 0.319083, 2.206259, 0.438250}};
static float dm_19_17[7][7]={{0,0,0,0,0,0,0},
{0, 1.160111, 3.036527, 2.090520, 0.506996, 2.523007, 2.425038},
{0, 3.036527, 1.210398, 0.370582, 1.975521, 2.395384, 2.342602},
{0, 2.090520, 0.370582, 0.208600, 1.267580, 0.187575, 1.340450},
{0, 0.506996, 1.975521, 1.267580, 0.167525, 1.417493, 0.331364},
{0, 2.523007, 2.395384, 0.187575, 1.417493, 0.245059, 2.119651},
{0, 2.425038, 2.342602, 1.340450, 0.331364, 2.119651, 0.347729}};
static float dm_19_18[7][7]={{0,0,0,0,0,0,0},
{0, 1.088965, 3.033821, 2.120758, 0.473214, 2.457352, 2.432026},
{0, 3.033821, 1.133849, 0.379829, 2.009372, 2.419403, 2.321236},
{0, 2.120758, 0.379829, 0.179593, 1.357010, 0.233102, 1.418578},
{0, 0.473214, 2.009372, 1.357010, 0.153161, 1.425354, 0.285522},
{0, 2.457352, 2.419403, 0.233102, 1.425354, 0.262864, 2.054949},
{0, 2.432026, 2.321236, 1.418578, 0.285522, 2.054949, 0.338514}};
static float dm_20_5[7][7]={{0,0,0,0,0,0,0},
{0, 1.897075, 3.279011, 1.691793, 0.504730, 2.480118, 2.562844},
{0, 3.279011, 2.039856, 0.633859, 1.632167, 2.502239, 2.351187},
{0, 1.691793, 0.633859, 0.568358, 0.603584, 0.107146, 1.236087},
{0, 0.504730, 1.632167, 0.603584, 0.501897, 0.828959, 0.259130},
{0, 2.480118, 2.502239, 0.107146, 0.828959, 0.486634, 2.206702},
{0, 2.562844, 2.351187, 1.236087, 0.259130, 2.206702, 0.747065}};
static float dm_20_6[7][7]={{0,0,0,0,0,0,0},
{0, 1.897075, 3.279011, 1.691793, 0.504730, 2.480118, 2.562844},
{0, 3.279011, 2.039856, 0.633859, 1.632167, 2.502239, 2.351187},
{0, 1.691793, 0.633859, 0.568358, 0.603584, 0.107146, 1.236087},
{0, 0.504730, 1.632167, 0.603584, 0.501897, 0.828959, 0.259130},
{0, 2.480118, 2.502239, 0.107146, 0.828959, 0.486634, 2.206702},
{0, 2.562844, 2.351187, 1.236087, 0.259130, 2.206702, 0.747065}};
static float dm_20_7[7][7]={{0,0,0,0,0,0,0},
{0, 1.896975, 3.278955, 1.691795, 0.504726, 2.480131, 2.562842},
{0, 3.278955, 2.039753, 0.633848, 1.632190, 2.502228, 2.351194},
{0, 1.691795, 0.633848, 0.568300, 0.603635, 0.107161, 1.236152},
{0, 0.504726, 1.632190, 0.603635, 0.501838, 0.829046, 0.259144},
{0, 2.480131, 2.502228, 0.107161, 0.829046, 0.486574, 2.206739},
{0, 2.562842, 2.351194, 1.236152, 0.259144, 2.206739, 0.746992}};
static float dm_20_8[7][7]={{0,0,0,0,0,0,0},
{0, 1.893588, 3.276862, 1.690784, 0.504129, 2.480570, 2.563086},
{0, 3.276862, 2.036224, 0.632813, 1.632784, 2.502765, 2.351393},
{0, 1.690784, 0.632813, 0.566635, 0.604567, 0.107215, 1.237196},
{0, 0.504129, 1.632784, 0.604567, 0.500459, 0.833358, 0.259465},
{0, 2.480570, 2.502765, 0.107215, 0.833358, 0.484631, 2.209749},
{0, 2.563086, 2.351393, 1.237196, 0.259465, 2.209749, 0.744986}};
static float dm_20_9[7][7]={{0,0,0,0,0,0,0},
{0, 1.884748, 3.272721, 1.689032, 0.502174, 2.481643, 2.563448},
{0, 3.272721, 2.026963, 0.630025, 1.634741, 2.503505, 2.351925},
{0, 1.689032, 0.630025, 0.562287, 0.606772, 0.108251, 1.240282},
{0, 0.502174, 1.634741, 0.606772, 0.496494, 0.843309, 0.260392},
{0, 2.481643, 2.503505, 0.108251, 0.843309, 0.479544, 2.217089},
{0, 2.563448, 2.351925, 1.240282, 0.260392, 2.217089, 0.739346}};
static float dm_20_10[7][7]={{0,0,0,0,0,0,0},
{0, 1.724070, 3.286052, 1.745294, 0.494028, 2.511104, 2.531181},
{0, 3.286052, 1.845625, 0.575819, 1.789622, 2.488166, 2.403681},
{0, 1.745294, 0.575819, 0.464041, 0.655968, 0.086096, 1.231891},
{0, 0.494028, 1.789622, 0.655968, 0.386445, 0.993640, 0.286030},
{0, 2.511104, 2.488166, 0.086096, 0.993640, 0.381186, 2.210917},
{0, 2.531181, 2.403681, 1.231891, 0.286030, 2.210917, 0.619655}};
static float dm_20_11[7][7]={{0,0,0,0,0,0,0},
{0, 1.366924, 3.326755, 1.917379, 0.486377, 2.535956, 2.402764},
{0, 3.326755, 1.458409, 0.487252, 2.081863, 2.377195, 2.464398},
{0, 1.917379, 0.487252, 0.291262, 0.818906, 0.121663, 1.238422},
{0, 0.486377, 2.081863, 0.818906, 0.204468, 1.272391, 0.381068},
{0, 2.535956, 2.377195, 0.121663, 1.272391, 0.212433, 2.115436},
{0, 2.402764, 2.464398, 1.238422, 0.381068, 2.115436, 0.410852}};
static float dm_20_12[7][7]={{0,0,0,0,0,0,0},
{0, 1.349682, 3.322530, 1.923718, 0.483384, 2.534184, 2.393804},
{0, 3.322530, 1.439522, 0.479792, 2.090923, 2.369673, 2.461525},
{0, 1.923718, 0.479792, 0.284782, 0.836368, 0.126042, 1.246251},
{0, 0.483384, 2.090923, 0.836368, 0.197208, 1.286660, 0.385916},
{0, 2.534184, 2.369673, 0.126042, 1.286660, 0.206645, 2.118761},
{0, 2.393804, 2.461525, 1.246251, 0.385916, 2.118761, 0.403098}};
static float dm_20_13[7][7]={{0,0,0,0,0,0,0},
{0, 1.325594, 3.311550, 1.928873, 0.475383, 2.528168, 2.382278},
{0, 3.311550, 1.412034, 0.461445, 2.106893, 2.361332, 2.453619},
{0, 1.928873, 0.461445, 0.277185, 0.862477, 0.132110, 1.265629},
{0, 0.475383, 2.106893, 0.862477, 0.186437, 1.309775, 0.393588},
{0, 2.528168, 2.361332, 0.132110, 1.309775, 0.200886, 2.128515},
{0, 2.382278, 2.453619, 1.265629, 0.393588, 2.128515, 0.394595}};
static float dm_20_14[7][7]={{0,0,0,0,0,0,0},
{0, 1.311939, 3.299898, 1.933137, 0.471935, 2.529169, 2.375251},
{0, 3.299898, 1.395992, 0.455706, 2.114821, 2.356211, 2.451006},
{0, 1.933137, 0.455706, 0.271715, 0.884807, 0.131733, 1.269681},
{0, 0.471935, 2.114821, 0.884807, 0.182317, 1.320966, 0.396050},
{0, 2.529169, 2.356211, 0.131733, 1.320966, 0.199041, 2.134307},
{0, 2.375251, 2.451006, 1.269681, 0.396050, 2.134307, 0.389641}};
static float dm_20_15[7][7]={{0,0,0,0,0,0,0},
{0, 1.290169, 3.289532, 1.928987, 0.454296, 2.557077, 2.372959},
{0, 3.289532, 1.366891, 0.412695, 2.119268, 2.344543, 2.452420},
{0, 1.928987, 0.412695, 0.254556, 0.948114, 0.109102, 1.276760},
{0, 0.454296, 2.119268, 0.948114, 0.179089, 1.351415, 0.361892},
{0, 2.557077, 2.344543, 0.109102, 1.351415, 0.225454, 2.170825},
{0, 2.372959, 2.452420, 1.276760, 0.361892, 2.170825, 0.384073}};
static float dm_20_16[7][7]={{0,0,0,0,0,0,0},
{0, 1.241983, 3.298278, 2.020828, 0.408475, 2.597074, 2.370026},
{0, 3.298278, 1.298912, 0.321238, 2.068440, 2.315534, 2.439604},
{0, 2.020828, 0.321238, 0.220983, 1.147124, 0.213801, 1.254817},
{0, 0.408475, 2.068440, 1.147124, 0.172898, 1.335235, 0.279635},
{0, 2.597074, 2.315534, 0.213801, 1.335235, 0.296732, 2.123562},
{0, 2.370026, 2.439604, 1.254817, 0.279635, 2.123562, 0.381151}};
static float dm_20_17[7][7]={{0,0,0,0,0,0,0},
{0, 1.031083, 3.146699, 2.295330, 0.511540, 2.584730, 2.277981},
{0, 3.146699, 1.064679, 0.357052, 2.105656, 2.264165, 2.292508},
{0, 2.295330, 0.357052, 0.171546, 1.497354, 0.225501, 1.336781},
{0, 0.511540, 2.105656, 1.497354, 0.136152, 1.441587, 0.273770},
{0, 2.584730, 2.264165, 0.225501, 1.441587, 0.196237, 1.955911},
{0, 2.277981, 2.292508, 1.336781, 0.273770, 1.955911, 0.267176}};
static float dm_20_18[7][7]={{0,0,0,0,0,0,0},
{0, 0.943522, 3.116469, 2.274659, 0.422065, 2.542425, 2.299795},
{0, 3.116469, 0.970661, 0.354446, 2.179069, 2.278761, 2.269135},
{0, 2.274659, 0.354446, 0.148767, 1.494225, 0.206332, 1.496611},
{0, 0.422065, 2.179069, 1.494225, 0.128695, 1.562489, 0.209998},
{0, 2.542425, 2.278761, 0.206332, 1.562489, 0.230554, 1.946200},
{0, 2.299795, 2.269135, 1.496611, 0.209998, 1.946200, 0.272444}};
static float dm_20_19[7][7]={{0,0,0,0,0,0,0},
{0, 0.900882, 2.994246, 2.284230, 0.220253, 2.658395, 2.356499},
{0, 2.994246, 0.929797, 0.286242, 2.159140, 2.277679, 2.304699},
{0, 2.284230, 0.286242, 0.130488, 1.356211, 0.237656, 1.714175},
{0, 0.220253, 2.159140, 1.356211, 0.130093, 1.740519, 0.194186},
{0, 2.658395, 2.277679, 0.237656, 1.740519, 0.250414, 1.898882},
{0, 2.356499, 2.304699, 1.714175, 0.194186, 1.898882, 0.292298}};


float **get_ribosum(const char **Alseq, int n_seq, int length){
  int i, j,k;
  float ident=0;
  int pairnum=0;
  float minimum=1;
  float maximum=0.;
  int min;
  int max;
  float **ribo;

  ribo=(float **)vrna_alloc(7*sizeof(float *));
  for (i=0; i<7; i++) {
    ribo[i]=(float *)vrna_alloc(7*sizeof(float));
  }
  for(j=0; j<n_seq-1; j++)
    for(k=j+1; k<n_seq; k++) {
      ident=length-vrna_hamming_distance(Alseq[k],Alseq[j]);
      if ((ident/(length))<minimum) minimum=ident/(float)(length);
      if ((ident/(length))>maximum) maximum=ident/(float)(length);
    }
  /*+2.5 for ALWAYS round up*/
  minimum*=100;
  maximum*=100;
  minimum+=0.5;
  maximum+=0.5;
  if (n_seq==1 || minimum>100.45){
    for (i=0; i<7; i++)
      for (j=0; j<7;j++)
        ribo[i][j]= 0.;
    return ribo;
  }
  min=(int) minimum/5;
  max=(int) maximum/5;

  if (max<12) max=12;
  if (min<5) min=5;
  if (min>=max) min=max-1;
  switch (max) {
  case 12:
    switch (min) {
    case 5:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_12_5[i][j];
      break;
    case 6:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_12_6[i][j];
      break;
    case 7:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_12_7[i][j];
      break;
    case 8:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_12_8[i][j];
      break;
    case 9:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_12_9[i][j];
      break;
    case 10:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_12_10[i][j];
      break;
    case 11:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_12_11[i][j];
      break;
    default:
      vrna_message_error("da hats was grobes im dmchoose\n");
    }
    break;
  case 13:
    switch (min) {
    case 5:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_13_5[i][j];
      break;
    case 6:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_13_6[i][j];
      break;
    case 7:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_13_7[i][j];
      break;
    case 8:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_13_8[i][j];
      break;
    case 9:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_13_9[i][j];
      break;
    case 10:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_13_10[i][j];
      break;
    case 11:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_13_11[i][j];
      break;
    case 12:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_13_12[i][j];
      break;
    default:
      vrna_message_error("da hats was grobes im dmchoose\n");
    }
    break;
  case 14:
    switch (min) {
    case 5:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_14_5[i][j];
      break;
    case 6:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_14_6[i][j];
      break;
    case 7:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_14_7[i][j];
      break;
    case 8:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_14_8[i][j];
      break;
    case 9:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_14_9[i][j];
      break;
    case 10:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_14_10[i][j];
      break;
    case 11:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_14_11[i][j];
      break;
    case 12:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_14_12[i][j];
      break;
    case 13:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_14_13[i][j];
      break;
    default:
      vrna_message_error("da hats was grobes im dmchoose\n");
    }
    break;
  case 15:
    switch (min) {
    case 5:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_15_5[i][j];
      break;
    case 6:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_15_6[i][j];
      break;
    case 7:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_15_7[i][j];
      break;
    case 8:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_15_8[i][j];
      break;
    case 9:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_15_9[i][j];
      break;
    case 10:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_15_10[i][j];
      break;
    case 11:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_15_11[i][j];
      break;
    case 12:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_15_12[i][j];
      break;
    case 13:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_15_13[i][j];
      break;
    case 14:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_15_14[i][j];
      break;
    default:
      vrna_message_error("da hats was grobes im dmchoose\n");
    }
    break;
  case 16:
    switch (min) {
    case 5:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_16_5[i][j];
      break;
    case 6:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_16_6[i][j];
      break;
    case 7:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_16_7[i][j];
      break;
    case 8:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_16_8[i][j];
      break;
    case 9:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_16_9[i][j];
      break;
    case 10:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_16_10[i][j];
      break;
    case 11:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_16_11[i][j];
      break;
    case 12:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_16_12[i][j];
      break;
    case 13:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_16_13[i][j];
      break;
    case 14:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_16_14[i][j];
    break;
    case 15:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_16_15[i][j];
      break;
    default:
      vrna_message_error("da hats was grobes im dmchoose\n");
    }
    break;
  case 17:
    switch (min) {
    case 5:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_17_5[i][j];
      break;
    case 6:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_17_6[i][j];
      break;
    case 7:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_17_7[i][j];
      break;
    case 8:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_17_8[i][j];
      break;
    case 9:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_17_9[i][j];
      break;
    case 10:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_17_10[i][j];
      break;
    case 11:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_17_11[i][j];
      break;
    case 12:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_17_12[i][j];
      break;
    case 13:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_17_13[i][j];
      break;
    case 14:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_17_14[i][j];
    break;
    case 15:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_17_15[i][j];
      break;
    case 16:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_17_16[i][j];
      break;
    default:
      vrna_message_error("da hats was grobes im dmchoose\n");
    }
    break;
  case 18:
    switch (min) {
    case 5:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_18_5[i][j];
      break;
    case 6:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_18_6[i][j];
      break;
    case 7:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_18_7[i][j];
      break;
    case 8:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_18_8[i][j];
      break;
    case 9:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_18_9[i][j];
      break;
    case 10:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_18_10[i][j];
      break;
    case 11:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_18_11[i][j];
      break;
    case 12:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_18_12[i][j];
      break;
    case 13:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_18_13[i][j];
      break;
    case 14:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_18_14[i][j];
    break;
    case 15:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_18_15[i][j];
      break;
    case 16:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_18_16[i][j];
      break;
    case 17:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_18_17[i][j];
      break;
    default:
      vrna_message_error("da hats was grobes im dmchoose\n");
    }
    break;
   case 19:
    switch (min) {
    case 5:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_19_5[i][j];
      break;
    case 6:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_19_6[i][j];
      break;
    case 7:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_19_7[i][j];
      break;
    case 8:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_19_8[i][j];
      break;
    case 9:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_19_9[i][j];
      break;
    case 10:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_19_10[i][j];
      break;
    case 11:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_19_11[i][j];
      break;
    case 12:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_19_12[i][j];
      break;
    case 13:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_19_13[i][j];
      break;
    case 14:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_19_14[i][j];
      break;
    case 15:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_19_15[i][j];
      break;
    case 16:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_19_16[i][j];
      break;
    case 17:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_19_17[i][j];
      break;
    case 18:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_19_18[i][j];
      break;
    default:
      vrna_message_error("da hats was grobes im dmchoose\n");
    }
    break;
  case 20:
    switch (min) {
    case 5:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_20_5[i][j];
      break;
    case 6:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_20_6[i][j];
      break;
    case 7:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_20_7[i][j];
      break;
    case 8:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_20_8[i][j];
      break;
    case 9:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_20_9[i][j];
      break;
    case 10:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_20_10[i][j];
      break;
    case 11:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_20_11[i][j];
      break;
    case 12:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_20_12[i][j];
      break;
    case 13:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_20_13[i][j];
      break;
    case 14:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_20_14[i][j];
    break;
    case 15:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_20_15[i][j];
      break;
    case 16:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_20_16[i][j];
      break;
    case 17:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_20_17[i][j];
      break;
    case 18:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_20_18[i][j];
      break;
    case 19:
      for (i=0; i<7; i++) for (j=0; j<7;j++) ribo[i][j]=dm_20_19[i][j];
      break;
    default:
      vrna_message_error("da hats was grobes im dmchoose\n");
    }
    break;
  default:
    vrna_message_error("da hats was grobes im dmchoose\n");
  }
  return ribo;
}

PUBLIC float **readribosum(char *name){

  float **dm;
  char *line;
  FILE *fp;
  int i=0;
  int who=0;
  float a,b,c,d,e,f;
  int translator[7]={0,5,1,2,3,6,4};

  fp=fopen(name,"r");
  dm=(float **)vrna_alloc(7*sizeof(float*));
  for (i=0; i<7;i++) {
    dm[i]=(float *)vrna_alloc(7*sizeof(float));
  }
  while(1) { /*bisma hoit fertisch san*/
    line=get_line(fp);
    if (*line=='#') continue;
    i=0;
    i=sscanf(line,"%f %f %f %f %f %f",&a,&b,&c,&d,&e,&f);
    if (i==0) break;
    dm[translator[++who]][translator[1]]=a;
    dm[translator[who]][translator[2]]=b;
    dm[translator[who]][translator[3]]=c;
    dm[translator[who]][translator[4]]=d;
    dm[translator[who]][translator[5]]=e;
    dm[translator[who]][translator[6]]=f;
    free(line);
    if (who==6) break;
  }
  fclose(fp);
  return dm;
}

findpath.c/     0           0     0     644     14536     `
/* gcc -fopenmp -g3 -DTEST_FINDPATH findpath.c -o FINDpath -lRNA -lm -I ../H/ -L ./ */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include "findpath.h"
#include "data_structures.h"
#include "model.h"
#include "params.h"
#include "fold.h"
#include "cofold.h"
#include "fold_vars.h"
#include "utils.h"
#include "structure_utils.h"

#ifdef _OPENMP
#include <omp.h>
#endif

#define LOOP_EN

/**
 *  @brief
 */
typedef struct move {
  int i;  /* i,j>0 insert; i,j<0 delete */
  int j;
  int when;  /* 0 if still available, else resulting distance from start */
  int E;
} move_t;

/**
 *  @brief
 */
typedef struct intermediate {
  short *pt;      /**<  @brief  pair table */
  int Sen;        /**<  @brief  saddle energy so far */
  int curr_en;    /**<  @brief  current energy */
  move_t *moves;  /**<  @brief  remaining moves to target */
} intermediate_t;

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/
PRIVATE int         BP_dist;
PRIVATE move_t      *path=NULL;
PRIVATE int         path_fwd; /* 1: struc1->struc2, else struc2 -> struc1 */

PRIVATE vrna_fold_compound_t  *backward_compat_compound = NULL;

#ifdef _OPENMP

/* NOTE: all variables are assumed to be uninitialized if they are declared as threadprivate
*/
#pragma omp threadprivate(BP_dist, path, path_fwd, backward_compat_compound)

#endif

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/
PRIVATE move_t  *copy_moves(move_t *mvs);
PRIVATE int     compare_ptable(const void *A, const void *B);
PRIVATE int     compare_energy(const void *A, const void *B);
PRIVATE int     compare_moves_when(const void *A, const void *B);
PRIVATE void    free_intermediate(intermediate_t *i);

#ifdef TEST_FINDPATH

/* TEST_FINDPATH, COFOLD */
PRIVATE void  usage(void);

#endif

PRIVATE int     find_path_once(vrna_fold_compound_t *vc, const char *struc1, const char *struc2, int maxE, int maxl);
PRIVATE int     try_moves(vrna_fold_compound_t *vc, intermediate_t c, int maxE, intermediate_t *next, int dist);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/
PUBLIC void free_path(vrna_path_t *path){
  vrna_path_t *tmp = path;
  if(tmp){
    while(tmp->s){ free(tmp->s); tmp++;}
    free(path);
  }
}

PUBLIC int
find_saddle(const char *seq,
            const char *struc1,
            const char *struc2,
            int max){

  int                 maxE;
  char                *sequence;
  vrna_fold_compound_t  *vc;
  vrna_md_t           md;

  vc = NULL;
  set_model_details(&md);

  if(backward_compat_compound){
    if(!strcmp(seq, backward_compat_compound->sequence)){ /* check if sequence is the same as before */
      md.window_size = backward_compat_compound->length;
      if(!memcmp(&md, &(backward_compat_compound->params->model_details), sizeof(vrna_md_t))){ /* check if model_details are the same as before */
        vc = backward_compat_compound; /* re-use previous vrna_fold_compound_t */
      }
    }
  }

  if(!vc){
    vrna_fold_compound_free(backward_compat_compound);

    sequence = vrna_cut_point_insert(seq, cut_point);

    backward_compat_compound = vc = vrna_fold_compound(sequence, &md, VRNA_OPTION_EVAL_ONLY);

    free(sequence);
  }

  maxE = vrna_path_findpath_saddle(vc, struc1, struc2, max);

  return maxE;
}

PUBLIC int
vrna_path_findpath_saddle( vrna_fold_compound_t *vc,
                  const char *struc1,
                  const char *struc2,
                  int max) {

  int         maxl, maxE;
  const char  *tmp;
  move_t      *bestpath=NULL;
  int         dir;

  path_fwd  = 0;
  maxE      = INT_MAX - 1;

  maxl = 1;
  do {
    int saddleE;
    path_fwd = !path_fwd;
    if (maxl>max) maxl=max;
    if(path) free(path);
    saddleE  = find_path_once(vc, struc1, struc2, maxE, maxl);
    if (saddleE<maxE) {
      maxE = saddleE;
      if (bestpath) free(bestpath);
      bestpath = path;
      path = NULL;
      dir = path_fwd;
    } else{
      free(path);path=NULL;
    }
    tmp=struc1;
    struc1=struc2;
    struc2=tmp;
    maxl *=2;
  } while (maxl<2*max);

  /* (re)set some globals */
  path=bestpath;
  path_fwd = dir;

  return maxE;
}

PUBLIC vrna_path_t *
get_path( const char *seq,
          const char *s1,
          const char* s2,
          int maxkeep){

  vrna_path_t              *route    = NULL;
  char                *sequence = NULL;
  vrna_fold_compound_t  *vc       = NULL;
  vrna_md_t           md;

  set_model_details(&md);

  if(backward_compat_compound){
    if(!strcmp(seq, backward_compat_compound->sequence)){ /* check if sequence is the same as before */
      if(!memcmp(&md, &(backward_compat_compound->params->model_details), sizeof(vrna_md_t))){ /* check if model_details are the same as before */
        vc = backward_compat_compound; /* re-use previous vrna_fold_compound_t */
      }
    }
  }

  if(!vc){
    vrna_fold_compound_free(backward_compat_compound);

    sequence = vrna_cut_point_insert(seq, cut_point);

    backward_compat_compound = vc = vrna_fold_compound(sequence, &md, VRNA_OPTION_EVAL_ONLY);

    free(sequence);
  }

  route = vrna_path_findpath(vc, s1, s2, maxkeep);

  return (route);
}

PUBLIC vrna_path_t *
vrna_path_findpath(vrna_fold_compound_t *vc,
              const char *s1,
              const char* s2,
              int maxkeep){

  int E, d;
  vrna_path_t *route=NULL;

  E = vrna_path_findpath_saddle(vc, s1, s2, maxkeep);

  route = (vrna_path_t *)vrna_alloc((BP_dist+2)*sizeof(vrna_path_t));

  qsort(path, BP_dist, sizeof(move_t), compare_moves_when);

  if (path_fwd) {
    /* memorize start of path */
    route[0].s  = strdup(s1);
    route[0].en = vrna_eval_structure(vc, s1);

    for (d=0; d<BP_dist; d++) {
      int i,j;
      route[d+1].s = strdup(route[d].s);
      i = path[d].i; j=path[d].j;
      if (i<0) { /* delete */
        route[d+1].s[(-i)-1] = route[d+1].s[(-j)-1] = '.';
      } else {
        route[d+1].s[i-1] = '('; route[d+1].s[j-1] = ')';
      }
      route[d+1].en = path[d].E/100.0;
    }
  }
  else {
    /* memorize start of path */

    route[BP_dist].s  = strdup(s2);
    route[BP_dist].en = vrna_eval_structure(vc, s2);

    for (d=0; d<BP_dist; d++) {
      int i,j;
      route[BP_dist-d-1].s = strdup(route[BP_dist-d].s);
      i = path[d].i;
      j = path[d].j;
      if (i<0) { /* delete */
        route[BP_dist-d-1].s[(-i)-1] = route[BP_dist-d-1].s[(-j)-1] = '.';
      } else {
        route[BP_dist-d-1].s[i-1] = '('; route[BP_dist-d-1].s[j-1] = ')';
      }
      route[BP_dist-d-1].en = path[d].E/100.0;
    }
  }

#if _DEBUG_FINDPATH_
  fprintf(stderr, "\n%s\n%s\n%s\n\n", seq, s1, s2);
  for (d=0; d<=BP_dist; d++)
    fprintf(stderr, "%s %6.2f\n", route[d].s, route[d].en);
  fprintf(stderr, "%d\n", *num_entry);
#endif

  free(path);path=NULL;
  return (route);
}

PRIVATE int
try_moves(vrna_fold_compound_t *vc,
          intermediate_t c,
          int maxE,
          intermediate_t *next,
          int dist){

  int *loopidx, len, num_next=0, en, oldE;
  move_t *mv;
  short *pt;

  len = c.pt[0];
  loopidx = vrna_loopidx_from_ptable(c.pt);
  oldE = c.Sen;
  for (mv=c.moves; mv->i!=0; mv++) {
    int i,j;
    if (mv->when>0) continue;
    i = mv->i; j = mv->j;
    pt = (short *) vrna_alloc(sizeof(short)*(len+1));
    memcpy(pt, c.pt,(len+1)*sizeof(short));
    if (j<0) { /*it's a delete move */
      pt[-i]=0;
      pt[-j]=0;
    } else { /* insert move */
      if ((loopidx[i] == loopidx[j]) && /* i and j belong to same loop */
          (pt[i] == 0) && (pt[j]==0)     /* ... and are unpaired */
          ) {
        pt[i]=j;
        pt[j]=i;
      } else {
        free(pt);
        continue; /* llegal move, try next; */
      }
    }
#ifdef LOOP_EN
    en = c.curr_en + vrna_eval_move_pt(vc, c.pt, i, j);
#else
    en = vrna_eval_structure_pt(vc, pt);
#endif
    if (en<maxE) {
      next[num_next].Sen = (en>oldE)?en:oldE;
      next[num_next].curr_en = en;
      next[num_next].pt = pt;
      mv->when=dist;
      mv->E = en;
      next[num_next++].moves = copy_moves(c.moves);
      mv->when=0;
    }
    else free(pt);
  }
  free(loopidx);
  return num_next;
}

PRIVATE int find_path_once(vrna_fold_compound_t *vc, const char *struc1, const char *struc2, int maxE, int maxl) {
  short *pt1, *pt2;
  move_t *mlist;
  int i, len, d, dist=0, result;
  intermediate_t *current, *next;

  pt1 = vrna_ptable(struc1);
  pt2 = vrna_ptable(struc2);
  len = (int) strlen(struc1);

  mlist = (move_t *) vrna_alloc(sizeof(move_t)*len); /* bp_dist < n */

  for (i=1; i<=len; i++) {
    if (pt1[i] != pt2[i]) {
      if (i<pt1[i]) { /* need to delete this pair */
        mlist[dist].i = -i;
        mlist[dist].j = -pt1[i];
        mlist[dist++].when = 0;
      }
      if (i<pt2[i]) { /* need to insert this pair */
        mlist[dist].i = i;
        mlist[dist].j = pt2[i];
        mlist[dist++].when = 0;
      }
    }
  }
  free(pt2);
  BP_dist = dist;
  current = (intermediate_t *) vrna_alloc(sizeof(intermediate_t)*(maxl+1));
  current[0].pt = pt1;
  current[0].Sen = current[0].curr_en = vrna_eval_structure_pt(vc, pt1);
  current[0].moves = mlist;
  next = (intermediate_t *) vrna_alloc(sizeof(intermediate_t)*(dist*maxl+1));

  for (d=1; d<=dist; d++) { /* go through the distance classes */
    int c, u, num_next=0;
    intermediate_t *cc;

    for (c=0; current[c].pt != NULL; c++) {
      num_next += try_moves(vc, current[c], maxE, next+num_next, d);
    }
    if (num_next==0) {
      for (cc=current; cc->pt != NULL; cc++) free_intermediate(cc);
      current[0].Sen=INT_MAX;
      break;
    }
    /* remove duplicates via sort|uniq
       if this becomes a bottleneck we can use a hash instead */
    qsort(next, num_next, sizeof(intermediate_t),compare_ptable);
    for (u=0,c=1; c<num_next; c++) {
      if (memcmp(next[u].pt,next[c].pt,sizeof(short)*len)!=0) {
        next[++u] = next[c];
      } else {
        free_intermediate(next+c);
      }
    }
    num_next = u+1;
    qsort(next, num_next, sizeof(intermediate_t),compare_energy);
    /* free the old stuff */
    for (cc=current; cc->pt != NULL; cc++) free_intermediate(cc);
    for (u=0; u<maxl && u<num_next; u++) {
      current[u] = next[u];
    }
    for (; u<num_next; u++)
      free_intermediate(next+u);
    num_next=0;
  }
  free(next);
  path = current[0].moves;
  result = current[0].Sen;
  free(current[0].pt); free(current);
  return(result);
}

PRIVATE void free_intermediate(intermediate_t *i) {
   free(i->pt);
   free(i->moves);
   i->pt = NULL;
   i->moves = NULL;
   i->Sen = INT_MAX;
 }

PRIVATE int compare_ptable(const void *A, const void *B) {
  intermediate_t *a, *b;
  int c;
  a = (intermediate_t *) A;
  b = (intermediate_t *) B;

  c = memcmp(a->pt, b->pt, a->pt[0]*sizeof(short));
  if (c!=0) return c;
  if ((a->Sen - b->Sen) != 0) return (a->Sen - b->Sen);
  return (a->curr_en - b->curr_en);
}

PRIVATE int compare_energy(const void *A, const void *B) {
  intermediate_t *a, *b;
  a = (intermediate_t *) A;
  b = (intermediate_t *) B;

  if ((a->Sen - b->Sen) != 0) return (a->Sen - b->Sen);
  return (a->curr_en - b->curr_en);
}

PRIVATE int compare_moves_when(const void *A, const void *B) {
  move_t *a, *b;
  a = (move_t *) A;
  b = (move_t *) B;

  return(a->when - b->when);
}

PRIVATE move_t* copy_moves(move_t *mvs) {
  move_t *newX;
  newX = (move_t *) vrna_alloc(sizeof(move_t)*(BP_dist+1));
  memcpy(newX,mvs,sizeof(move_t)*(BP_dist+1));
  return newX;
}

#ifdef TEST_FINDPATH

PUBLIC void print_path(const char *seq, const char *struc) {
  int d;
  char *s;
  s = strdup(struc);
  if (cut_point == -1)
    printf("%s\n%s\n", seq, s);
    /* printf("%s\n%s %6.2f\n", seq, s, vrna_eval_structure_simple(seq,s)); */
  else {
    char *pstruct, *pseq;
    pstruct = vrna_cut_point_insert(s, cut_point);
    pseq = vrna_cut_point_insert(seq, cut_point);
    printf("%s\n%s\n", pseq, pstruct);
    /* printf("%s\n%s %6.2f\n", pseq, pstruct, vrna_eval_structure_simple(seq,s)); */
    free(pstruct);
    free(pseq);
  }
  qsort(path, BP_dist, sizeof(move_t), compare_moves_when);
  for (d=0; d<BP_dist; d++) {
    int i,j;
    i = path[d].i; j=path[d].j;
    if (i<0) { /* delete */
      s[(-i)-1] = s[(-j)-1] = '.';
    } else {
      s[i-1] = '('; s[j-1] = ')';
    }
    /* printf("%s %6.2f - %6.2f\n", s, vrna_eval_structure_simple(seq,s), path[d].E/100.0); */
  }
  free(s);
}

int main(int argc, char *argv[]) {
  char *line, *seq, *s1, *s2;
  int E, maxkeep=1000;
  int verbose=0, i;
  vrna_path_t *route, *r;

  for (i=1; i<argc; i++) {
    switch ( argv[i][1] ) {
      case 'm': if (strcmp(argv[i],"-m")==0)
                  sscanf(argv[++i], "%d", &maxkeep);
                break;
      case 'v': verbose = !strcmp(argv[i],"-v");
                break;
      case 'd': if (strcmp(argv[i],"-d")==0){
                  sscanf(argv[++i], "%d", &dangles);
                  md.dangles = dangles;
                }
                break;
      default: usage();
    }
  }

  cut_point = -1;
  line = get_line(stdin);
  seq = vrna_cut_point_remove(line, &cut_point);
  free(line);   
  line = get_line(stdin);
  s1 = vrna_cut_point_remove(line, &cut_point);
  free(line);
  line = get_line(stdin);
  s2 = vrna_cut_point_remove(line, &cut_point);
  free(line);

  E = find_saddle(seq, s1, s2, maxkeep);
  printf("saddle_energy = %6.2f\n", E/100.);
  if (verbose) {
      if (path_fwd)
          print_path(seq,s1);
      else
          print_path(seq,s2);
      free(path);
      path = NULL;
      route = get_path(seq, s1, s2, maxkeep);
      for (r=route; r->s; r++) {
          if (cut_point == -1) {
              printf("%s %6.2f\n", r->s, r->en);
              /* printf("%s %6.2f - %6.2f\n", r->s, vrna_eval_structure_simple(seq,r->s), r->en); */
          } else {
              char *pstruct;
              pstruct = vrna_cut_point_insert(r->s, cut_point);
              printf("%s %6.2f\n", pstruct, r->en);
              /* printf("%s %6.2f - %6.2f\n", pstruct, vrna_eval_structure_simple(seq,r->s), r->en); */
              free(pstruct);
          }
          free(r->s);
      }
      free(route);
  }
  free(seq); free(s1); free(s2);
  return(EXIT_SUCCESS);
}

static void usage(void){
  vrna_message_error("usage: findpath.c  [-m depth] [-d[0|1|2]] [-v]");
}

#endif
convert_epars.c/0           0     0     644     33731     `
/*
###################################
# convert energy parameter files  #
# from ViennaRNAPackage 1.8.4 to  #
# 2.0 format                      #
#                                 #
# Ronny Lorenz                    #
###################################
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>

#include "utils.h"
#include "fold_vars.h"
#include "read_epars.h"
#include "pair_mat.h"

#include "1.8.4_epars.h"
#include "1.8.4_intloops.h"

#include "convert_epars.h"

enum parset_184 {UNKNOWN_184= -1, QUIT_184, S_184, SH_184, HP_184, B_184, IL_184, MMI_184, MMH_184, MMM_184, MM_H_184,
             DE5_184, DE3_184, DE5_H_184, DE3_H_184, ML_184, TL_184, TRI_184, TE_184, NIN_184, MISC_184,
             INT11_184, INT11_H_184, INT21_184, INT21_H_184, INT22_184, INT22_H_184};


PRIVATE unsigned int  read_old_parameter_file(FILE *ifile, int skip_header);
PRIVATE void          write_new_parameter_file(FILE *ofile, unsigned int options);
PRIVATE void          rd_stacks(int stack[NBPAIRS+1][NBPAIRS+1], FILE *fp);
PRIVATE void          rd_loop(int looparray[31], FILE *fp);
PRIVATE void          rd_mismatch(int mismatch[NBPAIRS+1][5][5], FILE *fp);
PRIVATE void          rd_int11(int int11[NBPAIRS+1][NBPAIRS+1][5][5], FILE *fp);
PRIVATE void          rd_int21(int int21[NBPAIRS+1][NBPAIRS+1][5][5][5], FILE *fp);
PRIVATE void          rd_int22(int int22[NBPAIRS+1][NBPAIRS+1][5][5][5][5], FILE *fp);
PRIVATE void          rd_dangle(int dangles[NBPAIRS+1][5], FILE *fp);
PRIVATE void          rd_MLparams(FILE *fp);
PRIVATE void          rd_misc(FILE *fp);
PRIVATE void          rd_ninio(FILE *fp);
PRIVATE void          rd_Tetra_loop(FILE *fp);
PRIVATE void          rd_Tri_loop(FILE *fp);
PRIVATE void          check_symmetry(void);
PRIVATE enum          parset_184 gettype_184(char ident[]);
PRIVATE char          *get_array1(int *arr, int size, FILE *fp);
PRIVATE void          ignore_comment(char *line);
PRIVATE void          display_array(int *p, int size, int line, FILE *fp);


PUBLIC void convert_parameter_file(const char *iname, const char *oname, unsigned int options){
  FILE          *ifile, *ofile;
  unsigned int  old_options = 0;
  int           skip_input_header = 0;

  if(options & VRNA_CONVERT_OUTPUT_DUMP){
    if(oname == NULL) oname = iname;
    skip_input_header = 1;
  }
  else{
    if(iname == NULL){
      ifile = stdin;
      skip_input_header = 1;
    }
    else if(!(ifile=fopen(iname,"r"))){
      fprintf(stderr, "convert_epars: can't open file %s\n", iname);
      return;
    }
    /* read old (1.8.4 format) parameter file */
    old_options = read_old_parameter_file(ifile, skip_input_header);
    if(ifile != stdin) fclose(ifile);
    check_symmetry();
  }

  if(options & VRNA_CONVERT_OUTPUT_VANILLA)
    options = old_options;

  if(oname == NULL) ofile = stdout;
  else if(!(ofile=fopen(oname,"a+"))){
    fprintf(stderr, "convert_epars: can't open file %s for writing\n", oname);
    return;
  }
  write_new_parameter_file(ofile, options);
  if(ofile != stdout) fclose(ofile);
}


/*------------------------------------------------------------*/
PRIVATE unsigned int read_old_parameter_file(FILE *ifile, int skip_header){
  char                  *line, ident[32];
  enum      parset_184  type;
  int                   r, last;
  unsigned  int         read_successfully = 0;

  if (!(line = get_line(ifile))) {
    vrna_message_warning("convert_epars: can't read input parameter file");
    return 0;
  }
  if(!skip_header){
    if (strncmp(line,"## RNAfold parameter file",25)!=0){
      vrna_message_warning("convert_epars: Missing header line in input parameter file.\n"
                "May be this file has incorrect format?");
      free(line);
      return 0;
    }
    free(line);
    line = get_line(ifile);
  }
  last = 0;
  do{
    r = sscanf(line, "# %31s", ident);
    if (r==1){
      type = gettype_184(ident);
      switch (type){
        case QUIT_184:    if(ifile == stdin){
                            fprintf(stderr, "press ENTER to continue...\n");
                            fflush(stderr);
                          }
                          last = 1;
                          break;
        case SH_184:      rd_stacks(enthalpies_184, ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_STACK;
                          break;
        case S_184:       rd_stacks(stack37_184, ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_STACK;
                          break;
        case HP_184:      rd_loop(hairpin37_184, ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_HP;
                          break;
        case B_184:       rd_loop(bulge37_184, ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_BULGE;
                          break;
        case IL_184:      rd_loop(internal_loop37_184, ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_INT;
                          break;
        case MMH_184:     rd_mismatch(mismatchH37_184, ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_MM_HP;
                          break;
        case MMI_184:     rd_mismatch(mismatchI37_184, ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_MM_INT
                                              |VRNA_CONVERT_OUTPUT_MM_INT_1N  /* since 1:n-interior loop mismatches are treated seperately in 2.0 */
                                              |VRNA_CONVERT_OUTPUT_MM_INT_23; /* since 2:3-interior loop mismatches are treated seperately in 2.0 */
                          break;
        case MMM_184:     rd_mismatch(mismatchM37_184, ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_MM_MULTI;
                          break;
        case MM_H_184:    rd_mismatch(mism_H_184, ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_MM_HP      /* since hairpin mismatches are treated seperately in 2.0 */
                                              |VRNA_CONVERT_OUTPUT_MM_INT     /* since interior loop  mismatches are treated seperately in 2.0 */
                                              |VRNA_CONVERT_OUTPUT_MM_INT_1N  /* since 1:n-interior loop mismatches are treated seperately in 2.0 */
                                              |VRNA_CONVERT_OUTPUT_MM_INT_23  /* since 2:3-interior loop mismatches are treated seperately in 2.0 */
                                              |VRNA_CONVERT_OUTPUT_MM_MULTI;  /* since multi loop mismatches are treated seperately in 2.0 */
                          break;
        case INT11_184:   rd_int11(int11_37_184, ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_INT_11;
                          break;
        case INT11_H_184: rd_int11(int11_H_184, ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_INT_11;
                          break;
        case INT21_184:   rd_int21(int21_37_184, ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_INT_21;
                          break;
        case INT21_H_184: rd_int21(int21_H_184, ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_INT_21;
                          break;
        case INT22_184:   rd_int22(int22_37_184, ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_INT_22;
                          break;
        case INT22_H_184: rd_int22(int22_H_184, ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_INT_22;
                          break;
        case DE5_184:     rd_dangle(dangle5_37_184, ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_DANGLE5
                                              |VRNA_CONVERT_OUTPUT_MM_MULTI /* since multi loop mismatches were treated as dangle contribution */
                                              |VRNA_CONVERT_OUTPUT_MM_EXT;  /* since exterior loop mismatches were treated as dangle contribution */
                          break;
        case DE5_H_184:   rd_dangle(dangle5_H_184, ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_DANGLE5
                                              |VRNA_CONVERT_OUTPUT_MM_MULTI /* since multi loop mismatches were treated as dangle contribution */
                                              |VRNA_CONVERT_OUTPUT_MM_EXT;  /* since exterior loop mismatches were treated as dangle contribution */
                          break;
        case DE3_184:     rd_dangle(dangle3_37_184, ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_DANGLE3
                                              |VRNA_CONVERT_OUTPUT_MM_MULTI /* since multi loop mismatches were treated as dangle contribution */
                                              |VRNA_CONVERT_OUTPUT_MM_EXT;  /* since exterior loop mismatches were treated as dangle contribution */
                          break;
        case DE3_H_184:   rd_dangle(dangle3_H_184, ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_DANGLE3
                                              |VRNA_CONVERT_OUTPUT_MM_MULTI /* since multi loop mismatches were treated as dangle contribution */
                                              |VRNA_CONVERT_OUTPUT_MM_EXT;  /* since exterior loop mismatches were treated as dangle contribution */
                          break;
        case ML_184:      rd_MLparams(ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_ML
                                              |VRNA_CONVERT_OUTPUT_MISC;    /* since TerminalAU went to "misc" section */
                          break;
        case NIN_184:     rd_ninio(ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_NINIO;
                          break;
        case TL_184:      rd_Tetra_loop(ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_SPECIAL_HP;
                          break;
        case TRI_184:     rd_Tri_loop(ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_SPECIAL_HP;
                          break;
        case MISC_184:    rd_misc(ifile);
                          read_successfully |= VRNA_CONVERT_OUTPUT_MISC;
                          break;
        default:          /* do nothing but complain */
                          fprintf(stderr,"convert_parameter_file: Unknown field identifier in `%s'\n", line);
      }
    } /* else ignore line */
    free(line);
  } while((line=get_line(ifile)) && !last);
  return read_successfully;
}

PRIVATE void display_array(int *p, int size, int nl, FILE *fp){
  int i;
  for (i=1; i<=size; i++, p++) {
    switch(*p){
      case  INF: fprintf(fp,"   INF");    break;
      case -INF: fprintf(fp,"  -INf");    break;
      case  DEF: fprintf(fp,"   DEF");    break;
      default:   fprintf(fp,"%6d",  *p);  break;
    }
    if ((i%nl)==0) fprintf(fp,"\n");
  }
  if (size%nl) fprintf(fp,"\n");
  return;
}

PRIVATE char *get_array1(int *arr, int size, FILE *fp){
  int    i, p, pos, pp, r, last;
  char  *line, buf[16];
  i = last = 0;
  while( i<size ) {
    line = get_line(fp);
    if (!line) vrna_message_error("convert_epars: unexpected end of file in get_array1");
    ignore_comment(line);
    pos=0;
    while ((i<size)&&(sscanf(line+pos,"%15s%n", buf, &pp)==1)) {
      pos += pp;
      if (buf[0]=='*') {i++; continue;}
      else if (buf[0]=='x') { /* should only be used for loop parameters */
        if (i==0) vrna_message_error("convert_epars: can't extrapolate first value");
        p = arr[last] + (int) (0.5+ lxc37_184*log(((double) i)/(double)(last)));
      }
      else if (strcmp(buf,"DEF") == 0) p = DEF;
      else if (strcmp(buf,"INF") == 0) p = INF;
      else if (strcmp(buf,"NST") == 0) p = NST;
      else {
        r=sscanf(buf,"%d", &p);
        if (r!=1) {
          return line+pos;
          fprintf(stderr, "convert_epars: can't interpret `%s' in get_array1\n", buf);
          exit(1);
        }
        last = i;
      }
      arr[i++]=p;
    }
    free(line);
  }

  return NULL;
}
/*------------------------------------------------------------*/

PRIVATE void  rd_stacks(int stacks[NBPAIRS+1][NBPAIRS+1], FILE *fp)
{
  int    i;
  char  *cp;
  for (i=1; i<=NBPAIRS; i++) {
    cp = get_array1(stacks[i]+1,NBPAIRS, fp);
    if (cp) {
      fprintf(stderr,"convert_epars: \nrd_stacks: %s\n", cp);
      exit(1);
    }
  }
  return;
}
/*------------------------------------------------------------*/

PRIVATE void rd_loop(int loop[31], FILE *fp)
{
  char *cp;

  cp   = get_array1(loop, 31, fp);

  if (cp) {
    fprintf(stderr,"convert_epars: \nrd_loop: %s\n", cp);
    exit(1);
  }
  return;
}
/*------------------------------------------------------------*/

PRIVATE void rd_mismatch(int mismatch[NBPAIRS+1][5][5], FILE *fp)
{
  char  *cp;
  int    i;

  for (i=1; i<NBPAIRS+1; i++) {
    cp = get_array1(mismatch[i][0],5*5, fp);
    if (cp) {
      fprintf(stderr, "convert_epars: rd_mismatch: in field mismatch[%d]\n\t%s\n", i, cp);
      exit(1);
    }
  }
  return;
}

/*------------------------------------------------------------*/
PRIVATE void rd_int11(int int11[NBPAIRS+1][NBPAIRS+1][5][5], FILE *fp)
{
  char  *cp;
  int    i, j;

  for (i=1; i<NBPAIRS+1; i++) {
    for (j=1; j<NBPAIRS+1; j++) {
      cp = get_array1(int11[i][j][0],5*5, fp);
      if (cp) {
        fprintf(stderr, "convert_epars: rd_int11: in field int11[%d][%d]\n\t%s\n", i, j, cp);
        exit(1);
      }
    }
  }
  return;
}

/*------------------------------------------------------------*/
PRIVATE void rd_int21(int int21[NBPAIRS+1][NBPAIRS+1][5][5][5], FILE *fp)
{
  char  *cp;
  int    i, j, k;

  for (i=1; i<NBPAIRS+1; i++) {
    for (j=1; j<NBPAIRS+1; j++) {
      for (k=0; k<5; k++) {
        cp = get_array1(int21[i][j][k][0],5*5, fp);
        if (cp) {
          fprintf(stderr, "convert_epars: rd_int21: in field int21[%d][%d][%d]\n\t%s\n",
                  i, j, k, cp);
          exit(1);
        }
      }
    }
  }
  return;
}

/*------------------------------------------------------------*/
PRIVATE void rd_int22(int int22[NBPAIRS+1][NBPAIRS+1][5][5][5][5], FILE *fp)
{
  char  *cp;
  int    i, j, k, l, m;

  for (i=1; i<NBPAIRS+1; i++)
    for (j=1; j<NBPAIRS+1; j++)
      for (k=1; k<5; k++)
        for (l=1; l<5; l++)
          for (m=1; m<5; m++) {
            cp = get_array1(int22[i][j][k][l][m]+1,4, fp);
            if (cp) {
              fprintf(stderr, "convert_epars: rd_int22: in field "
                      "int22[%d][%d][%d][%d][%d]\n\t%s\n",
                      i, j, k, l, m, cp);
              exit(1);
            }
          }

  return;
}

/*------------------------------------------------------------*/
PRIVATE void  rd_dangle(int dangle[NBPAIRS+1][5], FILE *fp)
{
  int   i;
  char *cp;

  for (i=0; i< NBPAIRS+1; i++) {
    cp = get_array1(dangle[i],5, fp);
    if (cp) {
      fprintf(stderr,"convert_epars: \nrd_dangle: %s\n", cp);
      exit(1);
    }
  }
  return;
}

/*------------------------------------------------------------*/
PRIVATE void  rd_MLparams(FILE *fp)
{
  char *cp;
  int values[4];

  cp   = get_array1(values,4, fp);
  if (cp) {
    fprintf(stderr,"convert_epars: rd_MLparams: %s\n", cp);
    exit(1);
  }

  ML_BASE37_184     = values[0];
  ML_closing37_184  = values[1];
  ML_intern37_184   = values[2];
  TerminalAU_184    = values[3];

  return;
}

/*------------------------------------------------------------*/

PRIVATE void  rd_misc(FILE *fp)
{
  char *cp;
  int values[1]; /* so far just one */

  cp   = get_array1(values,1, fp);
  if (cp) {
    fprintf(stderr,"convert_epars: rd_misc: %s\n", cp);
    exit(1);
  }

  DuplexInit_184 = values[0];

  return;
}

/*------------------------------------------------------------*/

PRIVATE void  rd_ninio(FILE *fp)
{
  char  *cp;
  int temp[2];

  cp = get_array1(temp, 2, fp);

  if (cp) {
    fprintf(stderr,"convert_epars: rd_F_ninio: %s\n", cp);
    exit(1);
  }
  F_ninio37_184[2] = temp[0];
  MAX_NINIO_184  = temp[1];
  return;
}

/*------------------------------------------------------------*/
PRIVATE void  rd_Tetra_loop(FILE *fp)
{
  int    i, r;
  char   *buf;

  i=0;
  memset(&Tetraloops_184, 0, 1400);
  memset(&TETRA_ENERGY37_184, 0, sizeof(int)*200);
  do {
    buf = get_line(fp);
    if (buf==NULL) break;
    r = sscanf(buf,"%6s %d", &Tetraloops_184[7*i], &TETRA_ENERGY37_184[i]);
    strcat(Tetraloops_184, " ");
    free(buf);
    i++;
  } while((r==2)&&(i<200));
  return;
}

/*------------------------------------------------------------*/
PRIVATE void  rd_Tri_loop(FILE *fp)
{
  int    i, r;
  char   *buf;

  i=0;
  memset(&Triloops_184, 0, 241);
  memset(&Triloop_E37_184, 0, sizeof(int)*40);
  do {
    buf = get_line(fp);
    if (buf==NULL) break;
    r = sscanf(buf,"%5s %d", &Triloops_184[6*i], &Triloop_E37_184[i]);
    Triloops_184[6*i+5]=' ';
    free(buf);
    i++;
  } while((r==2)&&(i<40));
  return;
}

/*------------------------------------------------------------*/


PRIVATE void ignore_comment(char * line)
{
  /* excise C style comments */
  /* only one comment per line, no multiline comments */
  char *cp1, *cp2;

  if ((cp1=strstr(line, "/*"))) {
    cp2 = strstr(cp1, "*/");
    if (cp2==NULL)
      vrna_message_error("convert_epars: unclosed comment in parameter file");
    /* can't use strcpy for overlapping strings */
    for (cp2+=2; *cp2!='\0'; cp2++, cp1++)
      *cp1 = *cp2;
    *cp1 = '\0';
  }

  return;
}

PRIVATE enum parset_184 gettype_184(char ident[]){
  if (strcmp(ident,"stack_enthalpies") == 0)          return SH_184;
  else if (strcmp(ident,"stack_energies") == 0)       return S_184;
  else if (strcmp(ident,"hairpin" ) == 0)             return HP_184;
  else if (strcmp(ident,"bulge") == 0)                return B_184;
  else if (strcmp(ident,"internal_loop") == 0)        return IL_184;
  else if (strcmp(ident,"mismatch_hairpin") == 0)     return MMH_184;
  else if (strcmp(ident,"mismatch_interior") == 0)    return MMI_184;
  else if (strcmp(ident,"mismatch_multi") == 0)       return MMM_184;
  else if (strcmp(ident,"mismatch_enthalpies") == 0)  return MM_H_184;
  else if (strcmp(ident,"int11_energies") == 0)       return INT11_184;
  else if (strcmp(ident,"int11_enthalpies") == 0)     return INT11_H_184;
  else if (strcmp(ident,"int21_energies") == 0)       return INT21_184;
  else if (strcmp(ident,"int21_enthalpies") == 0)     return INT21_H_184;
  else if (strcmp(ident,"int22_energies") == 0)       return INT22_184;
  else if (strcmp(ident,"int22_enthalpies") == 0)     return INT22_H_184;
  else if (strcmp(ident,"dangle5")== 0)               return DE5_184;
  else if (strcmp(ident,"dangle3")== 0)               return DE3_184;
  else if (strcmp(ident,"dangle5_enthalpies")== 0)    return DE5_H_184;
  else if (strcmp(ident,"dangle3_enthalpies")== 0)    return DE3_H_184;
  else if (strcmp(ident,"ML_params")== 0)             return ML_184;
  else if (strcmp(ident,"NINIO") == 0)                return NIN_184;
  else if (strcmp(ident,"Tetraloops") == 0)           return TL_184;
  else if (strcmp(ident,"Triloops") == 0)             return TRI_184;
  else if (strcmp(ident,"END") == 0)                  return QUIT_184;
  else return UNKNOWN_184;
}

PRIVATE void write_new_parameter_file(FILE *ofile, unsigned int option_bits){
  int           c;
  char          *pnames[] = {"NP", "CG", "GC", "GU", "UG", "AU", "UA", " @"};
  char          bnames[]  = "@ACGU";
  unsigned  int options   = 0;

  options = (option_bits & VRNA_CONVERT_OUTPUT_ALL) ?
              VRNA_CONVERT_OUTPUT_HP
            | VRNA_CONVERT_OUTPUT_STACK
            | VRNA_CONVERT_OUTPUT_MM_HP
            | VRNA_CONVERT_OUTPUT_MM_INT
            | VRNA_CONVERT_OUTPUT_MM_INT_1N
            | VRNA_CONVERT_OUTPUT_MM_INT_23
            | VRNA_CONVERT_OUTPUT_MM_MULTI
            | VRNA_CONVERT_OUTPUT_MM_EXT
            | VRNA_CONVERT_OUTPUT_DANGLE5
            | VRNA_CONVERT_OUTPUT_DANGLE3
            | VRNA_CONVERT_OUTPUT_INT_11
            | VRNA_CONVERT_OUTPUT_INT_21
            | VRNA_CONVERT_OUTPUT_INT_22
            | VRNA_CONVERT_OUTPUT_BULGE
            | VRNA_CONVERT_OUTPUT_INT
            | VRNA_CONVERT_OUTPUT_ML
            | VRNA_CONVERT_OUTPUT_MISC
            | VRNA_CONVERT_OUTPUT_SPECIAL_HP
            | VRNA_CONVERT_OUTPUT_NINIO
            :
              option_bits;

  make_pair_matrix(); /* needed for special loop energy contributions */

  fprintf(ofile,"## RNAfold parameter file v2.0\n");

  if(options & VRNA_CONVERT_OUTPUT_STACK){
    fprintf(ofile,"\n# %s\n", settype(S));
    fprintf(ofile,"/*  CG    GC    GU    UG    AU    UA    @  */\n");
    for (c=1; c<NBPAIRS+1; c++)
      display_array(stack37_184[c]+1,NBPAIRS,NBPAIRS, ofile);
    fprintf(ofile,"\n# %s\n", settype(S_H));
    fprintf(ofile,"/*  CG    GC    GU    UG    AU    UA    @  */\n");
    for (c=1; c<NBPAIRS+1; c++)
      display_array(enthalpies_184[c]+1,NBPAIRS,NBPAIRS, ofile);
  }

  if(options & VRNA_CONVERT_OUTPUT_MM_HP){
    fprintf(ofile,"\n# %s\n", settype(MMH));
    { int i,k;
      for (k=1; k<NBPAIRS+1; k++)
        for (i=0; i<5; i++)
          display_array(mismatchH37_184[k][i],5,5, ofile);
    }
    fprintf(ofile,"\n# %s\n", settype(MMH_H));
    { int i,k;
      for (k=1; k<NBPAIRS+1; k++)
        for (i=0; i<5; i++)
          display_array(mism_H_184[k][i],5,5, ofile);
    }
  }

  if(options & VRNA_CONVERT_OUTPUT_MM_INT){
    fprintf(ofile,"\n# %s\n", settype(MMI));
    { int i,k;
      for (k=1; k<NBPAIRS+1; k++)
        for (i=0; i<5; i++)
          display_array(mismatchI37_184[k][i],5,5, ofile);
    }
    fprintf(ofile,"\n# %s\n", settype(MMI_H));
    { int i,k;
      for (k=1; k<NBPAIRS+1; k++)
        for (i=0; i<5; i++)
          display_array(mism_H_184[k][i],5,5, ofile);
    }
  }

  if(options & VRNA_CONVERT_OUTPUT_MM_INT_1N){
    fprintf(ofile,"\n# %s\n", settype(MMI1N));
    { int i,k;
      for (k=1; k<NBPAIRS+1; k++)
        for (i=0; i<5; i++)
          display_array(mismatchI37_184[k][i],5,5, ofile);
    }
    fprintf(ofile,"\n# %s\n", settype(MMI1N_H));
    { int i,k;
    for (k=1; k<NBPAIRS+1; k++)
      for (i=0; i<5; i++)
        display_array(mism_H_184[k][i],5,5, ofile);
    }
  }

  if(options & VRNA_CONVERT_OUTPUT_MM_INT_23){
    fprintf(ofile,"\n# %s\n", settype(MMI23));
    { int i,k;
      for (k=1; k<NBPAIRS+1; k++)
        for (i=0; i<5; i++)
          display_array(mismatchI37_184[k][i],5,5, ofile);
    }
    fprintf(ofile,"\n# %s\n", settype(MMI23_H));
    { int i,k;
    for (k=1; k<NBPAIRS+1; k++)
      for (i=0; i<5; i++)
        display_array(mism_H_184[k][i],5,5, ofile);
    }
  }

  if(options & VRNA_CONVERT_OUTPUT_MM_MULTI){
    fprintf(ofile,"\n# %s\n", settype(MMM));
    fprintf(ofile,"/*  @     A     C     G     U   */\n");
    { int i,j,k;
      int bla[5];
      for (k=1; k<NBPAIRS+1; k++)
        for (i=0; i<5; i++){
          for(j=0;j<5; j++)
            bla[j] = ((dangle5_37_184[k][i] == INF) ? 0 : dangle5_37_184[k][i]) + ((dangle3_37_184[k][j] == INF) ? 0 : dangle3_37_184[k][j]);
          display_array(bla,5,5, ofile);
        }
    }
    fprintf(ofile,"\n# %s\n", settype(MMM_H));
    fprintf(ofile,"/*  @     A     C     G     U   */\n");
    { int i,j,k,bla[5];
      for (k=1; k<NBPAIRS+1; k++)
        for (i=0; i<5; i++){
          for(j=0;j<5; j++)
            bla[j] = ((dangle5_H_184[k][i] == INF) ? 0 : dangle5_H_184[k][i]) + ((dangle3_H_184[k][j] == INF) ? 0 : dangle3_H_184[k][j]);
          display_array(bla,5,5, ofile);
        }
    }
  }

  if(options & VRNA_CONVERT_OUTPUT_MM_EXT){
    fprintf(ofile,"\n# %s\n", settype(MME));
    fprintf(ofile,"/*  @     A     C     G     U   */\n");
    { int i,j,k;
      int bla[5];
      for (k=1; k<NBPAIRS+1; k++)
        for (i=0; i<5; i++){
          for(j=0;j<5; j++)
            bla[j] = ((dangle5_37_184[k][i] == INF) ? 0 : dangle5_37_184[k][i]) + ((dangle3_37_184[k][j] == INF) ? 0 : dangle3_37_184[k][j]);
          display_array(bla,5,5, ofile);
        }
    }
    fprintf(ofile,"\n# %s\n", settype(MME_H));
    fprintf(ofile,"/*  @     A     C     G     U   */\n");
    { int i,j,k,bla[5];
      for (k=1; k<NBPAIRS+1; k++)
        for (i=0; i<5; i++){
          for(j=0;j<5; j++)
            bla[j] = ((dangle5_37_184[k][i] == INF) ? 0 : dangle5_H_184[k][i]) + ((dangle3_H_184[k][j] == INF) ? 0 : dangle3_H_184[k][j]);
          display_array(bla,5,5, ofile);
        }
    }
  }

  if(options & VRNA_CONVERT_OUTPUT_DANGLE5){
    fprintf(ofile,"\n# %s\n", settype(D5));
    fprintf(ofile,"/*  @     A     C     G     U   */\n");
    for (c=1; c<NBPAIRS+1; c++)
      display_array(dangle5_37_184[c], 5, 5, ofile);
    fprintf(ofile,"\n# %s\n", settype(D5_H));
    fprintf(ofile,"/*  @     A     C     G     U   */\n");
    for (c=1; c<NBPAIRS+1; c++)
      display_array(dangle5_H_184[c], 5, 5, ofile);
  }

  if(options & VRNA_CONVERT_OUTPUT_DANGLE3){
    fprintf(ofile,"\n# %s\n", settype(D3));
    fprintf(ofile,"/*  @     A     C     G     U   */\n");
    for (c=1; c<NBPAIRS+1; c++)
      display_array(dangle3_37_184[c], 5, 5, ofile);
    fprintf(ofile,"\n# %s\n", settype(D3_H));
    fprintf(ofile,"/*  @     A     C     G     U   */\n");
    for (c=1; c<NBPAIRS+1; c++)
      display_array(dangle3_H_184[c], 5, 5, ofile);
  }

  if(options & VRNA_CONVERT_OUTPUT_INT_11){
    /* don't print "no pair" entries for interior loop arrays */
    fprintf(ofile,"\n# %s\n", settype(INT11));
    { int i,k,l;
      for (k=1; k<NBPAIRS+1; k++)
        for (l=1; l<NBPAIRS+1; l++){
          fprintf(ofile, "/* %2s..%2s */\n", pnames[k], pnames[l]);
          for (i=0; i<5; i++)
            display_array(int11_37_184[k][l][i], 5, 5, ofile);
        }
    }
    fprintf(ofile,"\n# %s\n", settype(INT11_H));
    { int i,k,l;
      for (k=1; k<NBPAIRS+1; k++)
        for (l=1; l<NBPAIRS+1; l++){
          fprintf(ofile, "/* %2s..%2s */\n", pnames[k], pnames[l]);
          for (i=0; i<5; i++)
            display_array(int11_H_184[k][l][i],5,5, ofile);
        }
    }
  }

  if(options & VRNA_CONVERT_OUTPUT_INT_21){
    fprintf(ofile,"\n# %s\n", settype(INT21));
    { int p1, p2, i, j;
      for (p1=1; p1<NBPAIRS+1; p1++)
        for (p2=1; p2<NBPAIRS+1; p2++)
          for (i=0; i<5; i++){
            fprintf(ofile, "/* %2s.%c..%2s */\n", pnames[p1], bnames[i], pnames[p2]);
            for (j=0; j<5; j++)
              display_array(int21_37_184[p1][p2][i][j],5,5, ofile);
          }
    }
    fprintf(ofile,"\n# %s\n", settype(INT21_H));
    { int p1, p2, i, j;
      for (p1=1; p1<NBPAIRS+1; p1++)
        for (p2=1; p2<NBPAIRS+1; p2++)
          for (i=0; i<5; i++){
            fprintf(ofile, "/* %2s.%c..%2s */\n", pnames[p1], bnames[i], pnames[p2]);
            for (j=0; j<5; j++)
              display_array(int21_H_184[p1][p2][i][j],5,5, ofile);
          }
    }
  }

  if(options & VRNA_CONVERT_OUTPUT_INT_22){
    fprintf(ofile,"\n# %s\n", settype(INT22));
    { int p1, p2, i, j, k;
      for (p1=1; p1<NBPAIRS; p1++)
        for (p2=1; p2<NBPAIRS; p2++)
          for (i=1; i<5; i++)
            for (j=1; j<5; j++){
              fprintf(ofile, "/* %2s.%c%c..%2s */\n", pnames[p1], bnames[i], bnames[j], pnames[p2]);
              for (k=1; k<5; k++)
                display_array(int22_37_184[p1][p2][i][j][k]+1,4,5, ofile);
            }
    }
    fprintf(ofile,"\n# %s\n", settype(INT22_H));
    { int p1, p2, i, j, k;
      for (p1=1; p1<NBPAIRS; p1++)
        for (p2=1; p2<NBPAIRS; p2++)
          for (i=1; i<5; i++)
            for (j=1; j<5; j++){
              fprintf(ofile, "/* %2s.%c%c..%2s */\n", pnames[p1], bnames[i], bnames[j], pnames[p2]);
              for (k=1; k<5; k++)
                display_array(int22_H_184[p1][p2][i][j][k]+1,4,5, ofile);
            }
    }
  }

  if(options & VRNA_CONVERT_OUTPUT_HP){
    fprintf(ofile,"\n# %s\n", settype(HP));
    display_array(hairpin37_184, 31, 10, ofile);
    /* we had no hairpin enthalpies before, so
    *  we just pretend to have had some with value 0
    */
    fprintf(ofile,"\n# %s\n", settype(HP_H));
    {
      fprintf(ofile, "   INF   INF   INF");
      for(c=4;c<=31; c++){
        fprintf(ofile, "%6d", 0);
        if(c%10 == 0) fprintf(ofile, "\n");
      }
    }
    fprintf(ofile,"\n");
  }

  if(options & VRNA_CONVERT_OUTPUT_BULGE){
    fprintf(ofile,"\n# %s\n", settype(B));
    display_array(bulge37_184, 31, 10, ofile);

    /* we had no bulge enthalpies before, so
    *  we just pretend to have had some with value 0
    */
    fprintf(ofile,"\n# %s\n", settype(B_H));
    {
      fprintf(ofile, "   INF");
      for(c=2;c<=31; c++){
        fprintf(ofile, "%6d", 0);
        if(c%10 == 0) fprintf(ofile, "\n");
      }
    }
    fprintf(ofile,"\n");
  }

  if(options & VRNA_CONVERT_OUTPUT_INT){
    fprintf(ofile,"\n# %s\n", settype(IL));
    display_array(internal_loop37_184, 31, 10, ofile);

    /* we had no internal_loop enthalpies before, so
    *  we just pretend to have had some with value 0
    */
    fprintf(ofile,"\n# %s\n", settype(IL_H));
    {
      fprintf(ofile, "   INF   INF   INF   INF");
      for(c=5;c<=31; c++){
        fprintf(ofile, "%6d", 0);
        if(c%10 == 0) fprintf(ofile, "\n");
      }
    }
    fprintf(ofile,"\n");
    fprintf(ofile,"\n# %s\n"
                  "/* Ninio = MIN(max, m*|n1-n2| */\n"
                  "/*\t    m\t  m_dH     max  */\n"
                  "\t%6d\t%6d\t%6d\n", settype(NIN), F_ninio37_184[2], 0, MAX_NINIO_184);
  }

  if(options & VRNA_CONVERT_OUTPUT_ML){
    fprintf(ofile,"\n# %s\n", settype(ML));
    fprintf(ofile,"/* F = cu*n_unpaired + cc + ci*loop_degree (+TermAU) */\n");
    fprintf(ofile,"/*\t    cu\t cu_dH\t    cc\t cc_dH\t    ci\t ci_dH  */\n");
    fprintf(ofile,"\t%6d\t%6d\t%6d\t%6d\t%6d\t%6d\n", ML_BASE37_184, 0, ML_closing37_184, 0, ML_intern37_184, 0);
  }

  if(options & VRNA_CONVERT_OUTPUT_MISC){
    fprintf(ofile,"\n# %s\n", settype(MISC));
    fprintf(ofile,"/* all parameters are pairs of 'energy enthalpy' */\n");
    fprintf(ofile,"/*    DuplexInit     TerminalAU   LXC  */\n");
    fprintf(ofile,"   %6d %6d %6d %6d   %3.6f %6d\n", DuplexInit_184, 0, TerminalAU_184, 0, lxc37_184, 0);
  }

  if(options & VRNA_CONVERT_OUTPUT_SPECIAL_HP){
    fprintf(ofile,"\n# %s\n", settype(TRI));
    {
      int base_en = hairpin37_184[3];
      int base_dH = TETRA_ENTH37_184;
      for (c=0; c< (int)strlen(Triloops_184)/6; c++){
        int en = base_en;
        char bla[5];
        strncpy(bla, Triloops_184+c*6, 5);
        int type = pair[(short)encode_char(toupper(bla[0]))][(short)encode_char(toupper(bla[4]))];
        if(type > 2) en += TerminalAU_184;
        fprintf(ofile,"\t%.5s %6d %6d\n", Triloops_184+c*6, Triloop_E37_184[c] + en, base_dH);
      }
    }

    /* since the old hairpin loop function treated the tabulated tetraloop energy as bonus
    *  and the new one takes this tabulated energy as a total energy, we have to compute some
    *  things now...
    */
    fprintf(ofile,"\n# %s\n", settype(TL));
    {
      int base_en = hairpin37_184[4];
      int base_dH = TETRA_ENTH37_184;
      for (c=0; c< (int)strlen(Tetraloops_184)/7; c++){
        char bla[6];
        int en = base_en;
        int dH = base_dH;
        strncpy(bla, Tetraloops_184+c*7, 6);
        short si  = (short)encode_char(toupper(bla[1]));
        short sj  = (short)encode_char(toupper(bla[4]));
        int type  = pair[(short)encode_char(toupper(bla[0]))][(short)encode_char(toupper(bla[5]))];
        en   += mismatchH37_184[type][si][sj];
        dH   += mism_H_184[type][si][sj];
        fprintf(ofile,"\t%.6s %6d %6d\n", Tetraloops_184+c*7, en + TETRA_ENERGY37_184[c], dH);
      }
    }
    fprintf(ofile,"\n# %s\n", settype(HEX));
    {
      fprintf(ofile, "\n");
    }
  }

  fprintf(ofile, "\n# %s\n", settype(QUIT));
}

PRIVATE void check_symmetry(void) {
  int i,j,k,l;

  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      if (stack37_184[i][j] != stack37_184[j][i])
        fprintf(stderr, "WARNING: stacking energies not symmetric\n");

  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      if (enthalpies_184[i][j] != enthalpies_184[j][i])
        fprintf(stderr, "WARNING: stacking enthalpies not symmetric\n");


  /* interior 1x1 loops */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      for (k=0; k<5; k++)
        for (l=0; l<5; l++)
          if (int11_37_184[i][j][k][l] != int11_37_184[j][i][l][k])
            fprintf(stderr, "WARNING: int11 energies not symmetric\n");

  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      for (k=0; k<5; k++)
        for (l=0; l<5; l++)
          if (int11_H_184[i][j][k][l] != int11_H_184[j][i][l][k])
            fprintf(stderr, "WARNING: int11 enthalpies not symmetric\n");

  /* interior 2x2 loops */
  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      for (k=0; k<5; k++)
        for (l=0; l<5; l++) {
          int m,n;
          for (m=0; m<5; m++)
            for (n=0; n<5; n++)
              if (int22_37_184[i][j][k][l][m][n] != int22_37_184[j][i][m][n][k][l])
                fprintf(stderr, "WARNING: int22 energies not symmetric\n");
        }

  for (i=0; i<=NBPAIRS; i++)
    for (j=0; j<=NBPAIRS; j++)
      for (k=0; k<5; k++)
        for (l=0; l<5; l++) {
          int m,n;
          for (m=0; m<5; m++)
            for (n=0; n<5; n++)
              if (int22_H_184[i][j][k][l][m][n] != int22_H_184[j][i][m][n][k][l])
                fprintf(stderr, "WARNING: int22 enthalpies not symmetric: %d %d %d %d %d %d\n", i,j,k,l,m,n);
        }
}

MEA.c/          0           0     0     644     7780      `
/*
                               MEA.c
                 c  Ivo L Hofacker, Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>    /* #defines DBL_EPSILON */
#include <math.h>
#include "fold_vars.h"
#include "utils.h"
#include "params.h"
#include "gquad.h"
#include "MEA.h"

/* compute an MEA structure, i.e. the structure maximising
   EA = \sum_{(i,j) \in S} 2\gamma p_{i,j} + \sum_{i is unpaired} p^u_i

   This can be computed by a variant of the Nussinov recursion:
   M(i,j) = min(M(i,j-1)+pu[j], min_k M(i,k-1)+C(k,j)
   C(i,j) = 2*gamma*p_ij + M(i+1,j-1)

   Just for fun, we implement it as a sparse DP algorithm.
   At any time we store only the current and previous row of M.
   The C matrix is implemented as a sparse matrix:
   For each j we store in C[j] a list of values (i, MEA([i..j])), containing
   the MEA over all structures closed by (i,j).
   The list is sparse since only C values where C(i,j)==M(i,j) can
   contribute to the optimal solution.
*/

typedef struct Litem {
  int i;
  double A;
} Litem;

typedef struct List {
  unsigned size;   /* allocated space */
  unsigned nelem;
  Litem *list;
} List;

PRIVATE int comp_plist(const void *a, const void *b);
PRIVATE plist *prune_sort(plist *p, double *pu, int n, double gamma, short *S, int gq);
PRIVATE void pushC(List *c, int i, double a);

struct MEAdat{
  plist *pl;
  double *pu;
  double gamma;
  List *C;
  double *Mi;
  char * structure;
};

PRIVATE void mea_backtrack(const struct MEAdat *bdat, int i, int j, int paired, short *S, vrna_exp_param_t *pf);

PUBLIC float MEA(plist *p, char *structure, double gamma) {
  return MEA_seq(p, NULL, structure, gamma, NULL);
}

PUBLIC float MEA_seq(plist *p, const char *sequence, char *structure, double gamma, vrna_exp_param_t *pf){

  int i,j,n;
  Litem *li;
  plist *pp, *pl;
  short *S = NULL;
  int with_gquad = 0;

  List *C;
  double MEA, *Mi, *Mi1, *tmp, *pu;
  struct MEAdat bdat;

  n = strlen(structure);
  for (i=0; i<n; i++) structure[i] = '.';

  if(sequence){
    if(pf){
      S = vrna_seq_encode(sequence, &(pf->model_details));
    } else {
      vrna_exp_param_t *pf_params;
      vrna_md_t         md;
      set_model_details(&md);
      pf_params = vrna_exp_params(&md);
      S = vrna_seq_encode(sequence, &(pf_params->model_details));
      with_gquad = pf_params->model_details.gquad;
      free(pf_params);
    }
  }
  if(pf)
    with_gquad = pf->model_details.gquad;

  pu = vrna_alloc(sizeof(double)*(n+1));
  pp = pl = prune_sort(p, pu, n, gamma, S, with_gquad);

  C = (List*) vrna_alloc((n+1)*(sizeof(List)));

  Mi = (double *) vrna_alloc((n+1)*sizeof(double));
  Mi1 = (double *) vrna_alloc((n+1)*sizeof(double));

  for (i=n; i>0; i--) {
    Mi[i] = pu[i];
    for (j=i+1; j<=n; j++) {
      double EA;
      Mi[j] = Mi[j-1] + pu[j];
      for (li=C[j].list; li<C[j].list+C[j].nelem; li++) {
        EA = li->A + Mi[(li->i) -1];
        Mi[j] = MAX2(Mi[j], EA);
      }
      if (pp->i == i && pp->j ==j) {
        EA = 2*gamma*pp->p +  Mi1[j-1];
        if (Mi[j]<EA) {
          Mi[j]=EA;
          pushC(&C[j], i, EA); /* only push into C[j] list if optimal */
        }
        pp++;
      }

    }
    tmp = Mi1; Mi1 = Mi; Mi = tmp;
  }

  MEA = Mi1[n];

  bdat.structure = structure; bdat.gamma = gamma;
  bdat.C = C;  bdat.Mi=Mi1; bdat.pl=pl; bdat.pu = pu;
  mea_backtrack(&bdat, 1, n, 0, S, pf);
  free(Mi); free(Mi1); free(pl); free(pu);
  for (i=1; i<=n; i++)
    if (C[i].list) free(C[i].list);
  free(C);
  if(S) free(S);
  return MEA;
}

PRIVATE int comp_plist(const void *a, const void *b) {
  plist *A, *B;
  int di;
  A = (plist *)a;
  B = (plist *)b;
  di = (B->i - A->i);
  if (di!=0) return di;
  return (A->j - B->j);
}


PRIVATE plist *prune_sort(plist *p, double *pu, int n, double gamma, short *S, int gq){
  /*
     produce a list containing all base pairs with
     2*gamma*p_ij > p^u_i + p^u_j
     already sorted to be in the order we need them within the DP
  */
  unsigned size, i, nump = 0;
  plist *pp, *pc, *pc2;

  for (i=1; i<=n; i++) pu[i]=1.;

  for (pc=p; pc->i >0; pc++) {
    pu[pc->i] -= pc->p;
    pu[pc->j] -= pc->p;
  }

  if(gq){
    if(!S) vrna_message_error("no sequence information available in MEA gquad!");
    /* remove probabilities that i or j are enclosed by a gquad */
    for (i=1; i<=n; i++){
      for(pc2 = p; pc2->i > 0; pc2++){
        /* skip all non-gquads */
        if(S[pc2->i] != 3) continue;
        if(S[pc2->j] != 3) continue;
        /* remove only if i is enclosed */
        if((pc2->i < i) && (pc2->j > i))
          pu[i] -= pc2->p;
      }
    }
  }

  size = n+1;
  pp = vrna_alloc(sizeof(plist)*(n+1));
  for (pc=p; pc->i >0; pc++) {
    if (pc->i > n) vrna_message_error("mismatch between plist and structure in MEA()");
    if (pc->p*2*gamma > pu[pc->i] + pu[pc->j]) {
      if (nump+1 >= size) {
        size += size/2 + 1;
        pp = vrna_realloc(pp, size*sizeof(plist));
      }
      pp[nump++] = *pc;
    }
  }
  pp[nump].i = pp[nump].j = pp[nump].p = 0;
  qsort(pp, nump, sizeof(plist), comp_plist);
  return pp;
}

PRIVATE void pushC(List *c, int i, double a) {
  if (c->nelem+1>=c->size) {
    c->size = MAX2(8,c->size*sqrt(2));
    c->list = vrna_realloc(c->list, sizeof(Litem)*c->size);
  }
  c->list[c->nelem].i = i;
  c->list[c->nelem].A = a;
  c->nelem++;
}

PRIVATE void mea_backtrack(const struct MEAdat *bdat, int i, int j, int pair, short *S, vrna_exp_param_t *pf){
  /* backtrack structure for the interval [i..j] */
  /* recursively calls itself, recomputes the necessary parts of the M matrix */
  List *C; Litem *li;
  double *Mi, prec;
  double *pu;
  int fail=1;
  int gq = 0;
  if(pf)
    gq = pf->model_details.gquad;


  C = bdat->C;
  Mi = bdat->Mi;
  pu = bdat->pu;

  if (pair) {
    int k;
    /* if pair == 1, insert pair and re-compute Mi values */
    /* else Mi is already filled */
    if(gq){
      if((S[i] == 3) && (S[j] == 3)){
        int L, l[3];
        get_gquad_pattern_pf(S, i, j, pf, &L, l);
        for(k=0;k<L;k++){
          bdat->structure[i+k-1]\
          = bdat->structure[i+k+L+l[0]-1]\
          = bdat->structure[i+k+2*L+l[0]+l[1]-1]\
          = bdat->structure[i+k+3*L+l[0]+l[1]+l[2]-1]\
          = '+';
        }
        return;
      } else {
        bdat->structure[i-1] = '(';
        bdat->structure[j-1] = ')';
        i++; j--;
        /* We've done this before in MEA() but didn't keep the results */
        Mi[i-1]=0; Mi[i]=pu[i];
        for (k=i+1; k<=j; k++) {
          Mi[k] = Mi[k-1] + pu[k];
          for (li=C[k].list; li<C[k].list+C[k].nelem && li->i >= i; li++) {
            double EA;
            EA = li->A + Mi[(li->i) -1];
            Mi[k] = MAX2(Mi[k], EA);
          }
        }
      }
    } else {
      bdat->structure[i-1] = '(';
      bdat->structure[j-1] = ')';
      i++; j--;
      /* We've done this before in MEA() but didn't keep the results */
      Mi[i-1]=0; Mi[i]=pu[i];
      for (k=i+1; k<=j; k++) {
        Mi[k] = Mi[k-1] + pu[k];
        for (li=C[k].list; li<C[k].list+C[k].nelem && li->i >= i; li++) {
          double EA;
          EA = li->A + Mi[(li->i) -1];
          Mi[k] = MAX2(Mi[k], EA);
        }
      }
    }
  }

  prec = DBL_EPSILON * Mi[j];
  /* Mi values are filled, do the backtrace */
  while (j>i && Mi[j] <= Mi[j-1] + pu[j] + prec) {
    bdat->structure[j-1]='.';
    j--;
  }
  for (li=C[j].list; li<C[j].list + C[j].nelem && li->i >= i; li++) {
    if (Mi[j] <= li->A + Mi[(li->i) -1] + prec) {
      if (li->i > i+3) mea_backtrack(bdat, i, (li->i)-1, 0, S, pf);
      mea_backtrack(bdat, li->i, j, 1, S, pf);
      fail = 0;
    }
  }
  if (fail && j>i) vrna_message_error("backtrack failed for MEA()");
}
mm.c/           0           0     0     644     3494      `
/*
      Implementation of Nussinov Maximum Matching
      Ronny Lorenz
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include "utils.h"
#include "energy_par.h"
#include "fold_vars.h"
#include "pair_mat.h"
#include "params.h"

/* the encoded string MUST have the length of the sequence at position 0!!! */
PUBLIC unsigned int maximumMatching(const char *string){
  unsigned int i, j, l, length, max = 0;
  unsigned int *mm;            /* holds maximum matching on subsequence [i,j] */
  short *encodedString = encode_sequence(string, 0);
  int *iindx = vrna_idx_row_wise((unsigned) encodedString[0]);
  make_pair_matrix();
  length = (unsigned int)encodedString[0];
  mm = (unsigned int *) vrna_alloc(sizeof(unsigned int)*((length*(length+1))/2+2));
  for(j = 1; j<=length; j++)
    for(i=(j>TURN?(j-TURN):1); i<j; i++)
      mm[iindx[i]-j] = 0;
  for(i=length-TURN-1;i>0; i--)
    for(j=i+TURN+1; j<= length; j++){
      max = mm[iindx[i]-j+1];
      for(l=j-TURN-1; l>=i; l--)
        if(pair[encodedString[l]][encodedString[j]])
          max = MAX2(max, ((l>i) ? mm[iindx[i]-l+1] : 0) + 1 + mm[iindx[l+1]-j+1]);
       mm[iindx[i]-j] = max;
    }
  max = mm[iindx[1]-length];
  free(mm);
  free(iindx);
  free(encodedString);
  return max;
}

/* the encoded string MUST have the length of the sequence at position 0!!! */
PUBLIC unsigned int *maximumMatchingConstraint(const char *string, short *ptable){
  unsigned int i, j, l, length, max = 0;
  unsigned int *mm;            /* holds maximum matching on subsequence [i,j] */
  short *encodedString = encode_sequence(string, 0);
  int *iindx = vrna_idx_row_wise((unsigned) encodedString[0]);
  make_pair_matrix();
  length = (unsigned int)encodedString[0];
  mm = (unsigned int *) vrna_alloc(sizeof(unsigned int)*((length*(length+1))/2+2));
  for(j = 1; j<=length; j++)
    for(i=(j>TURN?(j-TURN):1); i<j; i++)
      mm[iindx[i]-j] = 0;
  for(i=length-TURN-1;i>0; i--)
    for(j=i+TURN+1; j<= length; j++){
      max = mm[iindx[i]-j+1];
      for(l=j-TURN-1; l>=i; l--){
        if(pair[encodedString[l]][encodedString[j]]){
          if(ptable[l] != j)
            max = MAX2(max, ((l>i) ? mm[iindx[i]-l+1] : 0) + 1 + mm[iindx[l+1]-j+1]);
        }
      }
      mm[iindx[i]-j] = max;
    }
  free(iindx);
  free(encodedString);
  return mm;
}

/* the encoded string MUST have the length of the sequence at position 0!!! */
PUBLIC unsigned int *maximumMatching2Constraint(const char *string, short *ptable, short *ptable2){
  unsigned int i, j, l, length, max = 0;
  unsigned int *mm;            /* holds maximum matching on subsequence [i,j] */
  short *encodedString = encode_sequence(string, 0);
  int *iindx = vrna_idx_row_wise((unsigned) encodedString[0]);
  make_pair_matrix();
  length = (unsigned int)encodedString[0];
  mm = (unsigned int *) vrna_alloc(sizeof(unsigned int)*((length*(length+1))/2+2));
  for(j = 1; j<=length; j++)
    for(i=(j>TURN?(j-TURN):1); i<j; i++)
      mm[iindx[i]-j] = 0;
  for(i=length-TURN-1;i>0; i--)
    for(j=i+TURN+1; j<= length; j++){
      max = mm[iindx[i]-j+1];
      for(l=j-TURN-1; l>=i; l--){
        if(pair[encodedString[l]][encodedString[j]]){
          if(ptable[l] != j && ptable2[l] != j)
            max = MAX2(max, ((l>i) ? mm[iindx[i]-l+1] : 0) + 1 + mm[iindx[l+1]-j+1]);
        }
      }
      mm[iindx[i]-j] = max;
    }
  free(iindx);
  free(encodedString);
  return mm;
}

/44             0           0     0     644     10124     `
/*
           compute potentially pseudoknotted structures of an RNA sequence
                             Ivo Hofacker
                          Vienna RNA package
*/

/*
  library containing the function used in PKplex
  it generates pseudoknotted structures by letting the sequence form a duplex structure with itself
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include <time.h>

#include "energy_par.h"
#include "fold_vars.h"
#include "utils.h"
#include "params.h"
#include "loop_energies.h"

#include "pair_mat.h"

#include "fold.h"
#include "PKplex.h"

#undef  MAXLOOP
#define MAXLOOP 10

PRIVATE void  update_dfold_params(void);
PRIVATE void  duplexfold_XS(const char *s1, int **access_s1, const int threshold, const int max_interaction_length);
PRIVATE char  *backtrack_XS(int kk, int ll, const int ii, const int jj, const int max_interaction_length);
PRIVATE void  make_ptypes(const char *structure);

PRIVATE vrna_param_t  *P = NULL;
PRIVATE int     ***c3 = NULL;      /* energy array used in duplexfold */
PRIVATE short   *S1 = NULL, *SS1 = NULL;
PRIVATE int     n1;
PRIVATE char    *ptype = NULL;     /* precomputed array of pair types */
PRIVATE int     *indx = NULL;      /* index for moving in the triangle matrices ptype[] */

PUBLIC  dupVar  *PlexHits = NULL;
PUBLIC  int     PlexHitsArrayLength = 100;
PUBLIC  int     NumberOfHits        = 0;
PUBLIC  int     verbose             = 0;

/*-----------------------------------------------------------------------duplexfold_XS---------------------------------------------------------------------------*/

PRIVATE void  duplexfold_XS(const char *s1,
                            int **access_s1,
                            const int threshold,
                            const int max_interaction_length){

  int i, j, k, l, p, q, Emin=INF, l_min=0, k_min=0, j_min=0;
  int type, type2, type3, E, tempK;
  char *struc;
  int length = (int) strlen(s1);
  struc=NULL;

  c3 = (int ***) vrna_alloc(sizeof(int **) * (length));
  for (i=0; i<length; i++){
    c3[i] = (int **) vrna_alloc(sizeof(int *) * max_interaction_length);
    for (j=0; j<max_interaction_length; j++) {
      c3[i][j]=(int *) vrna_alloc(sizeof(int) * max_interaction_length);
    }
  }

  i = length - 9;

  while( i-- > 11 ){
    Emin=INF;
    j_min=0;
    l_min=0;
    k_min=0;

    /* init all matrix elements to INF */
    for (j=0; j < length; j++){
      for(k=0;k<max_interaction_length;k++){
        for(l=0;l<max_interaction_length;l++){
          c3[j][k][l]=INF;
        }
      }
    }
    char string[10] = {'\0'};
    /* matrix starting values for (i,j)-basepairs */
    for(j=i+4; j<n1-10; j++) {
      type=ptype[indx[j]+i];
      if (type) {
        c3[j-11][max_interaction_length-1][0] = P->DuplexInit;
        c3[j-11][max_interaction_length-1][0] += E_Hairpin(j-i-1, type,  SS1[i+1], SS1[j-1], string, P);
/*        c3[j-11][max_interaction_length-1][0] += E_ExtLoop(type, SS1[i+1], SS1[j-1], P); */
/*           c3[j-11][max_interaction_length-1][0] += E_ExtLoop(rtype[type], SS1[j-1], SS1[i+1], P); */
       }
    }

    int i_pos_begin=MAX2(9, i-max_interaction_length); /* why 9 ??? */

    /* fill matrix */
    for(k=i-1; k>i_pos_begin; k--) {
      tempK=max_interaction_length-i+k-1;
      for(l = i + 5; l < n1 - 9; l++) { /* again, why 9 less then the sequence length ? */
        type2 = ptype[indx[l] + k];
        if(!type2) continue;
        for(p = k + 1; (p <= i) && (p <= k + MAXLOOP + 1); p++){
          for(q = l - 1; (q>=i+4) && (q >= l - MAXLOOP - 1); q--){
            if (p - k + l - q - 2 > MAXLOOP) break;
            type3 = ptype[indx[q] + p];
            if(!type3) continue;
            E = E_IntLoop(p - k - 1, l - q - 1, type2, rtype[type3], SS1[k + 1], SS1[l - 1], SS1[p - 1], SS1[q + 1], P);
            for(j = MAX2(i + 4, l - max_interaction_length + 1); j <= q; j++){
              type = ptype[indx[j]+i];
              if (type){
                c3[j-11][tempK][l-j] = MIN2(c3[j-11][tempK][l-j], c3[j-11][max_interaction_length-i+p-1][q-j]+E);
              }
            }/* next j */
          }/* next q */
        }/* next p */
      }/* next l */
    }/* next k */

    /* read out matrix minimum */
    for(j=i+4; j<n1-10; j++) {
      type=ptype[indx[j]+i];
      if (!type) continue;
      int j_pos_end=MIN2(n1-9,j+max_interaction_length);
      for (k=i-1; k>i_pos_begin; k--) {
        for (l=j+1; l<j_pos_end; l++) {
          type2=ptype[indx[l]+k];
          if (!type2) continue;
          E = c3[j-11][max_interaction_length-i+k-1][l-j];
/*           printf("[%d,%d][%d,%d]\t%6.2f\t%6.2f\t%6.2f\n", i, k, l, j, E/100., access_s1[i-k+1][i]/100., access_s1[l-j+1][l]/100.); */
          E+=access_s1[i-k+1][i]+access_s1[l-j+1][l];
          E+=E_ExtLoop(type2,((k>i_pos_begin+1)? SS1[k-1]:-1),((l<j_pos_end-1)? SS1[l+1]:-1),P);
          E+=E_ExtLoop(rtype[type], SS1[j-1], SS1[i+1], P);
          if (E<Emin) {
            Emin=E; k_min=k; l_min=l;
            j_min=j;
          }
        }
      }
    }

    if(Emin  < threshold){
      struc = backtrack_XS(k_min, l_min, i, j_min, max_interaction_length);

      /* lets take care of the dangles */
      /* find best combination */
      int dx_5, dx_3, dy_5, dy_3,dGx,dGy,bonus_x, bonus_y;
      dx_5 = dx_3 = dy_5 = dy_3 = dGx = dGy = bonus_x = bonus_y = 0;
      dGx = access_s1[i-k_min+1][i];
      dGy = access_s1[l_min-j_min+1][l_min];
      PlexHits[NumberOfHits].tb=k_min -10 -dx_5;
      PlexHits[NumberOfHits].te=i -10 + dx_3;
      PlexHits[NumberOfHits].qb=j_min -10 - dy_5;
      PlexHits[NumberOfHits].qe=l_min -10 + dy_3;
      PlexHits[NumberOfHits].ddG=(double) Emin * 0.01;
      PlexHits[NumberOfHits].dG1=(double) dGx*0.01 ;
      PlexHits[NumberOfHits].dG2=(double) dGy*0.01 ;
      PlexHits[NumberOfHits].energy = PlexHits[NumberOfHits].ddG - PlexHits[NumberOfHits].dG1 - PlexHits[NumberOfHits].dG2;
      PlexHits[NumberOfHits].structure = struc;

      /* output: */
      if(PlexHits[NumberOfHits].energy * 100 < threshold){
        if (verbose) printf("%s %3d,%-3d : %3d,%-3d (%5.2f = %5.2f + %5.2f + %5.2f)\n", PlexHits[NumberOfHits].structure, PlexHits[NumberOfHits].tb, PlexHits[NumberOfHits].te, PlexHits[NumberOfHits].qb, PlexHits[NumberOfHits].qe, PlexHits[NumberOfHits].ddG, PlexHits[NumberOfHits].energy, PlexHits[NumberOfHits].dG1, PlexHits[NumberOfHits].dG2);
        NumberOfHits++;
        if(NumberOfHits==PlexHitsArrayLength-1){
          PlexHitsArrayLength*=2;
          PlexHits = (dupVar *) vrna_realloc(PlexHits,sizeof(dupVar)*PlexHitsArrayLength);
        }
      }
    }
  }

  for (i=0; i<(n1-20); i++) {
    for (j=0; j<max_interaction_length; j++) {
      free(c3[i][j]);
    }
    free(c3[i]);
  }
  free(c3);
}


PRIVATE char *backtrack_XS(int k, int l, const int i, const int j, const int max_interaction_length) {
  /* backtrack structure going backwards from i, and forwards from j
     return structure in bracket notation with & as separator */
  int p, q, type, type2, E, traced, i0, j0;
  char *st1, *st2, *struc;
  st1 = (char *) vrna_alloc(sizeof(char)*(i-k+2));
  st1[i-k+1]='\0';
  st2 = (char *) vrna_alloc(sizeof(char)*(l-j+2));
  st2[l-j+1]='\0';

  i0=k; j0=l;
  while (k<=i && l>=j) {
    E = c3[j-11][max_interaction_length-i+k-1][l-j]; traced=0;
    st1[k-i0] = '(';
    st2[l-j] = ')';

    type=ptype[indx[l]+k];
    if (!type) vrna_message_error("backtrack failed in fold duplex bli");
    for (p=k+1; p<=i; p++) {
      for (q=l-1; q>=j; q--) {
        int LE;
        if (p-k+l-q-2>MAXLOOP) break;
        type2=ptype[indx[q]+p];
        if (!type2) continue;
         LE = E_IntLoop(p-k-1, l-q-1, type, rtype[type2], SS1[k+1], SS1[l-1], SS1[p-1], SS1[q+1], P);
         if (E == c3[j-11][max_interaction_length-i+p-1][q-j]+LE) {
          traced=1;
           k=p; l=q;
          break;
        }
      }
      if (traced) break;
    }
    if (!traced) {
      E-=E_ExtLoop(type2, ((k<i)?SS1[k+1]:-1), ((l>j-1)? SS1[l-1]:-1), P);
      break;
      if (E != P->DuplexInit) {
        vrna_message_error("backtrack failed in fold duplex bal");
      } else break;
    }
  }
  struc = (char *) vrna_alloc(k-i0+1+j0-l+1+2);

  for (p=0; p<=i-i0; p++){
    if (!st1[p]) st1[p] = '.';
  }

  for (p=0; p<=j0-j; p++) {
    if (!st2[p]) {
      st2[p] = '.';
    }
  }

  strcpy(struc, st1);
  strcat(struc, "&");
  strcat(struc, st2);
  free(st1); free(st2);
  return struc;
}

PUBLIC  dupVar  **PKLduplexfold_XS( const char *s1,
                                    int **access_s1,
                                    const int threshold,
                                    const int max_interaction_length,
                                    const int delta){

  if ((!P) || (fabs(P->temperature - temperature)>1e-6))
    update_dfold_params();

  n1 = (int) strlen(s1);
  S1 = encode_sequence(s1, 0);
  SS1 = encode_sequence(s1, 1);

  indx  = vrna_idx_col_wise(n1);
  ptype = (char *) vrna_alloc(sizeof(char)*((n1*(n1+1))/2+2));
  make_ptypes(s1);

  P->DuplexInit=0;
  duplexfold_XS(s1,access_s1,threshold, max_interaction_length);
  free(S1); free(SS1);
  free(indx); free(ptype);
  return NULL;
}

/*---------------------------------UTILS------------------------------------------*/

PRIVATE void update_dfold_params(void){
  vrna_md_t md;
  if(P)
    free(P);
  set_model_details(&md);
  P = vrna_params(&md);
  make_pair_matrix();
}

/*---------------------------------------------------------------------------*/

PRIVATE void make_ptypes(const char *structure) {
  int n,i,j,k,l;

  n=S1[0];
  for (k=1; k<n-TURN; k++)
    for (l=1; l<=2; l++) {
      int type,ntype=0,otype=0;
      i=k; j = i+TURN+l; if (j>n) continue;
      type = pair[S1[i]][S1[j]];
      while ((i>=1)&&(j<=n)) {
        if ((i>1)&&(j<n)) ntype = pair[S1[i-1]][S1[j+1]];
        if (noLonelyPairs && (!otype) && (!ntype))
          type = 0; /* i.j can only form isolated pairs */
        ptype[indx[j]+i] = (char) type;
        otype =  type;
        type  = ntype;
        i--; j++;
      }
    }
}
plex.c/         0           0     0     644     110088    `
/*
           compute the duplex structure of two RNA strands,
                allowing only inter-strand base pairs.
         see cofold() for computing hybrid structures without
                             restriction.
                             Ivo Hofacker
                          Vienna RNA package

*/


/*
  library containing the function used in rnaplex
  the program rnaplex uses the following function
  Lduplexfold: finds high scoring segments
  it stores the end-position of these segments in an array
  and call then for each of these positions the duplexfold function
  which allows one to make backtracking for each of the high scoring position
  It allows one to find suboptimal partially overlapping (depends on a a parameter)
  duplexes between a long RNA and a shorter one.
  Contrarly to RNAduplex, the energy model is not in E~log(N),
  where N is the length of an interial loop but used an affine model,
  where the extension and begin parameter are fitted to the energy
  parameter used by RNAduplex. This allows one to check for duplex between a short RNA(20nt)
  and a long one at the speed of 1Mnt/s. At this speed the whole genome (3Gnt) can be analyzed for one siRNA
  in about 50 minutes.
  The algorithm is based on an idea by Durbin and Eddy:when the alginment reach a value larger than a
  given threshold this value is stored in an array. When the alignment score goes
  then under this threshold, the alignemnent begin from this value, in that way the backtracking allow us
  to find all non-overlapping high-scoring segments.
  For more information check "durbin, biological sequence analysis"
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include "utils.h"
#include "energy_par.h"
#include "fold_vars.h"
#include "fold.h"
#include "pair_mat.h"
#include "params.h"
#include "plex.h"
#include "ali_plex.h"
#include "loop_energies.h"
/* #################SIMD############### */

/* int subopt_sorted=0; */

#define PUBLIC
#define PRIVATE static

#define STACK_BULGE1  1   /* stacking energies for bulges of size 1 */
#define NEW_NINIO     1   /* new asymetry penalty */
#define ARRAY 32          /*array size*/
#define UNIT 100
#define MINPSCORE -2 * UNIT

/**
*** Macro that define indices for the Single Array approach defined in FLduplexfold_XS->gain of 20% in runtime
*** so that everything is done in a 1D array.
*** input is idx for i, j for j and the length of the query RNA
*** 1D is divided in 6 subarrays, one for each number of allowed state
*** The length of each subarray is 5*L. 5 the maximal stored distance on the target sequence,
*** L is the length of the query sequence
**/
#define LCI(i,j,l)      ((i     )*l + j)
#define LINI(i,j,l)     ((i +  5)*l + j)
#define LBXI(i,j,l)     ((i + 10)*l + j)
#define LBYI(i,j,l)     ((i + 15)*l + j)
#define LINIX(i,j,l)    ((i + 20)*l + j)
#define LINIY(i,j,l)    ((i + 25)*l + j)

PRIVATE void  encode_seqs(const char *s1, const char *s2);
PRIVATE short *encode_seq(const char *seq);
PRIVATE void  update_dfold_params(void);
/**
*** duplexfold(_XS)/backtrack(_XS) computes duplex interaction with standard energy and considers extension_cost
*** find_max(_XS)/plot_max(_XS) find suboptimals and MFE
*** fduplexfold(_XS) computes duplex in a plex way
**/
PRIVATE duplexT duplexfold(const char *s1, const char *s2, const int extension_cost);
PRIVATE char * backtrack(int i, int j, const int extension_cost);
PRIVATE void   find_max(const int *position, const int *position_j, const int delta, const int threshold, const int length, const char *s1, const char *s2, const int extension_cost, const int fast,const int il_a, const int il_b, const int b_a, const int b_b);
PRIVATE void   plot_max(const int max, const int max_pos, const int max_pos_j, const int alignment_length, const char *s1, const char *s2, const int extension_cost, const int fast,const int il_a, const int il_b, const int b_a, const int b_b);

/* PRIVATE duplexT duplexfold_XS(const char *s1, const char *s2,const int **access_s1, const int **access_s2, const int i_pos, const int j_pos, const int threshold); */
PRIVATE duplexT duplexfold_XS(const char *s1, const char *s2,const int **access_s1, const int **access_s2, const int i_pos, const int j_pos, const int threshold, const int i_flag, const int j_flag);
/* PRIVATE char *   backtrack_XS(int i, int j, const int** access_s1, const int** access_s2); */
PRIVATE char *backtrack_XS(int i, int j, const int **access_s1,const int **access_s2,const int i_flag, const int j_flag );
PRIVATE void find_max_XS(const int *position, const int *position_j,const int delta, const int threshold, const int alignment_length,
                         const char *s1, const char *s2, const int **access_s1, const int **access_s2, const int fast,const int il_a, const int il_b, const int b_a, const int b_b);
PRIVATE void plot_max_XS(const int max, const int max_pos, const int max_pos_j, const int alignment_length, const char *s1, const char *s2, const int **access_s1, const int **access_s2, const int fast,const int il_a, const int il_b, const int b_a, const int b_b);
PRIVATE duplexT fduplexfold(const char *s1, const char *s2, const int extension_cost, const int il_a, const int il_b, const int b_a, const int b_b);
PRIVATE char *fbacktrack(int i, int j, const int extension_cost,const int il_a, const int il_b, const int b_a, const int b_b, int *dG);
PRIVATE duplexT fduplexfold_XS(const char *s1, const char *s2, const int **access_s1, const int **access_s2, const int i_pos, const int j_pos, const int threshold,const int il_a, const int il_b, const int b_a, const int b_b);
PRIVATE char * fbacktrack_XS(int i, int j, const int **access_s1, const int **access_s2, const int i_pos, const int j_pos, const int il_a, const int il_b, const int b_a, const int b_b, int *dGe, int *dGeplex, int *dGx, int *dGy);



/*@unused@*/

#define MAXSECTORS      500     /* dimension for a backtrack array */
#define LOCALITY        0.      /* locality parameter for base-pairs */

PRIVATE vrna_param_t *P = NULL;

/**
*** energy array used in fduplexfold and fduplexfold_XS
*** We do not use the 1D array here as it is not time critical
*** It also makes the code more readable
*** c -> stack;in -> interior loop;bx/by->bulge;inx/iny->1xn loops
**/

PRIVATE int   **c=NULL, **in=NULL, **bx=NULL, **by=NULL, **inx=NULL, **iny=NULL;

/**
*** S1, SS1, ... contains the encoded sequence for target and query
*** n1, n2, n3, n4 contains target and query length
**/

PRIVATE short  *S1=NULL, *SS1=NULL, *S2=NULL, *SS2=NULL;/*contains the sequences*/
PRIVATE int   n1,n2;    /* sequence lengths */
PRIVATE int n3, n4; /*sequence length for the duplex*/;


/*-----------------------------------------------------------------------duplexfold_XS---------------------------------------------------------------------------*/

/**
*** duplexfold_XS is the pendant to the duplex function as defined in duplex.c
*** but takes the accessibility into account. It is similar to the MFE version of RNAup
*** The only approximation made is that target 3' end - query 5' end base pair is known
*** s1,s2 are the query and target sequence; access_s1, access_s2 are the accessibility
*** profiles, i_pos, j_pos are the coordinates of the closing pair.
**/



PRIVATE duplexT duplexfold_XS(const char *s1, const char *s2, const int **access_s1, const int **access_s2, const int i_pos, const int j_pos, const int threshold, const int i_flag, const int j_flag) {
  int i, j,p,q, Emin=INF, l_min=0, k_min=0;
  char *struc;
  vrna_md_t   md;

  struc=NULL;
  duplexT mfe;
  n3 = (int) strlen(s1);
  n4 = (int) strlen(s2);

  set_model_details(&md);

  if ((!P) || (fabs(P->temperature - temperature)>1e-6)) {
    update_fold_params();
    if(P)
      free(P);
    P = vrna_params(&md);
    make_pair_matrix();
  }

  c = (int **) vrna_alloc(sizeof(int *) * (n3+1));
  for (i=0; i<=n3; i++) c[i] = (int *) vrna_alloc(sizeof(int) * (n4+1));
  for (i=0; i<=n3; i++){
    for(j=0;j<=n4;j++){
      c[i][j]=INF;
    }
  }
  encode_seqs(s1, s2);
  int type, type2, type3, E, k,l;
  i=n3-i_flag; j=1+j_flag;
  type = pair[S1[i]][S2[j]];
  if(!type){
    printf("Error during initialization of the duplex in duplexfold_XS\n");
    mfe.structure=NULL;
    mfe.energy = INF;
    return mfe;
  }
  c[i][j] = P->DuplexInit;
  /**  if (type>2) c[i][j] += P->TerminalAU;
  ***  c[i][j]+=P->dangle3[rtype[type]][SS1[i+1]];
  ***  c[i][j]+=P->dangle5[rtype[type]][SS2[j-1]];
  *** The three above lines are replaced by the line below
  **/


  c[i][j] += E_ExtLoop(rtype[type], (j_flag ? SS2[j-1] : -1) , (i_flag ? SS1[i+1] : -1),  P);

/*   if(j_flag ==0 && i_flag==0){ */
/*     c[i][j] += E_ExtLoop(rtype[type], -1 , -1 , P); */
/*   }else if(j_flag ==0 && i_flag==1){ */
/*     c[i][j] += E_ExtLoop(rtype[type], -1 , SS1[i+1], P); */
/*   }else if(j_flag ==1 && i_flag==0){ */
/*     c[i][j] += E_ExtLoop(rtype[type], SS2[j-1] , -1, P); */
/*   }else { */
/*     c[i][j] += E_ExtLoop(rtype[type], SS2[j-1] , SS1[i+1], P); */
/*   } */
  /*  Just in case we have only one bp, we initialize ... */
  /*  k_min, l_min and Emin */
  k_min=i; l_min=j;Emin=c[i][j];
  for (k=i; k>1 ; k--) {
    if(k<i) c[k+1][0]=INF;
    for (l=j; l<=n4-1; l++) {
      if(!(k==i && l==j)){
        c[k][l]=INF;
      }
      type2 = pair[S1[k]][S2[l]];
      if (!type2) continue;
      for (p=k+1; p<= n3 - i_flag && p<k+MAXLOOP-1; p++) {
        for (q = l-1; q >= 1+j_flag; q--) {
          if (p-k+l-q-2>MAXLOOP) break;
          type3=pair[S1[p]][S2[q]];
          if(!type3) continue;
          E = E_IntLoop(p-k-1, l-q-1, type2, rtype[type3],SS1[k+1], SS2[l-1], SS1[p-1], SS2[q+1],P);
          c[k][l] = MIN2(c[k][l], c[p][q]+E);
        }
      }
      E = c[k][l];
      E+=access_s1[i-k+1][i_pos]+access_s2[l-1][j_pos+(l-1)-1];
      /**if (type2>2) E += P->TerminalAU;
      ***if (k>1) E += P->dangle5[type2][SS1[k-1]];
      ***if (l<n4) E += P->dangle3[type2][SS2[l+1]];
      *** Replaced by the line below
      **/
      E+=E_ExtLoop(type2, (k>1) ? SS1[k-1] : -1, (l<n4) ? SS2[l+1] : -1, P);

      if (E<Emin) {
        Emin=E; k_min=k; l_min=l;
      }
    }
  }

  if(Emin  > threshold){
    mfe.energy=INF;
    mfe.ddG=INF;
    mfe.structure=NULL;
    for (i=0; i<=n3; i++) free(c[i]);
    free(c);
    free(S1); free(S2); free(SS1); free(SS2);
    return mfe;
  } else{
    struc = backtrack_XS(k_min, l_min, access_s1, access_s2, i_flag, j_flag);
  }


  /**
  *** find best dangles combination
  **/
  int dx_5, dx_3, dy_5, dy_3,dGx,dGy,bonus_x;
  dx_5=0; dx_3=0; dy_5=0; dy_3=0;dGx=0;dGy=0;bonus_x=0;
  /* x--------x */
  /*  |||||||| */
  /* x--------x */
   dGx = access_s1[i-k_min+1][i_pos];dx_3=0; dx_5=0;bonus_x=0;
   dGy = access_s2[l_min-j+1][j_pos + (l_min-1)];

  mfe.tb=i_pos -9 - i + k_min -1 -dx_5;
  mfe.te=i_pos -9 -1 + dx_3;
  mfe.qb=j_pos -9 -1 - dy_5;
  mfe.qe=j_pos + l_min -3 -9 + dy_3;
  mfe.ddG=(double) Emin * 0.01;
  mfe.dG1=(double) dGx*0.01 ;
  mfe.dG2=(double) dGy*0.01 ;

  mfe.energy= mfe.ddG - mfe.dG1 - mfe.dG2;

  mfe.structure = struc;
  for (i=0; i<=n3; i++) free(c[i]);
  free(c);
  free(S1); free(S2); free(SS1); free(SS2);
  return mfe;
}






PRIVATE char *backtrack_XS(int i, int j, const int **access_s1,const int **access_s2, const int i_flag, const int j_flag) {
  /* backtrack structure going backwards from i, and forwards from j
     return structure in bracket notation with & as separator */
  int k, l, type, type2, E, traced, i0, j0;
  char *st1, *st2, *struc;
  st1 = (char *) vrna_alloc(sizeof(char)*(n3+1));
  st2 = (char *) vrna_alloc(sizeof(char)*(n4+1));
  i0=i;/*MAX2(i-1,1);*/j0=j;/*MIN2(j+1,n4);*/
  while (i<=n3-i_flag && j>=1+j_flag) {
    E = c[i][j]; traced=0;
    st1[i-1] = '(';
    st2[j-1] = ')';
    type = pair[S1[i]][S2[j]];
    if (!type) vrna_message_error("backtrack failed in fold duplex bli");
    for (k=i+1; k<=n3 && k>i-MAXLOOP-2; k++) {
      for (l=j-1; l>=1; l--) {
        int LE;
        if (i-k+l-j-2>MAXLOOP) break;
        type2 = pair[S1[k]][S2[l]];
        if (!type2) continue;
        LE = E_IntLoop(k-i-1, j-l-1, type, rtype[type2], SS1[i+1], SS2[j-1], SS1[k-1], SS2[l+1],P);
        if (E == c[k][l]+LE) {
          traced=1;
          i=k; j=l;
          break;
        }
      }
      if (traced) break;
    }
    if (!traced) {
#if 0
      if (i<n3) E -= P->dangle3[rtype[type]][SS1[i+1]];/* +access_s1[1][i+1]; */
      if (j>1)  E -= P->dangle5[rtype[type]][SS2[j-1]];/* +access_s2[1][j+1]; */
      if (type>2) E -= P->TerminalAU;
#endif
      E -= E_ExtLoop(rtype[type], SS2[j-1] , SS1[i+1], P);
      break;
      if (E != P->DuplexInit) {
        vrna_message_error("backtrack failed in fold duplex bal");
      } else break;
    }
  }
  /* if (i<n3)  i++; */
  /* if (j>1)   j--; */
  struc = (char *) vrna_alloc(i-i0+1+j0-j+1+2);
  for (k=MAX2(i0,1); k<=i; k++) if (!st1[k-1]) st1[k-1] = '.';
  for (k=j; k<=j0; k++) if (!st2[k-1]) st2[k-1] = '.';
  strcpy(struc, st1+MAX2(i0-1,0)); strcat(struc, "&");
  strcat(struc, st2+j-1);
  free(st1); free(st2);
  return struc;
}


/**
*** fduplexfold(_XS) computes the interaction based on the plex energy model.
*** Faster than duplex approach, but not standard model compliant
*** We use the standard matrix (c, in, etc..., because we backtrack)
**/

PRIVATE duplexT fduplexfold_XS(const char *s1, const char *s2, const int **access_s1, const int **access_s2, const int i_pos, const int j_pos, const int threshold,const int il_a, const int il_b, const int b_a, const int b_b) {
  /**
  *** i,j recursion index
  *** Emin, i_min, j_min MFE position and energy
  *** mfe struc duplex structure
  **/
  int i, j, Emin, i_min, j_min,l1;
  duplexT mfe;
  char *struc;
  /**
  *** bext=b_a bulge extension parameter for linear model
  *** iopen=il_b interior opening for linear model
  *** iext_s=2*il_a asymmetric extension for interior loop
  *** iext_ass=60+il_a symmetric extension for interior loop
  *** min_colonne=INF; max score of a row
  *** i_length;
  *** max_pos; position of best hit during recursion on target
  *** max_pos_j; position of best hit during recursion on query
  *** temp; temp variable for min_colonne
  *** min_j_colonne; position of the minimum on query in row j
  *** max=INF; absolute MFE
  *** n3,n4 length of target and query
  *** DJ contains the accessibility penalty for the query sequence
  *** maxPenalty contains the maximum penalty
  **/
  int bopen=b_b;
  int bext=b_a;
  int iopen=il_b;
  int iext_s=2*il_a;/* iext_s 2 nt nucleotide extension of interior loop, on i and j side */
  int iext_ass=50+il_a;/* iext_ass assymetric extension of interior loop, either on i or on j side. */
  int min_colonne=INF; /* enthaelt das maximum einer kolonne */
  int i_length;
  int max_pos;/* get position of the best hit */
  int max_pos_j;
  int temp=INF;
  int min_j_colonne;
  int max=INF;
  int **DJ;
  int maxPenalty[4];
  vrna_md_t   md;

  /**
  *** variable initialization
  **/
  n3 = (int) strlen(s1);
  n4 = (int) strlen(s2);

  set_model_details(&md);
  if ((!P) || (fabs(P->temperature - temperature)>1e-6)) {
    update_fold_params();
    if(P)
      free(P);
    P = vrna_params(&md);
    make_pair_matrix();
  }
  /**
  *** array initialization
  **/
  c  = (int**) vrna_alloc(sizeof(int *) * (n3+1));
  in = (int**) vrna_alloc(sizeof(int *) * (n3+1));
  bx = (int**) vrna_alloc(sizeof(int *) * (n3+1));
  by = (int**) vrna_alloc(sizeof(int *) * (n3+1));
  inx= (int**) vrna_alloc(sizeof(int *) * (n3+1));
  iny= (int**) vrna_alloc(sizeof(int *) * (n3+1));
  /* #pragma omp parallel for */
  for (i=0; i<=n3; i++){
    c[i]  = (int *) vrna_alloc(sizeof(int) * (n4+1));
    in[i] = (int *) vrna_alloc(sizeof(int) * (n4+1));
    bx[i] = (int *) vrna_alloc(sizeof(int) * (n4+1));
    by[i] = (int *) vrna_alloc(sizeof(int) * (n4+1));
    inx[i]= (int *) vrna_alloc(sizeof(int) * (n4+1));
    iny[i]= (int *) vrna_alloc(sizeof(int) * (n4+1));
  }
  for(i=0; i<n3; i++){
    for(j=0; j<n4; j++){
      in[i][j]=INF;/* no in before  1 */
      c[i][j] =INF; /* no bulge and no in before n2 */
      bx[i][j]=INF;/* no bulge before 1 */
      by[i][j]=INF;
      inx[i][j]=INF;/* no bulge before 1 */
      iny[i][j]=INF;
    }
  }
  /**
  *** sequence encoding
  **/
  encode_seqs(s1,s2);
  /**
  *** Compute max accessibility penalty for the query only once
  **/
  maxPenalty[0]=(int) -1*P->stack[2][2]/2;
  maxPenalty[1]=(int) -1*P->stack[2][2];
  maxPenalty[2]=(int) -3*P->stack[2][2]/2;
  maxPenalty[3]=(int) -2*P->stack[2][2];


  DJ=(int **)   vrna_alloc(4*sizeof(int*));
  DJ[0]=(int *) vrna_alloc((1+n4)*sizeof(int));
  DJ[1]=(int *) vrna_alloc((1+n4)*sizeof(int));
  DJ[2]=(int *) vrna_alloc((1+n4)*sizeof(int));
  DJ[3]=(int *) vrna_alloc((1+n4)*sizeof(int));

  j=n4-9;
  while(--j>9){
    int jdiff=j_pos+j-11;
    /**
    *** Depending in which direction (i:1->n vs j:m->1) the accessibility is computed we get slightly different results.
    *** We reduce the discrepancies by taking the average of d^i_k and d^j_l
    **/
    DJ[0][j] = 0.5*(access_s2[5][jdiff+4] - access_s2[4][jdiff+4] + access_s2[5][jdiff]  -access_s2[4][jdiff-1]  );
    DJ[1][j] = 0.5*(access_s2[5][jdiff+5] - access_s2[4][jdiff+5] + access_s2[5][jdiff+1]-access_s2[4][jdiff]  ) + DJ[0][j];
    DJ[2][j] = 0.5*(access_s2[5][jdiff+6] - access_s2[4][jdiff+6] + access_s2[5][jdiff+2]-access_s2[4][jdiff+1]) + DJ[1][j];
    DJ[3][j] = 0.5*(access_s2[5][jdiff+7] - access_s2[4][jdiff+7] + access_s2[5][jdiff+3]-access_s2[4][jdiff+2]) + DJ[2][j];



/*
    DJ[0][j] = access_s2[5][jdiff+4] - access_s2[4][jdiff+4]           ;
    DJ[1][j] = access_s2[5][jdiff+5] - access_s2[4][jdiff+5] + DJ[0][j];
    DJ[2][j] = access_s2[5][jdiff+6] - access_s2[4][jdiff+6] + DJ[1][j];
    DJ[3][j] = access_s2[5][jdiff+7] - access_s2[4][jdiff+7] + DJ[2][j];
    DJ[0][j] = MIN2(DJ[0][j],maxPenalty[0]);
    DJ[1][j] = MIN2(DJ[1][j],maxPenalty[1]);
    DJ[2][j] = MIN2(DJ[2][j],maxPenalty[2]);
    DJ[3][j] = MIN2(DJ[3][j],maxPenalty[3]);
*/
  }

  /**
  *** Start of the recursion
  *** first and last 10 nucleotides on target and query are dummy nucleotides
  *** allow to reduce number of if test
  **/
  i=11;
  i_length=n3-9;
  while(i < i_length) {
    int di1,di2,di3,di4;
    int idiff=i_pos-(n3-10-i);
    di1 = 0.5*(access_s1[5][idiff+4] - access_s1[4][idiff+4] + access_s1[5][idiff]   - access_s1[4][idiff-1]);
    di2 = 0.5*(access_s1[5][idiff+3] - access_s1[4][idiff+3] + access_s1[5][idiff-1] - access_s1[4][idiff-2]) + di1;
    di3 = 0.5*(access_s1[5][idiff+2] - access_s1[4][idiff+2] + access_s1[5][idiff-2] - access_s1[4][idiff-3]) + di2;
    di4 = 0.5*(access_s1[5][idiff+1] - access_s1[4][idiff+1] + access_s1[5][idiff-3] - access_s1[4][idiff-4]) + di3;
/*
    di1 =  access_s1[5][idiff]   - access_s1[4][idiff-1];
    di2 =  access_s1[5][idiff-1] - access_s1[4][idiff-2] + di1;
    di3 =  access_s1[5][idiff-2] - access_s1[4][idiff-3] + di2;
    di4 =  access_s1[5][idiff-3] - access_s1[4][idiff-4] + di3;
    di1=MIN2(di1,maxPenalty[0]);
    di2=MIN2(di2,maxPenalty[1]);
    di3=MIN2(di3,maxPenalty[2]);
    di4=MIN2(di4,maxPenalty[3]);
*/
    j=n4-9;
    min_colonne=INF;
    while (10 < --j) {
      int dj1,dj2,dj3,dj4;
      int jdiff=j_pos+j-11;
      dj1 = DJ[0][j];
      dj2 = DJ[1][j];
      dj3 = DJ[2][j];
      dj4 = DJ[3][j];
      int type, type2;
      type = pair[S1[i]][S2[j]];
      /**
      *** Start duplex
      **/
      /*
      c[i][j]=type ? P->DuplexInit + access_s1[1][idiff]+access_s2[1][jdiff] : INF;
      */
      c[i][j]=type ? P->DuplexInit: INF;
      /**
      *** update lin bx by linx liny matrix
      **/
      type2=pair[S2[j+1]][S1[i-1]];
      /**
      *** start/extend interior loop
      **/
      in[i][j]=MIN2(c[i - 1][j+1]+P->mismatchI[type2][SS2[j]][SS1[i]]+iopen+iext_s+di1+dj1,
                    in[i - 1][j]+iext_ass + di1);

      /**
      *** start/extend nx1 target
      *** use same type2 as for in
      **/
      inx[i][j]=MIN2(c[i-1][j+1]+P->mismatch1nI[type2][SS2[j]][SS1[i]]+iopen+iext_s+di1+dj1,
                     inx[i-1][j]+iext_ass+di1);
      /**
      *** start/extend 1xn target
      *** use same type2 as for in
      **/
      iny[i][j]=MIN2(c[i-1][j+1]+P->mismatch1nI[type2][SS2[j]][SS1[i]]+iopen+iext_s+di1+dj1,
                     iny[i][j+1]+iext_ass+dj1);
      /**
      *** extend interior loop
      **/
      in[i][j]=MIN2(in[i][j],in[i][j+1]+iext_ass + dj1);
      in[i][j]=MIN2(in[i][j],in[i - 1][j+1]+iext_s + di1 + dj1);
      /**
      *** start/extend bulge target
      **/
      type2=pair[S2[j]][S1[i-1]];
      bx[i][j]=MIN2(bx[i - 1][j]+bext + di1, c[i - 1][j]+bopen+bext+(type2>2?P->TerminalAU:0) + di1);
      /**
      *** start/extend bulge query
      **/
      type2=pair[S2[j+1]][S1[i]];
      by[i][j]=MIN2(by[i][j+1]+bext+dj1, c[i][j+1]+bopen+bext+(type2>2?P->TerminalAU:0)+dj1);
      /**
      ***end update recursion
      ***######################## Start stack extension##############################
      **/
      if(!type){continue;}
      c[i][j]+=E_ExtLoop(type, SS1[i-1], SS2[j+1],P);
      /**
      *** stack extension
      **/
      if((type2=pair[S1[i-1]][S2[j+1]]))
        c[i][j]=MIN2(c[i - 1][j+1]+P->stack[rtype[type]][type2]+di1+dj1, c[i][j]);
      /**
      *** 1x0 / 0x1 stack extension
      **/
      if((type2=pair[S1[i-1]][S2[j+2]]))
        c[i][j]=MIN2(c[i - 1][j+2]+P->bulge[1]+P->stack[rtype[type]][type2]+di1+dj2,c[i][j]);
      if((type2=pair[S1[i-2]][S2[j+1]]))
        c[i][j]=MIN2(c[i - 2][j+1]+P->bulge[1]+P->stack[type2][rtype[type]]+di2+dj1,c[i][j]);
      /**
      *** 1x1 / 2x2 stack extension
      **/
      if((type2=pair[S1[i-2]][S2[j+2]]))
        c[i][j]=MIN2(c[i - 2][j+2]+P->int11[type2][rtype[type]][SS1[i-1]][SS2[j+1]]+di2+dj2, c[i][j]);
      if((type2 = pair[S1[i-3]][S2[j+3]]))
        c[i][j]=MIN2(c[i - 3][j+3]+P->int22[type2][rtype[type]][SS1[i-2]][SS1[i-1]][SS2[j+1]][SS2[j+2]]+di3+dj3,c[i][j]);
      /**
      *** 1x2 / 2x1 stack extension
      *** E_IntLoop(1,2,type2, rtype[type],SS1[i-1], SS2[j+2], SS1[i-1], SS2[j+1], P) corresponds to
      *** P->int21[rtype[type]][type2][SS2[j+2]][SS1[i-1]][SS1[i-1]]
      **/
      if((type2 = pair[S1[i-3]][S2[j+2]]))
        c[i][j]=MIN2(c[i - 3][j+2]+P->int21[rtype[type]][type2][SS2[j+1]][SS1[i-2]][SS1[i-1]]+di3+dj2, c[i][j]);
      if((type2 = pair[S1[i-2]][S2[j+3]]))
        c[i][j]=MIN2(c[i - 2][j+3]+P->int21[type2][rtype[type]][SS1[i-1]][SS2[j+1]][SS2[j+2]]+di2+dj3, c[i][j]);

      /**
      *** 2x3 / 3x2 stack extension
      **/
      if((type2 = pair[S1[i-4]][S2[j+3]]))
        c[i][j]=MIN2(c[i - 4][j+3]+P->internal_loop[5]+P->ninio[2]+
                     P->mismatch23I[type2][SS1[i-3]][SS2[j+2]]+P->mismatch23I[rtype[type]][SS2[j+1]][SS1[i-1]]+di4+dj3, c[i][j]);
      if((type2 = pair[S1[i-3]][S2[j+4]]))
        c[i][j]=MIN2(c[i - 3][j+4]+P->internal_loop[5]+P->ninio[2]+
                     P->mismatch23I[type2][SS1[i-2]][SS2[j+3]]+P->mismatch23I[rtype[type]][SS2[j+1]][SS1[i-1]]+di3+dj4, c[i][j]);

      /**
      *** So now we have to handle 1x3, 3x1, 3x3, and mxn m,n > 3
      **/
      /**
      *** 3x3 or more
      **/
      c[i][j]=MIN2(in[i - 3][j+3]+P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+2*iext_s+di3+dj3, c[i][j]);
      /**
      *** 2xn or more
      **/
      c[i][j]=MIN2(in[i - 4][j+2]+P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_s+2*iext_ass+di4+dj2, c[i][j]);
      /**
      *** nx2 or more
      **/
      c[i][j]=MIN2(in[i - 2][j+4]+P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_s+2*iext_ass+di2+dj4, c[i][j]);
      /**
      *** nx1 n>2
      **/
      c[i][j]=MIN2(inx[i - 3][j+1]+P->mismatch1nI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_ass+iext_ass+di3+dj1, c[i][j]);
      /**
      *** 1xn n>2
      **/
      c[i][j]=MIN2(iny[i - 1][j+3]+P->mismatch1nI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_ass+iext_ass+dj3+di1, c[i][j]);
      /**
      *** nx0 n>1
      **/
      int bAU;
      bAU=(type>2?P->TerminalAU:0);
      c[i][j]=MIN2(bx[i - 2][j+1]+di2+dj1+bext+bAU, c[i][j]);
      /**
      *** 0xn n>1
      **/
      c[i][j]=MIN2(by[i - 1][j+2]+di1+dj2+bext+bAU, c[i][j]);
      /*
      remove this line printf("%d\t",c[i][j]);
      */
      temp=min_colonne;
      min_colonne=MIN2(c[i][j]+ E_ExtLoop(rtype[type], SS2[j-1], SS1[i+1], P),min_colonne);
      if(temp>min_colonne){
        min_j_colonne=j;
      }
      /* ---------------------------------------------------------------------end update */
    }
    if(max>=min_colonne){
      max=min_colonne;
      max_pos=i;
      max_pos_j=min_j_colonne;
    }
    i++;
    /*
    remove this line printf("\n");
    */
  }
  Emin=max;
  if(Emin>threshold){
    free(S1); free(S2); free(SS1); free(SS2);
    for (i=0; i<=n3; i++) {
      free(c[i]);
      free(in[i]);
      free(bx[i]);
      free(by[i]);
      free(inx[i]);
      free(iny[i]);
    }
    for (i=0; i<=3; i++) {
      free(DJ[i]);
    }
    free(c);free(in);free(bx);free(by);free(inx);free(iny);free(DJ);
    mfe.energy=0;
    mfe.structure=NULL;
    return mfe;
  }
  i_min=max_pos;
  j_min=max_pos_j;
  int dGe, dGeplex, dGx, dGy;
  dGe=dGeplex=dGx=dGy=0;
  /* printf("MAX fduplexfold_XS %d\n",Emin); */
  struc = fbacktrack_XS(i_min, j_min, access_s1, access_s2, i_pos, j_pos,il_a, il_b,b_a,b_b,&dGe, &dGeplex, &dGx, &dGy);

  l1 = strchr(struc, '&')-struc;
  int size;
  size=strlen(struc)-1;
  int lengthx; int endx; int lengthy; int endy;
  lengthx=l1;
  lengthx-=(struc[0]=='.'?1:0);
  lengthx-=(struc[l1-1]=='.'?1:0);
  endx=(i_pos-(n3-i_min));
  lengthy=size-l1;
  lengthy-=(struc[size]=='.'?1:0);
  lengthy-=(struc[l1+1]=='.'?1:0);
  endy=j_pos+j_min+lengthy -22;
  if (i_min<n3-10) i_min++;
  if (j_min>11 ) j_min--;
  mfe.i = i_min;
  mfe.j = j_min;
  mfe.ddG = (double) Emin*0.01;
  mfe.structure = struc;
  mfe.energy_backtrack = (double) dGe * 0.01;
  mfe.energy = (double) dGeplex * 0.01;
  mfe.opening_backtrack_x = (double) dGx * 0.01;
  mfe.opening_backtrack_y = (double) dGy * 0.01;
  mfe.dG1=0;/* !remove access to complete access array (double) access_s1[lengthx][endx+10] * 0.01; */
  mfe.dG2=0;/* !remove access to complete access array (double) access_s2[lengthy][endy+10] * 0.01; */
  free(S1); free(S2); free(SS1); free(SS2);
  for (i=0; i<=n3; i++) {
    free(c[i]);
    free(in[i]);
    free(bx[i]);
    free(by[i]);
    free(inx[i]);
    free(iny[i]);
  }
  for (i=0; i<=3; i++) {
    free(DJ[i]);
  }
  free(DJ);
  free(c);free(in);free(bx);free(by);free(iny);free(inx);
  return mfe;
}

PRIVATE char *fbacktrack_XS(int i, int j, const int** access_s1, const int** access_s2, const int i_pos, const int j_pos,const int il_a, const int il_b, const int b_a, const int b_b, int *dG, int *dGplex, int *dGx, int *dGy) {
  /* backtrack structure going backwards from i, and forwards from j
     return structure in bracket notation with & as separator */
  int k, l, type, type2, E, traced, i0, j0;
  char *st1, *st2, *struc;
  int bopen=b_b;
  int bext=b_a;
  int iopen=il_b;
  int iext_s=2*il_a;/* iext_s 2 nt nucleotide extension of interior loop, on i and j side */
  int iext_ass=50+il_a;/* iext_ass assymetric extension of interior loop, either on i or on j side. */
  st1 = (char *) vrna_alloc(sizeof(char)*(n3+1));
  st2 = (char *) vrna_alloc(sizeof(char)*(n4+1));
  i0=MIN2(i+1,n3-10); j0=MAX2(j-1,11);
  int state;
  state=1; /* we start backtracking from a a pair , i.e. c-matrix */
  /* state 1 -> base pair, c
     state 2 -> interior loop, in
     state 3 -> bx loop, bx
     state 4 -> by loop, by
  */
  traced=1;
  k=i; l=j; /* stores the i,j information for subsequence usage see * */
  int idiff,jdiff;
  /**
  *** (type>2?P->TerminalAU:0)+P->dangle3[rtype[type]][SS1[i+1]]+P->dangle5[rtype[type]][SS2[j-1]];
  **/

  int maxPenalty[4];
  vrna_md_t   md;

  set_model_details(&md);

  if ((!P) || (fabs(P->temperature - temperature)>1e-6)){
    update_dfold_params();
    if(P)
      free(P);
    P = vrna_params(&md);
    make_pair_matrix();
  }
  maxPenalty[0]=(int) -1*P->stack[2][2]/2;
  maxPenalty[1]=(int) -1*P->stack[2][2];
  maxPenalty[2]=(int) -3*P->stack[2][2]/2;
  maxPenalty[3]=(int) -2*P->stack[2][2];

  type = pair[S1[i]][S2[j]];
  *dG+= E_ExtLoop(rtype[type], SS2[j-1] , SS1[i+1] , P);
  *dGplex=*dG;

  while (i>10 && j<=n4-9 && traced) {
    int di1,di2,di3,di4;
    idiff=i_pos-(n3-10-i);
    di1 = 0.5*(access_s1[5][idiff+4] - access_s1[4][idiff+4] + access_s1[5][idiff]   - access_s1[4][idiff-1]);
    di2 = 0.5*(access_s1[5][idiff+3] - access_s1[4][idiff+3] + access_s1[5][idiff-1] - access_s1[4][idiff-2]) + di1;
    di3 = 0.5*(access_s1[5][idiff+2] - access_s1[4][idiff+2] + access_s1[5][idiff-2] - access_s1[4][idiff-3]) + di2;
    di4 = 0.5*(access_s1[5][idiff+1] - access_s1[4][idiff+1] + access_s1[5][idiff-3] - access_s1[4][idiff-4]) + di3;
/*
    di1 = access_s1[5][idiff]   - access_s1[4][idiff-1];
    di2 = access_s1[5][idiff-1] - access_s1[4][idiff-2] + di1;
    di3 = access_s1[5][idiff-2] - access_s1[4][idiff-3] + di2;
    di4 = access_s1[5][idiff-3] - access_s1[4][idiff-4] + di3;
    di1=MIN2(di1,maxPenalty[0]);
    di2=MIN2(di2,maxPenalty[1]);
    di3=MIN2(di3,maxPenalty[2]);
    di4=MIN2(di4,maxPenalty[3]);
*/
    int dj1,dj2,dj3,dj4;
    jdiff=j_pos+j-11;
    dj1=0.5*(access_s2[5][jdiff+4] - access_s2[4][jdiff+4] + access_s2[5][jdiff]  -access_s2[4][jdiff-1]  );
    dj2=0.5*(access_s2[5][jdiff+5] - access_s2[4][jdiff+5] + access_s2[5][jdiff+1]-access_s2[4][jdiff]  ) + dj1;
    dj3=0.5*(access_s2[5][jdiff+6] - access_s2[4][jdiff+6] + access_s2[5][jdiff+2]-access_s2[4][jdiff+1]) + dj2;
    dj4=0.5*(access_s2[5][jdiff+7] - access_s2[4][jdiff+7] + access_s2[5][jdiff+3]-access_s2[4][jdiff+2]) + dj3;



/*
    dj1 = access_s2[5][jdiff+4] - access_s2[4][jdiff+4];
    dj2 = access_s2[5][jdiff+5] - access_s2[4][jdiff+5] + dj1;
    dj3 = access_s2[5][jdiff+6] - access_s2[4][jdiff+6] + dj2;
    dj4 = access_s2[5][jdiff+7] - access_s2[4][jdiff+7] + dj3;
    dj1=MIN2(dj1,maxPenalty[0]);
    dj2=MIN2(dj2,maxPenalty[1]);
    dj3=MIN2(dj3,maxPenalty[2]);
    dj4=MIN2(dj4,maxPenalty[3]);
*/
    traced=0;
    switch(state){
    case 1:
      type = pair[S1[i]][S2[j]];
      int bAU;
      bAU=(type>2?P->TerminalAU:0);
      if(!type) vrna_message_error("backtrack failed in fold duplex");
      type2=pair[S1[i-1]][S2[j+1]];
      if(type2 && c[i][j]== (c[i - 1][j+1]+P->stack[rtype[type]][type2]+di1+dj1)){
        k=i-1;
        l=j+1;
        (*dG)+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGplex+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGx+=di1;
        *dGy+=dj1;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
      type2=pair[S1[i-1]][S2[j+2]];
      if(type2 && c[i][j]==(c[i - 1][j+2]+P->bulge[1]+P->stack[rtype[type]][type2]+di1+dj2)){
        k=i-1;
        l=j+2;
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGplex+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGx+=di1;
        *dGy+=dj2;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
      type2=pair[S1[i-2]][S2[j+1]];
      if(type2 && c[i][j]==(c[i - 2][j+1]+P->bulge[1]+P->stack[type2][rtype[type]]+di2+dj1)){
        k=i-2;
        l=j+1;
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGplex+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGx+=di2;
        *dGy+=dj1;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
      type2=pair[S1[i-2]][S2[j+2]];
      if(type2 && c[i][j]==(c[i - 2][j+2]+P->int11[type2][rtype[type]][SS1[i-1]][SS2[j+1]]+di2+dj2)){
        k=i-2;
        l=j+2;
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGplex+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGx+=di2;
        *dGy+=dj2;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
      type2 = pair[S1[i-3]][S2[j+3]];
      if(type2 && c[i][j]==(c[i - 3][j+3]+P->int22[type2][rtype[type]][SS1[i-2]][SS1[i-1]][SS2[j+1]][SS2[j+2]]+di3+dj3)){
        k=i-3;
        l=j+3;
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGplex+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGx+=di3;
        *dGy+=dj3;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
      type2 = pair[S1[i-3]][S2[j+2]];
      if(type2 && c[i][j]==(c[i - 3][j+2]+P->int21[rtype[type]][type2][SS2[j+1]][SS1[i-2]][SS1[i-1]]+di3+dj2)){
        k=i-3;
        l=j+2;
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGplex+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGx+=di3;
        *dGy+=dj2;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
      type2 = pair[S1[i-2]][S2[j+3]];
      if(type2 && c[i][j]==(c[i - 2][j+3]+P->int21[type2][rtype[type]][SS1[i-1]][SS2[j+1]][SS2[j+2]]+di2+dj3)){
        k=i-2;
        l=j+3;
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGplex+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGx+=di2;
        *dGy+=dj3;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
      type2 = pair[S1[i-4]][S2[j+3]];
      if(type2 && c[i][j]==(c[i - 4][j+3]+P->internal_loop[5]+P->ninio[2]+
                            P->mismatch23I[type2][SS1[i-3]][SS2[j+2]]+P->mismatch23I[rtype[type]][SS2[j+1]][SS1[i-1]]+di4+dj3)){
        k=i-4;
        l=j+3;
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGplex+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGx+=di2;
        *dGy+=dj3;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
      type2 = pair[S1[i-3]][S2[j+4]];
      if(type2 && c[i][j]==(c[i - 3][j+4]+P->internal_loop[5]+P->ninio[2]+
                            P->mismatch23I[type2][SS1[i-2]][SS2[j+3]]+P->mismatch23I[rtype[type]][SS2[j+1]][SS1[i-1]]+di3+dj4)){
        k=i-3;
        l=j+4;
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGplex+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGx+=di2;
        *dGy+=dj3;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
      if(c[i][j]==(in[i - 3][j+3]+P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+di3+dj3+2*iext_s)){
        k=i;
        l=j;
        *dGplex+=P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+2*iext_s;
        *dGx+=di3;
        *dGy+=dj3;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=i-3;
        j=j+3;
        state=2;
        traced=1;
        break;
      }
      if(c[i][j]==(in[i - 4][j+2]+P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+di4+dj2+iext_s+2*iext_ass)){
        k=i;
        l=j;
        *dGplex+=P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_s+2*iext_ass;
        *dGx+=di4;
        *dGy+=dj2;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=i-4;
        j=j+2;
        state=2;
        traced=1;
        break;
      }
      if(c[i][j]==(in[i - 2][j+4]+P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+di2+dj4+iext_s+2*iext_ass)){
        k=i;
        l=j;
        *dGplex+=P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_s+2*iext_ass;
        *dGx+=di2;
        *dGy+=dj4;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=i-2;
        j=j+4;
        state=2;
        traced=1;
        break;
      }
      if(c[i][j]==(inx[i - 3][j+1]+P->mismatch1nI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_ass+iext_ass+di3+dj1)){
        k=i;
        l=j;
        *dGplex+=P->mismatch1nI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_ass+iext_ass+di3+dj1;
        *dGx+=di3;
        *dGy+=dj1;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=i-3;
        j=j+1;
        state=5;
        traced=1;
        break;
      }
      if(c[i][j]==(iny[i - 1][j+3]+P->mismatch1nI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_ass+iext_ass+di1+dj3)){
        k=i;
        l=j;
        *dGplex+=P->mismatch1nI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_ass+iext_ass+di1+dj3;
        *dGx+=di1;
        *dGy+=dj3;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=i-1;
        j=j+3;
        state=6;
        traced=1;
        break;
      }
      if(c[i][j]==(bx[i - 2][j+1]+di2+dj1+bext+bAU)){
        k=i;
        l=j;
        st1[i-1] = '(';
        st2[j-1] = ')';
        *dGplex+=bext+bAU;
        *dGx+=di2;
        *dGy+=dj1;
        i=i-2;
        j=j+1;
        state=3;
        traced=1;
        break;
      }
      if(c[i][j]==(by[i - 1][j+2]+di1+dj2+bext+bAU)){
        k=i;
        l=j;
        *dGplex+=bext+bAU;
        *dGx+=di1;
        *dGy+=dj2;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=i-1;
        j=j+2;
        state=4;
        traced=1;
        break;
      }
      break;
    case 2:
      if(in[i][j]==(in[i - 1][j+1]+iext_s + di1 + dj1)){
        i--;
        j++;
        *dGplex+=iext_s;
        *dGx+=di1;
        *dGy+=dj1;
        state=2;
        traced=1;
        break;
      }
      if(in[i][j]==(in[i - 1][j]+iext_ass + di1)){
        i=i-1;
        *dGplex+=iext_ass;
        *dGx+=di1;
        state=2;
        traced=1;
        break;
      }
      if(in[i][j]==(in[i][j+1]+iext_ass + dj1)){
        j++;
        state=2;
        *dGy+=dj1;
        *dGplex+=iext_ass;
        traced=1;
        break;
      }
      type2=pair[SS2[j+1]][SS1[i-1]];
      if(type2 && in[i][j]==(c[i - 1][j+1]+P->mismatchI[type2][SS2[j]][SS1[i]]+iopen+iext_s + di1 +dj1)){
        *dGplex+=P->mismatchI[type2][SS2[j]][SS1[i]]+iopen+iext_s;
        int temp; temp=k; k=i-1; i=temp;
        temp=l; l=j+1; j=temp;
        type=pair[S1[i]][S2[j]];
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGx+=di1;
        *dGy+=dj1;
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
    case 3:
      if(bx[i][j]==(bx[i - 1][j]+bext+di1)){
        i--;
        *dGplex+=bext;
        *dGx+=di1;
        state=3;
        traced=1;
        break;
      }
      type2=pair[S2[j]][S1[i-1]];
      if(type2 && bx[i][j]==(c[i - 1][j]+bopen+bext+(type2>2?P->TerminalAU:0)+di1)){
        int temp; temp=k; k=i-1; i=temp;
        temp=l; l=j; j=temp;
        type=pair[S1[i]][S2[j]];
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGplex+=bopen+bext+(type2>2?P->TerminalAU:0);
        *dGx+=di1;
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
    case 4:
      if(by[i][j]==(by[i][j+1] + bext +dj1)){
        j++;
        *dGplex+=bext;
        state=4;
        traced=1;
        break;
      }
      type2=pair[S2[j+1]][S1[i]];
      if(type2 && by[i][j]==(c[i][j+1]+bopen+bext+(type2>2?P->TerminalAU:0) + dj1)){
        int temp; temp=k; k=i; i=temp;
        temp=l; l=j+1; j=temp;
        type=pair[S1[i]][S2[j]];
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGplex+=bopen+bext+(type2>2?P->TerminalAU:0);
        *dGy+=dj1;
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
    case 5:
      if(inx[i][j]==(inx[i-1][j]+iext_ass+di1)) {
        i--;
        *dGplex+=iext_ass;
        *dGx+=di1;
        state=5;
        traced=1;
        break;
      }
      type2=pair[S2[j+1]][S1[i-1]];
      if(type2 && inx[i][j]==(c[i-1][j+1]+P->mismatch1nI[type2][SS2[j]][SS1[i]]+iopen+iext_s+di1+dj1)){
        *dGplex+=P->mismatch1nI[type2][SS2[j]][SS1[i]]+iopen+iext_s;
        int temp; temp=k; k=i-1; i=temp;
        temp=l; l=j+1; j=temp;
        type=pair[S1[i]][S2[j]];
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGx+=di1;
        *dGy+=dj1;
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
    case 6:
      if(iny[i][j]==(iny[i][j+1]+iext_ass+dj1)) {
        j++;
        *dGplex+=iext_ass;
        *dGx+=dj1;
        state=6;
        traced=1;
        break;
      }
      type2=pair[S2[j+1]][S1[i-1]];
      if(type2 && iny[i][j]==(c[i-1][j+1]+P->mismatch1nI[type2][SS2[j]][SS1[i]]+iopen+iext_s+di1+dj1)){
        *dGplex+=P->mismatch1nI[type2][SS2[j]][SS1[i]]+iopen+iext_s;
        int temp; temp=k; k=i-1; i=temp;
        temp=l; l=j+1; j=temp;
        type=pair[S1[i]][S2[j]];
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        *dGx+=di1;
        *dGy+=dj1;
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
    }
  }
  if (!traced) {
    idiff=i_pos-(n3-10-i);
    jdiff=j_pos+j-11;
    E=c[i][j];
    /**
    *** if (i>1) {E -= P->dangle5[type][SS1[i-1]]; *dG+=P->dangle5[type][SS1[i-1]];*dGplex+=P->dangle5[type][SS1[i-1]];}
    *** if (j<n4){E -= P->dangle3[type][SS2[j+1]]; *dG+=P->dangle3[type][SS2[j+1]];*dGplex+=P->dangle3[type][SS2[j+1]];}
    *** if (type>2) {E -= P->TerminalAU; *dG+=P->TerminalAU;*dGplex+=P->TerminalAU;}
    **/
    int correction;
    correction = E_ExtLoop(type, (i>1) ? SS1[i-1] : -1, (j<n4) ? SS2[j+1] : -1, P);
    *dG+=correction;
    *dGplex+=correction;
    E-=correction;

/*
 if (E != P->DuplexInit+access_s1[1][idiff]+access_s2[1][jdiff]) {
      vrna_message_error("backtrack failed in second fold duplex");
    }
*/
    if (E != P->DuplexInit) {
      vrna_message_error("backtrack failed in second fold duplex");
    }
    else{
      *dG+=P->DuplexInit;
      *dGplex+=P->DuplexInit;
      *dGx+=0;/* access_s1[1][idiff]; */
      *dGy+=0;/* access_s2[1][jdiff]; */
      st1[i-1]='(';
      st2[j-1]=')';
    }
  }
  if (i>11)  i--;
  if (j<n4-10) j++;
  struc = (char *) vrna_alloc(i0-i+1+j-j0+1+2);
  for (k=MAX2(i,1); k<=i0; k++) if (!st1[k-1]) st1[k-1] = '.';
  for (k=j0; k<=j; k++) if (!st2[k-1]) st2[k-1] = '.';
  strcpy(struc, st1+MAX2(i-1,0));
  strcat(struc, "&");
  strcat(struc, st2+j0-1);
  /* printf("%s %3d,%-3d : %3d,%-3d\n", struc, i,i0,j0,j);  */
  free(st1); free(st2);
  return struc;
}


duplexT ** Lduplexfold_XS(const char *s1, const char *s2, const int **access_s1, const int **access_s2, const int threshold, const int alignment_length, const int delta, const int fast, const int il_a, const int il_b, const int b_a, const int b_b)
{
  /**
  *** See variable definition in fduplexfold_XS
  **/
  int i, j;
  int bopen=b_b;
  int bext=b_a;
  int iopen=il_b;
  int iext_s=2*il_a;
  int iext_ass=50+il_a;
  int min_colonne=INF;
  int i_length;
  int max_pos;
  int max_pos_j;
  int min_j_colonne;
  int max=INF;
  int *position;
  int *position_j;
  int maxPenalty[4];
  int **DJ;
  /**
  *** 1D array corresponding to the standard 2d recursion matrix
  *** Makes the computation 20% faster
  **/
  int *SA;
  vrna_md_t   md;
  /**
  *** variable initialization
  **/
  n1 = (int) strlen(s1);
  n2 = (int) strlen(s2);
  /**
  *** Sequence encoding
  **/

  set_model_details(&md);

  if ((!P) || (fabs(P->temperature - temperature)>1e-6)) {
    update_dfold_params();
    if(P)
      free(P);
    P = vrna_params(&md);
    make_pair_matrix();
  }
  encode_seqs(s1,s2);
  /**
  *** Position of the high score on the target and query sequence
  **/
  position = (int *) vrna_alloc((delta+n1+3+delta) * sizeof(int));
  position_j= (int *) vrna_alloc((delta+n1+3+delta) * sizeof(int));
  /**
  *** extension penalty, computed only once, further reduce the computation time
  **/
  maxPenalty[0]=(int) -1*P->stack[2][2]/2;
  maxPenalty[1]=(int) -1*P->stack[2][2];
  maxPenalty[2]=(int) -3*P->stack[2][2]/2;
  maxPenalty[3]=(int) -2*P->stack[2][2];

  DJ=(int **) vrna_alloc(4*sizeof(int*));
  DJ[0]=(int *) vrna_alloc(n2*sizeof(int));
  DJ[1]=(int *) vrna_alloc(n2*sizeof(int));
  DJ[2]=(int *) vrna_alloc(n2*sizeof(int));
  DJ[3]=(int *) vrna_alloc(n2*sizeof(int));
  j=n2-9;
  while(--j>10){
    DJ[0][j] = 0.5*(access_s2[5][j+4] - access_s2[4][j+4] + access_s2[5][j]  -access_s2[4][j-1]  );
    DJ[1][j] = 0.5*(access_s2[5][j+5] - access_s2[4][j+5] + access_s2[5][j+1]-access_s2[4][j]  ) + DJ[0][j];
    DJ[2][j] = 0.5*(access_s2[5][j+6] - access_s2[4][j+6] + access_s2[5][j+2]-access_s2[4][j+1]) + DJ[1][j];
    DJ[3][j] = 0.5*(access_s2[5][j+7] - access_s2[4][j+7] + access_s2[5][j+3]-access_s2[4][j+2]) + DJ[2][j];
/*
    DJ[0][j] = access_s2[5][j+4] - access_s2[4][j+4]           ;
    DJ[1][j] = access_s2[5][j+5] - access_s2[4][j+5] + DJ[0][j];
    DJ[2][j] = access_s2[5][j+6] - access_s2[4][j+6] + DJ[1][j];
    DJ[3][j] = access_s2[5][j+7] - access_s2[4][j+7] + DJ[2][j];
    DJ[0][j] = MIN2(DJ[0][j],maxPenalty[0]);
    DJ[1][j] = MIN2(DJ[1][j],maxPenalty[1]);
    DJ[2][j] = MIN2(DJ[2][j],maxPenalty[2]);
    DJ[3][j] = MIN2(DJ[3][j],maxPenalty[3]);
*/
  }
  /**
  *** instead of having 4 2-dim arrays we use a unique 1-dim array
  *** The mapping 2d -> 1D is done based ont the macro
  *** LCI(i,j,l)      ((i     )*l + j)
  *** LINI(i,j,l)     ((i +  5)*l + j)
  *** LBXI(i,j,l)     ((i + 10)*l + j)
  *** LBYI(i,j,l)     ((i + 15)*l + j)
  *** LINIX(i,j,l)    ((i + 20)*l + j)
  *** LINIY(i,j,l)    ((i + 25)*l + j)
  ***
  *** SA has a length of 5 (number of columns we look back) *
  ***                  * 6 (number of structures we look at) *
  ***                  * length of the sequence
  **/

  SA=(int *) vrna_alloc(sizeof(int)*5*6*(n2+5));
  for(j=n2+4;j>=0;j--) {
    SA[(j*30)   ]=SA[(j*30)+1   ]=SA[(j*30)+2   ]=SA[(j*30)+3   ]=SA[(j*30)+4   ]=INF;
    SA[(j*30)+5 ]=SA[(j*30)+1+5 ]=SA[(j*30)+2+5 ]=SA[(j*30)+3+5 ]=SA[(j*30)+4+5 ]=INF;
    SA[(j*30)+10]=SA[(j*30)+1+10]=SA[(j*30)+2+10]=SA[(j*30)+3+10]=SA[(j*30)+4+10]=INF;
    SA[(j*30)+15]=SA[(j*30)+1+15]=SA[(j*30)+2+15]=SA[(j*30)+3+15]=SA[(j*30)+4+15]=INF;
    SA[(j*30)+20]=SA[(j*30)+1+20]=SA[(j*30)+2+20]=SA[(j*30)+3+20]=SA[(j*30)+4+20]=INF;
    SA[(j*30)+25]=SA[(j*30)+1+25]=SA[(j*30)+2+25]=SA[(j*30)+3+25]=SA[(j*30)+4+25]=INF;
  }

  i=10 ;
  i_length= n1 - 9  ;
  while(i < i_length) {
    int di1,di2,di3,di4;
    int idx=i%5;
    int idx_1=(i-1)%5;
    int idx_2=(i-2)%5;
    int idx_3=(i-3)%5;
    int idx_4=(i-4)%5;
    di1 = 0.5*(access_s1[5][i+4] - access_s1[4][i+4] + access_s1[5][i]   - access_s1[4][i-1]);
    di2 = 0.5*(access_s1[5][i+3] - access_s1[4][i+3] + access_s1[5][i-1] - access_s1[4][i-2]) + di1;
    di3 = 0.5*(access_s1[5][i+2] - access_s1[4][i+2] + access_s1[5][i-2] - access_s1[4][i-3]) + di2;
    di4 = 0.5*(access_s1[5][i+1] - access_s1[4][i+1] + access_s1[5][i-3] - access_s1[4][i-4]) + di3;
/*
    di1 = access_s1[5][i]   - access_s1[4][i-1];
    di2 = access_s1[5][i-1] - access_s1[4][i-2] + di1;
    di3 = access_s1[5][i-2] - access_s1[4][i-3] + di2;
    di4 = access_s1[5][i-3] - access_s1[4][i-4] + di3;
    di1=MIN2(di1,maxPenalty[0]);
    di2=MIN2(di2,maxPenalty[1]);
    di3=MIN2(di3,maxPenalty[2]);
    di4=MIN2(di4,maxPenalty[3]);
*/
    j=n2 - 9;
    while (--j > 9) {
      int dj1,dj2,dj3,dj4;
      dj1=DJ[0][j];
      dj2=DJ[1][j];
      dj3=DJ[2][j];
      dj4=DJ[3][j];
      int type2, type,temp;
      type  = pair[S1[i]][S2[j]];
      /**
      *** Start duplex
      **/
      /* SA[LCI(idx,j,n2)] = type ? P->DuplexInit + access_s1[1][i] + access_s2[1][j] : INF; */
      SA[LCI(idx,j,n2)] = type ? P->DuplexInit : INF;
      /**
      *** update lin bx by linx liny matrix
      **/
      type2=pair[S2[j+1]][S1[i-1]];
      /**
      *** start/extend interior loop
      **/
      SA[LINI(idx,j,n2)]=MIN2(SA[LCI(idx_1,j+1,n2)]+P->mismatchI[type2][SS2[j]][SS1[i]]+di1+dj1+iopen+iext_s,
                              SA[LINI(idx_1,j,n2)]+iext_ass + di1);

      /**
      *** start/extend nx1 target
      *** use same type2 as for in
      **/
      SA[LINIX(idx,j,n2)]=MIN2(SA[LCI(idx_1,j+1,n2)]+P->mismatch1nI[type2][SS2[j]][SS1[i]]+di1+dj1+iopen+iext_s,
                               SA[LINIX(idx_1,j,n2)]+iext_ass + di1);
      /**
      *** start/extend 1xn target
      *** use same type2 as for in
      **/
      SA[LINIY(idx,j,n2)]=MIN2(SA[LCI(idx_1,j+1,n2)]+P->mismatch1nI[type2][SS2[j]][SS1[i]]+di1+dj1+iopen+iext_s,
                               SA[LINIY(idx,j+1,n2)]+iext_ass + dj1);
      /**
      *** extend interior loop
      **/
      SA[LINI(idx,j,n2)]=MIN2(SA[LINI(idx,j,n2)],SA[LINI(idx,j+1,n2)]+iext_ass + dj1);
      SA[LINI(idx,j,n2)]=MIN2(SA[LINI(idx,j,n2)],SA[LINI(idx_1,j+1,n2)]+iext_s + di1 + dj1);
      /**
      *** start/extend bulge target
      **/
      type2=pair[S2[j]][S1[i-1]];
      SA[LBXI(idx,j,n2)]=MIN2(SA[LBXI(idx_1,j,n2)]+bext + di1, SA[LCI(idx_1,j,n2)]+bopen+bext+(type2>2?P->TerminalAU:0) + di1);
      /**
      *** start/extend bulge query
      **/
      type2=pair[S2[j+1]][S1[i]];
      SA[LBYI(idx,j,n2)]=MIN2(SA[LBYI(idx,j+1,n2)]+bext + dj1 , SA[LCI(idx,j+1,n2)]+bopen+bext+(type2>2?P->TerminalAU:0)+ dj1);
      /**
      ***end update recursion
      **/
      if(!type){continue;}
      /**
      *** stack extension
      **/
      SA[LCI(idx,j,n2)]+= E_ExtLoop(type, SS1[i-1] , SS2[j+1], P);
      /**
      *** stack extension
      **/
      if((type2=pair[S1[i-1]][S2[j+1]]))
        SA[LCI(idx,j,n2)]=MIN2(SA[LCI(idx_1,j+1,n2)]+P->stack[rtype[type]][type2]+di1+dj1, SA[LCI(idx,j,n2)]);
      /**
      *** 1x0 / 0x1 stack extension
      **/
      if((type2=pair[S1[i-1]][S2[j+2]]))
        SA[LCI(idx,j,n2)]=MIN2(SA[LCI(idx_1,j+2,n2)]+P->bulge[1]+P->stack[rtype[type]][type2]+di1+dj2, SA[LCI(idx,j,n2)]);
      if((type2=pair[S1[i-2]][S2[j+1]]))
        SA[LCI(idx,j,n2)]=MIN2(SA[LCI(idx_2,j+1,n2)]+P->bulge[1]+P->stack[type2][rtype[type]]+di2+dj1, SA[LCI(idx,j,n2)]);
      /**
      *** 1x1 / 2x2 stack extension
      **/
      if((type2=pair[S1[i-2]][S2[j+2]]))
        SA[LCI(idx,j,n2)]=MIN2(SA[LCI(idx_2,j+2,n2)]+P->int11[type2][rtype[type]][SS1[i-1]][SS2[j+1]]+di2+dj2, SA[LCI(idx,j,n2)]);
      if((type2 = pair[S1[i-3]][S2[j+3]]))
        SA[LCI(idx,j,n2)]=MIN2(SA[LCI(idx_3,j+3,n2)]+P->int22[type2][rtype[type]][SS1[i-2]][SS1[i-1]][SS2[j+1]][SS2[j+2]]+di3+dj3, SA[LCI(idx,j,n2)]);
      /**
      *** 1x2 / 2x1 stack extension
      *** E_IntLoop(1,2,type2, rtype[type],SS1[i-1], SS2[j+2], SS1[i-1], SS2[j+1], P) corresponds to
      *** P->int21[rtype[type]][type2][SS2[j+2]][SS1[i-1]][SS1[i-1]]
      **/
      if((type2 = pair[S1[i-3]][S2[j+2]]))
        SA[LCI(idx,j,n2)]=MIN2(SA[LCI(idx_3,j+2,n2)]+P->int21[rtype[type]][type2][SS2[j+1]][SS1[i-2]][SS1[i-1]]+di3+dj2, SA[LCI(idx,j,n2)]);
      if((type2 = pair[S1[i-2]][S2[j+3]]))
        SA[LCI(idx,j,n2)]=MIN2(SA[LCI(idx_2,j+3,n2)]+P->int21[type2][rtype[type]][SS1[i-1]][SS2[j+1]][SS2[j+2]]+di2+dj3, SA[LCI(idx,j,n2)]);
      /**
      *** 2x3 / 3x2 stack extension
      **/
      if((type2 = pair[S1[i-4]][S2[j+3]]))
        SA[LCI(idx,j,n2)]=MIN2(SA[LCI(idx_4,j+3,n2)]+P->internal_loop[5]+P->ninio[2]+
                               P->mismatch23I[type2][SS1[i-3]][SS2[j+2]]+P->mismatch23I[rtype[type]][SS2[j+1]][SS1[i-1]]+di4+dj3, SA[LCI(idx,j,n2)]);
      if((type2 = pair[S1[i-3]][S2[j+4]]))
        SA[LCI(idx,j,n2)]=MIN2(SA[LCI(idx_3,j+4,n2)]+P->internal_loop[5]+P->ninio[2]+
                               P->mismatch23I[type2][SS1[i-2]][SS2[j+3]]+P->mismatch23I[rtype[type]][SS2[j+1]][SS1[i-1]]+di3+dj4, SA[LCI(idx,j,n2)]);
      /**
      *** So now we have to handle 1x3, 3x1, 3x3, and mxn m,n > 3
      **/
      /**
      *** 3x3 or more
      **/
      SA[LCI(idx,j,n2)]=MIN2(SA[LINI(idx_3,j+3,n2)]+P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+2*iext_s+di3+dj3,SA[LCI(idx,j,n2)]);
      /**
      *** 2xn or more
      **/
      SA[LCI(idx,j,n2)]=MIN2(SA[LINI(idx_4,j+2,n2)]+P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_s+2*iext_ass+di4+dj2, SA[LCI(idx,j,n2)]);
      /**
      *** nx2 or more
      **/
      SA[LCI(idx,j,n2)]=MIN2(SA[LINI(idx_2,j+4,n2)]+P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_s+2*iext_ass+di2+dj4, SA[LCI(idx,j,n2)]);
      /**
      *** nx1 n>2
      **/
      SA[LCI(idx,j,n2)]=MIN2(SA[LINIX(idx_3,j+1,n2)]+P->mismatch1nI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_ass+iext_ass+di3+dj1, SA[LCI(idx,j,n2)]);
      /**
      *** 1xn n>2
      **/
      SA[LCI(idx,j,n2)]=MIN2(SA[LINIY(idx_1,j+3,n2)]+P->mismatch1nI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_ass+iext_ass+dj3+di1, SA[LCI(idx,j,n2)]);
      /**
      *** nx0 n>1
      **/
      int bAU;
      bAU=(type>2?P->TerminalAU:0);
      SA[LCI(idx,j,n2)]=MIN2(SA[LBXI(idx_2,j+1,n2)]+di2+dj1+bext+bAU,SA[LCI(idx,j,n2)]);
      /**
      *** 0xn n>1
      **/
      SA[LCI(idx,j,n2)]=MIN2(SA[LBYI(idx_1,j+2,n2)]+di1+dj2+bext+bAU,SA[LCI(idx,j,n2)]);
      temp=min_colonne;
      /**
      *** (type>2?P->TerminalAU:0)+
      *** P->dangle3[rtype[type]][SS1[i+1]]+
      *** P->dangle5[rtype[type]][SS2[j-1]],
      **/
      /* remove this line printf("LCI %d:%d %d\t",i,j,SA[LCI(idx,j,n2)]); */
      /* remove this line printf("LI %d:%d %d\t",i,j, SA[LINI(idx,j,n2)]); */
      min_colonne=MIN2(SA[LCI(idx,j,n2)]+E_ExtLoop(rtype[type], SS2[j-1] , SS1[i+1] , P), min_colonne);

      if(temp>min_colonne){
        min_j_colonne=j;
      }

      /* ---------------------------------------------------------------------end update */
    }
    if(max>=min_colonne){
      max=min_colonne;
      max_pos=i;
      max_pos_j=min_j_colonne;
    }
    position[i+delta]=min_colonne;min_colonne=INF;
    position_j[i+delta]=min_j_colonne;
    /* remove this line printf("\n"); */
    i++;
  }
  /* printf("MAX: %d",max); */
  free(S1); free(S2); free(SS1); free(SS2);free(SA);
  if(max<threshold){
    find_max_XS(position, position_j, delta, threshold, alignment_length, s1, s2, access_s1, access_s2, fast,il_a, il_b,b_a, b_b);
  }
  if(max<INF){
    plot_max_XS(max, max_pos, max_pos_j, alignment_length, s1, s2, access_s1, access_s2,fast, il_a, il_b, b_a, b_b);
  }
  for (i=0; i<=3; i++) {
    free(DJ[i]);
  }
  free(DJ);
  free(position);
  free(position_j);
  return NULL;
}

PRIVATE void find_max_XS(const int *position, const int *position_j,const int delta, const int threshold, const int alignment_length, const char *s1, const char *s2, const int **access_s1, const int **access_s2, const int fast,const int il_a, const int il_b, const int b_a, const int b_b){
  int pos=n1-9;
  if(fast==1){
    while(10 < pos--){
      int temp_min=0;
      if(position[pos+delta]<(threshold)){
        int search_range;
        search_range=delta+1;
        while(--search_range){
          if(position[pos+delta-search_range]<=position[pos+delta-temp_min]){
            temp_min=search_range;
          }
        }
        pos-=temp_min;
        int max_pos_j;
        max_pos_j=position_j[pos+delta];
        int max;
        max=position[pos+delta];
        printf("target upper bound %d: query lower bound %d  (%5.2f) \n", pos-10, max_pos_j-10, ((double)max)/100);
        pos=MAX2(10,pos+temp_min-delta);
      }
    }
  }
  else if(fast==2){
    pos=n1-9;
    while(10 < pos--){
      int temp_min=0;
      if(position[pos+delta]<(threshold)){
        int search_range;
        search_range=delta+1;
        while(--search_range){
          if(position[pos+delta-search_range]<=position[pos+delta-temp_min]){
            temp_min=search_range;
          }
        }
        pos-=temp_min;
        int max_pos_j;
        max_pos_j=position_j[pos+delta];
        /* max_pos_j und pos entsprechen die realen position
            in der erweiterten sequenz.
           pos=1 -> position 1 in the sequence (and not 0 like in C)
           max_pos_j -> position 1 in the sequence ( not 0 like in C)
        */
        int alignment_length2; alignment_length2 = MIN2(n1,n2);
        int begin_t=MAX2(11, pos-alignment_length2+1);/* 10 */
        int end_t  =MIN2(n1-10, pos+1);
        int begin_q=MAX2(11, max_pos_j-1); /* 10 */
        int end_q  =MIN2(n2-10, max_pos_j+alignment_length2-1);
        char *s3 = (char*) vrna_alloc(sizeof(char)*(end_t - begin_t +2 + 20));
        char *s4 = (char*) vrna_alloc(sizeof(char)*(end_q - begin_q +2 + 20));
        strcpy(s3,"NNNNNNNNNN");strcpy(s4,"NNNNNNNNNN");
        strncat(s3, (s1+begin_t-1),  end_t - begin_t +1);
        strncat(s4, (s2+begin_q-1) , end_q - begin_q +1);
        strcat(s3,"NNNNNNNNNN");strcat(s4,"NNNNNNNNNN");
        s3[end_t -begin_t +1 +20 ]='\0';
        s4[end_q -begin_q +1 +20]='\0';
        duplexT test;
        test = fduplexfold_XS(s3, s4, access_s1, access_s2, end_t, begin_q,threshold, il_a, il_b, b_a, b_b);
        if(test.energy * 100 < threshold){
          int l1=strchr(test.structure, '&')-test.structure;
          printf(" %s %3d,%-3d : %3d,%-3d (%5.2f = %5.2f + %5.2f + %5.2f) [%5.2f] i:%d,j:%d <%5.2f>\n", test.structure,
                 begin_t-10+test.i-l1-10,
                 begin_t-10+test.i-1-10,
                 begin_q-10 + test.j-1-10 ,
                 (begin_q -11) + test.j + (int)strlen(test.structure)-l1-2-10,
                 test.ddG, test.energy, test.opening_backtrack_x, test.opening_backtrack_y, test.energy_backtrack,
                 pos-10, max_pos_j-10, ((double) position[pos+delta])/100);
          pos=MAX2(10,pos+temp_min-delta);
          free(test.structure);
        }
        free(s3);free(s4);
      }
    }
  }
  else{
    pos=n1-9;
    while( pos-- > 10 ){
      int temp_min=0;
      if(position[pos+delta]<(threshold)){
        int search_range;
        search_range=delta+1;
        while(--search_range){
          if(position[pos+delta-search_range]<=position[pos+delta-temp_min]){
            temp_min=search_range;
          }
        }
        pos-=temp_min; /* position on i */
        int max_pos_j;
        max_pos_j=position_j[pos+delta]; /* position on j */
        int begin_t=MAX2(11,pos-alignment_length);
        int end_t  =MIN2(n1-10, pos+1);
        int begin_q=MAX2(11,max_pos_j-1);
        int end_q  =MIN2(n2-10,max_pos_j+alignment_length-1);
        int i_flag;
        int j_flag;
        i_flag = (end_t   ==  pos+1?1:0);
        j_flag = (begin_q == max_pos_j-1?1:0);
        char *s3 = (char*) vrna_alloc(sizeof(char)*(end_t - begin_t +2));
        char *s4 = (char*) vrna_alloc(sizeof(char)*(end_q - begin_q +2));
        strncpy(s3, (s1+begin_t),  end_t - begin_t+1);
        strncpy(s4, (s2+begin_q) , end_q - begin_q+1);
        s3[end_t -begin_t +1 ]='\0';
        s4[end_q -begin_q +1 ]='\0';
        duplexT test;
        test = duplexfold_XS(s3,s4,access_s1,access_s2,pos, max_pos_j,threshold,i_flag,j_flag);
        if(test.energy * 100 < threshold){
          printf("%s %3d,%-3d : %3d,%-3d (%5.2f = %5.2f + %5.2f + %5.2f) i:%d,j:%d <%5.2f>\n", test.structure,
                 test.tb,test.te,test.qb,test.qe, test.ddG, test.energy, test.dG1, test.dG2, pos-10, max_pos_j-10, ((double) position[pos+delta])/100);
          pos=MAX2(10,pos+temp_min-delta);
        }
        free(s3);free(s4);
        free(test.structure);
      }
    }
  }
}

#if 0
PRIVATE int compare(const void *sub1, const void *sub2) {
  int d;
  if (((duplexT *) sub1)->ddG > ((duplexT *) sub2)->ddG)
    return 1;
  if (((duplexT *) sub1)->ddG < ((duplexT *) sub2)->ddG)
    return -1;
  d = ((duplexT *) sub1)->i - ((duplexT *) sub2)->i;
  if (d!=0) return d;
  return  ((duplexT *) sub1)->j - ((duplexT *) sub2)->j;
}
#endif

PRIVATE void plot_max_XS(const int max, const int max_pos, const int max_pos_j, const int alignment_length, const char *s1, const char *s2, const int ** access_s1, const int ** access_s2, const int fast,const int il_a, const int il_b, const int b_a, const int b_b)
{
  if(fast==1){
    printf("target upper bound %d: query lower bound %d (%5.2f)\n", max_pos-3, max_pos_j, ((double)max)/100);
  }
  else if(fast==2){
    int alignment_length2; alignment_length2 = MIN2(n1,n2);
    int begin_t=MAX2(11, max_pos-alignment_length2+1);/* 10 */
    int end_t  =MIN2(n1-10, max_pos+1);
    int begin_q=MAX2(11, max_pos_j-1); /* 10 */
    int end_q  =MIN2(n2-10, max_pos_j+alignment_length2-1);
    char *s3 = (char*) vrna_alloc(sizeof(char)*(end_t - begin_t +2 + 20));
    char *s4 = (char*) vrna_alloc(sizeof(char)*(end_q - begin_q +2 + 20));
    strcpy(s3,"NNNNNNNNNN");strcpy(s4,"NNNNNNNNNN");
    strncat(s3, (s1+begin_t-1),  end_t - begin_t +1);
    strncat(s4, (s2+begin_q-1) , end_q - begin_q +1);
    strcat(s3,"NNNNNNNNNN");strcat(s4,"NNNNNNNNNN");
    s3[end_t -begin_t +1 +20 ]='\0';
    s4[end_q -begin_q +1 +20]='\0';
    duplexT test;
    test = fduplexfold_XS(s3, s4, access_s1, access_s2, end_t, begin_q, INF, il_a, il_b, b_a, b_b);
    int l1=strchr(test.structure, '&')-test.structure;
    printf("%s %3d,%-3d : %3d,%-3d (%5.2f = %5.2f + %5.2f + %5.2f) [%5.2f] i:%d,j:%d <%5.2f>\n", test.structure,
           begin_t-10+test.i-l1-10,
           begin_t-10+test.i-1-10,
           begin_q-10 + test.j-1-10 ,
           (begin_q -11) + test.j + (int)strlen(test.structure)-l1-2-10,
           test.ddG, test.energy, test.opening_backtrack_x, test.opening_backtrack_y, test.energy_backtrack,
           max_pos-10, max_pos_j-10, (double) max/100);

    free(s3);free(s4);
    free(test.structure);
  }
  else{
    int begin_t=MAX2(11,max_pos-alignment_length);
    int end_t  =MIN2(n1-10, max_pos+1);
    int begin_q=MAX2(11, max_pos_j-1);
    int end_q  =MIN2(n2-10,max_pos_j+alignment_length-1);
    int i_flag;
    int j_flag;
    i_flag = (end_t   == max_pos+1?1:0);
    j_flag = (begin_q == max_pos_j-1?1:0);
    char *s3 = (char*) vrna_alloc(sizeof(char)*(end_t - begin_t +2)); /* +1 for \0 +1 for distance */
    char *s4 = (char*) vrna_alloc(sizeof(char)*(end_q - begin_q +2));

    strncpy(s3, (s1+begin_t-1),  end_t - begin_t+1);/* -1 to go from  */
    strncpy(s4, (s2+begin_q-1) , end_q - begin_q+1);/* -1 to go from  */
    s3[end_t -begin_t +1 ]='\0';/*  */
    s4[end_q -begin_q +1 ]='\0';
    duplexT test;
    test = duplexfold_XS(s3,s4,access_s1,access_s2,max_pos, max_pos_j,INF,i_flag,j_flag);
    printf("%s %3d,%-3d : %3d,%-3d (%5.2f = %5.2f + %5.2f + %5.2f) i:%d,j:%d <%5.2f>\n", test.structure,
           test.tb,test.te,test.qb,test.qe, test.ddG, test.energy, test.dG1, test.dG2, max_pos-10, max_pos_j - 10,(double) max/100);
    free(s3);free(s4);free(test.structure);
  }
}


/*---------------------------------------------------------duplexfold----------------------------------------------------------------------------------*/


PRIVATE duplexT duplexfold(const char *s1, const char *s2, const int extension_cost) {
  int i, j, l1, Emin=INF, i_min=0, j_min=0;
  char *struc;
  duplexT mfe;
  vrna_md_t md;

  n3 = (int) strlen(s1);
  n4 = (int) strlen(s2);

  set_model_details(&md);
  if ((!P) || (fabs(P->temperature - temperature)>1e-6)) {
    update_fold_params();
    if(P)
      free(P);
    P = vrna_params(&md);
    make_pair_matrix();
  }

  c = (int **) vrna_alloc(sizeof(int *) * (n3+1));
  for (i=0; i<=n3; i++) c[i] = (int *) vrna_alloc(sizeof(int) * (n4+1));
  encode_seqs(s1, s2);
  for (i=1; i<=n3; i++) {
    for (j=n4; j>0; j--) {
      int type, type2, E, k,l;
      type = pair[S1[i]][S2[j]];
      c[i][j] = type ? P->DuplexInit +2 * extension_cost: INF;
      if (!type) continue;
      /**
      ***       if (i>1)  c[i][j] += P->dangle5[type][SS1[i-1]]+ extension_cost;
      ***       if (j<n4) c[i][j] += P->dangle3[type][SS2[j+1]]+ extension_cost;
      ***       if (type>2) c[i][j] += P->TerminalAU;
      **/
      c[i][j] += E_ExtLoop(type, (i>1) ? SS1[i-1] : -1, (j<n4) ? SS2[j+1] : -1, P);
      for (k=i-1; k>0 && k>i-MAXLOOP-2; k--) {
        for (l=j+1; l<=n4; l++) {
          if (i-k+l-j-2>MAXLOOP) break;
          type2 = pair[S1[k]][S2[l]];
          if (!type2) continue;
          E = E_IntLoop(i-k-1, l-j-1, type2, rtype[type],
                        SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P)+(i-k+l-j)*extension_cost;
          c[i][j] = MIN2(c[i][j], c[k][l]+E);
        }
      }
      E = c[i][j];
      /**
      ***      if (i<n3) E += P->dangle3[rtype[type]][SS1[i+1]]+extension_cost;
      ***      if (j>1)  E += P->dangle5[rtype[type]][SS2[j-1]]+extension_cost;
      ***      if (type>2) E += P->TerminalAU;
      ***
      **/
      E += E_ExtLoop(rtype[type], (j > 1) ? SS2[j-1] : -1, (i<n3) ? SS1[i+1] : -1, P);
      if (E<Emin) {
        Emin=E; i_min=i; j_min=j;
      }
    }
  }
  struc = backtrack(i_min, j_min, extension_cost);
  if (i_min<n3) i_min++;
  if (j_min>1 ) j_min--;
  l1 = strchr(struc, '&')-struc;
  int size;
  size=strlen(struc)-1;
  Emin-= size * (extension_cost);
  mfe.i = i_min;
  mfe.j = j_min;
  mfe.energy = (double) Emin/100.;
  mfe.structure = struc;
  for (i=0; i<=n3; i++) free(c[i]);
  free(c);
  free(S1); free(S2); free(SS1); free(SS2);
  return mfe;
}

PRIVATE char *backtrack(int i, int j, const int extension_cost) {
  /* backtrack structure going backwards from i, and forwards from j
     return structure in bracket notation with & as separator */
  int k, l, type, type2, E, traced, i0, j0;
  char *st1, *st2, *struc;

  st1 = (char *) vrna_alloc(sizeof(char)*(n3+1));
  st2 = (char *) vrna_alloc(sizeof(char)*(n4+1));

  i0=MIN2(i+1,n3); j0=MAX2(j-1,1);

  while (i>0 && j<=n4) {
    E = c[i][j]; traced=0;
    st1[i-1] = '(';
    st2[j-1] = ')';
    type = pair[S1[i]][S2[j]];
    if (!type) vrna_message_error("backtrack failed in fold duplex");
    for (k=i-1; k>0 && k>i-MAXLOOP-2; k--) {
      for (l=j+1; l<=n4; l++) {
        int LE;
        if (i-k+l-j-2>MAXLOOP) break;
        type2 = pair[S1[k]][S2[l]];
        if (!type2) continue;
        LE = E_IntLoop(i-k-1, l-j-1, type2, rtype[type],
                       SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P)+(i-k+l-j)*extension_cost;
        if (E == c[k][l]+LE) {
          traced=1;
          i=k; j=l;
          break;
        }
      }
      if (traced) break;
    }
    if (!traced) {

      E -=  E_ExtLoop(type, (i>1) ? SS1[i-1] : -1, (j<n4) ? SS2[j+1] : -1, P);
      /**
      ***      if (i>1) E -= P->dangle5[type][SS1[i-1]]+extension_cost;
      ***      if (j<n4) E -= P->dangle3[type][SS2[j+1]]+extension_cost;
      ***      if (type>2) E -= P->TerminalAU;
      **/
      if (E != P->DuplexInit+2*extension_cost) {
        vrna_message_error("backtrack failed in fold duplex");
      } else break;
    }
  }
  if (i>1)  i--;
  if (j<n4) j++;

  struc = (char *) vrna_alloc(i0-i+1+j-j0+1+2);
  for (k=MAX2(i,1); k<=i0; k++) if (!st1[k-1]) st1[k-1] = '.';
  for (k=j0; k<=j; k++) if (!st2[k-1]) st2[k-1] = '.';
  strcpy(struc, st1+MAX2(i-1,0));
  strcat(struc, "&");
  strcat(struc, st2+j0-1);
  /* printf("%s %3d,%-3d : %3d,%-3d\n", struc, i,i0,j0,j);  */
  free(st1); free(st2);
  return struc;
}

PRIVATE duplexT fduplexfold(const char *s1, const char *s2, const int extension_cost,const int il_a, const int il_b, const int b_a, const int b_b) {
  int i, j, Emin, i_min, j_min,l1;
  duplexT mfe;
  char *struc;
  int bopen=b_b;
  int bext=b_a+extension_cost;
  int iopen=il_b;
  int iext_s=2*(il_a+extension_cost);/* iext_s 2 nt nucleotide extension of interior loop, on i and j side */
  int iext_ass=50+il_a+extension_cost;/* iext_ass assymetric extension of interior loop, either on i or on j side. */
  int min_colonne=INF; /* enthaelt das maximum einer kolonne */
  int i_length;
  int max_pos;/* get position of the best hit */
  int max_pos_j;
  int temp=INF;
  int min_j_colonne;
  int max=INF;
  vrna_md_t md;
  /* FOLLOWING NEXT 4 LINE DEFINES AN ARRAY CONTAINING POSITION OF THE SUBOPT IN S1 */

  n3 = (int) strlen(s1);
  n4 = (int) strlen(s2);
  /* delta_check is the minimal distance allowed for two hits to be accepted */
  /* if both hits are closer, reject the smaller ( in term of position)  hits  */
  /* i want to implement a function that, given a position in a long sequence and a small sequence, */
  /* duplexfold them at this position and report the result at the command line */
  /* for this i first need to rewrite backtrack in order to remove the printf functio */
  /* END OF DEFINITION FOR NEEDED SUBOPT DATA  */
  set_model_details(&md);
  if ((!P) || (fabs(P->temperature - temperature)>1e-6)) {
    update_fold_params();
    if(P)
      free(P);
    P = vrna_params(&md);
    make_pair_matrix();
  }
  /*local c array initialization---------------------------------------------*/
  c  = (int**)  vrna_alloc(sizeof(int *) * (n3+1));
  in = (int**) vrna_alloc(sizeof(int *) * (n3+1));
  bx = (int**) vrna_alloc(sizeof(int *) * (n3+1));
  by = (int**) vrna_alloc(sizeof(int *) * (n3+1));
  inx= (int**) vrna_alloc(sizeof(int *) * (n3+1));
  iny= (int**) vrna_alloc(sizeof(int *) * (n3+1));
  for (i=0; i<=n3; i++){
    c[i]  = (int *) vrna_alloc(sizeof(int) * (n4+1));
    in[i] = (int *) vrna_alloc(sizeof(int) * (n4+1));
    bx[i] = (int *) vrna_alloc(sizeof(int) * (n4+1));
    by[i] = (int *) vrna_alloc(sizeof(int) * (n4+1));
    inx[i] = (int *) vrna_alloc(sizeof(int) * (n4+1));
    iny[i] = (int *) vrna_alloc(sizeof(int) * (n4+1));
  }
  /*-------------------------------------------------------------------------*/
  /*end of array initialisation----------------------------------*/
  /*maybe int *** would be better*/
  encode_seqs(s1,s2);
  /* ------------------------------------------matrix initialisierung */
  for(i=0; i<n3; i++){
    for(j=0; j<n4; j++){
      in[i][j]=INF;/* no in before  1 */
      c[i][j] =INF; /* no bulge and no in before n2 */
      bx[i][j]=INF;/* no bulge before 1 */
      by[i][j]=INF;
      inx[i][j]=INF;/* no bulge before 1 */
      iny[i][j]=INF;
    }
  }

  /*--------------------------------------------------------local array*/


  /* -------------------------------------------------------------matrix initialisierung */
  i=11;
  i_length=n3-9;
  while(i < i_length) {
    j=n4-9;
    min_colonne=INF;
    while (10 < --j) {
      int type, type2;
      type = pair[S1[i]][S2[j]];
      /**
      *** Start duplex
      **/
      c[i][j]=type ? P->DuplexInit + 2*extension_cost : INF;
      /**
      *** update lin bx by linx liny matrix
      **/
      type2=pair[S2[j+1]][S1[i-1]];
      /**
      *** start/extend interior loop
      **/
      in[i][j]=MIN2(c[i - 1][j+1]+P->mismatchI[type2][SS2[j]][SS1[i]]+iopen+iext_s, in[i - 1][j]+iext_ass);
      /**
      *** start/extend nx1 target
      *** use same type2 as for in
      **/
      inx[i][j]=MIN2(c[i-1][j+1]+P->mismatch1nI[type2][SS2[j]][SS1[i]]+iopen+iext_s,
                     inx[i-1][j]+iext_ass);
      /**
      *** start/extend 1xn target
      *** use same type2 as for in
      **/
      iny[i][j]=MIN2(c[i-1][j+1]+P->mismatch1nI[type2][SS2[j]][SS1[i]]+iopen+iext_s,
                     iny[i][j+1]+iext_ass);
      /**
      *** extend interior loop
      **/
      in[i][j]=MIN2(in[i][j],in[i][j+1]+iext_ass);
      in[i][j]=MIN2(in[i][j],in[i - 1][j+1]+iext_s);
      /**
      *** start/extend bulge target
      **/
      type2=pair[S2[j]][S1[i-1]];
      bx[i][j]=MIN2(bx[i - 1][j]+bext, c[i - 1][j]+bopen+bext+(type2>2?P->TerminalAU:0));
      /**
      *** start/extend bulge query
      **/
      type2=pair[S2[j+1]][S1[i]];
      by[i][j]=MIN2(by[i][j+1]+bext, c[i][j+1]+bopen+bext+(type2>2?P->TerminalAU:0));
      /**
      ***end update recursion
      ***######################## Start stack extension##############################
      **/
      if(!type){continue;}
      c[i][j]+=E_ExtLoop(type, SS1[i-1] , SS2[j+1], P) + 2*extension_cost;
      /**
      *** stack extension
      **/
      if((type2=pair[S1[i-1]][S2[j+1]]))
        c[i][j]=MIN2(c[i - 1][j+1]+P->stack[rtype[type]][type2]+2*extension_cost, c[i][j]);
      /**
      *** 1x0 / 0x1 stack extension
      **/
      type2=pair[S1[i-1]][S2[j+2]];
      c[i][j]=MIN2(c[i - 1][j+2]+P->bulge[1]+P->stack[rtype[type]][type2]+3*extension_cost,c[i][j]);
      type2=pair[S1[i-2]][S2[j+1]];
      c[i][j]=MIN2(c[i - 2][j+1]+P->bulge[1]+P->stack[type2][rtype[type]]+3*extension_cost,c[i][j]);
      /**
      *** 1x1 / 2x2 stack extension
      **/
      type2=pair[S1[i-2]][S2[j+2]];
      c[i][j]=MIN2(c[i - 2][j+2]+P->int11[type2][rtype[type]][SS1[i-1]][SS2[j+1]]+4*extension_cost, c[i][j]);
      type2 = pair[S1[i-3]][S2[j+3]];
      c[i][j]=MIN2(c[i - 3][j+3]+P->int22[type2][rtype[type]][SS1[i-2]][SS1[i-1]][SS2[j+1]][SS2[j+2]]+6*extension_cost,c[i][j]);
      /**
      *** 1x2 / 2x1 stack extension
      *** E_IntLoop(1,2,type2, rtype[type],SS1[i-1], SS2[j+2], SS1[i-1], SS2[j+1], P) corresponds to
      *** P->int21[rtype[type]][type2][SS2[j+2]][SS1[i-1]][SS1[i-1]]
      **/
      type2 = pair[S1[i-3]][S2[j+2]];
      c[i][j]=MIN2(c[i - 3][j+2]+P->int21[rtype[type]][type2][SS2[j+1]][SS1[i-2]][SS1[i-1]]+5*extension_cost, c[i][j]);
      type2 = pair[S1[i-2]][S2[j+3]];
      c[i][j]=MIN2(c[i - 2][j+3]+P->int21[type2][rtype[type]][SS1[i-1]][SS2[j+1]][SS2[j+2]]+5*extension_cost, c[i][j]);

      /**
      *** 2x3 / 3x2 stack extension
      **/
      if((type2 = pair[S1[i-4]][S2[j+3]]))
        c[i][j]=MIN2(c[i - 4][j+3]+P->internal_loop[5]+P->ninio[2]+
                     P->mismatch23I[type2][SS1[i-3]][SS2[j+2]]+P->mismatch23I[rtype[type]][SS2[j+1]][SS1[i-1]]+7*extension_cost, c[i][j]);
      if((type2 = pair[S1[i-3]][S2[j+4]]))
        c[i][j]=MIN2(c[i - 3][j+4]+P->internal_loop[5]+P->ninio[2]+
                     P->mismatch23I[type2][SS1[i-2]][SS2[j+3]]+P->mismatch23I[rtype[type]][SS2[j+1]][SS1[i-1]]+7*extension_cost, c[i][j]);
      /**
      *** So now we have to handle 1x3, 3x1, 3x3, and mxn m,n > 3
      **/
      /**
      *** 3x3 or more
      **/
      c[i][j]=MIN2(in[i - 3][j+3]+P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+2*iext_s+2*extension_cost, c[i][j]);
      /**
      *** 2xn or more
      **/
      c[i][j]=MIN2(in[i - 4][j+2]+P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_s+2*iext_ass+2*extension_cost, c[i][j]);
      /**
      *** nx2 or more
      **/
      c[i][j]=MIN2(in[i - 2][j+4]+P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_s+2*iext_ass+2*extension_cost, c[i][j]);
      /**
      *** nx1 n>2
      **/
      c[i][j]=MIN2(inx[i - 3][j+1]+P->mismatch1nI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_ass+iext_ass+2*extension_cost, c[i][j]);
      /**
      *** 1xn n>2
      **/
      c[i][j]=MIN2(iny[i - 1][j+3]+P->mismatch1nI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_ass+iext_ass+2*extension_cost, c[i][j]);
      /**
      *** nx0 n>1
      **/
      int bAU;
      bAU=(type>2?P->TerminalAU:0);
      c[i][j]=MIN2(bx[i - 2][j+1]+2*extension_cost+bext+bAU, c[i][j]);
      /**
      *** 0xn n>1
      **/
      c[i][j]=MIN2(by[i - 1][j+2]+2*extension_cost+bext+bAU, c[i][j]);
      temp=min_colonne;
      min_colonne=MIN2(c[i][j]+E_ExtLoop(rtype[type], SS2[j-1] , SS1[i+1] , P) + 2*extension_cost, min_colonne);
      if(temp>min_colonne){
        min_j_colonne=j;
      }
      /* ---------------------------------------------------------------------end update */
    }
    if(max>=min_colonne){
      max=min_colonne;
      max_pos=i;
      max_pos_j=min_j_colonne;
    }
    i++;
  }
  Emin=max;
  i_min=max_pos;
  j_min=max_pos_j;
  int dGe;
  dGe=0;
  struc = fbacktrack(i_min, j_min, extension_cost, il_a, il_b, b_a, b_b,&dGe);
  if (i_min<n3-10) i_min++;
  if (j_min>11 ) j_min--;
  l1 = strchr(struc, '&')-struc;
  int size;
  size=strlen(struc)-1;
  Emin-= size * (extension_cost);
  mfe.i = i_min;
  mfe.j = j_min;
  mfe.energy = (double) Emin/100.;
  mfe.energy_backtrack = (double) dGe/100.;
  mfe.structure = struc;
  free(S1); free(S2); free(SS1); free(SS2);
  for (i=0; i<=n3; i++) {
    free(c[i]);
    free(in[i]);
    free(bx[i]);
    free(by[i]);
    free(inx[i]);
    free(iny[i]);
  }
  free(c);free(in);free(bx);free(by);free(inx);free(iny);
  return mfe;
}


PRIVATE char *fbacktrack(int i, int j, const int extension_cost,const int il_a, const int il_b, const int b_a, const int b_b, int *dG) {
  /* backtrack structure going backwards from i, and forwards from j
     return structure in bracket notation with & as separator */
  int k, l, type, type2, E, traced, i0, j0;
  char *st1, *st2, *struc;
  int bopen=b_b;
  int bext=b_a+extension_cost;
  int iopen=il_b;
  int iext_s=2*(il_a+extension_cost);/* iext_s 2 nt nucleotide extension of interior loop, on i and j side */
  int iext_ass=50+il_a+extension_cost;/* iext_ass assymetric extension of interior loop, either on i or on j side. */
  st1 = (char *) vrna_alloc(sizeof(char)*(n3+1));
  st2 = (char *) vrna_alloc(sizeof(char)*(n4+1));
  i0=MIN2(i+1,n3-10); j0=MAX2(j-1,11);
  int state;
  state=1; /* we start backtracking from a a pair , i.e. c-matrix */
  /* state 1 -> base pair, c
     state 2 -> interior loop, in
     state 3 -> bx loop, bx
     state 4 -> by loop, by
  */
  traced=1;
  k=i;l=j;
  type=pair[S1[i]][S2[j]];
  *dG+=E_ExtLoop(rtype[type], SS2[j-1] , SS1[i+1] , P);
  /*     (type>2?P->TerminalAU:0)+P->dangle3[rtype[type]][SS1[i+1]]+P->dangle5[rtype[type]][SS2[j-1]]; */
  while (i>10 && j<=n4-9 && traced) {
    traced=0;
    switch(state){
    case 1:
      type = pair[S1[i]][S2[j]];
      int bAU;
      bAU=(type>2?P->TerminalAU:0);
      if(!type) vrna_message_error("backtrack failed in fold duplex");
      type2=pair[S1[i-1]][S2[j+1]];
      if(type2 && c[i][j]== (c[i - 1][j+1]+P->stack[rtype[type]][type2]+2*extension_cost)){
        k=i-1;
        l=j+1;
        (*dG)+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
      type2=pair[S1[i-1]][S2[j+2]];
      if(type2 && c[i][j]==(c[i - 1][j+2]+P->bulge[1]+P->stack[rtype[type]][type2]+3*extension_cost)){
        k=i-1;
        l=j+2;
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
      type2=pair[S1[i-2]][S2[j+1]];
      if(type2 && c[i][j]==(c[i - 2][j+1]+P->bulge[1]+P->stack[type2][rtype[type]]+3*extension_cost)){
        k=i-2;
        l=j+1;
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
      type2=pair[S1[i-2]][S2[j+2]];
      if(type2 && c[i][j]==(c[i - 2][j+2]+P->int11[type2][rtype[type]][SS1[i-1]][SS2[j+1]]+4*extension_cost)){
        k=i-2;
        l=j+2;
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
      type2 = pair[S1[i-3]][S2[j+3]];
      if(type2 && c[i][j]==(c[i - 3][j+3]+P->int22[type2][rtype[type]][SS1[i-2]][SS1[i-1]][SS2[j+1]][SS2[j+2]]+6*extension_cost)){
        k=i-3;
        l=j+3;
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
      type2 = pair[S1[i-3]][S2[j+2]];
      if(type2 && c[i][j]==(c[i - 3][j+2]+P->int21[rtype[type]][type2][SS2[j+1]][SS1[i-2]][SS1[i-1]]+5*extension_cost)){
        k=i-3;
        l=j+2;
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
      type2 = pair[S1[i-2]][S2[j+3]];
      if(type2 && c[i][j]==(c[i - 2][j+3]+P->int21[type2][rtype[type]][SS1[i-1]][SS2[j+1]][SS2[j+2]]+5*extension_cost)){
        k=i-2;
        l=j+3;
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
      type2 = pair[S1[i-4]][S2[j+3]];
      if(type2 && c[i][j]==(c[i - 4][j+3]+P->internal_loop[5]+P->ninio[2]+
                            P->mismatch23I[type2][SS1[i-3]][SS2[j+2]]+P->mismatch23I[rtype[type]][SS2[j+1]][SS1[i-1]]+7*extension_cost)){
        k=i-4;
        l=j+3;
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
      type2 = pair[S1[i-3]][S2[j+4]];
      if(type2 && c[i][j]==(c[i - 3][j+4]+P->internal_loop[5]+P->ninio[2]+
                            P->mismatch23I[type2][SS1[i-2]][SS2[j+3]]+P->mismatch23I[rtype[type]][SS2[j+1]][SS1[i-1]]+7*extension_cost)){
        k=i-3;
        l=j+4;
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
      if(c[i][j]==(in[i - 3][j+3]+P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+2*extension_cost+2*iext_s)){
        k=i;
        l=j;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=i-3;
        j=j+3;
        state=2;
        traced=1;
        break;
      }
      if(c[i][j]==(in[i - 4][j+2]+P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_s+2*iext_ass+2*extension_cost)){
        k=i;
        l=j;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=i-4;
        j=j+2;
        state=2;
        traced=1;
        break;
      }
      if(c[i][j]==(in[i - 2][j+4]+P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_s+2*iext_ass+2*extension_cost)){
        k=i;
        l=j;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=i-2;
        j=j+4;
        state=2;
        traced=1;
        break;
      }
      if(c[i][j]==(inx[i - 3][j+1]+P->mismatch1nI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_ass+iext_ass+2*extension_cost)){
        k=i;
        l=j;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=i-3;
        j=j+1;
        state=5;
        traced=1;
        break;
      }
      if(c[i][j]==(iny[i - 1][j+3]+P->mismatch1nI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_ass+iext_ass+2*extension_cost)){
        k=i;
        l=j;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=i-1;
        j=j+3;
        state=6;
        traced=1;
        break;
      }
      if(c[i][j]==(bx[i - 2][j+1]+2*extension_cost+bext+bAU)){
        k=i;
        l=j;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=i-2;
        j=j+1;
        state=3;
        traced=1;
        break;
      }
      if(c[i][j]==(by[i - 1][j+2]+2*extension_cost+bext+bAU)){
        k=i;
        l=j;
        st1[i-1] = '(';
        st2[j-1] = ')';
        i=i-1;
        j=j+2;
        state=4;
        traced=1;
        break;
      }
      break;
    case 2:
      if(in[i][j]==(in[i - 1][j+1]+iext_s)){
        i--;
        j++;
        state=2;
        traced=1;
        break;
      }
      if(in[i][j]==(in[i - 1][j]+iext_ass)){
        i=i-1;
        state=2;
        traced=1;
        break;
      }
      if(in[i][j]==(in[i][j+1]+iext_ass)){
        j++;
        state=2;
        traced=1;
        break;
      }
      type2=pair[S2[j+1]][S1[i-1]];
      if(type2 && in[i][j]==(c[i - 1][j+1]+P->mismatchI[type2][SS2[j]][SS1[i]]+iopen+iext_s)){
        int temp; temp=k; k=i-1; i=temp;
        temp=l; l=j+1; j=temp;
        type=pair[S1[i]][S2[j]];
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
    case 3:
      if(bx[i][j]==(bx[i - 1][j]+bext)){
        i--;
        state=3;
        traced=1;
        break;
      }
      type2=pair[S2[j]][S1[i-1]];
      if(type2 && bx[i][j]==(c[i - 1][j]+bopen+bext+(type2>2?P->TerminalAU:0))){
        int temp; temp=k; k=i-1; i=temp;
        temp=l; l=j; j=temp;
        type=pair[S1[i]][S2[j]];
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
    case 4:
      if(by[i][j]==(by[i][j+1] + bext)){
        j++;

        state=4;
        traced=1;
        break;
      }
      type2=pair[S2[j+1]][S1[i]];
      if(type2 && by[i][j]==(c[i][j+1]+bopen+bext+(type2>2?P->TerminalAU:0))){
        int temp; temp=k; k=i; i=temp;
        temp=l; l=j+1; j=temp;
        type=pair[S1[i]][S2[j]];
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
    case 5:
      if(inx[i][j]==(inx[i-1][j]+iext_ass)) {
        i--;
        state=5;
        traced=1;
        break;
      }
      type2=pair[S2[j+1]][S1[i-1]];
      if(type2 && inx[i][j]==(c[i-1][j+1]+P->mismatch1nI[type2][SS2[j]][SS1[i]]+iopen+iext_s)){
        int temp; temp=k; k=i-1; i=temp;
        temp=l; l=j+1; j=temp;
        type=pair[S1[i]][S2[j]];
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
    case 6:
      if(iny[i][j]==(iny[i][j+1]+iext_ass)) {
        j++;
        state=6;
        traced=1;
        break;
      }
      type2=pair[S2[j+1]][S1[i-1]];
      if(type2 && iny[i][j]==(c[i-1][j+1]+P->mismatch1nI[type2][SS2[j]][SS1[i]]+iopen+iext_s)){
        int temp; temp=k; k=i-1; i=temp;
        temp=l; l=j+1; j=temp;
        type=pair[S1[i]][S2[j]];
        *dG+=E_IntLoop(i-k-1, l-j-1, type2, rtype[type],SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
        i=k;
        j=l;
        state=1;
        traced=1;
        break;
      }
    }
  }
  if (!traced) {
    E=c[i][j];
    /**
    ***    if (i>1) {E -= P->dangle5[type][SS1[i-1]]+extension_cost; *dG+=P->dangle5[type][SS1[i-1]];}
    ***    if (j<n4){E -= P->dangle3[type][SS2[j+1]]+extension_cost; *dG+=P->dangle3[type][SS2[j+1]];}
    ***    if (type>2) {E -= P->TerminalAU; *dG+=P->TerminalAU;}
    **/
    int correction;
    correction = E_ExtLoop(type, (i>1) ? SS1[i-1] : -1, (j<n4) ? SS2[j+1] : -1, P);
    *dG+=correction;
    E-=correction+2*extension_cost;
    if (E != P->DuplexInit+2*extension_cost) {
      vrna_message_error("backtrack failed in second fold duplex");
    }
    else{
      *dG+=P->DuplexInit;
      st1[i-1]='(';
      st2[j-1]=')';
    }
  }
  if (i>11)  i--;
  if (j<n4-10) j++;
  struc = (char *) vrna_alloc(i0-i+1+j-j0+1+2);
  for (k=MAX2(i,1); k<=i0; k++) if (!st1[k-1]) st1[k-1] = '.';
  for (k=j0; k<=j; k++) if (!st2[k-1]) st2[k-1] = '.';
  strcpy(struc, st1+MAX2(i-1,0));
  strcat(struc, "&");
  strcat(struc, st2+j0-1);
  /* printf("%s %3d,%-3d : %3d,%-3d\n", struc, i,i0,j0,j);  */
  free(st1); free(st2);
  return struc;
}


duplexT ** Lduplexfold(const char *s1, const char *s2, const int threshold, const int extension_cost, const int alignment_length, const int delta, const int fast, const int il_a, const int il_b, const int b_a, const int b_b)
{
  /**
  *** See variable definition in fduplexfold_XS
  **/
  int i, j;
  int bopen=b_b;
  int bext=b_a+extension_cost;
  int iopen=il_b;
  int iext_s=2*(il_a+extension_cost);/* iext_s 2 nt nucleotide extension of interior loop, on i and j side */
  int iext_ass=50+il_a+extension_cost;/* iext_ass assymetric extension of interior loop, either on i or on j side. */
  int min_colonne=INF; /* enthaelt das maximum einer kolonne */
  int i_length;
  int max_pos;/* get position of the best hit */
  int max_pos_j;
  int temp=INF;
  int min_j_colonne;
  int max=INF;
  int *position; /* contains the position of the hits with energy > E */
  int *position_j;
  /**
  *** 1D array corresponding to the standard 2d recursion matrix
  *** Makes the computation 20% faster
  **/
  int *SA;
  vrna_md_t md;
  
  /**
  *** variable initialization
  **/
  n1 = (int) strlen(s1);
  n2 = (int) strlen(s2);
  /**
  *** Sequence encoding
  **/
  set_model_details(&md);
  if ((!P) || (fabs(P->temperature - temperature)>1e-6)) {
    update_fold_params();
    if(P)
      free(P);
    P = vrna_params(&md);
    make_pair_matrix();
  }
  encode_seqs(s1,s2);
  /**
  *** Position of the high score on the target and query sequence
  **/
  position = (int *) vrna_alloc((delta+n1+3+delta) * sizeof(int));
  position_j= (int *) vrna_alloc((delta+n1+3+delta) * sizeof(int));
  /**
  *** instead of having 4 2-dim arrays we use a unique 1-dim array
  *** The mapping 2d -> 1D is done based ont the macro
  *** LCI(i,j,l)      ((i     )*l + j)
  *** LINI(i,j,l)     ((i +  5)*l + j)
  *** LBXI(i,j,l)     ((i + 10)*l + j)
  *** LBYI(i,j,l)     ((i + 15)*l + j)
  *** LINIX(i,j,l)    ((i + 20)*l + j)
  *** LINIY(i,j,l)    ((i + 25)*l + j)
  ***
  *** SA has a length of 5 (number of columns we look back) *
  ***                  * 6 (number of structures we look at) *
  ***                  * length of the sequence
  **/
  SA=(int *) vrna_alloc(sizeof(int)*5*6*(n2+5));
  for(j=n2+4;j>=0;j--) {
    SA[(j*30)   ]=SA[(j*30)+1   ]=SA[(j*30)+2   ]=SA[(j*30)+3   ]=SA[(j*30)+4   ]=INF;
    SA[(j*30)+5 ]=SA[(j*30)+1+5 ]=SA[(j*30)+2+5 ]=SA[(j*30)+3+5 ]=SA[(j*30)+4+5 ]=INF;
    SA[(j*30)+10]=SA[(j*30)+1+10]=SA[(j*30)+2+10]=SA[(j*30)+3+10]=SA[(j*30)+4+10]=INF;
    SA[(j*30)+15]=SA[(j*30)+1+15]=SA[(j*30)+2+15]=SA[(j*30)+3+15]=SA[(j*30)+4+15]=INF;
    SA[(j*30)+20]=SA[(j*30)+1+20]=SA[(j*30)+2+20]=SA[(j*30)+3+20]=SA[(j*30)+4+20]=INF;
    SA[(j*30)+25]=SA[(j*30)+1+25]=SA[(j*30)+2+25]=SA[(j*30)+3+25]=SA[(j*30)+4+25]=INF;
  }
  i=10;
  i_length= n1 - 9 ;
  while(i < i_length) {
    int idx=i%5;
    int idx_1=(i-1)%5;
    int idx_2=(i-2)%5;
    int idx_3=(i-3)%5;
    int idx_4=(i-4)%5;
    j=n2-9;
    while (9 < --j) {
      int type, type2;
      type = pair[S1[i]][S2[j]];
      /**
      *** Start duplex
      **/
      SA[LCI(idx,j,n2)]=type ? P->DuplexInit + 2*extension_cost : INF;
      /**
      *** update lin bx by linx liny matrix
      **/
      type2=pair[S2[j+1]][S1[i-1]];
      /**
      *** start/extend interior loop
      **/
      SA[LINI(idx,j,n2)]=MIN2(SA[LCI(idx_1,j+1,n2)]+P->mismatchI[type2][SS2[j]][SS1[i]]+iopen+iext_s,
                              SA[LINI(idx_1,j,n2)]+iext_ass);
      /**
      *** start/extend nx1 target
      *** use same type2 as for in
      **/
      SA[LINIX(idx,j,n2)]=MIN2(SA[LCI(idx_1,j+1,n2)]+P->mismatch1nI[type2][SS2[j]][SS1[i]]+iopen+iext_s,
                               SA[LINIX(idx_1,j,n2)]+iext_ass);
      /**
      *** start/extend 1xn target
      *** use same type2 as for in
      **/
      SA[LINIY(idx,j,n2)]=MIN2(SA[LCI(idx_1,j+1,n2)]+P->mismatch1nI[type2][SS2[j]][SS1[i]]+iopen+iext_s,
                               SA[LINIY(idx,j+1,n2)]+iext_ass);
      /**
      *** extend interior loop
      **/
      SA[LINI(idx,j,n2)]=MIN2(SA[LINI(idx,j,n2)],SA[LINI(idx,j+1,n2)]+iext_ass);
      SA[LINI(idx,j,n2)]=MIN2(SA[LINI(idx,j,n2)],SA[LINI(idx_1,j+1,n2)]+iext_s);
      /**
      *** start/extend bulge target
      **/
      type2=pair[S2[j]][S1[i-1]];
      SA[LBXI(idx,j,n2)]=MIN2(SA[LBXI(idx_1,j,n2)]+bext, SA[LCI(idx_1,j,n2)]+bopen+bext+(type2>2?P->TerminalAU:0));
      /**
      *** start/extend bulge query
      **/
      type2=pair[S2[j+1]][S1[i]];
      SA[LBYI(idx,j,n2)]=MIN2(SA[LBYI(idx,j+1,n2)]+bext, SA[LCI(idx,j+1,n2)]+bopen+bext+(type2>2?P->TerminalAU:0));
      /**
      ***end update recursion
      ***##################### Start stack extension ######################
      **/
      if(!type){continue;}
      /**
      *** stack extension
      **/
      SA[LCI(idx,j,n2)]+= E_ExtLoop(type, SS1[i-1] , SS2[j+1], P) + 2*extension_cost;
      /**
      *** stack extension
      **/
      if((type2=pair[S1[i-1]][S2[j+1]]))
        SA[LCI(idx,j,n2)]=MIN2(SA[LCI(idx_1,j+1,n2)]+P->stack[rtype[type]][type2]+2*extension_cost, SA[LCI(idx,j,n2)]);
      /**
      *** 1x0 / 0x1 stack extension
      **/
      if((type2=pair[S1[i-1]][S2[j+2]]))
        SA[LCI(idx,j,n2)]=MIN2(SA[LCI(idx_1,j+2,n2)]+P->bulge[1]+P->stack[rtype[type]][type2]+3*extension_cost,SA[LCI(idx,j,n2)]);
      if((type2=pair[S1[i-2]][S2[j+1]]))
        SA[LCI(idx,j,n2)]=MIN2(SA[LCI(idx_2,j+1,n2)]+P->bulge[1]+P->stack[type2][rtype[type]]+3*extension_cost,SA[LCI(idx,j,n2)]);
      /**
      *** 1x1 / 2x2 stack extension
      **/
      if((type2=pair[S1[i-2]][S2[j+2]]))
        SA[LCI(idx,j,n2)]=MIN2(SA[LCI(idx_2,j+2,n2)]+P->int11[type2][rtype[type]][SS1[i-1]][SS2[j+1]]+4*extension_cost, SA[LCI(idx,j,n2)]);
      if((type2 = pair[S1[i-3]][S2[j+3]]))
        SA[LCI(idx,j,n2)]=MIN2(SA[LCI(idx_3,j+3,n2)]+P->int22[type2][rtype[type]][SS1[i-2]][SS1[i-1]][SS2[j+1]][SS2[j+2]]+6*extension_cost,SA[LCI(idx,j,n2)]);
      /**
      *** 1x2 / 2x1 stack extension
      *** E_IntLoop(1,2,type2, rtype[type],SS1[i-1], SS2[j+2], SS1[i-1], SS2[j+1], P) corresponds to
      *** P->int21[rtype[type]][type2][SS2[j+2]][SS1[i-1]][SS1[i-1]]
      **/
      if((type2 = pair[S1[i-3]][S2[j+2]]))
        SA[LCI(idx,j,n2)]=MIN2(SA[LCI(idx_3,j+2,n2)]+P->int21[rtype[type]][type2][SS2[j+1]][SS1[i-2]][SS1[i-1]]+5*extension_cost, SA[LCI(idx,j,n2)]);
      if((type2 = pair[S1[i-2]][S2[j+3]]))
        SA[LCI(idx,j,n2)]=MIN2(SA[LCI(idx_2,j+3,n2)]+P->int21[type2][rtype[type]][SS1[i-1]][SS2[j+1]][SS2[j+2]]+5*extension_cost, SA[LCI(idx,j,n2)]);
      /**
      *** 2x3 / 3x2 stack extension
      **/
      if((type2 = pair[S1[i-4]][S2[j+3]]))
        SA[LCI(idx,j,n2)]=MIN2(SA[LCI(idx_4,j+3,n2)]+P->internal_loop[5]+P->ninio[2]+
                               P->mismatch23I[type2][SS1[i-3]][SS2[j+2]]+P->mismatch23I[rtype[type]][SS2[j+1]][SS1[i-1]]+7*extension_cost, SA[LCI(idx,j,n2)]);
      if((type2 = pair[S1[i-3]][S2[j+4]]))
        SA[LCI(idx,j,n2)]=MIN2(SA[LCI(idx_3,j+4,n2)]+P->internal_loop[5]+P->ninio[2]+
                               P->mismatch23I[type2][SS1[i-2]][SS2[j+3]]+P->mismatch23I[rtype[type]][SS2[j+1]][SS1[i-1]]+7*extension_cost, SA[LCI(idx,j,n2)]);
      /**
      *** So now we have to handle 1x3, 3x1, 3x3, and mxn m,n > 3
      **/
      /**
      *** 3x3 or more
      **/
      SA[LCI(idx,j,n2)]=MIN2(SA[LINI(idx_3,j+3,n2)]+P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+2*iext_s+2*extension_cost,SA[LCI(idx,j,n2)]);
      /**
      *** 2xn or more
      **/
      SA[LCI(idx,j,n2)]=MIN2(SA[LINI(idx_4,j+2,n2)]+P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_s+2*iext_ass+2*extension_cost, SA[LCI(idx,j,n2)]);
      /**
      *** nx2 or more
      **/
      SA[LCI(idx,j,n2)]=MIN2(SA[LINI(idx_2,j+4,n2)]+P->mismatchI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_s+2*iext_ass+2*extension_cost, SA[LCI(idx,j,n2)]);
      /**
      *** nx1 n>2
      **/
      SA[LCI(idx,j,n2)]=MIN2(SA[LINIX(idx_3,j+1,n2)]+P->mismatch1nI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_ass+iext_ass+2*extension_cost, SA[LCI(idx,j,n2)]);
      /**
      *** 1xn n>2
      **/
      SA[LCI(idx,j,n2)]=MIN2(SA[LINIY(idx_1,j+3,n2)]+P->mismatch1nI[rtype[type]][SS1[i-1]][SS2[j+1]]+iext_ass+iext_ass+2*extension_cost, SA[LCI(idx,j,n2)]);
      /**
      *** nx0 n>1
      **/
      int bAU;
      bAU=(type>2?P->TerminalAU:0);
      SA[LCI(idx,j,n2)]=MIN2(SA[LBXI(idx_2,j+1,n2)]+2*extension_cost+bext+bAU,SA[LCI(idx,j,n2)]);
      /**
      *** 0xn n>1
      **/
      SA[LCI(idx,j,n2)]=MIN2(SA[LBYI(idx_1,j+2,n2)]+2*extension_cost+bext+bAU,SA[LCI(idx,j,n2)]);
      temp=min_colonne;

      min_colonne=MIN2(SA[LCI(idx,j,n2)]+E_ExtLoop(rtype[type], SS2[j-1] , SS1[i+1] , P) + 2*extension_cost, min_colonne);
      if(temp>min_colonne){
        min_j_colonne=j;
      }
    }
    if(max>=min_colonne){
      max=min_colonne;
      max_pos=i;
      max_pos_j=min_j_colonne;
    }
    position[i+delta]=min_colonne;min_colonne=INF;
    position_j[i+delta]=min_j_colonne;
    i++;
  }
  /* printf("MAX: %d",max); */
  free(S1); free(S2); free(SS1); free(SS2);
  if(max<threshold){
    find_max(position, position_j, delta, threshold, alignment_length, s1, s2, extension_cost, fast, il_a, il_b, b_a, b_b);
  }
  if(max<INF){
    plot_max(max, max_pos, max_pos_j,alignment_length, s1, s2, extension_cost,fast, il_a, il_b, b_a, b_b);
  }
  free(SA);
  free(position);
  free(position_j);
  return NULL;
}




PRIVATE void find_max(const int *position, const int *position_j,const int delta, const int threshold, const int alignment_length, const char *s1, const char *s2, const int extension_cost, const int fast,const int il_a, const int il_b, const int b_a, const int b_b){
  int pos=n1-9;
  if(fast==1){
    while(10 < pos--){
      int temp_min=0;
      if(position[pos+delta]<(threshold)){
        int search_range;
        search_range=delta+1;
        while(--search_range){
          if(position[pos+delta-search_range]<=position[pos+delta-temp_min]){
            temp_min=search_range;
          }
        }
        pos-=temp_min;
        int max_pos_j;
        max_pos_j=position_j[pos+delta];
        int max;
        max=position[pos+delta];
        printf("target upper bound %d: query lower bound %d  (%5.2f) \n", pos-10, max_pos_j-10, ((double)max)/100);
        pos=MAX2(10,pos+temp_min-delta);
      }
    }
  }
  else if(fast==2){
    pos=n1-9;
    while(10 < pos--){
      int temp_min=0;
      if(position[pos+delta]<(threshold)){
        int search_range;
        search_range=delta+1;
        while(--search_range){
          if(position[pos+delta-search_range]<=position[pos+delta-temp_min]){
            temp_min=search_range;
          }
        }
        pos-=temp_min;
        int max_pos_j;
        max_pos_j=position_j[pos+delta];
        /* max_pos_j und pos entsprechen die realen position
           in der erweiterten sequenz.
           pos=1 -> position 1 in the sequence (and not 0 like in C)
           max_pos_j -> position 1 in the sequence ( not 0 like in C)
        */
        int alignment_length2; alignment_length2 = MIN2(n1,n2);
        int begin_t=MAX2(11, pos-alignment_length2+1);/* 10 */
        int end_t  =MIN2(n1-10, pos+1);
        int begin_q=MAX2(11, max_pos_j-1); /* 10 */
        int end_q  =MIN2(n2-10, max_pos_j+alignment_length2-1);
        char *s3 = (char*) vrna_alloc(sizeof(char)*(end_t - begin_t +2 + 20));
        char *s4 = (char*) vrna_alloc(sizeof(char)*(end_q - begin_q +2 + 20));
        strcpy(s3,"NNNNNNNNNN");strcpy(s4,"NNNNNNNNNN");
        strncat(s3, (s1+begin_t-1),  end_t - begin_t +1);
        strncat(s4, (s2+begin_q-1) , end_q - begin_q +1);
        strcat(s3,"NNNNNNNNNN");strcat(s4,"NNNNNNNNNN");
        s3[end_t -begin_t +1 +20 ]='\0';
        s4[end_q -begin_q +1 +20]='\0';
        duplexT test;
        test = fduplexfold(s3, s4, extension_cost,il_a, il_b, b_a, b_b);
        if(test.energy * 100 < threshold){
          int l1=strchr(test.structure, '&')-test.structure;
          printf("%s %3d,%-3d : %3d,%-3d (%5.2f) [%5.2f]  i:%d,j:%d <%5.2f>\n", test.structure,
                 begin_t-10+test.i-l1-10,
                 begin_t-10+test.i-1-10,
                 begin_q-10 + test.j-1-10 ,
                 (begin_q -11) + test.j + (int)strlen(test.structure)-l1-2-10,
                 test.energy,test.energy_backtrack, pos-10, max_pos_j-10, ((double) position[pos+delta])/100);
          pos=MAX2(10,pos+temp_min-delta);
        }
        free(s3);free(s4);
        free(test.structure);
      }
    }
  }
#if 0
  else if(fast==3){
    pos=n1-9;
    while(10 < pos--){
      int temp_min=0;
      if(position[pos+delta]<(threshold)){
        int search_range;
        search_range=delta+1;
        while(--search_range){
          if(position[pos+delta-search_range]<=position[pos+delta-temp_min]){
            temp_min=search_range;
          }
        }
        pos-=temp_min;
        int max_pos_j;
        max_pos_j=position_j[pos+delta];
        /* max_pos_j und pos entsprechen die realen position
           in der erweiterten sequenz.
           pos=1 -> position 1 in the sequence (and not 0 like in C)
           max_pos_j -> position 1 in the sequence ( not 0 like in C)
        */
        //Here we can start the reverse recursion for the
        //Starting from the reported pos / max_pos_j we start the recursion
        //We have to be careful with the fact that all energies are inverted.

        int alignment_length2;
        //Select the smallest interaction length in order to define the new interaction length
        alignment_length2 = MIN2(n1-pos + 1,max_pos_j - 1 + 1);
        //
        int begin_t=MAX2(11, pos-alignment_length2+1);/* 10 */
        int end_t  =MIN2(n1-10, pos+1);
        int begin_q=MAX2(11, max_pos_j-1); /* 10 */
        int end_q  =MIN2(n2-10, max_pos_j+alignment_length2-1);
        char *s3 = (char*) vrna_alloc(sizeof(char)*(end_t - begin_t +2 + 20));
        char *s4 = (char*) vrna_alloc(sizeof(char)*(end_q - begin_q +2 + 20));
        strcpy(s3,"NNNNNNNNNN");strcpy(s4,"NNNNNNNNNN");
        strncat(s3, (s1+begin_t-1),  end_t - begin_t +1);
        strncat(s4, (s2+begin_q-1) , end_q - begin_q +1);
        strcat(s3,"NNNNNNNNNN");strcat(s4,"NNNNNNNNNN");
        s3[end_t -begin_t +1 +20 ]='\0';
        s4[end_q -begin_q +1 +20]='\0';
        duplexT test;
        test = fduplexfold(s4, s3, extension_cost,il_a, il_b, b_a, b_b);
        if(test.energy * 100 < threshold){
          int structureLength=strlen(test.structure);
          int l1=strchr(test.structure, '&')-test.structure;
          int start_t,end_t,start_q,end_q;


          /*reverse structure string*/
          char *reverseStructure = (char*) vrna_alloc(sizeof(char)*(structureLength+1));
          int posStructure;
          for(posStructure=l1+1; posStructure < structureLength; posStructure++){
            if(test.structure[posStructure]==')'){
              reverseStructure[posStructure-l1-1] = '(';
            }
            else{
              reverseStructure[posStructure-l1-1] = test.structure[posStructure];
            }
          }
          reverseStructure[structureLength-1-l1]='&';
          for(posStructure=0; posStructure<l1; posStructure++){
            if(test.structure[posStructure]=='('){
              reverseStructure[structureLength+posStructure-l1] = ')';
            }
            else{
              reverseStructure[structureLength+posStructure-l1] = test.structure[posStructure];
            }
          }
          reverseStructure[structureLength]='\0';
          //          l1=strchr(reverse.structure, '&')-test.structure;


          printf("%s %3d,%-3d : %3d,%-3d (%5.2f) [%5.2f] i:%d,j:%d <%5.2f>\n", reverseStructure,
                 begin_t-10 + test.j-1-10,
                 (begin_t -11) + test.j + strlen(test.structure)-l1-2-10,
                 begin_q-10+test.i-l1-10,
                 begin_q-10+test.i-1-10,
                 test.energy,test.energy_backtrack,pos, max_pos_j, ((double) position[pos+delta])/100);
          pos=MAX2(10,pos+temp_min-delta);
        }
        free(s3);free(s4);
        free(test.structure);
      }
    }
  }
#endif
  else{
    pos=n1-9;
    while(10 < pos--){
      int temp_min=0;
      if(position[pos+delta]<(threshold)){
        int search_range;
        search_range=delta+1;
        while(--search_range){
          if(position[pos+delta-search_range]<=position[pos+delta-temp_min]){
            temp_min=search_range;
          }
        }
        pos-=temp_min;
        int max_pos_j;
        max_pos_j=position_j[pos+delta];
        /* max_pos_j und pos entsprechen die realen position
           in der erweiterten sequenz.
           pos=1 -> position 1 in the sequence (and not 0 like in C)
           max_pos_j -> position 1 in the sequence ( not 0 like in C)
        */
        int alignment_length2; alignment_length2 = MIN2(n1,n2);
        int begin_t=MAX2(11, pos-alignment_length2+1);/* 10 */
        int end_t  =MIN2(n1-10, pos+1);
        int begin_q=MAX2(11, max_pos_j-1); /* 10 */
        int end_q  =MIN2(n2-10, max_pos_j+alignment_length2-1);
        char *s3 = (char*) vrna_alloc(sizeof(char)*(end_t - begin_t +2));
        char *s4 = (char*) vrna_alloc(sizeof(char)*(end_q - begin_q +2));
        strncpy(s3, (s1+begin_t-1),  end_t - begin_t +1);
        strncpy(s4, (s2+begin_q-1) , end_q - begin_q +1);
        s3[end_t -begin_t +1 ]='\0';
        s4[end_q -begin_q +1 ]='\0';
        duplexT test;
        test = duplexfold(s3, s4, extension_cost);
        if(test.energy * 100 < threshold){
          int l1=strchr(test.structure, '&')-test.structure;
          printf("%s %3d,%-3d : %3d,%-3d (%5.2f)  i:%d,j:%d <%5.2f>\n", test.structure,
                 begin_t-10+test.i-l1,
                 begin_t-10+test.i-1,
                 begin_q-10 + test.j-1 ,
                 (begin_q -11) + test.j + (int)strlen(test.structure)-l1-2,
                 test.energy, pos-10, max_pos_j-10, ((double) position[pos+delta])/100);
          pos=MAX2(10,pos+temp_min-delta);
        }
        free(s3);free(s4);
        free(test.structure);
      }
    }
  }
}
PRIVATE void plot_max(const int max, const int max_pos, const int max_pos_j, const int alignment_length, const char *s1, const char *s2, const int extension_cost, const int fast,const int il_a, const int il_b, const int b_a, const int b_b)
{
  if(fast==1){
    printf("target upper bound %d: query lower bound %d (%5.2f)\n", max_pos-10, max_pos_j-10, ((double)max)/100);
  }
  else if(fast==2){
    int alignment_length2; alignment_length2 = MIN2(n1,n2);
    int begin_t=MAX2(11, max_pos-alignment_length2+1);/* 10 */
    int end_t  =MIN2(n1-10, max_pos+1);
    int begin_q=MAX2(11, max_pos_j-1); /* 10 */
    int end_q  =MIN2(n2-10, max_pos_j+alignment_length2-1);
    char *s3 = (char*) vrna_alloc(sizeof(char)*(end_t - begin_t +2 + 20));
    char *s4 = (char*) vrna_alloc(sizeof(char)*(end_q - begin_q +2 + 20));
    strcpy(s3,"NNNNNNNNNN");strcpy(s4,"NNNNNNNNNN");
    strncat(s3, (s1+begin_t-1),  end_t - begin_t +1);
    strncat(s4, (s2+begin_q-1) , end_q - begin_q +1);
    strcat(s3,"NNNNNNNNNN");strcat(s4,"NNNNNNNNNN");
    s3[end_t -begin_t +1 +20 ]='\0';
    s4[end_q -begin_q +1 +20]='\0';
    duplexT test;
    test = fduplexfold(s3, s4, extension_cost,il_a, il_b, b_a, b_b);
    int l1=strchr(test.structure, '&')-test.structure;
    printf("%s %3d,%-3d : %3d,%-3d (%5.2f) [%5.2f] i:%d,j:%d <%5.2f>\n", test.structure,
           begin_t-10+test.i-l1-10,
           begin_t-10+test.i-1-10,
           begin_q-10 + test.j-1-10 ,
           (begin_q -11) + test.j + (int)strlen(test.structure)-l1-2-10,
           test.energy, test.energy_backtrack,max_pos-10, max_pos_j-10,((double) max)/100);
    free(s3);free(s4);free(test.structure);
  }
  else{
    duplexT test;
    int alignment_length2; alignment_length2 = MIN2(n1,n2);
    int begin_t=MAX2(11, max_pos-alignment_length2+1);
    int end_t  =MIN2(n1-10, max_pos+1);
    int begin_q=MAX2(11, max_pos_j-1);
    int end_q  =MIN2(n2-10, max_pos_j+alignment_length2-1);
    char *s3 = (char*) vrna_alloc(sizeof(char)*(end_t - begin_t +2));
    char *s4 = (char*) vrna_alloc(sizeof(char)*(end_q - begin_q +2));
    strncpy(s3, (s1+begin_t-1),  end_t - begin_t + 1);
    strncpy(s4, (s2+begin_q-1) , end_q - begin_q +1 );
    s3[end_t -begin_t +1 ]='\0';
    s4[end_q -begin_q +1 ]='\0';
    test = duplexfold(s3, s4, extension_cost);
    int l1=strchr(test.structure, '&')-test.structure;
    printf("%s %3d,%-3d : %3d,%-3d (%5.2f) i:%d,j:%d <%5.2f>\n", test.structure,
           begin_t-10+test.i-l1,
           begin_t-10+test.i-1,
           begin_q-10 +test.j-1 ,
           (begin_q -11) + test.j + (int)strlen(test.structure)-l1-2,
           test.energy, max_pos-10, max_pos_j -10, ((double) max)/100);
    free(s3);free(s4);free(test.structure);
  }
}


PRIVATE void update_dfold_params(void)
{
  vrna_md_t md;
  if(P)
    free(P);
  set_model_details(&md);
  P = vrna_params(&md);
  make_pair_matrix();
}

PRIVATE void encode_seqs(const char *s1, const char *s2) {
  unsigned int i,l;

  l = strlen(s1);
  S1 = encode_seq(s1);
  SS1= (short *) vrna_alloc(sizeof(short)*(l+1));
  /* SS1 exists only for the special X K and I bases and energy_set!=0 */

  for (i=1; i<=l; i++) { /* make numerical encoding of sequence */
    SS1[i] = alias[S1[i]];   /* for mismatches of nostandard bases */
  }

  l = strlen(s2);
  S2 = encode_seq(s2);
  SS2= (short *) vrna_alloc(sizeof(short)*(l+1));
  /* SS2 exists only for the special X K and I bases and energy_set!=0 */

  for (i=1; i<=l; i++) { /* make numerical encoding of sequence */
    SS2[i] = alias[S2[i]];   /* for mismatches of nostandard bases */
  }
}

PRIVATE short * encode_seq(const char *sequence) {
  unsigned int i,l;
  short *S;
  l = strlen(sequence);
  S = (short *) vrna_alloc(sizeof(short)*(l+2));
  S[0] = (short) l;

  /* make numerical encoding of sequence */
  for (i=1; i<=l; i++)
    S[i]= (short) encode_char(toupper(sequence[i-1]));

  /* for circular folding add first base at position n+1 */
  S[l+1] = S[1];

  return S;
}

int arraySize(duplexT** array)
{
  int site_count=0;
  while(array[site_count]!=NULL){
    site_count++;
  }
  return site_count;
}

void freeDuplexT(duplexT** array)
{
  int size=arraySize(array);
  while(--size){
    free(array[size]->structure);
    free(array[size]);
  }
  free(array[0]->structure);
  free(array);
}
snofold.c/      0           0     0     644     36363     `
/*
                  minimum free energy
                  RNA secondary structure prediction

                  c Ivo Hofacker, Chrisoph Flamm
                  original implementation by
                  Walter Fontana

                  Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include "utils.h"
#include "structure_utils.h"
#include "energy_par.h"
#include "fold_vars.h"
#include "pair_mat.h"
#include "params.h"
#include "snofold.h"
#include "loop_energies.h"

#ifdef __GNUC__
#define INLINE inline
#else
#define INLINE
#endif

#define PAREN

#define PUBLIC
#define PRIVATE static

#define STACK_BULGE1  1   /* stacking energies for bulges of size 1 */
#define NEW_NINIO     1   /* new asymetry penalty */

/*@unused@*/
PRIVATE void  get_arrays(unsigned int size);
/* PRIVATE int   stack_energy(int i, const char *string); */
PRIVATE void  make_ptypes(const short *S, const char *structure);
PRIVATE void encode_seq(const char *sequence);
PRIVATE void  backtrack(const char *sequence, int s);
PRIVATE int   fill_arrays(const char *sequence, const int max_asymm, const int threshloop,
                          const int min_s2, const int max_s2, const int half_stem, const int max_half_stem);
/*@unused@*/


/* alifold */
PRIVATE void alisnoinitialize_fold(const int length);
PRIVATE void make_pscores(const short *const* S, const char *const* AS,int n_seq, const char *structure);
PRIVATE int   *pscore;  /* precomputed array of pair types */
PRIVATE short **Sali;
PRIVATE int alifill_arrays(const char **string, const int max_asymm, const int threshloop, 
                           const int min_s2, const int max_s2, const int half_stem, 
                           const int max_half_stem);
PRIVATE void aliget_arrays(unsigned int size);
PRIVATE short * aliencode_seq(const char *sequence);
PRIVATE int alibacktrack(const char **strings, int s);

#define UNIT 100
#define MINPSCORE -2 * UNIT
/* end alifold */

#define MAXSECTORS      500     /* dimension for a backtrack array */
#define LOCALITY        0.      /* locality parameter for base-pairs */

#define MIN2(A, B)      ((A) < (B) ? (A) : (B))
#define MAX2(A, B)      ((A) > (B) ? (A) : (B))
#define SAME_STRAND(I,J) (((I)>=cut_point)||((J)<cut_point))

PRIVATE vrna_param_t *P = NULL;

PRIVATE int *indx = NULL; /* index for moving in the triangle matrices c[] and fMl[]*/

PRIVATE int   *c = NULL;       /* energy array, given that i-j pair */
PRIVATE int   *cc = NULL;      /* linear array for calculating canonical structures */
PRIVATE int   *cc1 = NULL;     /*   "     "        */
PRIVATE int   *Fmi = NULL;     /* holds row i of fML (avoids jumps in memory) */
PRIVATE int   *DMLi = NULL;    /* DMLi[j] holds MIN(fML[i,k]+fML[k+1,j])  */
PRIVATE int   *DMLi1 = NULL;   /*             MIN(fML[i+1,k]+fML[k+1,j])  */
PRIVATE int   *DMLi2 = NULL;   /*             MIN(fML[i+2,k]+fML[k+1,j])  */
PRIVATE char  *ptype = NULL;   /* precomputed array of pair types */
PRIVATE short *S = NULL, *S1 = NULL;
PRIVATE int    init_length=-1;
PRIVATE int    *mLoop = NULL; /*contains the minimum of c for a xy range*/
PRIVATE folden **foldlist = NULL;
PRIVATE folden **foldlist_XS = NULL;

PRIVATE int     *BP = NULL; /* contains the structure constrainsts: BP[i]
                        -1: | = base must be paired
                        -2: < = base must be paired with j<i
                        -3: > = base must be paired with j>i
                        -4: x = base must not pair
                        positive int: base is paired with int      */


static sect sector[MAXSECTORS]; /* stack of partial structures for backtracking */

PRIVATE char  alpha[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
/* needed by cofold/eval */
/* PRIVATE int cut_in_loop(int i); */
/* PRIVATE int min_hairpin = TURN; */

/* some definitions to take circfold into account...        */
/* PRIVATE int   *fM2 = NULL;*/        /* fM2 = multiloop region with exactly two stems, extending to 3' end        */
PUBLIC        int   Fc, FcH, FcI, FcM; /* parts of the exterior loop energies                        */
/*--------------------------------------------------------------------------*/

void snoinitialize_fold(const int length)
{
  unsigned int n;
  if (length<1) vrna_message_error("snoinitialize_fold: argument must be greater 0");
  if (init_length>0) snofree_arrays(length);
  get_arrays((unsigned) length);
  init_length=length;
  for (n = 1; n <= (unsigned) length; n++)
    indx[n] = (n*(n-1)) >> 1;        /* n(n-1)/2 */

  snoupdate_fold_params();
}

PRIVATE void alisnoinitialize_fold(const int length)
{
  unsigned int n;
  if (length<1) vrna_message_error("snoinitialize_fold: argument must be greater 0");
  if (init_length>0) snofree_arrays(length);
  aliget_arrays((unsigned) length);
  make_pair_matrix();
  init_length=length;
  for (n = 1; n <= (unsigned) length; n++)
    indx[n] = (n*(n-1)) >> 1;        /* n(n-1)/2 */
  snoupdate_fold_params();
}  


/*--------------------------------------------------------------------------*/

PRIVATE void get_arrays(unsigned int size)
{
  indx = (int *) vrna_alloc(sizeof(int)*(size+1));
  c     = (int *) vrna_alloc(sizeof(int)*((size*(size+1))/2+2));
  mLoop = (int *) vrna_alloc(sizeof(int)*((size*(size+1))/2+2));

  ptype = (char *) vrna_alloc(sizeof(char)*((size*(size+1))/2+2));
  cc    = (int *) vrna_alloc(sizeof(int)*(size+2));
  cc1   = (int *) vrna_alloc(sizeof(int)*(size+2));
  Fmi   = (int *) vrna_alloc(sizeof(int)*(size+1));
  DMLi  = (int *) vrna_alloc(sizeof(int)*(size+1));
  DMLi1  = (int *) vrna_alloc(sizeof(int)*(size+1));
  DMLi2  = (int *) vrna_alloc(sizeof(int)*(size+1));
  if (base_pair) free(base_pair);
  base_pair = (vrna_bp_stack_t *) vrna_alloc(sizeof(vrna_bp_stack_t)*(1+size/2));
  /* extra array(s) for circfold() */
}

PRIVATE void aliget_arrays(unsigned int size)
{
  indx = (int *) vrna_alloc(sizeof(int)*(size+1));
  c     = (int *) vrna_alloc(sizeof(int)*((size*(size+1))/2+2));
  mLoop = (int *) vrna_alloc(sizeof(int)*((size*(size+1))/2+2));
  pscore = (int *) vrna_alloc(sizeof(int)*((size*(size+1))/2+2));
  ptype = (char *) vrna_alloc(sizeof(char)*((size*(size+1))/2+2));
  cc    = (int *) vrna_alloc(sizeof(int)*(size+2));
  cc1   = (int *) vrna_alloc(sizeof(int)*(size+2));
  Fmi   = (int *) vrna_alloc(sizeof(int)*(size+1));
  DMLi  = (int *) vrna_alloc(sizeof(int)*(size+1));
  DMLi1  = (int *) vrna_alloc(sizeof(int)*(size+1));
  DMLi2  = (int *) vrna_alloc(sizeof(int)*(size+1));
  if (base_pair) free(base_pair);
  base_pair = (vrna_bp_stack_t *) vrna_alloc(sizeof(vrna_bp_stack_t)*(1+size/2));
  /* extra array(s) for circfold() */
}




/*--------------------------------------------------------------------------*/


void snofree_arrays(const int length)
{
  free(indx); free(c);free(cc); free(cc1);
  free(ptype);free(mLoop);
  int i;
  for(i=length;i>-1;i--){
    while(foldlist[i]!=NULL){
      folden *n = foldlist[i];
      foldlist[i] = foldlist[i]->next;
      free(n);
    }
    free(foldlist[i]);
  }
  free(foldlist);
  for(i=length;i>-1;i--){
    while(foldlist_XS[i]!=NULL){
      folden *n = foldlist_XS[i];
      foldlist_XS[i] = foldlist_XS[i]->next;
      free(n);
    }
    free(foldlist_XS[i]);
  }
  free(foldlist_XS);
  free(base_pair); base_pair=NULL; free(Fmi);
  free(DMLi); free(DMLi1);free(DMLi2);
  free(BP);
  init_length=0;
}

void alisnofree_arrays(const int length)
{
  free(indx); free(c);free(cc); free(cc1);
  free(ptype);free(mLoop);free(pscore);
  int i;
  for(i=length-1;i>-1;i--){
    while(foldlist[i]!=NULL){
      folden *n = foldlist[i];
      foldlist[i] = foldlist[i]->next;
      free(n);
    }
    free(foldlist[i]);
  }
  free(foldlist);
  free(base_pair); base_pair=NULL; free(Fmi);
  free(DMLi); free(DMLi1);free(DMLi2);
  free(BP);
  init_length=0;
}

/*--------------------------------------------------------------------------*/

void snoexport_fold_arrays(int **indx_p, int **mLoop_p, int **cLoop,  folden ***fold_p, folden ***fold_p_XS) {
  /* make the DP arrays available to routines such as subopt() */
  *indx_p = indx; *mLoop_p = mLoop;
  *cLoop = c; *fold_p = foldlist;*fold_p_XS=foldlist_XS;
}

/* void alisnoexport_fold_arrays(int **indx_p, int **mLoop_p, int **cLoop, folden ***fold_p, int **pscores) { */
/*   /\* make the DP arrays available to routines such as subopt() *\/ */
/*   *indx_p = indx; *mLoop_p = mLoop; */
/*   *cLoop = c; *fold_p = foldlist; */
/*   *pscores=pscore; */
/* } */

/*--------------------------------------------------------------------------*/










int snofold(const char *string, char *structure, const int max_assym, const int threshloop, 
              const int min_s2, const int max_s2, const int half_stem, const int max_half_stem) {
  int length, energy, bonus, bonus_cnt, s;
  
  /* Variable initialization */
  bonus = 0;
  bonus_cnt = 0;
  s     = 0;
  length = (int) strlen(string);
  
  S   = encode_sequence(string, 0);
  S1  = encode_sequence(string, 1);

  
  /* structure = (char *) vrna_alloc((unsigned) length+1); */
  
  if (length>init_length) snoinitialize_fold(length);
  else if (fabs(P->temperature - temperature)>1e-6) snoupdate_fold_params();

  

  /* encode_seq(string); */
  BP  = (int *)vrna_alloc(sizeof(int)*(length+2));
  make_ptypes(S, structure);
  energy=fill_arrays(string, max_assym, threshloop, min_s2, max_s2, half_stem, max_half_stem);
  backtrack(string, s);

  free(structure);
  free(S); free(S1); /* free(BP); */
  return energy;
}

PRIVATE void make_pscores(const short *const* S, const char *const* AS,
                          int n_seq, const char *structure) {
  /* calculate co-variance bonus for each pair depending on  */
  /* compensatory/consistent mutations and incompatible seqs */
  /* should be 0 for conserved pairs, >0 for good pairs      */
#define NONE -10000 /* score for forbidden pairs */
  int n,i,j,k,l,s,score;
  int dm[7][7]={{0,0,0,0,0,0,0}, /* hamming distance between pairs */
                       {0,0,2,2,1,2,2} /* CG */,
                {0,2,0,1,2,2,2} /* GC */,
                {0,2,1,0,2,1,2} /* GU */,
                {0,1,2,2,0,2,1} /* UG */,
                {0,2,2,1,2,0,2} /* AU */,
                {0,2,2,2,1,2,0} /* UA */};
  n=Sali[0][0];  /* length of seqs */
  for (i=1; i<n; i++) {
    for (j=i+1; (j<i+TURN+1) && (j<=n); j++)
      pscore[indx[j]+i] = NONE;
    for (j=i+TURN+1; j<=n; j++) {
      int pfreq[8]={0,0,0,0,0,0,0,0};
      for (s=0; s<n_seq; s++) {
        int type;
        if (Sali[s][i]==0 && Sali[s][j]==0) type = 7; /* gap-gap  */
        else {
          if ((AS[s][i] == '~')||(AS[s][j] == '~')) type = 7;
          else type = pair[Sali[s][i]][Sali[s][j]];
        }

        pfreq[type]++;
      }
      if (pfreq[0]*2>n_seq) { pscore[indx[j]+i] = NONE; continue;}
      for (k=1,score=0; k<=6; k++) /* ignore pairtype 7 (gap-gap) */
        for (l=k+1; l<=6; l++)
          /* scores for replacements between pairtypes    */
          /* consistent or compensatory mutations score 1 or 2  */
          score += pfreq[k]*pfreq[l]*dm[k][l];
      /* counter examples score -1, gap-gap scores -0.25   */
      pscore[indx[j]+i] = cv_fact *
        ((UNIT*score)/n_seq - nc_fact*UNIT*(pfreq[0] + pfreq[7]*0.25));
    }
  }

  if (noLonelyPairs) /* remove unwanted pairs */
    for (k=1; k<n-TURN-1; k++)
      for (l=1; l<=2; l++) {
        int type,ntype=0,otype=0;
        i=k; j = i+TURN+l;
        type = pscore[indx[j]+i];
        while ((i>=1)&&(j<=n)) {
          if ((i>1)&&(j<n)) ntype = pscore[indx[j+1]+i-1];
          if ((otype<-4*UNIT)&&(ntype<-4*UNIT))  /* worse than 2 counterex */
            pscore[indx[j]+i] = NONE; /* i.j can only form isolated pairs */
          otype =  type;
          type  = ntype;
          i--; j++;
        }
      }


  if (fold_constrained&&(structure!=NULL)) {
    int psij, hx, hx2, *stack, *stack2;
    stack = (int *) vrna_alloc(sizeof(int)*(n+1));
    stack2 = (int *) vrna_alloc(sizeof(int)*(n+1));

    for(hx=hx2=0, j=1; j<=n; j++) {
      switch (structure[j-1]) {
      case 'x': /* can't pair */
        for (l=1; l<j-TURN; l++) pscore[indx[j]+l] = NONE;
        for (l=j+TURN+1; l<=n; l++) pscore[indx[l]+j] = NONE;
        break;
      case '(':
        stack[hx++]=j;
        /* fallthrough */
      case '[':
        stack2[hx2++]=j;
        /* fallthrough */
      case '<': /* pairs upstream */
        for (l=1; l<j-TURN; l++) pscore[indx[j]+l] = NONE;
        break;
      case ']':
        if (hx2<=0) {
          fprintf(stderr, "%s\n", structure);
          vrna_message_error("unbalanced brackets in constraints");
        }
        i = stack2[--hx2];
        pscore[indx[j]+i]=NONE;
        break;
      case ')':
        if (hx<=0) {
          fprintf(stderr, "%s\n", structure);
          vrna_message_error("unbalanced brackets in constraints");
        }
        i = stack[--hx];
        psij = pscore[indx[j]+i]; /* store for later */
        for (k=j; k<=n; k++)
          for (l=i; l<=j; l++)
            pscore[indx[k]+l] = NONE;
        for (l=i; l<=j; l++)
          for (k=1; k<=i; k++)
            pscore[indx[l]+k] = NONE;
        for (k=i+1; k<j; k++)
          pscore[indx[k]+i] = pscore[indx[j]+k] = NONE;
        pscore[indx[j]+i] = (psij>0) ? psij : 0;
        /* fallthrough */
      case '>': /* pairs downstream */
        for (l=j+TURN+1; l<=n; l++) pscore[indx[l]+j] = NONE;
        break;
      }
    }
    if (hx!=0) {
      fprintf(stderr, "%s\n", structure);
      vrna_message_error("unbalanced brackets in constraint string");
    }
    free(stack); free(stack2);
  }
}

float alisnofold(const char **strings, const int max_assym, const int threshloop, 
              const int min_s2, const int max_s2, const int half_stem, const int max_half_stem) {
  int s,n_seq, length, energy;
  char * structure;
  length = (int) strlen(strings[0]);
  /* structure = (char *) vrna_alloc((unsigned) length+1); */
  structure = NULL;
  if (length>init_length) alisnoinitialize_fold(length);
  if (fabs(P->temperature - temperature)>1e-6) snoupdate_fold_params();
  for (s=0; strings[s]!=NULL; s++);
  n_seq = s;
  Sali = (short **) vrna_alloc(n_seq*sizeof(short *));
  for (s=0; s<n_seq; s++) {
    if (strlen(strings[s]) != length) vrna_message_error("uneqal seqence lengths");
    Sali[s] = aliencode_seq(strings[s]);
  }
  make_pscores((const short **) Sali, (const char *const *) strings, n_seq, structure);
  energy=alifill_arrays(strings, max_assym, threshloop, min_s2, max_s2, half_stem, max_half_stem);
  alibacktrack((const char **)strings, 0);
  for (s=0; s<n_seq; s++) free(Sali[s]);
  free(Sali);
  /* free(structure); */
  /*  free(S)*/; free(S1); /* free(BP); */
  return (float) energy/100.;
}

PRIVATE int alifill_arrays(const char **strings, const int max_asymm, const int threshloop, 
                           const int min_s2, const int max_s2, const int half_stem, 
                           const int max_half_stem) {

  int   i, j, length, energy;
  /* int   decomp, new_fML; */
  int   *type, type_2;
  int   bonus,n_seq,s;

  
  for (n_seq=0; strings[n_seq]!=NULL; n_seq++);
  type = (int *) vrna_alloc(n_seq*sizeof(int));
  length = strlen(strings[0]);
  bonus=0;
  /*   max_separation = (int) ((1.-LOCALITY)*(double)(length-2));*/ /* not in use */
  
    /* for (i=(j>TURN?(j-TURN):1); i<j; i++) { */
    /* } */
    for (i = (length)-TURN-1; i >= 1; i--) { /* i,j in [1..length] */
      for (j = i+TURN+1; j <= length; j++) {
        int p, q, ij,psc;
        ij = indx[j]+i;
        for (s=0; s<n_seq; s++) {
          type[s] = pair[Sali[s][i]][Sali[s][j]];
          if (type[s]==0) type[s]=7;
        }
        psc = pscore[indx[j]+i];
        if (psc>=MINPSCORE) {   /* we have a pair */
        int new_c=0, stackEnergy=INF; /* seems that new_c immer den minimum von cij enthaelt */
        /* hairpin ----------------------------------------------*/
        
        for (new_c=s=0; s<n_seq; s++)
          new_c += E_Hairpin(j-i-1,type[s],Sali[s][i+1],Sali[s][j-1],strings[s]+i-1,P);
        /*--------------------------------------------------------      
          check for elementary structures involving more than one
          closing pair (interior loop).
          --------------------------------------------------------*/      
        
        for (p = i+1; p <= MIN2(j-2-TURN,i+MAXLOOP+1) ; p++) {
          int minq = j-i+p-MAXLOOP-2;
          if (minq<p+1+TURN) minq = p+1+TURN;
          for (q = minq; q < j; q++) {
            if (pscore[indx[q]+p]<MINPSCORE) continue;
            if(abs((p-i) - (j-q)) > max_asymm) continue;
            for (energy = s=0; s<n_seq; s++) {
              type_2 = pair[Sali[s][q]][Sali[s][p]]; /* q,p not p,q! */
              if (type_2 == 0) type_2 = 7;
              energy += E_IntLoop(p-i-1, j-q-1, type[s], type_2,
                                  Sali[s][i+1], Sali[s][j-1],
                                  Sali[s][p-1], Sali[s][q+1],P);
            }
            new_c = MIN2(energy+c[indx[q]+p], new_c);
            if ((p==i+1)&&(j==q+1)) stackEnergy = energy; /* remember stack energy */
            
          } /* end q-loop */
        } /* end p-loop */
        
        /* coaxial stacking of (i.j) with (i+1.k) or (k+1.j-1) */
        
        new_c = MIN2(new_c, cc1[j-1]+stackEnergy);
        cc[j] = new_c - psc; /* add covariance bonnus/penalty */
        c[ij]=cc[j];
        } /* end >> if (pair) << */
        else c[ij] = INF;
        /* done with c[i,j], now compute fML[i,j] */
        /* free ends ? -----------------------------------------*/
        
      }

    {
      int *FF; /* rotate the auxilliary arrays */
      FF = DMLi2; DMLi2 = DMLi1; DMLi1 = DMLi; DMLi = FF;
      FF = cc1; cc1=cc; cc=FF;
      for (j=1; j<=length; j++) {cc[j]=Fmi[j]=DMLi[j]=INF; }
    }
  }
  foldlist = (folden**) vrna_alloc((length)*sizeof(folden*));

  for(i=0; i< length; i++){
    foldlist[i]=(folden*) vrna_alloc(sizeof(folden));
    foldlist[i]->next=NULL;
    foldlist[i]->k=INF+1;
    foldlist[i]->energy=INF;

  }
  folden* head; /* we save the stem loop information in a list like structure */

  for (i = length-TURN-1; i >= 1; i--) { /* i,j in [1..length] */
    int max_k, min_k;
    max_k = MIN2(length-min_s2,i+max_half_stem+1);
    min_k = MAX2(i+half_stem+1, length-max_s2);
    for (j = i+TURN+1; j <= length; j++) {
      int ij,a,b;
      ij = indx[j]+i;
      for(a=0; a< MISMATCH ;a++){
        for(b=0; b< MISMATCH ; b++){
          mLoop[ij]=MIN2(mLoop[ij],  c[indx[j-a]+i+b]);

        }
      }
      if(mLoop[ij]>=n_seq*threshloop){
        mLoop[ij]=INF;        
      }
      else{
        if(j>=min_k-1 && j < max_k){ /* comment if out to recover the known behaviour */
          head = (folden*) vrna_alloc(sizeof(folden));
          head->k=j;
          head->energy=mLoop[ij];
          head->next=foldlist[i];
          foldlist[i] = head;

        }
      }
    }
    
  }
  free(type);
  return mLoop[indx[length]+1];/* mLoop;  */
}

PRIVATE int alibacktrack(const char **strings, int s) {

  /*------------------------------------------------------------------
    trace back through the "c", "f5" and "fML" arrays to get the
    base pairing list. No search for equivalent structures is done.
    This is fast, since only few structure elements are recalculated.
    ------------------------------------------------------------------*/

  /* normally s=0.
     If s>0 then s items have been already pushed onto the sector stack */
  int   i, j, length, energy;/* , new; */
  int   type_2;
  int   bonus,n_seq,*type;  int   b=0,cov_en = 0;

  length = strlen(strings[0]);
  for (n_seq=0; strings[n_seq]!=NULL; n_seq++);
  type = (int *) vrna_alloc(n_seq*sizeof(int));
  if (s==0) {
    sector[++s].i = 1;
    sector[s].j = length;
    sector[s].ml = 2 ; 
  }
  while (s>0) {
    int ml, ss, cij, traced, i1, j1, p, q;
    int canonical = 1;     /* (i,j) closes a canonical structure */
    i  = sector[s].i;
    j  = sector[s].j;
    ml = sector[s--].ml;   /* ml is a flag indicating if backtracking is to
                              occur in the fML- (1) or in the f-array (0) */
    if (ml==2) {
      base_pair[++b].i = i;
      base_pair[b].j   = j;
      goto repeat1;
    }

    if (j < i+TURN+1) continue; /* no more pairs in this interval */


  repeat1:

    /*----- begin of "repeat:" -----*/
    if (canonical)  cij = c[indx[j]+i];
    for (ss=0; ss<n_seq; ss++) {
      type[ss] = pair[Sali[ss][i]][Sali[ss][j]];
      if (type[ss]==0) type[ss] = 7;
    }
    bonus = 0;
    
    if (noLonelyPairs)
      if (cij == c[indx[j]+i]) {
        /* (i.j) closes canonical structures, thus
           (i+1.j-1) must be a pair                */
        for (ss=0; ss<n_seq; ss++) {
          type_2 = pair[Sali[ss][j-1]][Sali[ss][i+1]];  /* j,i not i,j */
          if (type_2==0) type_2 = 7;
          cij -= P->stack[type[ss]][type_2];
        }
        cij += pscore[indx[j]+i];
        base_pair[++b].i = i+1;
        base_pair[b].j   = j-1;
        cov_en += pscore[indx[j-1]+i+1];
        i++; j--;
        canonical=0;
        goto repeat1;
      }
    canonical = 1;
    cij += pscore[indx[j]+i];
    {int cc=0;
      for (ss=0; ss<n_seq; ss++)
        cc += E_Hairpin(j-i-1, type[ss], Sali[ss][i+1], Sali[ss][j-1], strings[ss]+i-1,P);
      if (cij == cc) /* found hairpin */
        continue;
    }
    for (p = i+1; p <= MIN2(j-2-TURN,i+MAXLOOP+1); p++) {
      int minq;
      minq = j-i+p-MAXLOOP-2;
      if (minq<p+1+TURN) minq = p+1+TURN;
      for (q = j-1; q >= minq; q--) {
        for (ss=energy=0; ss<n_seq; ss++) {
          type_2 = pair[Sali[ss][q]][Sali[ss][p]];  /* q,p not p,q */
          if (type_2==0) type_2 = 7;
          energy += E_IntLoop(p-i-1, j-q-1, type[ss], type_2,
                               Sali[ss][i+1], Sali[ss][j-1],
                              Sali[ss][p-1], Sali[ss][q+1],P);
        }
        traced = (cij == energy+c[indx[q]+p]);
        if (traced) {
          base_pair[++b].i = p;
          base_pair[b].j   = q;
          cov_en += pscore[indx[q]+p];
          i = p, j = q;
          goto repeat1;
        }
      }
    }

    /* end of repeat: --------------------------------------------------*/

    /* (i.j) must close a multi-loop */
    /* tt = rtype[type]; */
/*     mm = bonus+P->MLclosing+P->MLintern[tt]; */
/*     d5 = P->dangle5[tt][S1[j-1]]; */
/*     d3 = P->dangle3[tt][S1[i+1]]; */
    i1 = i+1; j1 = j-1;
    sector[s+1].ml  = sector[s+2].ml = 1;
    
/*      if (k<=j-3-TURN) { /\\* found the decomposition *\\/ *\/ */
/*       sector[++s].i = i1; */
/*       sector[s].j   = k; */
/*       sector[++s].i = k+1; */
/*       sector[s].j   = j1; */
/*     } /\* else { *\/ */
/*       vrna_message_error("backtracking failed in repeat"); */
/*     } */
    
  }
  base_pair[0].i = b;    /* save the total number of base pairs */
  free(type);
  return cov_en;
}

PRIVATE int fill_arrays(const char *string, const int max_asymm, const int threshloop, 
                        const int min_s2, const int max_s2, const int half_stem, const int max_half_stem) {

  int   i, j,  length, energy;
  /*   int   decomp;*/ /*, new_fML; */
  int   no_close, type, type_2;
  int   bonus;
  int min_c;
  
  min_c=INF;
  length = (int) strlen(string);
  bonus=0;
  /*   max_separation = (int) ((1.-LOCALITY)*(double)(length-2)); */ /* not in use */


  

  for (i = length-TURN-1; i >= 1; i--) { /* i,j in [1..length] */
    /* printf("i=%d\t",i);  */
    for (j = i+TURN+1; j <= length; j++) {
/*         printf("j=%d,",j); */
      int p, q, ij;
      ij = indx[j]+i;
      type = ptype[ij];
      bonus = 0;
      energy = INF;

      if ((BP[i]==j)||(BP[i]==-1)||(BP[i]==-2)) bonus -= BONUS;
      if ((BP[j]==-1)||(BP[j]==-3)) bonus -= BONUS;
      if ((BP[i]==-4)||(BP[j]==-4)) type=0;

      no_close = (((type==3)||(type==4))&&no_closingGU);

      /* if (j-i-1 > max_separation) type = 0; */ /* forces locality degree */

      if (type) {   /* we have a pair */
        int new_c=0, stackEnergy=INF; /* seems that new_c immer den minimum von cij enthaelt */
        /* hairpin ----------------------------------------------*/

        if (no_close) new_c = FORBIDDEN;
        else
          new_c = E_Hairpin(j-i-1, type, S1[i+1], S1[j-1], string+i-1,P); /* computes hair pin structure for subsequence i...j */

        /*--------------------------------------------------------      
          check for elementary structures involving more than one
          closing pair (interior loop).
          --------------------------------------------------------*/      

        for (p = i+1; p <= MIN2(j-2-TURN,i+MAXLOOP+1) ; p++) {
          int minq = j-i+p-MAXLOOP-2;
          if (minq<p+1+TURN) minq = p+1+TURN;
          for (q = minq; q < j; q++) {
            
            if(abs((p-i) - (j-q)) > max_asymm) continue;
            type_2 = ptype[indx[q]+p];

            if (type_2==0) continue;
            type_2 = rtype[type_2];

            if (no_closingGU)
              if (no_close||(type_2==3)||(type_2==4))
                if ((p>i+1)||(q<j-1)) continue;  /* continue unless stack */

            energy = E_IntLoop(p-i-1, j-q-1, type, type_2,
                               S1[i+1], S1[j-1], S1[p-1], S1[q+1],P);
            new_c = MIN2(energy+c[indx[q]+p], new_c);
            if ((p==i+1)&&(j==q+1)) stackEnergy = energy; /* remember stack energy */

          } /* end q-loop */
        } /* end p-loop */




        /* coaxial stacking of (i.j) with (i+1.k) or (k+1.j-1) */


        new_c = MIN2(new_c, cc1[j-1]+stackEnergy);
        cc[j] = new_c;
        c[ij] = new_c;
        /*         min_c=MIN2(min_c, c[ij]); */

      } /* end >> if (pair) << */

      else c[ij] = INF;


      /* done with c[i,j], now compute fML[i,j] */
      /* free ends ? -----------------------------------------*/

    }

    {
      int *FF; /* rotate the auxilliary arrays */
      FF = DMLi2; DMLi2 = DMLi1; DMLi1 = DMLi; DMLi = FF;
      FF = cc1; cc1=cc; cc=FF;
      for (j=1; j<=length; j++) {cc[j]=Fmi[j]=DMLi[j]=INF; }
    }
  }
  foldlist = (folden**) vrna_alloc((length+1)*sizeof(folden*));
  foldlist_XS = (folden**) vrna_alloc((length+1)*sizeof(folden*));
  /* linked list initialization*/
  for(i=0; i<=length; i++){
    foldlist[i]=(folden*) vrna_alloc(sizeof(folden));
    foldlist[i]->next=NULL;
    foldlist[i]->k=INF+1;
    foldlist[i]->energy=INF;
    foldlist_XS[i]=(folden*) vrna_alloc(sizeof(folden));
    foldlist_XS[i]->next=NULL;
    foldlist_XS[i]->k=INF+1;
    foldlist_XS[i]->energy=INF;
  }
  folden* head; /* we save the stem loop information in a list like structure */
  folden* head_XS;
  for (i = length-TURN-1; i >= 1; i--) { /* i,j in [1..length] */
    int max_k, min_k;
    max_k = MIN2(length-min_s2,i+max_half_stem+1);
    min_k = MAX2(i+half_stem+1, length-max_s2);


    for (j = i+TURN+1; j <= length; j++) {
        int ij,a,b;
              ij = indx[j]+i;
            for(a=0; a< MISMATCH ;a++){
          for(b=0; b< MISMATCH ; b++){
              mLoop[ij]=MIN2(mLoop[ij],  c[indx[j-a]+i+b]);
            /* #mLoop[ij]=MIN2(mLoop[ij], c[indx[j-2]+i]); */
            /* #mLoop[ij]=MIN2(mLoop[ij], c[indx[j]+i+1]); */
            /* #mLoop[ij]=MIN2(mLoop[ij], c[indx[j-1]+i+1]); */
            /* #mLoop[ij]=MIN2(mLoop[ij], c[indx[j-2]+i+1]); */
            /* #mLoop[ij]=MIN2(mLoop[ij], c[indx[j]+i+2]); */
            /* #mLoop[ij]=MIN2(mLoop[ij], c[indx[j-1]+i+2]); */
            /* #mLoop[ij]=MIN2(mLoop[ij], c[indx[j-2]+i+2]); */
          }
        }
        min_c = MIN2(mLoop[ij] ,min_c);
        
        if(mLoop[ij]>=threshloop){
          mLoop[ij]=INF;        
        }
        else{
          if(j>=min_k-1 && j <= max_k){ /* comment if out to recover the known behaviour */
            head = (folden*) vrna_alloc(sizeof(folden));
            head->k=j;
            head->energy=mLoop[ij];
            head->next=foldlist[i];
            foldlist[i] = head;
            head_XS = (folden*) vrna_alloc(sizeof(folden));
            head_XS->k=i;
            head_XS->energy=mLoop[ij];
            head_XS->next=foldlist_XS[j];
            foldlist_XS[j] = head_XS;            
          }
        }
    }
    
  }
/*   int count=0; */
/*    for(i=0; i< length; i++){  */
/*      folden *temp;  */
/*      temp = foldlist[i];  */
/*      while(temp->next){  */
/*        count++; */
/*        printf("count %d: i%d j%d energy %d \n", count, i, temp->k, temp->energy);  */
/*        temp=temp->next;  */
/*      }      */
/*    }  */
/*    printf("Count %d \n", count); */
/*    count=0; */
/*    for(i=length-1; i>=0; i--){  */
/*      folden *temp;  */
/*      temp = foldlist_XS[i];  */
/*      while(temp->next){  */
/*        count++; */
/*        printf("count %d: i%d j%d energy %d \n", count, temp->k,i, temp->energy);  */
/*        temp=temp->next;  */
/*      }      */
/*    }  */
/*    printf("Count %d \n", count); */
/*    return mLoop[indx[length]+1]; */ /* mLoop; */
   return min_c;
  /* printf("\nmin_array = %d\n", min_c); */
  /* return f5[length]; */
}




PRIVATE void backtrack(const char *string, int s) {

  /*------------------------------------------------------------------
    trace back through the "c", "f5" and "fML" arrays to get the
    base pairing list. No search for equivalent structures is done.
    This is fast, since only few structure elements are recalculated.
    ------------------------------------------------------------------*/

  /* normally s=0.
     If s>0 then s items have been already pushed onto the sector stack */
  int   i, j, /*k,*/ length, energy, newX;
  int   no_close, type, type_2;/* , tt; */
  int   bonus;
  int   b=0;

  length = strlen(string);
  if (s==0) {
    sector[++s].i = 1;
    sector[s].j = length;
    sector[s].ml = 2 ; 
  }
  while (s>0) {
    int ml, cij, traced, i1, j1, /*d3, d5, mm,*/ p, q;
    int canonical = 1;     /* (i,j) closes a canonical structure */
    i  = sector[s].i;
    j  = sector[s].j;
    ml = sector[s--].ml;   /* ml is a flag indicating if backtracking is to
                              occur in the fML- (1) or in the f-array (0) */
    if (ml==2) {
      base_pair[++b].i = i;
      base_pair[b].j   = j;
      goto repeat1;
    }

    if (j < i+TURN+1) continue; /* no more pairs in this interval */


  repeat1:

    /*----- begin of "repeat:" -----*/
    if (canonical)  cij = c[indx[j]+i];
    type = ptype[indx[j]+i];
    bonus = 0;
    if (fold_constrained) {
      if ((BP[i]==j)||(BP[i]==-1)||(BP[i]==-2)) bonus -= BONUS;
      if ((BP[j]==-1)||(BP[j]==-3)) bonus -= BONUS;
    }
    if (noLonelyPairs)
      if (cij == c[indx[j]+i]) {
        /* (i.j) closes canonical structures, thus
           (i+1.j-1) must be a pair                */
        type_2 = ptype[indx[j-1]+i+1]; type_2 = rtype[type_2];
        cij -= P->stack[type][type_2] + bonus;
        base_pair[++b].i = i+1;
        base_pair[b].j   = j-1;
        i++; j--;
        canonical=0;
        goto repeat1;
      }
    canonical = 1;
    no_close = (((type==3)||(type==4))&&no_closingGU&&(bonus==0));
    if (no_close) {
      if (cij == FORBIDDEN) continue;
    } else
      if (cij == E_Hairpin(j-i-1, type, S1[i+1], S1[j-1],string+i-1,P)+bonus)
        continue;
    for (p = i+1; p <= MIN2(j-2-TURN,i+MAXLOOP+1); p++) {
      int minq;
      minq = j-i+p-MAXLOOP-2;
      if (minq<p+1+TURN) minq = p+1+TURN;
      for (q = j-1; q >= minq; q--) {
        type_2 = ptype[indx[q]+p];
        if (type_2==0) continue;
        type_2 = rtype[type_2];
        if (no_closingGU)
          if (no_close||(type_2==3)||(type_2==4))
            if ((p>i+1)||(q<j-1)) continue;  /* continue unless stack */
        energy = E_IntLoop(p-i-1, j-q-1, type, type_2,
                           S1[i+1], S1[j-1], S1[p-1], S1[q+1],P);
        newX = energy+c[indx[q]+p]+bonus;
        traced = (cij == newX);
        if (traced) {
          base_pair[++b].i = p;
          base_pair[b].j   = q;
          i = p, j = q;
          goto repeat1;
        }
      }
    }

    /* end of repeat: --------------------------------------------------*/

    /* (i.j) must close a multi-loop */
/*     tt = rtype[type]; */
/*     mm = bonus+P->MLclosing+P->MLintern[tt]; */
/*     d5 = P->dangle5[tt][S1[j-1]]; */
/*     d3 = P->dangle3[tt][S1[i+1]]; */
    i1 = i+1; j1 = j-1;
    sector[s+1].ml  = sector[s+2].ml = 1;

/*      if (k<=j-3-TURN) { */ /* found the decomposition */
/*       sector[++s].i = i1; */
/*       sector[s].j   = k; */
/*       sector[++s].i = k+1; */
/*       sector[s].j   = j1; */
/*     } else { */
/*         vrna_message_error("backtracking failed in repeat"); */
/*     } */
/*  */
  }

  base_pair[0].i = b;    /* save the total number of base pairs */
}

char *snobacktrack_fold_from_pair(const char *sequence, int i, int j) {
  char *structure;
  sector[1].i  = i;
  sector[1].j  = j;
  sector[1].ml = 2;
  base_pair[0].i=0;
  encode_seq(sequence);
  backtrack(sequence, 1);
  structure = vrna_db_from_bp_stack(base_pair, strlen(sequence));
  free(S);free(S1);
  return structure;
}

char *alisnobacktrack_fold_from_pair(const char **strings, int i, int j, int *cov) {
  char *structure;
  int n_seq, s, length;
  length = (int) strlen(strings[0]);
  for (s=0; strings[s]!=NULL; s++);
  n_seq = s;
  sector[1].i  = i;
  sector[1].j  = j;
  sector[1].ml = 2;
  base_pair[0].i=0;
  /* encode_seq(sequence); */
  Sali = (short **) vrna_alloc(n_seq*sizeof(short *));
  for (s=0; s<n_seq; s++) {
    if (strlen(strings[s]) != length) vrna_message_error("uneqal seqence lengths");
    Sali[s] = aliencode_seq(strings[s]);
  }
  *cov=alibacktrack(strings, 1);
  structure = vrna_db_from_bp_stack(base_pair, length);
  free(S);free(S1);
  for (s=0; s<n_seq; s++) {
    free(Sali[s]);
  }
  free(Sali);
  return structure;
}



/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/


/*--------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/


PRIVATE void encode_seq(const char *sequence) {
  unsigned int i,l;

  l = strlen(sequence);
  S = (short *) vrna_alloc(sizeof(short)*(l+2));
  S1= (short *) vrna_alloc(sizeof(short)*(l+2));
  /* S1 exists only for the special X K and I bases and energy_set!=0 */
  S[0] = (short) l;

  for (i=1; i<=l; i++) { /* make numerical encoding of sequence */
    S[i]= (short) encode_char(toupper(sequence[i-1]));
    S1[i] = alias[S[i]];   /* for mismatches of nostandard bases */
  }
  /* for circular folding add first base at position n+1 and last base at
        position 0 in S1        */
  S[l+1] = S[1]; S1[l+1]=S1[1]; S1[0] = S1[l];
}

PRIVATE short * aliencode_seq(const char *sequence) {
  unsigned int i,l;
  short *Stemp;
  l = strlen(sequence);
  Stemp = (short *) vrna_alloc(sizeof(short)*(l+2));
  Stemp[0] = (short) l;

  /* make numerical encoding of sequence */
  for (i=1; i<=l; i++)
    Stemp[i]= (short) encode_char(toupper(sequence[i-1]));

  /* for circular folding add first base at position n+1 */
  /* Stemp[l+1] = Stemp[1]; */

  return Stemp;
}

/*---------------------------------------------------------------------------*/

PUBLIC void snoupdate_fold_params(void)
{
  vrna_md_t md;
  if(P)
    free(P);
  set_model_details(&md);
  P = vrna_params(&md);
  make_pair_matrix();
  if (init_length < 0) init_length=0;
}

/*---------------------------------------------------------------------------*/

PRIVATE void make_ptypes(const short *S, const char *structure) {
  int n,i,j,k,l;

  n=S[0];
  for (k=1; k<n-TURN; k++)
    for (l=1; l<=2; l++) {
      int type,ntype=0,otype=0;
      i=k; j = i+TURN+l; if (j>n) continue;
      type = pair[S[i]][S[j]];
      while ((i>=1)&&(j<=n)) {
        if ((i>1)&&(j<n)) ntype = pair[S[i-1]][S[j+1]];
        if (noLonelyPairs && (!otype) && (!ntype))
          type = 0; /* i.j can only form isolated pairs */
        ptype[indx[j]+i] = (char) type;
        otype =  type;
        type  = ntype;
        i--; j++;
      }
    }

  if (fold_constrained&&(structure!=NULL)) {
    constrain_ptypes(structure, (unsigned int)n, ptype, BP, TURN, 0);
  }
}

snoop.c/        0           0     0     644     98664     `
/*                
           compute the duplex structure of two RNA strands,
                allowing only inter-strand base pairs.
         see cofold() for computing hybrid structures without
                             restriction.

                             Ivo Hofacker
                          Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include "utils.h"
#include "energy_par.h"
#include "fold_vars.h"
#include "snofold.h"
#include "pair_mat.h"
#include "params.h"
#include "snoop.h"
#include "PS_dot.h"
/* #include "fold.h" */
#include "duplex.h"
#include "loop_energies.h"


#define STACK_BULGE1  1   /* stacking energies for bulges of size 1 */
#define NEW_NINIO     1   /* new asymetry penalty */



PRIVATE void  encode_seqs(const char *s1, const char *s2);
PRIVATE short *encode_seq(const char *seq);

PRIVATE void find_max_snoop(const char *s1, const char *s2, const int max, 
                            const int alignment_length, const int* position, 
                            const int delta, const int distance,  const int penalty, 
                            const int threshloop, const int threshLE, const int threshRE, 
                            const int threshDE, const int threshTE, const int threshSE, const int threshD,
                            const int half_stem, const int max_half_stem,  const int min_s2, 
                            const int max_s2, const int min_s1, const int  max_s1, const int min_d1, const int min_d2, const char* name, const int fullStemEnergy);

PRIVATE void find_max_snoop_XS(const char *s1, const char *s2, const int **access_s1, const int max, 
                               const int alignment_length, const int* position, const int *position_j,
                               const int delta, const int distance,  const int penalty, 
                               const int threshloop, const int threshLE, const int threshRE, 
                               const int threshDE, const int threshTE, const int threshSE, const int threshD,
                               const int half_stem, const int max_half_stem,  const int min_s2, 
                               const int max_s2, const int min_s1, const int  max_s1, const int min_d1, const int min_d2, const char *name, const int fullStemEnergy);





PRIVATE char * alisnoop_backtrack(int i, int j, const char ** s2, 
                                  int* Duplex_El, int* Duplex_Er, int* Loop_E, int *Loop_D, int *u, 
                                  int *pscd, int *psct, int *pscg,
                                  const int penalty, const int threshloop, 
                                  const int threshLE, const int threshRE, const int threshDE, const int threshD,
                                  const int half_stem, const int max_half_stem, 
                                  const int min_s2, const int max_s2, const int min_s1, 
                                  const int max_s1, const int min_d1, const int min_d2,
                                  const short **S1, const short **S2);

   
PRIVATE char * snoop_backtrack(int i, int j, const char* s2, int* Duplex_El, int* Duplex_Er, int* Loop_E, int *Loop_D, int *u, 
                               const int penalty, const int threshloop, const int threshLE, const int threshRE, const int threshDE, 
                               const int threshD,
                               const int half_stem, const int max_half_stem, 
                               const int min_s2, const int max_s2, const int min_s1, const int max_s1, const int min_d1, const int min_d2);

PRIVATE char * snoop_backtrack_XS(int i, int j, const char* s2, int* Duplex_El, int* Duplex_Er, int* Loop_E, int *Loop_D, int *u, 
                               const int penalty, const int threshloop, const int threshLE, const int threshRE, const int threshDE, 
                               const int threshD,
                               const int half_stem, const int max_half_stem, 
                               const int min_s2, const int max_s2, const int min_s1, const int max_s1, const int min_d1, const int min_d2);




PRIVATE int compare(const void *sub1, const void *sub2);
PRIVATE int covscore(const int *types, int n_seq);
PRIVATE short * aliencode_seq(const char *sequence);

PUBLIC  int snoop_subopt_sorted=0; /* from subopt.c, default 0 */


/*@unused@*/




#define MAXLOOP_L        3
#define MIN2(A, B)      ((A) < (B) ? (A) : (B))
#define MAX2(A, B)      ((A) > (B) ? (A) : (B))
#define ASS                1
PRIVATE vrna_param_t *P = NULL;

PRIVATE int   **c = NULL;      /* energy array, given that i-j pair */
PRIVATE int   **r = NULL;
PRIVATE int   **lc = NULL;      /* energy array, given that i-j pair */
PRIVATE int   **lr = NULL;
PRIVATE int   **c_fill = NULL;
PRIVATE int   **r_fill = NULL;
PRIVATE int   **lpair = NULL;


PRIVATE short  *S1 = NULL, *SS1 = NULL, *S2 = NULL, *SS2 = NULL;
PRIVATE short *S1_fill = NULL, *SS1_fill = NULL, *S2_fill = NULL, *SS2_fill = NULL;
PRIVATE int   n1,n2;    /* sequence lengths */

extern int cut_point;

PRIVATE int delay_free=0;
/*--------------------------------------------------------------------------*/

snoopT alisnoopfold(const char **s1, const char **s2, 
                    const int penalty, const int threshloop, 
                    const int threshLE, const int threshRE, const int threshDE, const int threshD,
                    const int half_stem, const int max_half_stem, 
                    const int min_s2, const int max_s2, const int min_s1, 
                    const int max_s1, const int min_d1, const int min_d2) {
  
  int s,n_seq;
  int i, j, E, l1,Emin=INF, i_min=0, j_min=0;
  char *struc;
  snoopT mfe;
  int *indx;
  int *mLoop;
  int *cLoop;
  folden  **foldlist; folden **foldlist_XS;
  int Duplex_El, Duplex_Er,pscd,psct,pscg;
  int Loop_D;
  int u;
  int Loop_E;
  short **Sali1,**Sali2;
  int *type,*type2,*type3;
  vrna_md_t md;
  Duplex_El=0;Duplex_Er=0;Loop_E=0; Loop_D=0;pscd=0;psct=0;pscg=0;
  snoexport_fold_arrays(&indx, &mLoop, &cLoop,&foldlist, &foldlist_XS); 
  n1 = (int) strlen(s1[0]);
  n2 = (int) strlen(s2[0]);
  
  for (s=0; s1[s]!=NULL; s++);
  n_seq = s;
  for (s=0; s2[s]!=NULL; s++);
  if (n_seq != s) vrna_message_error("unequal number of sequences in aliduplexfold()\n");
  
  set_model_details(&md);
  if ((!P) || (fabs(P->temperature - temperature)>1e-6)) {
    snoupdate_fold_params();
    if(P)
      free(P);
    P = vrna_params(&md);
    make_pair_matrix();
  }
  
  c = (int **) vrna_alloc(sizeof(int *) * (n1+1));
  r = (int **) vrna_alloc(sizeof(int *) * (n1+1));
  for (i=0; i<=n1; i++) {
          c[i] = (int *) vrna_alloc(sizeof(int) * (n2+1));
        r[i] = (int *) vrna_alloc(sizeof(int) * (n2+1));
        for(j=n2; j>-1; j--){
                c[i][j]=INF;
                r[i][j]=INF;
        }
  }
  Sali1 = (short **) vrna_alloc((n_seq+1)*sizeof(short *));
  Sali2 = (short **) vrna_alloc((n_seq+1)*sizeof(short *));
  for (s=0; s<n_seq; s++) {
    if ((int)strlen(s1[s]) != n1) vrna_message_error("uneqal seqence lengths");
    if ((int)strlen(s2[s]) != n2) vrna_message_error("uneqal seqence lengths");
    Sali1[s] = aliencode_seq(s1[s]);
    Sali2[s] = aliencode_seq(s2[s]);
  }
  type = (int *) vrna_alloc(n_seq*sizeof(int));
  type2 = (int *) vrna_alloc(n_seq*sizeof(int));
  type3 = (int *) vrna_alloc(n_seq*sizeof(int));
  /*   encode_seqs(s1, s2); */
  for (i=6; i<=n1-5; i++) {
    int U; U=0;
    for (s=0; s<n_seq; s++) {
      U+=Sali1[s][i-2];
    }
    U = (U==(n_seq)*4?1:0);
    for (j=n2-min_d2; j>min_d1; j--) {
      int type4, k,l,psc,psc2,psc3;
      for (s=0; s<n_seq; s++) {
        type[s] = pair[Sali1[s][i]][Sali2[s][j]];
      }
      psc = covscore(type, n_seq);
      for (s=0; s<n_seq; s++) if (type[s]==0) type[s]=7;
      c[i][j] = (psc>=MINPSCORE) ? (n_seq*P->DuplexInit) : INF;
      if (psc<MINPSCORE) continue;
      if(/*  pair[Sali1[i+1]][Sali2[j-1]] &&  */
         U && j < max_s1 && j > min_s1 &&  
         j > n2 - max_s2 - max_half_stem && 
         j < n2 -min_s2 -half_stem ) { /*constraint on s2 and i*/
        folden *temp;
        temp=foldlist[j+1];
        while(temp->next){
          int k = temp->k;
          for (s=0; s<n_seq; s++) {
            type2[s]= pair[Sali1[s][i-3]][Sali2[s][k+1]];
            type3[s]= pair[Sali1[s][i-4]][Sali2[s][k+1]];
          }
          psc2 = covscore(type2, n_seq);
          psc3 = covscore(type3, n_seq);
          if(psc2 > MINPSCORE){
            r[i][j]=MIN2(r[i][j],c[i-3][k+1]+temp->energy);
          }
          if(psc3 > MINPSCORE){
            r[i][j]=MIN2(r[i][j],c[i-4][k+1]+temp->energy);
          }
          temp=temp->next;
        }
      }
      /* dangle 5'SIDE relative to the mRNA  */
      for (s=0; s<n_seq; s++) {
        c[i][j] += E_ExtLoop(type[s], Sali1[s][i-1],Sali2[s][j+1],P);
      }
      for (k=i-1; k>0 && (i-k)<MAXLOOP_L; k--) {
        for (l=j+1; l<=n2 ; l++) {
          if (i-k+l-j>2*MAXLOOP_L-2) break;
          if (abs(i-k-l+j) >= ASS ) continue;
          for (E=s=0; s<n_seq; s++) { 
            type4 = pair[Sali1[s][k]][Sali2[s][l]];
            if (type4==0) type4=7;
            E += E_IntLoop(i-k-1, l-j-1, type4, rtype[type[s]],
                           Sali1[s][k+1], Sali2[s][l-1], Sali1[s][i-1], Sali2[s][j+1],P);
          }
          c[i][j] = MIN2(c[i][j], c[k][l] + E);
          r[i][j] = MIN2(r[i][j], r[k][l] + E);
        }
      }
      c[i][j]-=psc;
      r[i][j]-=psc;
      E = r[i][j]; 
      for (s=0; s<n_seq; s++) {
        E+= E_ExtLoop(rtype[type[s]], Sali2[s][j-1], Sali1[s][i+1], P);
        /**
        *** if (i<n1) E += P->dangle3[rtype[type[s]]][Sali1[s][i+1]];
        *** if (j>1)  E += P->dangle5[rtype[type[s]]][Sali2[s][j-1]];
        *** if (type[s]>2) E += P->TerminalAU;
        **/
      }
      if (E<Emin) {
        Emin=E; i_min=i; j_min=j;
      } 
    }
  }
  if(Emin > 0){
          printf("no target found under the constraints chosen\n");
        for (i=0; i<=n1; i++) {free(r[i]);free(c[i]);}
        free(c);
        free(r);
        for(s=0; s<n_seq;s++){
          free(Sali1[s]);
          free(Sali2[s]);
        }
        free(Sali1); free(Sali2);
        free(S2); free(SS1); free(SS2);free(type);free(type2);free(type3);
        mfe.energy=INF;
        mfe.structure=NULL;
        return mfe;
  }
  struc = alisnoop_backtrack(i_min, j_min,(const char**) s2, 
                             &Duplex_El, &Duplex_Er, &Loop_E, 
                             &Loop_D, &u, &pscd, &psct, &pscg,
                             penalty, threshloop, threshLE, 
                             threshRE,threshDE, threshD,
                             half_stem, max_half_stem, min_s2, 
                             max_s2, min_s1, max_s1, min_d1, 
                             min_d2,(const short**) Sali1,(const short**) Sali2);
  /* if (i_min<n1-5) i_min++; */
  /* if (j_min>6 ) j_min--; */
  l1 = strchr(struc, '&')-struc;
  mfe.i = i_min-5;
  mfe.j = j_min-5;
  mfe.u = u -5;
  mfe.Duplex_Er = (float) Duplex_Er/100;
  mfe.Duplex_El = (float) Duplex_El/100;
  mfe.Loop_D = (float) Loop_D/100;
  mfe.Loop_E = (float) Loop_E/100;
  mfe.energy = (float) Emin/100 ;
  /* mfe.fullStemEnergy = (float) fullStemEnergy/100; */
  mfe.pscd = pscd;
  mfe.psct = psct;
  mfe.structure = struc;
  for(s=0; s<n_seq;s++){
    free(Sali1[s]);free(Sali2[s]);
  }
  free(Sali1);free(Sali2);free(type);free(type2);free(type3);

  if (!delay_free) {
    for (i=0; i<=n1; i++) {free(r[i]);free(c[i]);}
    free(c);
    free(r);
    free(S2); free(SS1); free(SS2);
  }
  return mfe;
}

PUBLIC snoopT *alisnoop_subopt(const char **s1, const char **s2, int delta, int w, 
                              const int penalty, const int threshloop, 
                               const int threshLE, const int threshRE, const int threshDE, const int threshTE, const int threshSE, const int threshD,
                              const int distance, const int half_stem, const int max_half_stem,
                               const int min_s2, const int max_s2, const int min_s1, const int max_s1, const int min_d1, const int min_d2) {


  short **Sali1, **Sali2;
  /* printf("%d %d\n", min_s2, max_s2); */
  int i,j,s,n_seq, n1, n2, E, n_subopt=0, n_max;
  char *struc;
  snoopT mfe;
  snoopT *subopt;
  int thresh;
  int *type;
  int Duplex_El, Duplex_Er, Loop_E,pscd,psct,pscg;
  int Loop_D;
  Duplex_El=0; Duplex_Er=0; Loop_E=0;Loop_D=0;pscd=0;psct=0;pscg=0;
  int u;
  u=0;
  n_max=16;
  subopt = (snoopT *) vrna_alloc(n_max*sizeof(snoopT));
  delay_free=1;
  mfe = alisnoopfold(s1, s2, penalty, threshloop, threshLE, threshRE, threshDE,threshD,
                  half_stem, max_half_stem,
                     min_s2, max_s2, min_s1, max_s1, min_d1, min_d2);
  if(mfe.energy > 0){
          free(subopt);
        delay_free=0;
        return NULL;
  }
  thresh = MIN2((int) ((mfe.Duplex_Er + mfe.Duplex_El + mfe.Loop_E)*100+0.1 + 410) + delta, threshTE );
 /* subopt[n_subopt++]=mfe; */
  free(mfe.structure);
  n1 = (int)strlen(s1[0]);
  n2 = (int)strlen(s2[0]);
  for (s=0; s1[s]!=NULL; s++);
  n_seq = s;
  Sali1 = (short **) vrna_alloc((n_seq+1)*sizeof(short *));
  Sali2 = (short **) vrna_alloc((n_seq+1)*sizeof(short *));
  for (s=0; s<n_seq; s++) {
    if ((int)strlen(s1[s]) != n1) vrna_message_error("uneqal seqence lengths");
    if ((int)strlen(s2[s]) != n2) vrna_message_error("uneqal seqence lengths");
    Sali1[s] = aliencode_seq(s1[s]);
    Sali2[s] = aliencode_seq(s2[s]);
  }
  Sali1[n_seq]=NULL;  Sali2[n_seq]=NULL;
  type = (int *) vrna_alloc(n_seq*sizeof(int));
  for (i=n1; i>1; i--){
    for (j=1; j<=n2; j++) {
      int  ii,jj, Ed,psc,skip;
      for (s=0; s<n_seq; s++) {
        type[s] = pair[Sali2[s][j]][Sali1[s][i]];
      }
      psc = covscore(type, n_seq);
      for (s=0; s<n_seq; s++) if (type[s]==0) type[s]=7;
      if (psc<MINPSCORE) continue;
      E = Ed = r[i][j];
      for  (s=0; s<n_seq; s++) {
        /*         if (i<n1-5) Ed += P->dangle3[type[s]][Sali1[s][i+1]]; */
        /*       if (j>6)  Ed += P->dangle5[type[s]][Sali2[s][j-1]]; */
        if (type[s]>2) Ed += P->TerminalAU;
      }
      if (Ed>thresh) continue;
      /* too keep output small, remove hits that are dominated by a
         better one close (w) by. For simplicity we do test without
         adding dangles, which is slightly inaccurate. 
      */ 
      w=1;
      for (skip=0, ii=MAX2(i-w,1); (ii<=MIN2(i+w,n1)) && type; ii++) { 
        for (jj=MAX2(j-w,1); jj<=MIN2(j+w,n2); jj++)
          if (r[ii][jj]<E) {skip=1; break;}
      }
      if (skip){continue;}
      psct=0;
      pscg=0;
      struc = alisnoop_backtrack(i,j,s2, &Duplex_El, 
                                 &Duplex_Er, &Loop_E, &Loop_D, &u, &pscd, &psct,&pscg, 
                                 penalty, threshloop,threshLE,threshRE,threshDE, threshD,
                                 half_stem, max_half_stem, min_s2, max_s2, min_s1, max_s1, min_d1, min_d2,(const short int**) Sali1,(const int short **) Sali2);
              
      if (Duplex_Er > threshRE || Duplex_El > threshLE || Loop_D > threshD ||
         (Duplex_Er + Duplex_El) > threshDE || 
         (Duplex_Er + Duplex_El + Loop_E) > threshTE ||
         (Duplex_Er + Duplex_El + Loop_E + Loop_D + 410) > threshSE) {
                 /* printf(" Duplex_Er %d threshRE %d Duplex_El %d threshLE %d \n" */
                /*        " Duplex_Er + Duplex_El %d  threshDE %d \n" */
                /*        " Duplex_Er + Duplex_El + Loop_E %d  threshTE %d \n" */
                /*        " Duplex_Er + Duplex_El + Loop_E + Loop_D %d  threshSE %d \n",  */
                /*          Duplex_Er , threshRE , Duplex_El ,threshLE, */
                /*          Duplex_Er + Duplex_El, threshDE, */
                /*          Duplex_Er + Duplex_El+  Loop_E , threshTE, */
                /*          Duplex_Er + Duplex_El+  Loop_E + Loop_D, threshSE);  */
                 Duplex_Er=0; 
                Duplex_El=0;
                Loop_E = 0;
                Loop_D = 0;
                u=0,
                free(struc);
                continue;
        }

      if (n_subopt+1>=n_max) {
        n_max *= 2;
        subopt = (snoopT *) vrna_realloc(subopt, n_max*sizeof(snoopT));
      }
      
      subopt[n_subopt].i = i-5;
      subopt[n_subopt].j = j-5;
      subopt[n_subopt].u = u-5;
      subopt[n_subopt].Duplex_Er = Duplex_Er * 0.01;
      subopt[n_subopt].Duplex_El = Duplex_El * 0.01;
      subopt[n_subopt].Loop_E = Loop_E * 0.01;
      subopt[n_subopt].Loop_D = Loop_D * 0.01;
      subopt[n_subopt].energy = (Duplex_Er +Duplex_El + Loop_E + Loop_D + 410) * 0.01 ;
      subopt[n_subopt].pscd = pscd * 0.01;
      subopt[n_subopt].psct = -psct * 0.01;
      subopt[n_subopt++].structure = struc;
      
      /* i=u; */
      Duplex_Er=0; Duplex_El=0; Loop_E=0; Loop_D=0;u=0;pscd=0;psct=0;
    }
  }
  
  for (i=0; i<=n1; i++) {free(c[i]);free(r[i]);}
  free(c);free(r);
  for (s=0; s<n_seq; s++) {
    free(Sali1[s]); free(Sali2[s]);
  }
  free(Sali1); free(Sali2); free(type);
  
  if (snoop_subopt_sorted) 
    qsort(subopt, n_subopt, sizeof(snoopT), compare);
  subopt[n_subopt].i =0;
  subopt[n_subopt].j =0;
  subopt[n_subopt].structure = NULL;
  return subopt;
}







PRIVATE char *alisnoop_backtrack(int i, int j, const char ** snoseq, int *Duplex_El, 
                                 int *Duplex_Er, int *Loop_E, int *Loop_D, int *u, 
                                 int *pscd, int *psct, int *pscg,
                                 const int penalty, const int threshloop, const int threshLE, 
                                 const int threshRE, const int threshDE, const int threshD, const int half_stem, 
                                 const int max_half_stem, 
                                 const int min_s2, const int max_s2, const int min_s1, 
                                 const int max_s1, 
                                 const int min_d1, const int min_d2,const short **Sali1, const short **Sali2) {
  /* backtrack structure going backwards from i, and forwards from j 
     return structure in bracket notation with & as separator */
  int k, l, *type,*type2,*type3,type4, E, traced, i0, j0,s,n_seq,psc;
  int traced_r=0; /* flag for following backtrack in c or r */
  char *st1, *st2, *struc;
  char *struc_loop;
  n1 = (int) Sali1[0][0];
  n2 = (int) Sali2[0][0];
  
  for (s=0; Sali1[s]!=NULL; s++);
  n_seq = s;
  for (s=0; Sali2[s]!=NULL; s++);
  if (n_seq != s) vrna_message_error("unequal number of sequences in alibacktrack()\n");
  
  st1 = (char *) vrna_alloc(sizeof(char)*(n1+1));
  st2 = (char *) vrna_alloc(sizeof(char)*(n2+1));
  type = (int *) vrna_alloc(n_seq*sizeof(int));
  type2 = (int *) vrna_alloc(n_seq*sizeof(int));
  type3 = (int *) vrna_alloc(n_seq*sizeof(int));
  int *indx;
  int *mLoop;
  int *cLoop;
  folden **foldlist, **foldlist_XS;
  snoexport_fold_arrays(&indx, &mLoop, &cLoop,&foldlist, &foldlist_XS ); 
  i0=i; j0=j; /* MIN2(i+1,n1); j0=MAX2(j-1,1);!modified */
  for (s=0; s<n_seq; s++) {
    type[s] = pair[Sali1[s][i]][Sali2[s][j]];
    if(type[s]==0) type[s] = 7;
    *Duplex_Er += E_ExtLoop(rtype[type[s]], (j>1) ? Sali2[s][j-1] : -1, (i<n1) ? Sali1[s][i+1] : -1, P);
    /**
    *** if (i<n1)   *Duplex_Er += P->dangle3[rtype[type[s]]][Sali1[s][i+1]];
    *** if (j>1)    *Duplex_Er += P->dangle5[rtype[type[s]]][Sali2[s][j-1]];
    *** if (type[s]>2) *Duplex_Er += P->TerminalAU;
    **/
  }
  while (i>0 && j<=n2-min_d2 ) {
    if(!traced_r) {
      E = r[i][j]; traced=0;
      st1[i-1] = '<';
      st2[j-1] = '>'; 
      for (s=0; s<n_seq; s++) {
        type[s] = pair[Sali1[s][i]][Sali2[s][j]];
      }
      psc = covscore(type,n_seq);
      for (s=0; s<n_seq; s++) if (type[s]==0) type[s] = 7;
      E += psc;
      *pscd +=psc;
      for (k=i-1; k>0 && (i-k)<MAXLOOP_L; k--) {
        for (l=j+1; l<=n2 ; l++) {
          int LE;
          if (i-k+l-j>2*MAXLOOP_L-2) break;
          if (abs(i-k-l+j) >= ASS) continue;
          for (s=LE=0; s<n_seq; s++) {
            type4 = pair[Sali1[s][k]][Sali2[s][l]];
            if (type4==0) type4=7;
            LE += E_IntLoop(i-k-1, l-j-1, type4, rtype[type[s]], Sali1[s][k+1], Sali2[s][l-1], Sali1[s][i-1], Sali2[s][j+1],P);
          }
          if (E == r[k][l]+LE) {
            traced=1; 
            i=k; j=l;
            *Duplex_Er+=LE;
            break;
          }
        }
        if (traced) break;
      }
      if(!traced){
        int U=0;
        for (s=0; s<n_seq; s++) {
          U+=Sali1[s][i-2];
        }
        U = (U==(n_seq)*4?1:0);
        if(/*  pair[Sali1[i+1]][Sali2[j-1]] && */   /* only U's are allowed */
            U && j < max_s1 && j > min_s1 && 
            j > n2 - max_s2 - max_half_stem && 
            j < n2 -min_s2 -half_stem ) {
          int min_k, max_k;
          max_k = MIN2(n2-min_s2,j+max_half_stem+1);
          min_k = MAX2(j+half_stem+1, n2-max_s2);
          folden * temp;
          temp=foldlist[j+1];
          while(temp->next) {
            int psc2, psc3;
            int k = temp->k;
            for (s=0; s<n_seq; s++) {
              type2[s]= pair[Sali1[s][i-3]][Sali2[s][k+1]];
              type3[s]= pair[Sali1[s][i-4]][Sali2[s][k+1]];
            }
            psc2 = covscore(type2, n_seq);
            psc3 = covscore(type3, n_seq);
            if(psc2>MINPSCORE /*&& pair[Sali1[i-4]][Sali2[k+2]]*/    ){  /* introduce structure from RNAfold */
              if(E==c[i-3][k+1]+temp->energy){
                *Loop_E=temp->energy;
                st1[i-3]= '|';
                *u=i-2;
                int a,b;
                /* int fix_ij=indx[k-1+1]+j+1; */
                for(a=0; a< MISMATCH ;a++){
                  for(b=0; b< MISMATCH ; b++){
                    int ij=indx[k-1-a+1]+j+1+b;
                    if(cLoop[ij]==temp->energy) {
                      /* int bla; */
                      struc_loop=alisnobacktrack_fold_from_pair(snoseq, j+1+b, k-a-1+1,psct);
                    a=INF; b=INF;        
                    }
                  }
                }
                traced=1;
                traced_r=1;
                i=i-3;j=k+1;
                break;
              }
            }
             if (psc3>MINPSCORE  /*&& pair[Sali1[i-5]][Sali2[k+2]]*/){  /* introduce structure from RNAfold */
              if(E==c[i-4][k+1]+temp->energy){
                *Loop_E=temp->energy;
                st1[i-3]= '|';
                *u=i-2;
                int a,b;
                /* int fix_ij=indx[k-1+1]+j+1; */
                for(a=0; a< MISMATCH ;a++){
                  for(b=0; b< MISMATCH ; b++){
                    int ij=indx[k-1-a+1]+j+1+b;
                    if(cLoop[ij]==temp->energy) {
                      /* int bla; */
                      struc_loop=alisnobacktrack_fold_from_pair(snoseq, j+1+b, k-a-1+1,psct);
                      a=INF; b=INF;        
                    }
                  }
                }
                traced=1;
                traced_r=1;
                i=i-4;j=k+1;
                break;
              }
            } /* else if */
            temp=temp->next;
          } /* while temp-> next */
        } /* test on j  */
      }/* traced? */
    }/* traced_r? */
    else{
      E = c[i][j]; traced=0;
      st1[i-1] = '<';
      st2[j-1] = '>'; 
      for (s=0; s<n_seq; s++) {
        type[s] = pair[Sali1[s][i]][Sali2[s][j]];
      }
      psc = covscore(type,n_seq);
      for (s=0; s<n_seq; s++) if (type[s]==0) type[s] = 7;
      E += psc;
      *pscd+=psc;
      if (!type) vrna_message_error("backtrack failed in fold duplex c");
      for (k=i-1; (i-k)<MAXLOOP_L; k--) {
        for (l=j+1; l<=n2; l++) {
          int LE;
          if (i-k+l-j>2*MAXLOOP_L-2) break;
          if (abs(i-k-l+j) >= ASS) continue;
          for (s=LE=0; s<n_seq; s++) {
            type4 = pair[Sali1[s][k]][Sali2[s][l]];
            if (type4==0) type4=7;
            LE += E_IntLoop(i-k-1, l-j-1, type4, rtype[type[s]], Sali1[s][k+1], Sali2[s][l-1], Sali1[s][i-1], Sali2[s][j+1],P);
          }
          if (E == c[k][l]+LE) {
            traced=1; 
            i=k; j=l;
            *Duplex_El+=LE;
            break;
          }
        }
        if (traced) break;
      }
    }
    if (!traced) { 
      for (s=0; s<n_seq; s++) {
        int correction;
        correction = E_ExtLoop(type[s], (i>1) ? Sali1[s][i-1] : -1, (j<n2) ? Sali2[s][j+1] : -1, P);
        *Duplex_El += correction;
        E          -= correction;
        /**
        *** if (i>1)    {E -= P->dangle5[type[s]][Sali1[s][i-1]]; *Duplex_El +=P->dangle5[type[s]][Sali1[s][i-1]];}
        *** if (j<n2)   {E -= P->dangle3[type[s]][Sali2[s][j+1]]; *Duplex_El +=P->dangle3[type[s]][Sali2[s][j+1]];}
        *** if (type[s]>2) {E -= P->TerminalAU;                      *Duplex_El +=P->TerminalAU;}
        **/
      }
      if (E != n_seq * P->DuplexInit) {
        vrna_message_error("backtrack failed in fold duplex end");
      } else break;
    }
  }
/*   if (i>1)  i--;  */
/*   if (j<n2) j++;  */
  /* struc = (char *) vrna_alloc(i0-i+1+j-j0+1+2); */ /* declare final duplex structure */
  struc = (char *) vrna_alloc(i0-i+1+n2-1+1+2); /* declare final duplex structure */
  char * struc2;
  struc2 = (char *) vrna_alloc(n2+1);
  /* char * struct_const; */
  for (k=MAX2(i,1); k<=i0; k++) if (!st1[k-1]) st1[k-1] = '.';
  /* for (k=j0; k<=j; k++) if (!st2[k-1]) st2[k-1] = struc_loop[k-1];*/ /* '.'; normal */
  /*  char * struct_const; */
  /*  struct_const = (char *) vrna_alloc(sizeof(char)*(n2+1));   */
  for (k=1; k<=n2; k++) {
    if (!st2[k-1]) st2[k-1] = struc_loop[k-1];/* '.'; */
    struc2[k-1] = st2[k-1];/* '.'; */
    /*      if (k>=j0 && k<=j){ */
    /*              struct_const[k-1]='x'; */
    /*      } */
    /*      else{ */
    /*              if(k<j0) {struct_const[k-1]='<';} */
    /*              if(k>j) {struct_const[k-1]='>';} */
    /*      } */
  }

  /*   char duplexseq_1[j0+1]; */
  /* char duplexseq_2[n2-j+3]; */
  if(j<n2){
    char **duplexseq_1, **duplexseq_2;
    duplexseq_1 = (char**) vrna_alloc((n_seq+1) * sizeof(char*));
    duplexseq_2 = (char**) vrna_alloc((n_seq+1) * sizeof(char*));
    for(s=0; s<n_seq; s++){
      duplexseq_1[s] = (char*) vrna_alloc((j0)*sizeof(char)); /* modfied j0+1 */
      duplexseq_2[s] = (char*) vrna_alloc((n2-j+2)*sizeof(char)); /* modified j+3 */
      strncpy(duplexseq_1[s], snoseq[s], j0-1); /* modified j0 */
      strcpy(duplexseq_2[s], snoseq[s] + j); /* modified j-1 */
      duplexseq_1[s][j0-1]='\0'; /* modified j0 */
      duplexseq_2[s][n2-j+1]='\0';/* modified j+2 */
    }
    duplexseq_1[n_seq]=NULL;
    duplexseq_2[n_seq]=NULL;
    duplexT temp;
    temp=aliduplexfold((const char**)duplexseq_1, (const char**)duplexseq_2);
    *Loop_D =  MIN2(0,-410 + (int) 100 * temp.energy*n_seq);
    if(*Loop_D){
      int l1,ibegin, iend, jbegin, jend;
      l1=strchr(temp.structure, '&')-temp.structure;
      ibegin=temp.i-l1;
      iend  =temp.i-1;
      jbegin=temp.j;
      jend  =temp.j+(int)strlen(temp.structure)-l1-2-1;
      for(k=ibegin+1; k<=iend+1; k++){
        struc2[k-1]=temp.structure[k-ibegin-1];
      }
      for(k=jbegin+j; k<=jend+j; k++){
        struc2[k-1]=temp.structure[l1+k-j-jbegin+1];
      }
    }
    for(s=0; s<n_seq; s++){
      free(duplexseq_1[s]);
      free(duplexseq_2[s]);
    }
    free(duplexseq_1);free(duplexseq_2);
    free(temp.structure);
  }
  strcpy(struc, st1+MAX2(i-1,0)); strcat(struc, "&"); 
  /* strcat(struc, st2); */
  strncat(struc, struc2+5, (int)strlen(struc2)-10);
  free(struc2);
  free(struc_loop);
  free(st1); free(st2);
  free(type);free(type2);free(type3);
  /* free_arrays(); */
  return struc;
}







void Lsnoop_subopt(const char *s1, const char *s2, int delta, int w, 
                   const int penalty, const int threshloop, 
                   const int threshLE, const int threshRE, const int threshDE, const int threshTE,const int threshSE,const int threshD,
                   const int distance,
                   const int half_stem, const int max_half_stem,
                   const int min_s2, const int max_s2, const int min_s1, const int max_s1, const int min_d1, const int min_d2, const int alignment_length, const char* name, const int fullStemEnergy)
{

 int min_colonne=INF;
 int max_pos;
 int max;max=INF;
 /* int temp; */
 /* int nsubopt=10; */
 n1 = (int) strlen(s1);
 n2 = (int) strlen(s2);
 int *position;
 position = (int*) vrna_alloc((n1+3)*sizeof(int));


  /* int Eminj, Emin_l; */
  int i, j; /* l1, Emin=INF, i_min=0, j_min=0; */
  /* char *struc; */
  /* snoopT mfe; */
  int *indx;
  int *mLoop;
  int *cLoop;
  folden **foldlist, **foldlist_XS;
  int Duplex_El, Duplex_Er;
  int Loop_D;
  /* int u; */
  int Loop_E;
  vrna_md_t md;

  Duplex_El=0;Duplex_Er=0;Loop_E=0, Loop_D=0;
  snoexport_fold_arrays(&indx, &mLoop, &cLoop, &foldlist, &foldlist_XS); 
  set_model_details(&md);
  if ((!P) || (fabs(P->temperature - temperature)>1e-6)) {
    snoupdate_fold_params();
    if(P)
      free(P);
    P = vrna_params(&md);
    make_pair_matrix();
  }
  
  lc = (int **) vrna_alloc(sizeof(int *) * (5));
  lr = (int **) vrna_alloc(sizeof(int *) * (5));
  for (i=0; i<5; i++) {
          lc[i] = (int *) vrna_alloc(sizeof(int) * (n2+1));
        lr[i] = (int *) vrna_alloc(sizeof(int) * (n2+1));
        for(j=n2; j>-1; j--){
                lc[i][j]=INF;
                lr[i][j]=INF;
        }
  }
  encode_seqs(s1, s2);
  for (i=1; i<=n1; i++) {
      int idx=i%5;
      int idx_1=(i-1)%5;
      int idx_2=(i-2)%5;
      int idx_3=(i-3)%5;
      int idx_4=(i-4)%5;
    for (j=n2-min_d2; j>min_d1; j--) {
      int type, type2, k;
      type = pair[S1[i]][S2[j]];
      lc[idx][j] = (type) ? P->DuplexInit + 2*penalty : INF;
      lr[idx][j] = INF;
      if(!type) continue;
      if( /*pair[S1[i+1]][S2[j-1]]   &&  check that we have a solid base stack after the mLoop */
          j < max_s1 && j > min_s1 &&  
          j > n2 - max_s2 - max_half_stem && 
          j < n2 -min_s2 -half_stem && S1[i-2]==4) { /*constraint on s2 and i*/
        int min_k, max_k;
        max_k = MIN2(n2-min_s2,j+max_half_stem+1);
        min_k = MAX2(j+half_stem+1, n2-max_s2);
        for(k=min_k; k <= max_k ; k++){         
          if(mLoop[indx[k-1]+j+1] < 0){
                }
          if(pair[S1[i-3]][S2[k]] /*genau zwei ungepaarte nucleotiden --NU--*/
             && mLoop[indx[k-1]+j+1] < threshloop){  
            lr[idx][j]=MIN2(lr[idx][j], lc[idx_3][k]+mLoop[indx[k-1]+j+1]);
          }
          else if(pair[S1[i-4]][S2[k]] &&  mLoop[indx[k-1]+j+1] < threshloop){/*--NUN--*/
            lr[idx][j]=MIN2(lr[idx][j], lc[idx_4][k]+mLoop[indx[k-1]+j+1]);
          }
              }
      }
      /* dangle 5'SIDE relative to the mRNA  */
      lc[idx][j] += E_ExtLoop(type, (i>1) ? SS1[i-1] : -1, (j<n2) ? SS2[j+1] : -1, P);
      /**
      *** if (i>1)    lc[idx][j] += P->dangle5[type][SS1[i-1]];
      *** if (j<n2)   lc[idx][j] += P->dangle3[type][SS2[j+1]];
      *** if (type>2) lc[idx][j] += P->TerminalAU;
      **/
      
      if(j<n2 && i>1){
        type2=pair[S1[i-1]][S2[j+1]];
              if(type2>0){
          lc[idx][j]=MIN2(lc[idx_1][j+1]+E_IntLoop(0,0,type2, rtype[type],SS1[i], SS2[j], SS1[i-1], SS2[j+1], P)+2*penalty, lc[idx][j]);
          lr[idx][j]=MIN2(lr[idx_1][j+1]+E_IntLoop(0,0,type2, rtype[type],SS1[i], SS2[j], SS1[i-1], SS2[j+1], P)+2*penalty, lr[idx][j]);
              }
      }
      if(j<n2-1 && i>2){
        type2=pair[S1[i-2]][S2[j+2]];
        if(type2>0 ){
          lc[idx][j]=MIN2(lc[idx_2][j+2]+E_IntLoop(1,1,type2, rtype[type],SS1[i-1], SS2[j+1], SS1[i-1], SS2[j+1], P)+4*penalty, lc[idx][j]);
          lr[idx][j]=MIN2(lr[idx_2][j+2]+E_IntLoop(1,1,type2, rtype[type],SS1[i-1], SS2[j+1], SS1[i-1], SS2[j+1], P)+4*penalty, lr[idx][j]);
        }
      }
      if(j<n2-2 && i>3){
        type2 = pair[S1[i-3]][S2[j+3]];
        if(type2>0){
          lc[idx][j]=MIN2(lc[idx_3][j+3]+E_IntLoop(2,2,type2, rtype[type],SS1[i-2], SS2[j+2], SS1[i-1], SS2[j+1], P)+6*penalty,lc[idx][j]);
          lr[idx][j]=MIN2(lr[idx_3][j+3]+E_IntLoop(2,2,type2, rtype[type],SS1[i-2], SS2[j+2], SS1[i-1], SS2[j+1], P)+6*penalty,lr[idx][j]);
              }
      }
      /**
      *** (type>2?P->TerminalAU:0)+(i<(n1)?P->dangle3[rtype[type]][SS1[i+1]]+penalty:0)+(j>1?P->dangle5[rtype[type]][SS2[j-1]]+penalty:0)
      **/
      min_colonne=MIN2(lr[idx][j]+E_ExtLoop(rtype[type], (j > 1) ? SS2[j-1] : -1, (i<n1) ? SS1[i+1] : -1, P), min_colonne);
      }
      position[i]=min_colonne;
      if(max>=min_colonne){
        max=min_colonne;
        max_pos=i;
      }
      min_colonne=INF;
 }
 
  free(S1); free(S2); free(SS1); free(SS2);
  if(max<threshTE){
        find_max_snoop(s1, s2, max, alignment_length, position, delta, 
                       distance, penalty, threshloop, threshLE, threshRE, threshDE, 
                       threshTE, threshSE, threshD, half_stem, max_half_stem, min_s2, max_s2, min_s1, max_s1, min_d1, min_d2,name, fullStemEnergy);
   }
  for (i=1; i<5; i++) {free(lc[i]);free(lr[i]);}
  free(lc[0]);free(lr[0]);
  free(lc);free(lr);
  free(position);
  
}  



void Lsnoop_subopt_list(const char *s1, const char *s2, int delta, int w, 
                        const int penalty, const int threshloop, 
                        const int threshLE, const int threshRE, const int threshDE, const int threshTE,const int threshSE,const int threshD,
                        const int distance,
                        const int half_stem, const int max_half_stem,
                        const int min_s2, const int max_s2, const int min_s1, const int max_s1, const int min_d1, const int min_d2, const int alignment_length,const char *name,const int fullStemEnergy)
{
 
 int min_colonne=INF;
 int max_pos;
 int max;max=INF;
 /* int temp; */
 /* int nsubopt=10; */
 n1 = (int) strlen(s1);
 n2 = (int) strlen(s2);
 int *position;
 position = (int*) vrna_alloc((n1+3)*sizeof(int));


 /* int Eminj, Emin_l; */
  int i, j;/*  l1, Emin=INF, i_min=0, j_min=0; */
  /* char *struc; */
  /* snoopT mfe; */
  int *indx;
  int *mLoop;
  int *cLoop;
  folden **foldlist, **foldlist_XS;
  int Duplex_El, Duplex_Er;
  int Loop_D;
  /* int u; */
  int Loop_E;
  vrna_md_t md;

  Duplex_El=0;Duplex_Er=0;Loop_E=0, Loop_D=0;
  snoexport_fold_arrays(&indx, &mLoop, &cLoop, &foldlist,  &foldlist_XS); 

  set_model_details(&md);
  if ((!P) || (fabs(P->temperature - temperature)>1e-6)) {
    snoupdate_fold_params();
    if(P)
      free(P);
    P = vrna_params(&md);
    make_pair_matrix();
  }
  
  lpair = (int **) vrna_alloc(sizeof(int *) * (6));
  lc    = (int **) vrna_alloc(sizeof(int *) * (6));
  lr    = (int **) vrna_alloc(sizeof(int *) * (6));
  for (i=0; i<6; i++) {
          lc[i] = (int *) vrna_alloc(sizeof(int) * (n2+1));
        lr[i] = (int *) vrna_alloc(sizeof(int) * (n2+1));
        lpair[i] = (int *) vrna_alloc(sizeof(int) * (n2+1));
        for(j=n2; j>-1; j--){
                lc[i][j]=INF;
                lr[i][j]=INF;
                lpair[i][j]=0;
        }
  }
  encode_seqs(s1, s2);
  int lim_maxj=n2-min_d2 ;
  int lim_minj=min_d1;
  int lim_maxi=n1;
  for (i=5; i<=lim_maxi; i++) {
    int idx=i%5;
    int idx_1=(i-1)%5;
    int idx_2=(i-2)%5;
    int idx_3=(i-3)%5;
    int idx_4=(i-4)%5;

    for (j=lim_maxj; j>lim_minj; j--) {
      int type, type2;/*  E, k,l; */
      type = pair[S1[i]][S2[j]];
      lpair[idx][j] = type;
      lc[idx][j] = (type) ? P->DuplexInit + 2*penalty : INF;
      lr[idx][j] = INF;
      if(!type) continue;
      if( /*pair[S1[i+1]][S2[j-1]] && Be sure it binds*/
          j < max_s1 && j > min_s1 &&  
          j > n2 - max_s2 - max_half_stem && 
          j < n2 -min_s2 -half_stem && S1[i-2]==4 ) { /*constraint on s2 and i*/
        int min_k, max_k;
        max_k = MIN2(n2-min_s2,j+max_half_stem+1);
        min_k = MAX2(j+half_stem+1, n2-max_s2);
        folden * temp;
        temp=foldlist[j+1];
        while(temp->next){
          int k = temp->k;
          /* if(k >= min_k-1 && k < max_k){ comment to recover normal behaviour */
          if(lpair[idx_3][k+1] /*&& lpair[idx_4][k+2]*/){
            lr[idx][j]=MIN2(lr[idx][j], lc[idx_3][k+1]+temp->energy);/*--NU--*/
          }
          /*else*/ if(lpair[idx_4][k+1]){/*--NUN--*/
            lr[idx][j]=MIN2(lr[idx][j], lc[idx_4][k+1]+temp->energy);
          }
            /*  } */
          temp=temp->next;
        }
      }
      /* dangle 5'SIDE relative to the mRNA  */
      lc[idx][j] += E_ExtLoop(type,  SS1[i-1] , SS2[j+1] , P);
      /**
      ***      lc[idx][j] += P->dangle5[type][SS1[i-1]];
      ***      lc[idx][j] += P->dangle3[type][SS2[j+1]];
      ***      if (type>2) lc[idx][j] += P->TerminalAU;
      **/
      /*       if(j<n2 && i>1){ */
      /* type2=pair[S1[i-1]][S2[j+1]]; */
        type2=lpair[idx_1][j+1];
        if(type2>0 ){
          lc[idx][j]=MIN2(lc[idx_1][j+1]+E_IntLoop(0,0,type2, rtype[type],SS1[i], SS2[j], SS1[i-1], SS2[j+1], P)+2*penalty, lc[idx][j]);
          lr[idx][j]=MIN2(lr[idx_1][j+1]+E_IntLoop(0,0,type2, rtype[type],SS1[i], SS2[j], SS1[i-1], SS2[j+1], P)+2*penalty, lr[idx][j]);
        }
        /* } */
        /*       if(j<n2-1 && i>2){ */
        /* type2=pair[S1[i-2]][S2[j+2]]; */
        type2=lpair[idx_2][j+2];
        if(type2>0 ){
          lc[idx][j]=MIN2(lc[idx_2][j+2]+E_IntLoop(1,1,type2, rtype[type],SS1[i-1], SS2[j+1], SS1[i-1], SS2[j+1], P), lc[idx][j]);
          lr[idx][j]=MIN2(lr[idx_2][j+2]+E_IntLoop(1,1,type2, rtype[type],SS1[i-1], SS2[j+1], SS1[i-1], SS2[j+1], P), lr[idx][j]);
          /*         } */
      }
        /*       if(j<n2-2 && i>3){ */
        /* type2 = pair[S1[i-3]][S2[j+3]]; */
        type2 =lpair[idx_3][j+3];
        if(type2>0 ){
          lc[idx][j]=MIN2(lc[idx_3][j+3]+E_IntLoop(2,2,type2, rtype[type],SS1[i-2], SS2[j+2], SS1[i-1], SS2[j+1], P)+6*penalty,lc[idx][j]);
          lr[idx][j]=MIN2(lr[idx_3][j+3]+E_IntLoop(2,2,type2, rtype[type],SS1[i-2], SS2[j+2], SS1[i-1], SS2[j+1], P)+6*penalty,lr[idx][j]);
          /*         } */
      }
      /* min_colonne=MIN2(lr[idx][j]+(type>2?P->TerminalAU:0)+P->dangle3[rtype[type]][SS1[i+1]]+P->dangle5[rtype[type]][SS2[j-1]], min_colonne); */
      int bla;
      bla=lr[idx][j]+E_ExtLoop(rtype[type], SS2[j-1] , SS1[i+1], P)+2*penalty;
      min_colonne=MIN2(bla, min_colonne);
    }
    position[i]=min_colonne;
    if(max>=min_colonne){
      max=min_colonne;
      max_pos=i;
      }
    min_colonne=INF;
 }
 
  free(S1); free(S2); free(SS1); free(SS2);
  if(max<threshTE){
      find_max_snoop(s1, s2, max, alignment_length, position, 
                     delta, distance, penalty, threshloop, 
                     threshLE, threshRE, threshDE, threshTE, threshSE, threshD,
                     half_stem, max_half_stem, min_s2, max_s2, min_s1, max_s1, min_d1, min_d2,name, fullStemEnergy);
   }
  for (i=1; i<6; i++) {free(lc[i]);free(lr[i]);free(lpair[i]);}
  free(lc[0]);free(lr[0]);free(lpair[0]);
  free(lc);free(lr);free(lpair);
  free(position);
}  


PRIVATE void find_max_snoop(const char *s1, const char *s2,const int max,  const int alignment_length, const int* position, const int delta, 
                            const int distance, const int penalty, const int threshloop,  const int threshLE, const int threshRE, 
                            const int threshDE, const int threshTE, const int threshSE, const int threshD, 
                            const int half_stem, const int max_half_stem, const int min_s2, const int max_s2, const int min_s1, const int max_s1, const int min_d1, const int min_d2, const char* name, const int fullStemEnergy)
{
  int count=0;
  int pos=n1+1;
  int threshold = MIN2(threshTE , max + delta );
  /* printf("threshTE %d max %d\n", threshTE, max); */
  /* #pragma omp parallel for */
  /*   for(pos=n1+1;pos>distance;pos--){ */
  while(pos-- > 5){
    int temp_min=0;
    if(position[pos]<(threshold)){
      int search_range;
      search_range=distance+1;
      while(--search_range){
        if(position[pos-search_range]<=position[pos-temp_min]){
          temp_min=search_range;
        }
      }
      pos-=temp_min;
      int begin=MAX2(6, pos-alignment_length+1);
      char *s3 = (char*) vrna_alloc(sizeof(char)*(pos-begin+3+12));
      strcpy(s3, "NNNNN");
      strncat(s3, (s1+begin-1), pos-begin+2);
      strcat(s3,"NNNNN\0");
      /* printf("%s s3\n", s3);  */
      snoopT test;
      test = snoopfold(s3, s2, penalty, threshloop, threshLE, threshRE, threshDE, threshD, half_stem, max_half_stem, min_s2, max_s2, min_s1, 
                       max_s1, min_d1, min_d2,fullStemEnergy);
      if(test.energy==INF){
        free(s3);
        continue;
      }
      if(test.Duplex_El > threshLE * 0.01 || test.Duplex_Er > threshRE * 0.01  ||
         test.Loop_D > threshD * 0.01 || (test.Duplex_Er + test.Duplex_El) > threshDE * 0.01 ||
         (test.Duplex_Er + test.Duplex_El + test.Loop_E + test.Loop_D + 410) > threshSE*0.01) {
        free(test.structure);free(s3);
        continue;
      }
      int l1;
      l1 = strchr(test.structure, '&')-test.structure;
      
      int shift=0;
      if(test.i > (int)strlen(s3)-10){
        test.i--;
        l1--; 
      }
      if(test.i-l1<0){
        l1--;
        shift++;
      }
      char *target_struct =  (char*) vrna_alloc(sizeof(char) * (strlen(test.structure)+1));
      strncpy(target_struct, test.structure+shift, l1);
      strncat(target_struct, test.structure + (strchr(test.structure, '&')-
                                               test.structure), (int)strlen(test.structure) - (strchr(test.structure, '&')-
                                                                                          test.structure));
      strcat(target_struct,"\0");
      char *target; 
      target = (char *) vrna_alloc(l1+1);
      strncpy(target, (s3+test.i+5-l1), l1);
      target[l1]='\0';
      char *s4;
      s4 = (char*) vrna_alloc(sizeof(char) *(strlen(s2)-9));
      strncpy(s4, s2+5, (int)strlen(s2)-10);
      s4[(int)strlen(s2)-10]='\0';
      printf("%s %3d,%-3d;%3d : %3d,%-3d (%5.2f = %5.2f + %5.2f + %5.2f + %5.2f + 4.1 ) (%5.2f) \n%s&%s\n", 
             target_struct,begin + test.i-5-l1,begin + test.i -6 , begin + test.u -6, 
             test.j+1, test.j + (int)(strrchr(test.structure,'>') - strchr(test.structure,'>'))+1 ,
             test.Loop_D + test.Duplex_El + test.Duplex_Er + test.Loop_E + 4.10, test.Duplex_El,
             test.Duplex_Er, test.Loop_E, test.Loop_D,test.fullStemEnergy, target,s4);
      if(name){
        char *temp_seq;
        char *temp_struc;
        char psoutput[100];
        temp_seq = (char*) vrna_alloc(sizeof(char)*(l1+n2-9));
        temp_struc = (char*) vrna_alloc(sizeof(char)*(l1+n2-9));
        strcpy(temp_seq, target);
        strcat(temp_seq, s4);
        strncpy(temp_struc, target_struct, l1);
        strcat(temp_struc, target_struct+l1+1);
        temp_seq[n2+l1-10]='\0';
        temp_struc[n2+l1-10]='\0';
        cut_point = l1+1;
        char str[16];char upos[16];
        strcpy(psoutput,"sno_");
        sprintf(str,"%d",count);
        strcat(psoutput,str);
        sprintf(upos,"%d",begin + test.u - 6);
        strcat(psoutput,"_u_");
        strcat(psoutput,upos);
        strcat(psoutput,"_");
        strcat(psoutput,name);
        strcat(psoutput,".ps\0");
        //PS_rna_plot_snoop_a(temp_seq, temp_struc, psoutput, NULL, NULL);
        cut_point = -1;
        free(temp_seq);
        free(temp_struc);
        count++;
        /* free(psoutput); */
      }
      free(s4);
      free(test.structure);
      free(target_struct);
      free(target);
      free(s3);
    }
  }
  
}








snoopT snoopfold(const char *s1, const char *s2, 
                 const int penalty, const int threshloop, const int threshLE, const int threshRE, const int threshDE,
                 const int threshD,
                 const int half_stem, const int max_half_stem, 
                 const int min_s2, const int max_s2, const int min_s1, const int max_s1, const int min_d1, const int min_d2, const int fullStemEnergy) {
  /* int Eminj, Emin_l; */
  int i, j, l1, Emin=INF, i_min=0, j_min=0;
  char *struc;
  snoopT mfe;
  int *indx;
  int *mLoop;
  int *cLoop;
  folden** foldlist, **foldlist_XS;
  int Duplex_El, Duplex_Er;
  int Loop_D;
  int u;
  int Loop_E;
  vrna_md_t md;
  Duplex_El=0;Duplex_Er=0;Loop_E=0, Loop_D=0;
  snoexport_fold_arrays(&indx, &mLoop, &cLoop,&foldlist, &foldlist_XS ); 
  n1 = (int) strlen(s1);
  n2 = (int) strlen(s2);
  
  set_model_details(&md);
  if ((!P) || (fabs(P->temperature - temperature)>1e-6)) {
    snoupdate_fold_params();
    if(P)
      free(P);
    P = vrna_params(&md);
    make_pair_matrix();
  }
  
  c = (int **) vrna_alloc(sizeof(int *) * (n1+1));
  r = (int **) vrna_alloc(sizeof(int *) * (n1+1));
  for (i=0; i<=n1; i++) {
          c[i] = (int *) vrna_alloc(sizeof(int) * (n2+1));
        r[i] = (int *) vrna_alloc(sizeof(int) * (n2+1));
        for(j=n2; j>-1; j--){
                c[i][j]=INF;
                r[i][j]=INF;
        }
  }
  encode_seqs(s1, s2);
  for (i=6; i<=n1-5; i++) {
    for (j=n2-min_d2; j>min_d1; j--) {
      int type, type2, E, k,l;
      type = pair[S1[i]][S2[j]];
      c[i][j] = (type ) ? P->DuplexInit : INF;
      if(!type) continue;
      if(/*  pair[S1[i+1]][S2[j-1]] &&  */
         j < max_s1 && j > min_s1 &&  
         j > n2 - max_s2 - max_half_stem && 
         j < n2 -min_s2 -half_stem && S1[i-2]==4  ) { /*constraint on s2 and i*/
        int min_k, max_k;
        max_k = MIN2(n2-min_s2,j+max_half_stem);
        min_k = MAX2(j+half_stem, n2-max_s2);
        folden * temp;
        temp=foldlist[j+1];
        while(temp->next){
          int k = temp->k;
          /* if(k >= min_k-1 && k < max_k){ uncomment to recovernormal behaviour */
          if(pair[S1[i-3]][S2[k+1]] /*&& pair[S1[i-4]][S2[k+2]]*/ ){
            r[i][j]=MIN2(r[i][j], c[i-3][k+1]+temp->energy);
          }
          /*else*/ if(pair[S1[i-4]][S2[k+1]] /*&& pair[S1[i-5]][S2[k+2]]*/ ){
            r[i][j]=MIN2(r[i][j], c[i-4][k+1]+temp->energy);
          }
          /* } */
          temp=temp->next;
        }
      }
      /* dangle 5'SIDE relative to the mRNA  */
      /**
      *** c[i][j] += P->dangle5[type][SS1[i-1]];
      *** c[i][j] += P->dangle3[type][SS2[j+1]];
      *** if (type>2) c[i][j] += P->TerminalAU;
      **/
      c[i][j]+=E_ExtLoop(type, SS1[i-1] , SS2[j+1], P);
      for (k=i-1; k>0 && (i-k)<MAXLOOP_L; k--) {
        for (l=j+1; l<=n2 ; l++) {
          if (i-k+l-j>2*MAXLOOP_L-2) break;
          if (abs(i-k-l+j) >= ASS ) continue;
          type2 = pair[S1[k]][S2[l]];
          if (!type2) continue;
          E = E_IntLoop(i-k-1, l-j-1, type2, rtype[type],
                        SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
          c[i][j] = MIN2(c[i][j], c[k][l]+E+(i-k+l-j)*penalty);
          r[i][j] = MIN2(r[i][j], r[k][l]+E+(i-k+l-j)*penalty);
        }
      }
      E = r[i][j]; 
      /**
      *** if (i<n1) E += P->dangle3[rtype[type]][SS1[i+1]];              
      *** if (j>1)  E += P->dangle5[rtype[type]][SS2[j-1]]; 
      *** f (type>2) E += P->TerminalAU;
      **/
      E+=E_ExtLoop(rtype[type], (j > 1) ? SS2[j-1] : -1, (i<n1) ? SS1[i+1] : -1, P);
      if (E<Emin) {
        Emin=E; i_min=i; j_min=j;
      } 
    }
  }
  if(Emin > 0){
          printf("no target found under the constraints chosen\n");
        for (i=0; i<=n1; i++) {free(r[i]);free(c[i]);}
        free(c);
        free(r);
        free(S1); free(S2); free(SS1); free(SS2);
        mfe.energy=INF;
        return mfe;
  }
  struc = snoop_backtrack(i_min, j_min,s2, &Duplex_El, &Duplex_Er, &Loop_E, &Loop_D, 
                          &u, penalty, threshloop, threshLE, threshRE,threshDE, threshD,
                            half_stem, max_half_stem, min_s2, max_s2, min_s1, max_s1, min_d1, min_d2);
/*   if (i_min<n1-5) i_min++; */
/*   if (j_min>1 ) j_min--; */
  l1 = strchr(struc, '&')-struc;
  mfe.i = i_min-5;
  mfe.j = j_min-5;
  mfe.u = u -5;
  mfe.Duplex_Er = (float) Duplex_Er/100;
  mfe.Duplex_El = (float) Duplex_El/100;
  mfe.Loop_D = (float) Loop_D/100;
  mfe.Loop_E = (float) Loop_E/100;
  mfe.energy = (float) Emin/100 ;
  mfe.fullStemEnergy = (float) fullStemEnergy/100;
  mfe.structure = struc;
  if (!delay_free) {
    for (i=0; i<=n1; i++) {free(r[i]);free(c[i]);}
    free(c);
    free(r);
    free(S1); free(S2); free(SS1); free(SS2);
  }
  return mfe;
}

PRIVATE int snoopfold_XS_fill(const char *s1, const char *s2, const int **access_s1,
                 const int penalty, const int threshloop, const int threshLE, const int threshRE, const int threshDE,
                 const int threshD,
                 const int half_stem, const int max_half_stem, 
                 const int min_s2, const int max_s2, const int min_s1, const int max_s1, const int min_d1, const int min_d2) {
  /* int Eminj, Emin_l; */
  int i, j, Emin=INF, i_min=0, j_min=0;
  /* char *struc; */
  /* snoopT mfe; */
  int *indx;
  int *mLoop;
  int *cLoop;
  folden** foldlist, **foldlist_XS;
  int Duplex_El, Duplex_Er;
  int Loop_D;
  /* int u; */
  int Loop_E;
  vrna_md_t   md;
  Duplex_El=0;Duplex_Er=0;Loop_E=0, Loop_D=0;
  snoexport_fold_arrays(&indx, &mLoop, &cLoop,&foldlist, &foldlist_XS ); 
  n1 = (int) strlen(s1);
  n2 = (int) strlen(s2);
  
  set_model_details(&md);
  if ((!P) || (fabs(P->temperature - temperature)>1e-6)) {
    snoupdate_fold_params();
    if(P)
      free(P);
    P = vrna_params(&md);
    make_pair_matrix();
  }
  
  c_fill = (int **) vrna_alloc(sizeof(int *) * (n1+1));
  r_fill = (int **) vrna_alloc(sizeof(int *) * (n1+1));
  for (i=0; i<=n1; i++) {
          c_fill[i] = (int *) vrna_alloc(sizeof(int) * (n2+1));
        r_fill[i] = (int *) vrna_alloc(sizeof(int) * (n2+1));
        for(j=n2; j>-1; j--){
                c_fill[i][j]=INF;
                r_fill[i][j]=INF;
        }
  }
  encode_seqs(s1, s2);

  int di[5];
  di[0]=0;  
  for (i=6; i<=n1-5; i++) {
    di[1]=access_s1[5][i]   - access_s1[4][i-1];           
    di[2]=access_s1[5][i-1] - access_s1[4][i-2] + di[1];
    di[3]=access_s1[5][i-2] - access_s1[4][i-3] + di[2];
    di[4]=access_s1[5][i-3] - access_s1[4][i-4] + di[3];
    di[1]=MIN2(di[1],165);
    di[2]=MIN2(di[2],330);
    di[3]=MIN2(di[3],495);
    di[4]=MIN2(di[4],660);
    for (j=n2-min_d2; j>min_d1; j--) {
      int type, type2, E, k,l;
      type = pair[S1[i]][S2[j]];
      c_fill[i][j] = (type ) ? P->DuplexInit : INF;
      if(!type) continue;
      if(/*  pair[S1[i+1]][S2[j-1]] &&  */
         j < max_s1 && j > min_s1 &&  
         j > n2 - max_s2 - max_half_stem && 
         j < n2 -min_s2 -half_stem && S1[i-2]==4  ) { /*constraint on s2 and i*/
        int min_k, max_k;
        max_k = MIN2(n2-min_s2,j+max_half_stem);
        min_k = MAX2(j+half_stem, n2-max_s2);
        folden * temp;
        temp=foldlist[j+1];
        while(temp->next){
          int k = temp->k;
          /* if(k >= min_k-1 && k < max_k){ uncomment to recovernormal behaviour */
          if(pair[S1[i-3]][S2[k+1]] /*&& pair[S1[i-4]][S2[k+2]]*/ ){
            r_fill[i][j]=MIN2(r_fill[i][j], c_fill[i-3][k+1]+temp->energy+ di[3]);
          }
          /*else*/ if(pair[S1[i-4]][S2[k+1]] /*&& pair[S1[i-5]][S2[k+2]]*/ ){
            r_fill[i][j]=MIN2(r_fill[i][j], c_fill[i-4][k+1]+temp->energy + di[4]);
          }
          /* } */
          temp=temp->next;
        }
      }
      /* dangle 5'SIDE relative to the mRNA  */
      /**
      *** c_fill[i][j] += P->dangle5[type][SS1[i-1]];
      *** c_fill[i][j] += P->dangle3[type][SS2[j+1]];
      *** if (type>2) c_fill[i][j] += P->TerminalAU;
      **/
      c_fill[i][j]+= E_ExtLoop(type, SS1[i-1], SS2[j+1],P);
      for (k=i-1; k>0 && (i-k)<MAXLOOP_L; k--) {
        for (l=j+1; l<=n2 ; l++) {
          if (i-k+l-j>2*MAXLOOP_L-2) break;
          if (abs(i-k-l+j) >= ASS ) continue;
          type2 = pair[S1[k]][S2[l]];
          if (!type2) continue;
          E = E_IntLoop(i-k-1, l-j-1, type2, rtype[type],
                        SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
          c_fill[i][j] = MIN2(c_fill[i][j], c_fill[k][l]+E+di[i-k]);
          r_fill[i][j] = MIN2(r_fill[i][j], r_fill[k][l]+E+di[i-k]);
        }
      }
      E = r_fill[i][j]; 
      /**
      ***  if (i<n1) E += P->dangle3[rtype[type]][SS1[i+1]];              
      ***  if (j>1)  E += P->dangle5[rtype[type]][SS2[j-1]]; 
      *** if (type>2) E += P->TerminalAU;
      **/
      E+= E_ExtLoop(rtype[type], (j > 1) ? SS2[j-1] : -1, (i<n1) ? SS1[i+1] : -1, P);
      if (E<Emin) {
        Emin=E; i_min=i; j_min=j;
      } 
    }
  }
  return Emin;
}



PUBLIC snoopT *snoop_subopt(const char *s1, const char *s2, int delta, int w, 
                            const int penalty, const int threshloop, 
                            const int threshLE, const int threshRE, const int threshDE, const int threshTE, const int threshSE, const int threshD,
                            const int distance, const int half_stem, const int max_half_stem,
                            const int min_s2, const int max_s2, const int min_s1, const int max_s1, const int min_d1, const int min_d2, const int fullStemEnergy) {



  /* printf("%d %d\n", min_s2, max_s2); */
  int i,j, n1, n2, E, n_subopt=0, n_max;
  char *struc;
  snoopT mfe;
  snoopT *subopt;
  int thresh;

  int Duplex_El, Duplex_Er, Loop_E;
  int Loop_D;
  Duplex_El=0; Duplex_Er=0; Loop_E=0;Loop_D=0;
  int u;
  u=0;
  n_max=16;
  subopt = (snoopT *) vrna_alloc(n_max*sizeof(snoopT));
  delay_free=1;
  mfe = snoopfold(s1, s2, penalty, threshloop, threshLE, threshRE, threshDE,threshD,
                  half_stem, max_half_stem,
                  min_s2, max_s2, min_s1, max_s1, min_d1, min_d2, fullStemEnergy);



  if(mfe.energy > 0){
          free(subopt);
        delay_free=0;
        return NULL;
  }
  thresh = MIN2((int) ((mfe.Duplex_Er + mfe.Duplex_El + mfe.Loop_E)*100+0.1 + 410) + delta, threshTE );
 /* subopt[n_subopt++]=mfe; */
  free(mfe.structure);
  
  n1 = (int)strlen(s1); n2=(int)strlen(s2);
  for (i=n1; i>0; i--) {
    for (j=1; j<=n2; j++) {
      int type, Ed;
      type = pair[S2[j]][S1[i]];
      if (!type) continue;
      E = Ed = r[i][j];
      /**
      *** if (i<n1) Ed += P->dangle3[type][SS1[i+1]]; 
      *** if (j>1)  Ed += P->dangle5[type][SS2[j-1]]; 
      *** if (type>2) Ed += P->TerminalAU;
      **/
      Ed+= E_ExtLoop(type, (j > 1) ? SS2[j-1] : -1, (i<n1) ? SS1[i+1] : -1, P);
      if (Ed>thresh) continue;
      /* too keep output small, remove hits that are dominated by a
         better one close (w) by. For simplicity we do test without
         adding dangles, which is slightly inaccurate. 
      */ 
      /* w=1; */
/*       for (ii=MAX2(i-w,1); (ii<=MIN2(i+w,n1)) && type; ii++) {  */
/*         for (jj=MAX2(j-w,1); jj<=MIN2(j+w,n2); jj++) */
/*           if (r[ii][jj]<E) {type=0; break;} */
/*       } */
      if (!type) continue;

      struc = snoop_backtrack(i,j,s2, &Duplex_El, &Duplex_Er, &Loop_E, &Loop_D, &u, penalty, threshloop,threshLE,threshRE,threshDE,threshD, 
                        half_stem, max_half_stem, min_s2, max_s2, min_s1, max_s1, min_d1, min_d2);
      if (Duplex_Er > threshRE || Duplex_El > threshLE || Loop_D > threshD ||
         (Duplex_Er + Duplex_El) > threshDE || 
         (Duplex_Er + Duplex_El + Loop_E) > threshTE ||
         (Duplex_Er + Duplex_El + Loop_E + Loop_D + 410) > threshSE) {
                 /* printf(" Duplex_Er %d threshRE %d Duplex_El %d threshLE %d \n" */
                /*        " Duplex_Er + Duplex_El %d  threshDE %d \n" */
                /*        " Duplex_Er + Duplex_El + Loop_E %d  threshTE %d \n" */
                /*        " Duplex_Er + Duplex_El + Loop_E + Loop_D %d  threshSE %d \n",  */
                /*          Duplex_Er , threshRE , Duplex_El ,threshLE, */
                /*          Duplex_Er + Duplex_El, threshDE, */
                /*          Duplex_Er + Duplex_El+  Loop_E , threshTE, */
                /*          Duplex_Er + Duplex_El+  Loop_E + Loop_D, threshSE);  */
                 Duplex_Er=0; 
                Duplex_El=0;
                Loop_E = 0;
                Loop_D = 0;
                u=0,
                free(struc);
                continue;
        }

      if (n_subopt+1>=n_max) {
        n_max *= 2;
        subopt = (snoopT *) vrna_realloc(subopt, n_max*sizeof(snoopT));
      }
      subopt[n_subopt].i = i-5;
      subopt[n_subopt].j = j-5;
      subopt[n_subopt].u = u-5;
      subopt[n_subopt].Duplex_Er = Duplex_Er * 0.01;
      subopt[n_subopt].Duplex_El = Duplex_El * 0.01;
      subopt[n_subopt].Loop_E = Loop_E * 0.01;
      subopt[n_subopt].Loop_D = Loop_D * 0.01;
      subopt[n_subopt].energy = (Duplex_Er +Duplex_El + Loop_E + Loop_D + 410) * 0.01 ;
      subopt[n_subopt].fullStemEnergy = (float) fullStemEnergy * 0.01;
      subopt[n_subopt++].structure = struc;

      Duplex_Er=0; Duplex_El=0; Loop_E=0; Loop_D=0;u=0;
    }
  }
  
  for (i=0; i<=n1; i++) {free(c[i]);free(r[i]);}
  free(c);free(r);
  free(S1); free(S2); free(SS1); free(SS2);
  delay_free=0;

  if (snoop_subopt_sorted) qsort(subopt, n_subopt, sizeof(snoopT), compare);
  subopt[n_subopt].i =0;
  subopt[n_subopt].j =0;
  subopt[n_subopt].structure = NULL;
  return subopt;
}

PUBLIC void snoop_subopt_XS(const char *s1, const char *s2, const int **access_s1, int delta, int w, 
                            const int penalty, const int threshloop, 
                            const int threshLE, const int threshRE, const int threshDE, const int threshTE, const int threshSE, const int threshD,
                            const int distance, const int half_stem, const int max_half_stem,
                            const int min_s2, const int max_s2, const int min_s1, const int max_s1, const int min_d1, const int min_d2, const int alignment_length, const char *name, const int fullStemEnergy) {



  /* printf("%d %d\n", min_s2, max_s2); */
  int i,j, E,  n_max;
  /* char *struc; */
  /* snoopT mfe; */

  int thresh;

  int Duplex_El, Duplex_Er, Loop_E;
  int Loop_D;
  Duplex_El=0; Duplex_Er=0; Loop_E=0;Loop_D=0;
  int u;
  u=0;
  n_max=16;
  delay_free=1;
  int Emin = snoopfold_XS_fill(s1, s2, access_s1,penalty, threshloop, threshLE, threshRE, threshDE,threshD,
                               half_stem, max_half_stem,
                               min_s2, max_s2, min_s1, max_s1, min_d1, min_d2);
  if(Emin > 0){
    delay_free=0;
  }
  thresh = MIN2(-100, threshTE +alignment_length*30);  
  /*   n1=(int)strlen(s1);  */
  /*   n2=(int)strlen(s2); */
  
  int n3=(int)strlen(s1);
  int n4=(int)strlen(s2);
  S1_fill = (short*)vrna_alloc(sizeof(short)*(n3+2));
  S2_fill = (short*)vrna_alloc(sizeof(short)*(n4+2));
  SS1_fill = (short*)vrna_alloc(sizeof(short)*(n3+1));
  SS2_fill = (short*)vrna_alloc(sizeof(short)*(n4+1));
  memcpy(S1_fill, S1, sizeof(short)*n3+2);
  memcpy(S2_fill, S2, sizeof(short)*n4+2);
  memcpy(SS1_fill, SS1, sizeof(short)*n3+1);
  memcpy(SS2_fill, SS2, sizeof(short)*n4+1);
  free(S1);free(S2);free(SS1);free(SS2);
  int count=0;
  for (i=n3-5; i>0; i--) {
    for (j=1; j<=n4; j++) {
      int type, Ed;
      type = pair[S2_fill[j]][S1_fill[i]];
      if (!type) continue;
      E = Ed = r_fill[i][j];
      /**
      ***if (i<n3) Ed += P->dangle3[type][SS1_fill[i+1]]; 
      ***if (j>1)  Ed += P->dangle5[type][SS2_fill[j-1]]; 
      ***if (type>2) Ed += P->TerminalAU;
      **/
      Ed+=E_ExtLoop(type, (j > 1) ? SS2[j-1] : -1, (i<n3) ? SS1[i+1] : -1, P);
      if (Ed>thresh) continue;
      
      /* to keep output small, remove hits that are dominated by a
         better one close (w) by. For simplicity we do test without
         adding dangles, which is slightly inaccurate. 
      */ 
/*       w=10;  */
/*       for (ii=MAX2(i-w,1); (ii<=MIN2(i+w,n3-5)) && type; ii++) {   */
/*         for (jj=MAX2(j-w,1); jj<=MIN2(j+w,n4-5); jj++)  */
/*           if (r_fill[ii][jj]<E) {type=0; break;}  */
/*       }  */
/*       i=ii;j=jj; */
      if (!type) continue;
      int begin=MAX2(5, i-alignment_length);
      int end  =MIN2(n3-5, i-1); 
      char *s3 = (char*) vrna_alloc(sizeof(char)*(end-begin+2)+5);
      strncpy(s3, (s1+begin), end - begin +1);
      strcat(s3,"NNNNN\0");
      int n5 = (int)strlen(s3);
      snoopT test = snoopfold_XS(s3, s2, access_s1, i, j ,penalty, 
                          threshloop, threshLE, threshRE, 
                          threshDE, threshD, half_stem, 
                          max_half_stem, min_s2, max_s2, min_s1, 
                                 max_s1, min_d1, min_d2,fullStemEnergy);
      if(test.energy==INF){
        free(s3);
        continue;
      }
      if( test.Duplex_El > threshLE * 0.01 ||test.Duplex_Er > threshRE * 0.01  || 
          test.Loop_D > threshD * 0.01 || (test.Duplex_Er + test.Duplex_El) > threshDE * 0.01 || 
          (test.Duplex_Er + test.Duplex_El + test.Loop_E) > threshTE*0.01 || (test.Duplex_Er + test.Duplex_El + test.Loop_E + test.Loop_D + 410) > threshSE*0.01) 
        { 
          free(test.structure);free(s3); 
          continue; 
        }
      char *s4; 
      s4 = (char*) vrna_alloc(sizeof(char) *(n4-9)); 
      strncpy(s4, s2+5, n4-10); 
      s4[n4-10]='\0';
      
      char *s5 = vrna_alloc(sizeof(char) * n5-test.i+2-5);
      strncpy(s5,s3+test.i-1,n5-test.i+1-5);
      s5[n5-test.i+1-5]='\0';
      float dE = ((float) (access_s1[n5-test.i+1-5][i]))*0.01;
      printf("%s %3d,%-3d;%3d : %3d,%-3d (%5.2f = %5.2f + %5.2f + %5.2f + %5.2f + %5.2f + 4.10)  (%5.2f)\n%s&%s\n" ,  
             test.structure, i  -  (n5 - test.i) ,i - 5, i - (n5 - test.u ),
             j-5, j-5 + (int)(strrchr(test.structure,'>') - strchr(test.structure,'>')), 
             test.Loop_D + test.Duplex_El + test.Duplex_Er + test.Loop_E + 4.10+dE, test.Duplex_El, 
             test.Duplex_Er, test.Loop_E, test.Loop_D,dE , test.fullStemEnergy, s5,s4);
      if(name){
        int begin_t, end_t, begin_q, end_q, andX, pipe,k; 
        char psoutput[100];
        begin_q=0;
        end_q=n4-10;
        begin_t=0;
        end_t=n5-test.i+ 1-5;
        andX=end_t+1;
        pipe=test.u -test.i + 1;
        cut_point = end_t +1 ;
        char *catseq, *catstruct;/*  *fname;  */
        catseq = (char*) vrna_alloc(n5 + end_q -begin_q +2);
        catstruct = (char*) vrna_alloc(n5 + end_q -begin_q +2);
        strcpy(catseq, s5);
        strncpy(catstruct, test.structure, end_t);
        strcat(catseq, s4);
        strncat(catstruct, test.structure+end_t+1, end_q-begin_q+1);
        catstruct[end_t - begin_t + end_q-begin_q+2]='\0';
        catseq[end_t - begin_t + end_q-begin_q+2]='\0';
        int *relative_access;
        relative_access = vrna_alloc(sizeof(int)*strlen(s5));
        relative_access[0] = access_s1[1][i - (n5  - test.i) + 5];
        for(k=1;k<(int)strlen(s5);k++){
          relative_access[k] =  access_s1[k+1][i - (n5  - test.i) + k + 5] -  access_s1[k][i - (n5  - test.i) + k + 4];
        }
        char str[16];char upos[16];
        strcpy(psoutput,"sno_XS_");
        sprintf(str,"%d",count);
        strcat(psoutput,str);
        sprintf(upos,"%d",i - (n5 - test.u ));
        strcat(psoutput,"_u_");
        strcat(psoutput,upos);
        strcat(psoutput,"_");
        strcat(psoutput,name);
        strcat(psoutput,".ps\0");
        //PS_rna_plot_snoop_a(catseq, catstruct, psoutput,relative_access,NULL);
        free(catseq);free(catstruct);free(relative_access);
        count++;
      }
      free(s3);free(s4);free(s5);free(test.structure);
    }
  }  
  for (i=0; i<=n3; i++) {free(c_fill[i]);free(r_fill[i]);}
  free(c_fill);free(r_fill);
  free(S1_fill); free(S2_fill); free(SS1_fill); free(SS2_fill);
  delay_free=0;
}




PRIVATE char *snoop_backtrack(int i, int j, const char* snoseq, 
                              int *Duplex_El, int *Duplex_Er, 
                              int *Loop_E, int *Loop_D, int *u, 
                              const int penalty, const int threshloop, 
                              const int threshLE, const int threshRE, const int threshDE, const int threshD,
                              const int half_stem, const int max_half_stem, 
                              const int min_s2, const int max_s2, const int min_s1, 
                              const int max_s1, const int min_d1, const int min_d2) {
  /* backtrack structure going backwards from i, and forwards from j 
     return structure in bracket notation with & as separator */
  int k, l, type, type2, E, traced, i0, j0;
  int traced_r=0; /* flag for following backtrack in c or r */
  char *st1, *st2, *struc;
  char *struc_loop;

  st1 = (char *) vrna_alloc(sizeof(char)*(n1+1));
  st2 = (char *) vrna_alloc(sizeof(char)*(n2+1));
  int *indx;
  int *mLoop;
  int *cLoop;
  folden **foldlist, **foldlist_XS;
  type=pair[S1[i]][S2[j]];
  snoexport_fold_arrays(&indx, &mLoop, &cLoop,&foldlist, &foldlist_XS ); 
  i0=i; j0=j;
  /**
  *** if (i<n1)   *Duplex_Er += P->dangle3[rtype[type]][SS1[i+1]];
  *** if (j>1)    *Duplex_Er += P->dangle5[rtype[type]][SS2[j-1]];
  *** if (type>2) *Duplex_Er += P->TerminalAU;
  **/
  *Duplex_Er += E_ExtLoop(rtype[type], (j > 1) ? SS2[j-1] : -1, (i<n1) ? SS1[i+1] : -1, P);
  while (i>0 && j<=n2-min_d2 ) {
    if(!traced_r) {
      E = r[i][j]; traced=0;
      st1[i-1] = '<';
      st2[j-1] = '>'; 
      type = pair[S1[i]][S2[j]];
      if (!type) vrna_message_error("backtrack failed in fold duplex r");
      for (k=i-1; k>0 && (i-k)<MAXLOOP_L; k--) {
        for (l=j+1; l<=n2 ; l++) {
          int LE;
          if (i-k+l-j>2*MAXLOOP_L-2) break;
          if (abs(i-k-l+j) >= ASS) continue;
          
          type2 = pair[S1[k]][S2[l]];
          if (!type2) continue;
          LE = E_IntLoop(i-k-1, l-j-1, type2, rtype[type],
                         SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
          if (E == r[k][l]+LE+(i-k+l-j)*penalty) {
            traced=1; 
            i=k; j=l;
            *Duplex_Er+=LE;
            break;
          }
        }
        if (traced) break;
      }
      if(!traced){
        if(/*  pair[S1[i+1]][S2[j-1]] && */  
            j < max_s1 && j > min_s1 && 
            j > n2 - max_s2 - max_half_stem && 
            j < n2 -min_s2 -half_stem && 
            S1[i-2]==4) {
          int min_k, max_k;
          max_k = MIN2(n2-min_s2,j+max_half_stem+1);
          min_k = MAX2(j+half_stem+1, n2-max_s2);
          folden * temp;
          temp=foldlist[j+1];
          while(temp->next) {
            int k = temp->k;
            if(pair[S1[i-3]][S2[k+1]] /*&& pair[S1[i-4]][S2[k+2]]*/    ){  /* introduce structure from RNAfold */
              if(E==c[i-3][k+1]+temp->energy){
                *Loop_E=temp->energy;
                st1[i-3]= '|';
                *u=i-2;
                int a,b;
                /* int fix_ij=indx[k-1+1]+j+1; */
                for(a=0; a< MISMATCH ;a++){
                  for(b=0; b< MISMATCH ; b++){
                    int ij=indx[k-1-a+1]+j+1+b;
                    if(cLoop[ij]==temp->energy) {
                      struc_loop=snobacktrack_fold_from_pair(snoseq, j+1+b, k-a-1+1);
                    a=INF; b=INF;        
                    }
                  }
                }
                traced=1;
                traced_r=1;
                i=i-3;j=k+1;
                break;
              }
            }
            /*else*/ if (pair[S1[i-4]][S2[k+1]] /*&& pair[S1[i-5]][S2[k+2]]*/){  /* introduce structure from RNAfold */
              if(E==c[i-4][k+1]+temp->energy){
                *Loop_E=temp->energy;
                st1[i-3]= '|';
                *u=i-2;
                int a,b;
                /* int fix_ij=indx[k-1+1]+j+1; */
                for(a=0; a< MISMATCH ;a++){
                  for(b=0; b< MISMATCH ; b++){
                    int ij=indx[k-1-a+1]+j+1+b;
                    if(cLoop[ij]==temp->energy) {
                      struc_loop=snobacktrack_fold_from_pair(snoseq, j+1+b, k-a-1+1);
                      a=INF; b=INF;        
                    }
                  }
                }
                traced=1;
                traced_r=1;
                i=i-4;j=k+1;
                break;
              }
            } /* else if */
            temp=temp->next;
          } /* while temp-> next */
        } /* test on j  */
      }/* traced? */
    }/* traced_r? */
    else{
      E = c[i][j]; traced=0;
      st1[i-1] = '<';
      st2[j-1] = '>'; 
      type = pair[S1[i]][S2[j]];
      if (!type) vrna_message_error("backtrack failed in fold duplex c");
      for (k=i-1; (i-k)<MAXLOOP_L; k--) {
        for (l=j+1; l<=n2; l++) {
          int LE;
          if (i-k+l-j>2*MAXLOOP_L-2) break;
          if (abs(i-k-l+j) >= ASS) continue;
          type2 = pair[S1[k]][S2[l]];
          if (!type2) continue;
          LE = E_IntLoop(i-k-1, l-j-1, type2, rtype[type],
                         SS1[k+1], SS2[l-1], SS1[i-1], SS2[j+1],P);
          if (E == c[k][l]+LE+(i-k+l-j)*penalty) {
            traced=1; 
            i=k; j=l;
            *Duplex_El+=LE;
            break;
          }
        }
        if (traced) break;
      }
    }
    if (!traced) { 
      int correction;
      correction = E_ExtLoop(type, (i>1) ? SS1[i-1] : -1, (j<n2) ? SS2[j+1] : -1, P);
      E-=correction;
      *Duplex_El+=correction;
      /**
      *** if (i>1)    {E -= P->dangle5[type][SS1[i-1]]; *Duplex_El +=P->dangle5[type][SS1[i-1]];}
      *** if (j<n2)   {E -= P->dangle3[type][SS2[j+1]]; *Duplex_El +=P->dangle3[type][SS2[j+1]];}
      *** if (type>2) {E -= P->TerminalAU;                    *Duplex_El +=P->TerminalAU;}
      **/
      if (E != P->DuplexInit) {
        vrna_message_error("backtrack failed in fold duplex end");
      } else break;
    }
  }
/*   if (i>1)  i--; */
/*   if (j<n2) j++; */  
  /* struc = (char *) vrna_alloc(i0-i+1+j-j0+1+2); */ /* declare final duplex structure */
  struc = (char *) vrna_alloc(i0-i+1+n2-1+1+2); /* declare final duplex structure */
  char * struc2;
  struc2 = (char *) vrna_alloc(n2+1);
  /* char * struct_const; */
  for (k=MAX2(i,1); k<=i0; k++) if (!st1[k-1]) st1[k-1] = '.';
  /* for (k=j0; k<=j; k++) if (!st2[k-1]) st2[k-1] = struc_loop[k-1];*/ /* '.'; normal */
  /*  char * struct_const; */
  /*  struct_const = (char *) vrna_alloc(sizeof(char)*(n2+1));   */
  for (k=1; k<=n2; k++) {
    if (!st2[k-1]) st2[k-1] = struc_loop[k-1];/* '.'; */
    struc2[k-1] = st2[k-1];/* '.'; */
    /*      if (k>=j0 && k<=j){ */
    /*              struct_const[k-1]='x'; */
    /*      } */
    /*      else{ */
    /*              if(k<j0) {struct_const[k-1]='<';} */
    /*              if(k>j) {struct_const[k-1]='>';} */
    /*      } */
  }
  char duplexseq_1[j0];
  char duplexseq_2[n2-j+2];
  if(j<n2){
    strncpy(duplexseq_1, snoseq, j0-1);
    strcpy(duplexseq_2, snoseq + j);
    duplexseq_1[j0-1]='\0';
    duplexseq_2[n2-j+1]='\0';
    duplexT temp;
    temp=duplexfold(duplexseq_1, duplexseq_2);
    *Loop_D =  MIN2(0,-410 + (int) 100 * temp.energy);
    if(*Loop_D){
      int l1,ibegin, iend, jbegin, jend;
      l1=strchr(temp.structure, '&')-temp.structure;
      ibegin=temp.i-l1;
      iend  =temp.i-1;
      jbegin=temp.j;
      jend  =temp.j+(int)strlen(temp.structure)-l1-2-1;
      for(k=ibegin+1; k<=iend+1; k++){
        struc2[k-1]=temp.structure[k-ibegin-1];
      }
      for(k=jbegin+j; k<=jend+j; k++){
        struc2[k-1]=temp.structure[l1+k-j-jbegin+1];
      } 
    }
    free(temp.structure);
  } 
  strcpy(struc, st1+MAX2(i-1,0)); strcat(struc, "&"); 
  /* strcat(struc, st2); */
  strncat(struc, struc2+5, (int)strlen(struc2)-10);
  free(struc2);
  free(struc_loop);
  free(st1); free(st2);
  /* free_arrays(); */
  return struc;
}

void Lsnoop_subopt_list_XS(const char *s1, const char *s2,  const int **access_s1, int delta, int w, 
                        const int penalty, const int threshloop, 
                        const int threshLE, const int threshRE, const int threshDE, const int threshTE,const int threshSE,const int threshD,
                        const int distance,
                        const int half_stem, const int max_half_stem,
                           const int min_s2, const int max_s2, const int min_s1, const int max_s1, const int min_d1, const int min_d2, const int alignment_length, const char *name, const int fullStemEnergy)
{
 
 int min_colonne=INF;
 int max_pos;
 int max;max=INF;
 /* int temp; */
 /* int nsubopt=10; */
 n1 = (int) strlen(s1);
 n2 = (int) strlen(s2);
 int *position;
 int *position_j;
 int min_j_colonne;
 int max_pos_j=INF; 
 position = (int*) vrna_alloc((n1+3)*sizeof(int));
 position_j = (int*) vrna_alloc((n1+3)*sizeof(int));

 /* int Eminj, Emin_l; */
  int i, j;/*  l1, Emin=INF, i_min=0, j_min=0; */
  /* char *struc; */
  /* snoopT mfe; */
  int *indx;
  int *mLoop;
  int *cLoop;
  folden **foldlist, **foldlist_XS;
  int Duplex_El, Duplex_Er;
  int Loop_D;
  /* int u; */
  int Loop_E;
  vrna_md_t md;

  Duplex_El=0;Duplex_Er=0;Loop_E=0, Loop_D=0;
  snoexport_fold_arrays(&indx, &mLoop, &cLoop, &foldlist, &foldlist_XS); 

  set_model_details(&md);
  if ((!P) || (fabs(P->temperature - temperature)>1e-6)) {
    snoupdate_fold_params();
    if(P)
      free(P);
    P = vrna_params(&md);
    make_pair_matrix();
  }
  
  lpair = (int **) vrna_alloc(sizeof(int *) * (6));
  lc    = (int **) vrna_alloc(sizeof(int *) * (6));
  lr    = (int **) vrna_alloc(sizeof(int *) * (6));
  for (i=0; i<6; i++) {
          lc[i] = (int *) vrna_alloc(sizeof(int) * (n2+1));
        lr[i] = (int *) vrna_alloc(sizeof(int) * (n2+1));
        lpair[i] = (int *) vrna_alloc(sizeof(int) * (n2+1));
        for(j=n2; j>-1; j--){
                lc[i][j]=INF;
                lr[i][j]=INF;
                lpair[i][j]=0;
        }
  }
  encode_seqs(s1, s2);
  int lim_maxj=n2-min_d2 ;
  int lim_minj=min_d1;
  int lim_maxi=n1-5;
  for (i=5; i<=lim_maxi; i++) {
    int idx=i%5;
    int idx_1=(i-1)%5;
    int idx_2=(i-2)%5;
    int idx_3=(i-3)%5;
    int idx_4=(i-4)%5;
    int di1, di2, di3, di4;
    di1 = access_s1[5][i]   - access_s1[4][i-1];           
    di2 =access_s1[5][i-1] - access_s1[4][i-2] + di1;
    di3 = access_s1[5][i-2] - access_s1[4][i-3] + di2;
    di4 = access_s1[5][i-3] - access_s1[4][i-4] + di3;
    di1=MIN2(di1,165);
    di2=MIN2(di2,330);
    di3=MIN2(di3,495);
    di4=MIN2(di4,660);
    for (j=lim_maxj; j>lim_minj; j--) {
      int type, type2;/*  E, k,l; */
      type = pair[S1[i]][S2[j]];
      lpair[idx][j] = type;
      lc[idx][j] = (type) ? P->DuplexInit + access_s1[1][i] : INF;
      lr[idx][j] = INF;
      if(!type) continue;
      if( /*pair[S1[i+1]][S2[j-1]] && Be sure it binds*/
          j < max_s1 && j > min_s1 &&  
          j > n2 - max_s2 - max_half_stem && 
          j < n2 -min_s2 -half_stem && S1[i-2]==4 ) { /*constraint on s2 and i*/
        int min_k, max_k;
        max_k = MIN2(n2-min_s2,j+max_half_stem+1);
        min_k = MAX2(j+half_stem+1, n2-max_s2);
        folden * temp;
        temp=foldlist[j+1];
        while(temp->next){
          int k = temp->k;
          /* if(k >= min_k-1 && k < max_k){ comment to recover normal behaviour */
          if(lpair[idx_3][k+1] && lc[idx_3][k+1] /*+di3*/ < 411 /*&& lpair[idx_4][k+2]*/){ /*  remove second condition */
            lr[idx][j]=MIN2(lr[idx][j], di3 + lc[idx_3][k+1]+temp->energy);/*--NU--*/
          }
          /*else*/ if(lpair[idx_4][k+1] && /*di4 +*/ lc[idx_4][k+1] < 411  ){/*--NUN--*/ /*  remove second condition  */
            lr[idx][j]=MIN2(lr[idx][j], di4 + lc[idx_4][k+1]+temp->energy);
          }
            /*  } */
          temp=temp->next;
        }
      }
      /* dangle 5'SIDE relative to the mRNA  */
      /**
      *** lc[idx][j] += P->dangle5[type][SS1[i-1]];
      *** lc[idx][j] += P->dangle3[type][SS2[j+1]];
      *** if (type>2) lc[idx][j] += P->TerminalAU;
      **/
      lc[idx][j]+=E_ExtLoop(type, SS1[i-1] ,  SS2[j+1] , P);
      /*       if(j<n2 && i>1){ */
      /* type2=pair[S1[i-1]][S2[j+1]]; */
        type2=lpair[idx_1][j+1];
        if(type2>0 ){
          lc[idx][j]=MIN2(lc[idx_1][j+1]+E_IntLoop(0,0,type2, rtype[type],SS1[i], SS2[j], SS1[i-1], SS2[j+1], P)+di1, lc[idx][j]);
          lr[idx][j]=MIN2(lr[idx_1][j+1]+E_IntLoop(0,0,type2, rtype[type],SS1[i], SS2[j], SS1[i-1], SS2[j+1], P)+di1, lr[idx][j]);
        }
        type2=lpair[idx_2][j+2];
        if(type2>0 ){
          lc[idx][j]=MIN2(lc[idx_2][j+2]+E_IntLoop(1,1,type2, rtype[type],SS1[i-1], SS2[j+1], SS1[i-1], SS2[j+1], P)+di2, lc[idx][j]);
          lr[idx][j]=MIN2(lr[idx_2][j+2]+E_IntLoop(1,1,type2, rtype[type],SS1[i-1], SS2[j+1], SS1[i-1], SS2[j+1], P)+di2, lr[idx][j]);
         
      }
        type2 =lpair[idx_3][j+3];
        if(type2>0 ){
          lc[idx][j]=MIN2(lc[idx_3][j+3]+E_IntLoop(2,2,type2, rtype[type],SS1[i-2], SS2[j+2], SS1[i-1], SS2[j+1], P)+di3,lc[idx][j]);
          lr[idx][j]=MIN2(lr[idx_3][j+3]+E_IntLoop(2,2,type2, rtype[type],SS1[i-2], SS2[j+2], SS1[i-1], SS2[j+1], P)+di3,lr[idx][j]);

      }
      int bla;
      int temp2;
      temp2=min_colonne;
      bla=lr[idx][j] + E_ExtLoop(rtype[type], SS2[j-1], SS1[i+1] , P);
        /**
        *** (type>2?P->TerminalAU:0)+P->dangle3[rtype[type]][SS1[i+1]]+P->dangle5[rtype[type]][SS2[j-1]];
        **/
      min_colonne=MIN2(bla, min_colonne);
      if(temp2>min_colonne){
        min_j_colonne=j;
      }
    }
    position[i]=min_colonne;
    if(max>=min_colonne){
      max=min_colonne;
      max_pos=i;
      max_pos_j=min_j_colonne;
      }
    position_j[i]=min_j_colonne;
    min_colonne=INF;
 }
  free(S1); free(S2); free(SS1); free(SS2);

  if(max<threshTE + 30*alignment_length){
    find_max_snoop_XS(s1, s2, access_s1,max,alignment_length, position, position_j,
                     delta, distance, penalty, threshloop, 
                     threshLE, threshRE, threshDE, threshTE, threshSE, threshD,
                      half_stem, max_half_stem, min_s2, max_s2, min_s1, max_s1, min_d1, min_d2,name,fullStemEnergy);
   }
  for (i=1; i<6; i++) {free(lc[i]);free(lr[i]);free(lpair[i]);}
  free(lc[0]);free(lr[0]);free(lpair[0]);
  free(lc);free(lr);free(lpair);
  free(position);free(position_j);
}  


PRIVATE void find_max_snoop_XS(const char *s1, const char *s2, const int **access_s1, 
                               const int max,  const int alignment_length, 
                               const int* position, const int* position_j, const int delta, 
                               const int distance, const int penalty, const int threshloop,  const int threshLE, const int threshRE, 
                               const int threshDE, const int threshTE, const int threshSE, const int threshD, 
                               const int half_stem, const int max_half_stem, const int min_s2, const int max_s2, const int min_s1, const int max_s1, const int min_d1, const int min_d2, const char *name, const int fullStemEnergy){
  int count=0;
  int n3=(int)strlen(s1);
  int n4=(int)strlen(s2);
  int pos=n1-4;
  int max_pos_j;
  int threshold = MIN2(threshTE + alignment_length*30, -100);
  /* printf("threshTE %d max %d\n", threshTE, max); */
  /* #pragma omp parallel for */
  /*   for(pos=n1+1;pos>distance;pos--){ */
  while(pos-->5){
    int temp_min=0;
    if(position[pos]<(threshold)){
      int search_range;
      search_range=distance+1;
      while(--search_range){
        if(position[pos-search_range]<=position[pos-temp_min]){
          temp_min=search_range;
        }
      }
      pos-=temp_min;
      max_pos_j=position_j[pos];
      int begin=MAX2(5, pos-alignment_length);
      int end  =MIN2(n3-5, pos-1); 
      char *s3 = (char*) vrna_alloc(sizeof(char)*(end-begin+2)+5);
      strncpy(s3, (s1+begin), end - begin +1);
      strcat(s3,"NNNNN\0");

      int n5 = (int)strlen(s3);
      snoopT test;
      test = snoopfold_XS(s3, s2, access_s1, pos, max_pos_j ,penalty, 
                          threshloop, threshLE, threshRE, 
                          threshDE, threshD, half_stem, 
                          max_half_stem, min_s2, max_s2, min_s1, 
                          max_s1, min_d1, min_d2, fullStemEnergy);
      if(test.energy==INF){
        free(s3);
        continue;
      }
      if( test.Duplex_El > threshLE * 0.01 ||test.Duplex_Er > threshRE * 0.01  || 
         test.Loop_D > threshD * 0.01 || (test.Duplex_Er + test.Duplex_El) > threshDE * 0.01 || 
         (test.Duplex_Er + test.Duplex_El + test.Loop_E) > threshTE*0.01 || (test.Duplex_Er + test.Duplex_El + test.Loop_E + test.Loop_D + 410) > threshSE*0.01) { 
        free(test.structure);free(s3); 
        continue; 
      }
      
      char *s4; 
      s4 = (char*) vrna_alloc(sizeof(char) *(n4-9)); 
      strncpy(s4, s2+5, n4-10); 
      s4[n4-10]='\0';

      char *s5 = vrna_alloc(sizeof(char) * n5-test.i+2-5);
      strncpy(s5,s3+test.i-1,n5-test.i+1-5);
      s5[n5-test.i+1-5]='\0';
      float dE = ((float) (access_s1[n5-test.i+1-5][pos]))*0.01;
      printf("%s %3d,%-3d;%3d : %3d,%-3d (%5.2f = %5.2f + %5.2f + %5.2f + %5.2f + %5.2f + 4.10) (%5.2f)\n%s&%s\n" ,  
             test.structure, pos  -  (n5 - test.i) ,pos - 5, pos - (n5 - test.u ),
             max_pos_j-5, max_pos_j-5 + (int)(strrchr(test.structure,'>') - strchr(test.structure,'>')), 
             test.Loop_D + test.Duplex_El + test.Duplex_Er + test.Loop_E + 4.10+dE, test.Duplex_El, 
             test.Duplex_Er, test.Loop_E, test.Loop_D,dE ,test.fullStemEnergy, s5,s4);
      if(name){
        int begin_t, end_t, begin_q, end_q, andX, pipe, i; 
        char psoutput[100];
        begin_q=0;
        end_q=n4-10;
        begin_t=0;
        end_t=n5-test.i+ 1-5;
        andX=end_t+1;
        pipe=test.u -test.i + 1;
        cut_point = end_t +1 ;
        char *catseq, *catstruct;/*  *fname;  */
        catseq = (char*) vrna_alloc(n5 + end_q -begin_q +2);
        catstruct = (char*) vrna_alloc(n5 + end_q -begin_q +2);
        strcpy(catseq, s5);
        strncpy(catstruct, test.structure, end_t);
        strcat(catseq, s4);
        strncat(catstruct, test.structure+end_t+1, end_q-begin_q+1);
        catstruct[end_t - begin_t + end_q-begin_q+2]='\0';
        catseq[end_t - begin_t + end_q-begin_q+2]='\0';
        int *relative_access;
        relative_access = vrna_alloc(sizeof(int)*strlen(s5));

        relative_access[0] = access_s1[1][pos - (n5  - test.i) + 5];
        for(i=1;i<(int)strlen(s5);i++){
          relative_access[i] =  access_s1[i+1][pos - (n5  - test.i) + i + 5] -  access_s1[i][pos - (n5  - test.i) + i + 4];
        }
        char str[16];
        char upos[16];
        strcpy(psoutput,"sno_XS_");
        sprintf(str,"%d",count);
        strcat(psoutput,str);
        sprintf(upos,"%d",pos - (n5 - test.u ));
        strcat(psoutput,"_u_");
        strcat(psoutput,upos);
        strcat(psoutput,"_");
        strcat(psoutput,name);
        strcat(psoutput,".ps\0");
        //PS_rna_plot_snoop_a(catseq, catstruct, psoutput,relative_access,NULL);
        free(catseq);free(catstruct);free(relative_access);
        count++;
      }
      free(s3);free(s4);free(s5);free(test.structure);
    }
  }
}

snoopT snoopfold_XS(const char *s1, const char *s2, const int **access_s1, const int pos_i, const int pos_j,
                 const int penalty, const int threshloop, const int threshLE, const int threshRE, const int threshDE,
                 const int threshD,
                 const int half_stem, const int max_half_stem, 
                    const int min_s2, const int max_s2, const int min_s1, const int max_s1, const int min_d1, const int min_d2, const int fullStemEnergy) {
  /*   int Eminj, Emin_l; */
  int a,b,i, j, Emin=INF, a_min=0, b_min=0;
  char *struc;
  snoopT mfe;
  int *indx;
  int *mLoop;
  int *cLoop;
  folden** foldlist, **foldlist_XS;
  int Duplex_El, Duplex_Er;
  int Loop_D;
  int u;
  int Loop_E;
  vrna_md_t md;

  Duplex_El=0;Duplex_Er=0;Loop_E=0, Loop_D=0;
  snoexport_fold_arrays(&indx, &mLoop, &cLoop,&foldlist, &foldlist_XS ); 
  n1 = (int) strlen(s1);
  n2 = (int) strlen(s2);
  
  set_model_details(&md);
  if ((!P) || (fabs(P->temperature - temperature)>1e-6)) {
    snoupdate_fold_params();
    if(P)
      free(P);
    P = vrna_params(&md);
    make_pair_matrix();
  }
  
  c = (int **) vrna_alloc(sizeof(int *) * (n1+1));
  r = (int **) vrna_alloc(sizeof(int *) * (n1+1));
  for (i=0; i<=n1; i++) {
          c[i] = (int *) vrna_alloc(sizeof(int) * (n2+1));
        r[i] = (int *) vrna_alloc(sizeof(int) * (n2+1));
        for(j=n2; j>-1; j--){
                c[i][j]=INF;
                r[i][j]=INF;
        }
  }
  encode_seqs(s1, s2);
  i=n1-5;
  j=pos_j;
  /* printf("tar: %s\nsno: %s\n ", s1, s2); */
  /* printf("pos_i %d pos_j %d\n", pos_i, pos_j); */
  /* printf("type %d n1 %d n2 %d S1[n1] %d S2[n2] %d", pair[S1[i]][S2[j]], n1, n2, S1[n1], S2[n2]); */
  int type, type2, E, p,q;    
  r[i][j] = P->DuplexInit; 
  /* r[i][j] += P->dangle3[rtype[type]][SS1[i+1]] + P->dangle5[rtype[type]][SS2[j-1]];  */
  
  if(pair[S1[i]][S2[j]]>2) r[i][j]+=P->TerminalAU;
  for(a=i-1; a>0;a--){ /* i-1 */
    r[a+1][0]=INF;
    for(b=j+1; b<=n2-min_d2;b++){ /* j+1 */
      r[a][b]=INF;
      type = pair[S1[a]][S2[b]]; 
       if(!type) continue; 
       if(S1[a+1]==4){ 
         folden * temp; 
         temp=foldlist_XS[b-1]; 
         while(temp->next) {     
           int k = temp->k; 
           if(pair[S1[a+3]][S2[k-1]] && k< max_s1 && k > min_s1 && k > n2 - max_s2 - max_half_stem &&  k < n2 -min_s2 -half_stem /*&& r[a+3][k-1] + access_s1[i-(a+3)+1][pos_i] < 411*/) { /* remove last condition last condition is to check if the interaction is stable enough */
             c[a][b]=MIN2(c[a][b], r[a+3][k-1]+temp->energy); 
           }
           temp=temp->next;
         }
       }
       if(S1[a+2]==4){
         folden * temp; 
         temp=foldlist_XS[b-1]; 
         while(temp->next){ 
           int k = temp->k; 
           if(pair[S1[a+4]][S2[k-1]] &&  k< max_s1 && k > min_s1 && k > n2 - max_s2 - max_half_stem &&  k < n2 -min_s2 -half_stem /*&& r[a+4][k-1] + access_s1[i-(a+4)+1][pos_i] < 411 */ ) { /* remove last condition  */
             c[a][b]=MIN2(c[a][b], r[a+4][k-1]+temp->energy); 
           }
           temp=temp->next;
         }
       }
       for(p=a+1; p<n1 && (p-a) < MAXLOOP_L; p++) { /* p < n1 */
         for (q=b-1; q > 1  ; q--) {  /* q > 1 */
           if (p-a+b-q>2*MAXLOOP_L-2) break; 
           if (abs((p-a)-(b-q)) >= ASS ) continue; 
           type2 = pair[S1[p]][S2[q]]; 
           if (!type2) continue; 
           E = E_IntLoop(p-a-1, b-q-1, type2, rtype[type],SS1[a+1], SS2[b-1], SS1[p-1], SS2[q+1],P); 
           c[a][b] = MIN2(c[a][b], c[p][q]+E); 
           r[a][b] = MIN2(r[a][b], r[p][q]+E); 
         }
       }
       E = c[a][b];  
       if (type>2) E += P->TerminalAU;  
       /*        E +=P->dangle5[rtype[type]][SS1[i+1]]; */
       /* E +=P->dangle5[rtype[type]][SS2[j-1]];  */
       E+=access_s1[i-a+1][pos_i]; 
       if (E<Emin) { 
         Emin=E; a_min=a; b_min=b; 
       }  
    }
  }
  if(Emin > 0){ 
    printf("no target found under the constraints chosen\n");
    for (i=0; i<=n1; i++) {free(r[i]);free(c[i]);}
    free(c);
    free(r); 
    free(S1); free(S2); free(SS1); free(SS2);
    mfe.energy=INF;
    return mfe;
  }  
  type2=pair[S1[a_min]][S2[b_min]];
  if(type2>2) Emin +=P->TerminalAU;
  mfe.energy = ((float) (Emin))/100;
  struc = snoop_backtrack_XS(a_min, b_min,s2, &Duplex_El, &Duplex_Er, &Loop_E, &Loop_D, 
                             &u, penalty, threshloop, threshLE, threshRE,threshDE, threshD, 
                             half_stem, max_half_stem, min_s2, max_s2, min_s1, max_s1, min_d1, min_d2); 

  mfe.i = a_min;
  mfe.j = b_min;
  mfe.u = u;
  mfe.Duplex_Er = (float) Duplex_Er/100;
  mfe.Duplex_El = (float) Duplex_El/100;
  mfe.Loop_D = (float) Loop_D/100;
  mfe.Loop_E = (float) Loop_E/100;
  mfe.energy = (float) Emin/100 ;
  mfe.fullStemEnergy = (float) fullStemEnergy/100;
  mfe.structure = struc;
  return mfe;
}

PRIVATE char *snoop_backtrack_XS(int i, int j, const char* snoseq, 
                              int *Duplex_El, int *Duplex_Er, 
                              int *Loop_E, int *Loop_D, int *u, 
                              const int penalty, const int threshloop, 
                              const int threshLE, const int threshRE, const int threshDE, const int threshD,
                              const int half_stem, const int max_half_stem, 
                              const int min_s2, const int max_s2, const int min_s1, 
                              const int max_s1, const int min_d1, const int min_d2) {
  /* backtrack structure going backwards from i, and forwards from j 
     return structure in bracket notation with & as separator */
  int k, l, type, type2, E, traced, i0, j0;
  int traced_c=0; /* flag for following backtrack in c or r */
  char *st1, *st2, *struc;
  char *struc_loop;

  st1 = (char *) vrna_alloc(sizeof(char)*(n1+1));
  st2 = (char *) vrna_alloc(sizeof(char)*(n2+1));
  int *indx;
  int *mLoop;
  int *cLoop;
  folden **foldlist, **foldlist_XS;
  type=pair[S1[i]][S2[j]];
  snoexport_fold_arrays(&indx, &mLoop, &cLoop,&foldlist, &foldlist_XS ); 
  i0=i;j0=j;
  /*   i0=MAX2(i,1); j0=MIN2(j+1,n2); */
  while (i<=n1 && j>=1 ) {
    if(!traced_c) {
      E = c[i][j]; traced=0;
      st1[i] = '<';
      st2[j-1] = '>'; 
      type = pair[S1[i]][S2[j]];
      if (!type) vrna_message_error("backtrack failed in fold duplex c");
      for (k=i+1; k>0 && (k-i)<MAXLOOP_L; k++) {
        for (l=j-1; l>=1 ; l--) {
          int LE;
          if (k-i+j-l>2*MAXLOOP_L-2) break;
          if (abs(k-i-j+l) >= ASS) continue;
          type2 = pair[S1[k]][S2[l]];
          if (!type2) continue;
          LE = E_IntLoop(k-i-1, j-l-1, type2, rtype[type],
                         SS1[i+1], SS2[j-1], SS1[k-1], SS2[l+1],P);
          if (E == c[k][l]+LE) {
            traced=1; 
            i=k; j=l;
            *Duplex_El+=LE;
            break;
          }
        }
        if (traced) break;
      }
      if(!traced){
        if(S1[i+1]==4) {
          folden * temp;
          temp=foldlist_XS[j-1];
          while(temp->next) {
            int k = temp->k;
            if(pair[S1[i+3]][S2[k-1]] && k< max_s1 && k > min_s1 && k > n2 - max_s2 - max_half_stem &&  k < n2 -min_s2 -half_stem ) {
              if(E==r[i+3][k-1]+temp->energy){
                *Loop_E=temp->energy;
                st1[i+1]= '|';
                st1[i+2]='.';
                *u=i+1;
                int a,b;
                for(a=0; a< MISMATCH ;a++){
                  for(b=0; b< MISMATCH ; b++){
                    int ij=indx[j-1-a]+k+b;
                    if(cLoop[ij]==temp->energy) {
                      struc_loop=snobacktrack_fold_from_pair(snoseq, k+b, j-1-a); 
                      a=INF; b=INF;        
                    }
                  }
                }
                traced=1;
                traced_c=1;
                i=i+3;j=k-1;
                break;
              }
            }
            temp=temp->next;
          }
        }
        if (S1[i+2]==4){  /* introduce structure from RNAfold */
          folden * temp;
          temp=foldlist_XS[j-1];
          while(temp->next) {
            int k = temp->k;
            if(pair[S1[i+4]][S2[k-1]] && k< max_s1 && k > min_s1 && k > n2 - max_s2 - max_half_stem &&  k < n2 -min_s2 -half_stem ) {
              if(E==r[i+4][k-1]+temp->energy){
                *Loop_E=temp->energy;
                st1[i+2]= '|';
                st1[i+1]=st1[i+3]='.';
                *u=i+2;
                int a,b;
                for(a=0; a< MISMATCH ;a++){
                  for(b=0; b< MISMATCH ; b++){
                    int ij=indx[j-1-a]+k+b;
                    if(cLoop[ij]==temp->energy) {
                      struc_loop=snobacktrack_fold_from_pair(snoseq, k+b, j-a-1);
                      a=INF; b=INF;        
                    }
                  }
                }
                traced=1;
                traced_c=1;
                i=i+4;j=k-1;
                break;
              }
            }
            temp=temp->next;
          }
        }
      }/* traced? */
    }/* traced_r? */
    else{
      E = r[i][j]; traced=0;
      st1[i] = '<';
      st2[j-1] = '>'; 
      type = pair[S1[i]][S2[j]];
      if (!type) vrna_message_error("backtrack failed in fold duplex r");
      for (k=i+1; k>0 && (k-i)<MAXLOOP_L; k++) {
        for (l=j-1; l>=1 ; l--) {
          int LE;
          if (k-i+j-l>2*MAXLOOP_L-2) break;
          if (abs(k-i-j+l) >= ASS) continue;
          type2 = pair[S1[k]][S2[l]];
          if (!type2) continue;
          LE = E_IntLoop(k-i-1, j-l-1, type2, rtype[type],
                         SS1[i+1], SS2[j-1], SS1[k-1], SS2[l+1],P);
          if (E == r[k][l]+LE) {
            traced=1; 
            i=k; j=l;
            *Duplex_Er+=LE;
            break;
          }
        }
        if (traced) break;
      }
    }
    if (!traced) { 
/*       if (i>1)    {E -= P->dangle5[type][SS1[i-1]]; *Duplex_El +=P->dangle5[type][SS1[i-1]];} */
/*       if (j<n2)   {E -= P->dangle3[type][SS2[j+1]]; *Duplex_El +=P->dangle3[type][SS2[j+1]];} */
      if (type>2) {E -= P->TerminalAU;        *Duplex_Er +=P->TerminalAU;}
      if (E != P->DuplexInit) {
        vrna_message_error("backtrack failed in fold duplex end");
      } else break;
    }
  }

  
  /* struc = (char *) vrna_alloc(i0-i+1+j-j0+1+2); */ /* declare final duplex structure */
  struc = (char *) vrna_alloc(i-i0+1+n2); /* declare final duplex structure */
  char * struc2;
  struc2 = (char *) vrna_alloc(n2+1);
  /* char * struct_const; */

  for (k=MIN2(i0,1); k<=i; k++) if (!st1[k-1]) st1[k-1] = '.';
  /* for (k=j0; k<=j; k++) if (!st2[k-1]) st2[k-1] = struc_loop[k-1];*/ /* '.'; normal */
  /*  char * struct_const; */
  /*  struct_const = (char *) vrna_alloc(sizeof(char)*(n2+1));   */
  for (k=1; k<=n2; k++) {
    if (!st2[k-1]) st2[k-1] = struc_loop[k-1];/* '.'; */
    struc2[k-1] = st2[k-1];/* '.'; */
    /*      if (k>=j0 && k<=j){ */
    /*              struct_const[k-1]='x'; */
    /*      } */
    /*      else{ */
    /*              if(k<j0) {struct_const[k-1]='<';} */
    /*              if(k>j) {struct_const[k-1]='>';} */
    /*      } */
  }
  char duplexseq_1[j];
  char duplexseq_2[n2-j0+2];
  if(j0<n2){
    strncpy(duplexseq_1, snoseq, j-1);
    strcpy(duplexseq_2, snoseq + j0);
    duplexseq_1[j-1]='\0';
    duplexseq_2[n2-j0+1]='\0';
    duplexT temp;
    temp=duplexfold(duplexseq_1, duplexseq_2);
    *Loop_D =  MIN2(0,-410 + (int) 100 * temp.energy);
    if(*Loop_D){
      int l1,ibegin, iend, jbegin, jend;
      l1=strchr(temp.structure, '&')-temp.structure;
      ibegin=temp.i-l1;
      iend  =temp.i-1;
      jbegin=temp.j;
      jend  =temp.j+(int)strlen(temp.structure)-l1-2-1;
      for(k=ibegin+1; k<=iend+1; k++){
        struc2[k-1]=temp.structure[k-ibegin-1];
      }
      for(k=jbegin+j0; k<=jend+j0; k++){
        struc2[k-1]=temp.structure[l1+k-j0-jbegin+1];
      } 
    }
    free(temp.structure);
  } 
  strcpy(struc, st1+MAX2(i0,1)); strcat(struc, "&"); 
  /* strcat(struc, st2); */
  strncat(struc, struc2+5, (int)strlen(struc2)-10);
  free(struc2);
  free(struc_loop);
  free(st1); free(st2);
  
    for (i=0; i<=n1; i++) {free(r[i]);free(c[i]);}
    free(c);
    free(r);
    free(S1);free(S2);free(SS1);free(SS2);
    /* free_arrays(); */
  return struc;
}

PRIVATE int covscore(const int *types, int n_seq) {
  /* calculate co-variance bonus for a pair depending on  */
  /* compensatory/consistent mutations and incompatible seqs */
  /* should be 0 for conserved pairs, >0 for good pairs      */
#define NONE -10000 /* score for forbidden pairs */
  int k,l,s,score, pscore;
  int dm[7][7]={{0,0,0,0,0,0,0}, /* hamming distance between pairs */
                {0,0,2,2,1,2,2} /* CG */,
                {0,2,0,1,2,2,2} /* GC */,
                {0,2,1,0,2,1,2} /* GU */,
                {0,1,2,2,0,2,1} /* UG */,
                {0,2,2,1,2,0,2} /* AU */,
                {0,2,2,2,1,2,0} /* UA */};
  
  int pfreq[8]={0,0,0,0,0,0,0,0};
  for (s=0; s<n_seq; s++)
    pfreq[types[s]]++;

  if (pfreq[0]*2>n_seq) return NONE;
  for (k=1,score=0; k<=6; k++) /* ignore pairtype 7 (gap-gap) */
    for (l=k+1; l<=6; l++)
      /* scores for replacements between pairtypes    */
      /* consistent or compensatory mutations score 1 or 2  */
      score += pfreq[k]*pfreq[l]*dm[k][l];
  
  /* counter examples score -1, gap-gap scores -0.25   */
  pscore = cv_fact * 
    ((UNIT*score)/n_seq - nc_fact*UNIT*(pfreq[0] + pfreq[7]*0.25));
  return pscore;
}

/*---------------------------------------------------------------------------*/

PRIVATE short * aliencode_seq(const char *sequence) {
  unsigned int i,l;
  short *Stemp;
  l = strlen(sequence);
  Stemp = (short *) vrna_alloc(sizeof(short)*(l+2));
  Stemp[0] = (short) l;

  /* make numerical encoding of sequence */
  for (i=1; i<=l; i++)
    Stemp[i]= (short) encode_char(toupper(sequence[i-1]));

  /* for circular folding add first base at position n+1 */
  /* Stemp[l+1] = Stemp[1]; */

  return Stemp;
}

PRIVATE short * encode_seq(const char *sequence) {
  unsigned int i,l;
  short *S;
  l = strlen(sequence);
extern double nc_fact;
  S = (short *) vrna_alloc(sizeof(short)*(l+2));
  S[0] = (short) l;

  /* make numerical encoding of sequence */
  for (i=1; i<=l; i++)
    S[i]= (short) encode_char(toupper(sequence[i-1]));
  /* for circular folding add first base at position n+1 */
  S[l+1] = S[1];

  return S;
}

PRIVATE void encode_seqs(const char *s1, const char *s2) {
  unsigned int i,l;

  l = strlen(s1);
  S1 = encode_seq(s1);
  SS1= (short *) vrna_alloc(sizeof(short)*(l+1));
  /* SS1 exists only for the special X K and I bases and energy_set!=0 */
  
  for (i=1; i<=l; i++) { /* make numerical encoding of sequence */
    SS1[i] = alias[S1[i]];   /* for mismatches of nostandard bases */
  }

  l = strlen(s2);
  S2 = encode_seq(s2);
  SS2= (short *) vrna_alloc(sizeof(short)*(l+1));
  /* SS2 exists only for the special X K and I bases and energy_set!=0 */
  
  for (i=1; i<=l; i++) { /* make numerical encoding of sequence */
    SS2[i] = alias[S2[i]];   /* for mismatches of nostandard bases */
  }
}

PRIVATE int compare(const void *sub1, const void *sub2) {
  int d;
  if (((snoopT *) sub1)->energy > ((snoopT *) sub2)->energy)
    return 1;
  if (((snoopT *) sub1)->energy < ((snoopT *) sub2)->energy)
    return -1;
  d = ((snoopT *) sub1)->i - ((snoopT *) sub2)->i;
  if (d!=0) return d;
  return  ((snoopT *) sub1)->j - ((snoopT *) sub2)->j;
}



move_set.c/     0           0     0     644     28297     `

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <limits.h>
#include <time.h>

#include "pair_mat.h"
#include "fold_vars.h"
#include "fold.h"
#include "utils.h"

#include "move_set.h"


/* maximum degeneracy value - if degeneracy is greater than this, program segfaults */
#define MAX_DEGEN 100
#define MINGAP 3


#define bool int
#define true 1
#define false 0

/*
#################################
# PRIVATE DATA STRUCTURES       #
#################################
*/

/* internal struct with moves, sequence, degeneracy and options*/
typedef struct _Encoded {
  /* sequence*/
  short *s0;
  short *s1;

  const char  *seq;

  /* moves*/
  int   bp_left;
  int   bp_right;
  int   bp_left2;   /* if noLP is enabled (and for shift moves)*/
  int   bp_right2;

  /* options*/
  int noLP;
  int verbose_lvl;
  int first;
  int shift;

  /* degeneracy*/
  int begin_unpr;
  int begin_pr;
  int end_unpr;
  int end_pr;
  short *processed[MAX_DEGEN];
  short *unprocessed[MAX_DEGEN];
  int current_en;

  /* moves in random (needs to be freed afterwards)*/
  int *moves_from;
  int *moves_to;
  int num_moves;

  /* function for flooding */
  int (*funct) (struct_en*, struct_en*);


} Encoded;

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/
PRIVATE int cnt_move = 0;

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/
PRIVATE int     compare(short *lhs, short *rhs);
PRIVATE int     find_min(short *arr[MAX_DEGEN], int begin, int end);
PRIVATE int     equals(const short *first, const short *second);
PRIVATE int     count_move(void);
PRIVATE int     lone_base(short *pt, int i);
PRIVATE void    free_degen(Encoded *Enc);
PRIVATE inline void do_move(short *pt, int bp_left, int bp_right);
PRIVATE int     update_deepest(Encoded *Enc, struct_en *str, struct_en *min);
PRIVATE int     deletions(Encoded *Enc, struct_en *str, struct_en *minim);
PRIVATE inline  bool compat(char a, char b);
PRIVATE inline  bool try_insert(const short *pt, const char *seq, int i, int j);
PRIVATE inline  bool try_insert_seq(const char *seq, int i, int j);
PRIVATE int     insertions(Encoded *Enc, struct_en *str, struct_en *minim);
PRIVATE int     shifts(Encoded *Enc, struct_en *str, struct_en *minim);
PRIVATE int     move_set(Encoded *Enc, struct_en *str);
PRIVATE void    construct_moves(Encoded *Enc, short *structure);
PRIVATE int     move_rset(Encoded *Enc, struct_en *str);
PRIVATE int     find_lone_pair(short* str);


/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PRIVATE int
compare(short *lhs, short *rhs){

  /* printf("%d ", (int)lhs[0]); */

  int i=1;
  char l=0,r=0;
  while (i<=lhs[0]) {
    l = (lhs[i]==0?'.':(lhs[i]<lhs[lhs[i]]?')':'('));
    r = (rhs[i]==0?'.':(rhs[i]<rhs[rhs[i]]?')':'('));
    if (l != r) break;
    i++;
  }

  return (i<=lhs[0] && l>r);
}

PRIVATE int
find_min(short *arr[MAX_DEGEN], int begin, int end){

  short *min = arr[begin];
  short min_num = begin;
  int i;

  for (i=begin+1; i<end; i++) {
    if (compare(arr[i], min)) {
      min = arr[i];
      min_num = i;
    }
  }
  return min_num;
}

PRIVATE int
equals(const short *first, const short *second){

  int i=1;
  while (i<=first[0] && first[i]==second[i]) {
    i++;
  }
  if (i>first[0]) return 1;
  else return 0;
}

PUBLIC void
copy_arr(short *dest, short *src){
  if (!src || !dest) {
    fprintf(stderr, "Empty pointer in copying\n");
    return;
  }
  memcpy(dest, src, sizeof(short)*(src[0]+1));
}

PUBLIC short *
allocopy(short *src){
  short *res = (short*) vrna_alloc(sizeof(short)*(src[0]+1));
  copy_arr(res, src);
  return res;
}

PRIVATE int
count_move(void){

  return cnt_move;
}



/* frees all things allocated by degeneracy...*/
PRIVATE void
free_degen(Encoded *Enc){

  int i;
  for (i=Enc->begin_unpr; i<Enc->end_unpr; i++) {
    if (Enc->unprocessed[i]) {
      free(Enc->unprocessed[i]);
      Enc->unprocessed[i]=NULL;
    }
  }
  for (i=Enc->begin_pr; i<Enc->end_pr; i++) {
    if (Enc->processed[i]) {
      free(Enc->processed[i]);
      Enc->processed[i]=NULL;
    }
  }
  Enc->begin_pr=0;
  Enc->begin_unpr=0;
  Enc->end_pr=0;
  Enc->end_unpr=0;
}

PRIVATE inline void
do_move(short *pt, int bp_left, int bp_right){

  /* delete*/
  if (bp_left<0) {
    pt[-bp_left]=0;
    pt[-bp_right]=0;
  } else { /* insert*/
    pt[bp_left]=bp_right;
    pt[bp_right]=bp_left;
  }
}

/* done with all structures along the way to deepest*/
PRIVATE int
update_deepest(Encoded *Enc, struct_en *str, struct_en *min){

  /* apply move + get its energy*/
  int tmp_en;
  tmp_en = str->energy + energy_of_move_pt(str->structure, Enc->s0, Enc->s1, Enc->bp_left, Enc->bp_right);
  do_move(str->structure, Enc->bp_left, Enc->bp_right);
  if (Enc->bp_left2 != 0) {
    tmp_en += energy_of_move_pt(str->structure, Enc->s0, Enc->s1, Enc->bp_left2, Enc->bp_right2);
    do_move(str->structure, Enc->bp_left2, Enc->bp_right2);
  }
  int last_en = str->energy;
  str->energy = tmp_en;


  /* use f_point if we have it */
  if (Enc->funct) {
    int end = Enc->funct(str, min);

    /*  undo moves */
    if (Enc->bp_left2!=0) do_move(str->structure, -Enc->bp_left2, -Enc->bp_right2);
    do_move(str->structure, -Enc->bp_left, -Enc->bp_right);
    str->energy = last_en;
    Enc->bp_left=0;
    Enc->bp_right=0;
    Enc->bp_left2=0;
    Enc->bp_right2=0;

    return (end?1:0);
  }

  if (Enc->verbose_lvl>1) { fprintf(stderr, "  "); print_str(stderr, str->structure); fprintf(stderr, " %d\n", tmp_en); }

  /* better deepest*/
  if (tmp_en < min->energy) {
    min->energy = tmp_en;
    copy_arr(min->structure, str->structure);

    /* delete degeneracy*/
    free_degen(Enc);

    /* undo moves*/
    if (Enc->bp_left2!=0) do_move(str->structure, -Enc->bp_left2, -Enc->bp_right2);
    do_move(str->structure, -Enc->bp_left, -Enc->bp_right);
    str->energy = last_en;
    Enc->bp_left=0;
    Enc->bp_right=0;
    Enc->bp_left2=0;
    Enc->bp_right2=0;
    return 1;
  }

  /* degeneracy*/
  if ((str->energy == min->energy) && (Enc->current_en == min->energy)) {
    int found = 0;
    int i;
    for (i=Enc->begin_pr; i<Enc->end_pr; i++) {
      if (equals(Enc->processed[i], str->structure)) {
        found = 1;
        break;
      }
    }
    for (i=Enc->begin_unpr; !found && i<Enc->end_unpr; i++) {
      if (equals(Enc->unprocessed[i], str->structure)) {
        found = 1;
        break;
      }
    }

    if (!found) {
      /* print_stren(stderr, str); // fprintf(stderr, " %6.2f\n", str->energy); */
      Enc->unprocessed[Enc->end_unpr]=allocopy(str->structure);
      Enc->end_unpr++;
    }
  }

  /* undo moves*/
  if (Enc->bp_left2!=0) do_move(str->structure, -Enc->bp_left2, -Enc->bp_right2);
  do_move(str->structure, -Enc->bp_left, -Enc->bp_right);
  str->energy = last_en;
  Enc->bp_left=0;
  Enc->bp_right=0;
  Enc->bp_left2=0;
  Enc->bp_right2=0;
  return 0;
}


/* deletions move set*/
PRIVATE int
deletions(Encoded *Enc, struct_en *str, struct_en *minim){

  int cnt = 0;
  short *pt = str->structure;
  int len = pt[0];
  int i;

  for (i=1; i<=len; i++) {
    if (pt[i]>pt[pt[i]]) {  /* '('*/
      Enc->bp_left=-i;
      Enc->bp_right=-pt[i];

      /*if nolp enabled, make (maybe) 2nd delete*/
      if (Enc->noLP) {
        int lone = -1;
        if (lone_base(pt, i-1)) lone=i-1;
        else if (lone_base(pt, i+1)) lone=i+1;
        else if (lone_base(pt, pt[i]-1)) lone=pt[i]-1;
        else if (lone_base(pt, pt[i]+1)) lone=pt[i]+1;

        /* check*/
        if (lone != -1 && (pt[lone]==0 || pt[pt[lone]]==0)) {
          fprintf(stderr, "WARNING: pt[%d(or %d)]!=\'.\'", lone, pt[lone]);
        }

        if (lone != -1) {
          Enc->bp_left2=-lone-1;
          Enc->bp_right2=-pt[lone]-1;
        }
        if (!lone_base(pt, pt[lone]-1) && !lone_base(pt, pt[lone]+1)) {
          cnt += update_deepest(Enc, str, minim);
          /* in case useFirst is on and structure is found, end*/
          if (Enc->first && cnt > 0) return cnt;
        }
      } else {  /* nolp not enabled*/
        cnt += update_deepest(Enc, str, minim);
        /* in case useFirst is on and structure is found, end*/
        if (Enc->first && cnt > 0) return cnt;
      }
    }
  }
  return cnt;
}

  /* compatible base pair?*/
PRIVATE inline bool
compat(char a, char b){

  if (a=='A' && b=='U') return true;
  if (a=='C' && b=='G') return true;
  if (a=='G' && b=='U') return true;
  if (a=='U' && b=='A') return true;
  if (a=='G' && b=='C') return true;
  if (a=='U' && b=='G') return true;
  /* and with T's*/
  if (a=='A' && b=='T') return true;
  if (a=='T' && b=='A') return true;
  if (a=='G' && b=='T') return true;
  if (a=='T' && b=='G') return true;
  return false;
}

/* try insert base pair (i,j)*/
PRIVATE inline bool
try_insert(const short *pt, const char *seq, int i, int j){

  if (i<=0 || j<=0 || i>pt[0] || j>pt[0]) return false;
  return (j-i>MINGAP && pt[j]==0 && pt[i]==0 && compat(seq[i-1], seq[j-1]));
}

/*  try insert base pair (i,j) */
PRIVATE inline bool
try_insert_seq(const char *seq, int i, int j){
  if (i<=0 || j<=0) return false;
  return (j-i>MINGAP && compat(seq[i-1], seq[j-1]));
}

/* insertions move set*/
PRIVATE int
insertions(Encoded *Enc, struct_en *str, struct_en *minim){

  int cnt = 0;
  short *pt = str->structure;
  int len = pt[0];
  int i,j;

  for (i=1; i<=len; i++) {
    if (pt[i]==0) {
      for (j=i+1; j<=len; j++) {
        /* end if found closing bracket*/
        if (pt[j]!=0 && pt[j]<j) break;  /*')'*/
        if (pt[j]!=0 && pt[j]>j) {       /*'('*/
          j = pt[j];
          continue;
        }
        /* if conditions are met, do insert*/
        if (try_insert(pt, Enc->seq, i, j)) {
          Enc->bp_left=i;
          Enc->bp_right=j;

          if (Enc->noLP) {
            /* if lone bases occur, try inserting one another base*/
            if (lone_base(pt, i) || lone_base(pt, j)) {
              /* inside*/
              if (try_insert(pt, Enc->seq, i+1, j-1)) {
                Enc->bp_left2=i+1;
                Enc->bp_right2=j-1;
                cnt += update_deepest(Enc, str, minim);
                /* in case useFirst is on and structure is found, end*/
                if (Enc->first && cnt > 0) return cnt;
              } else  /*outside*/
              if (try_insert(pt, Enc->seq, i-1, j+1)) {
                Enc->bp_left2=i-1;
                Enc->bp_right2=j+1;
                cnt += update_deepest(Enc, str, minim);
                /* in case useFirst is on and structure is found, end*/
                if (Enc->first && cnt > 0) return cnt;
              }
            } else {
              cnt += update_deepest(Enc, str, minim);
              /* in case useFirst is on and structure is found, end*/
              if (Enc->first && cnt > 0) return cnt;
            }
          } else {
            cnt += update_deepest(Enc, str, minim);
            /* in case useFirst is on and structure is found, end*/
            if (Enc->first && cnt > 0) return cnt;
          }
        }
      }
    }
  }
  return cnt;
}

/*shift move set*/
PRIVATE int
shifts(Encoded *Enc, struct_en *str, struct_en *minim){

  int cnt = 0;
  int brack_num = 0;
  short *pt = str->structure;
  int len = pt[0];
  int i, k;

  for (i=1; i<=len; i++) {
    if (pt[i]!=0 && pt[i]>i) {  /*'('*/
      int j=pt[i];

      /* outer switch left*/
      if (Enc->verbose_lvl>1) fprintf(stderr, "%2d bracket %2d position, outer switch left\n", brack_num+1, i);
      for (k=i-1; k>0; k--) {
        if (pt[k]!=0 && pt[k]>k/*'('*/) break;
        if (pt[k]!=0 && pt[k]<k/*')'*/) {
          k = pt[k];
          continue;
        }
        /* checks*/
        if (pt[k]!=0) {
          fprintf(stderr, "WARNING: \'%c\'should be \'.\' at pos %d!\n", pt[k], k);
        }

        /* switch (i,j) to (k,j)*/
        if (j-k>MINGAP && compat(Enc->seq[k-1], Enc->seq[j-1])) {
          Enc->bp_left=-i;
          Enc->bp_right=-j;
          Enc->bp_left2=k;
          Enc->bp_right2=j;
          cnt += update_deepest(Enc, str, minim);
          /* in case useFirst is on and structure is found, end*/
          if (Enc->first && cnt > 0) return cnt;
        }

        /* switch (i,j) to (k,i)*/
        if (i-k>MINGAP && compat(Enc->seq[i-1], Enc->seq[k-1])) {
          Enc->bp_left=-i;
          Enc->bp_right=-j;
          Enc->bp_left2=k;
          Enc->bp_right2=i;
          cnt += update_deepest(Enc, str, minim);
          /* in case useFirst is on and structure is found, end*/
          if (Enc->first && cnt > 0) return cnt;

        }
      }

      /* outer switch right*/
      if (Enc->verbose_lvl>1) fprintf(stderr, "%2d bracket %2d position, outer switch right\n", brack_num+1, i);
      for (k=j+1; k<=len; k++) {
        if (pt[k]!=0 && pt[k]<k/*')'*/) break;
        if (pt[k]!=0 && pt[k]>k/*'('*/) {
          k = pt[k];
          continue;
        }

        /* check*/
        if (pt[k]!=0) {
          fprintf(stderr, "WARNING: \'%c\'should be \'.\' at pos %d!\n", pt[k], k);
        }
        /* switch (i,j) to (i,k)*/
        if (k-i>MINGAP && compat(Enc->seq[i-1], Enc->seq[k-1])) {
          Enc->bp_left=-i;
          Enc->bp_right=-j;
          Enc->bp_left2=i;
          Enc->bp_right2=k;
          cnt += update_deepest(Enc, str, minim);
          /* in case useFirst is on and structure is found, end*/
          if (Enc->first && cnt > 0) return cnt;
        }
        /* switch (i,j) to (j,k)*/
        if (k-j>MINGAP && compat(Enc->seq[j-1], Enc->seq[k-1])) {
          Enc->bp_left=-i;
          Enc->bp_right=-j;
          Enc->bp_left2=j;
          Enc->bp_right2=k;
          cnt += update_deepest(Enc, str, minim);
          /* in case useFirst is on and structure is found, end*/
          if (Enc->first && cnt > 0) return cnt;
        }
      }

      if (Enc->verbose_lvl>1) fprintf(stderr, "%2d bracket %2d position, inner switch\n", brack_num+1, i);
      /* inner switch*/
      for (k=i+1; k<j; k++) {
        /* jump to end of the sub-bracketing*/
        if (pt[k]!=0 && pt[k]>k/*'('*/) {
            k=pt[k];
            continue;
        }

        /* left switch (i,j) to (k,j)*/
        if (j-k>MINGAP && compat(Enc->seq[k-1], Enc->seq[j-1])) {
          Enc->bp_left=-i;
          Enc->bp_right=-j;
          Enc->bp_left2=k;
          Enc->bp_right2=j;
          cnt += update_deepest(Enc, str, minim);
          /* in case useFirst is on and structure is found, end*/
          if (Enc->first && cnt > 0) return cnt;
        }

        /* right switch (i,j) to (i,k)*/
        if (k-i>MINGAP && compat(Enc->seq[i-1], Enc->seq[k-1])) {
          Enc->bp_left=-i;
          Enc->bp_right=-j;
          Enc->bp_left2=i;
          Enc->bp_right2=k;
          cnt += update_deepest(Enc, str, minim);
          /* in case useFirst is on and structure is found, end*/
          if (Enc->first && cnt > 0) return cnt;
        }
      } /* end inner switch for*/
      brack_num++;
    } /* end if (pt[i]=='(')*/
  } /* end for in switches*/
  return cnt;
}

/* move to deepest (or first) neighbour*/
PRIVATE int
move_set(Encoded *Enc, struct_en *str){

  /* count how many times called*/
  cnt_move++;

  /* count better neighbours*/
  int cnt = 0;

  /* deepest descent*/
  struct_en min;
  min.structure = allocopy(str->structure);
  min.energy = str->energy;
  Enc->current_en = str->energy;

  if (Enc->verbose_lvl>0) { fprintf(stderr, "  start of MS:\n  "); print_str(stderr, str->structure); fprintf(stderr, " %d\n\n", str->energy); }

  /* if using first dont do all of them*/
  bool end = false;
  /* insertions*/
  if (!end) cnt += insertions(Enc, str, &min);
  if (Enc->first && cnt>0) end = true;
  if (Enc->verbose_lvl>1) fprintf(stderr, "\n");

  /* deletions*/
  if (!end) cnt += deletions(Enc, str, &min);
  if (Enc->first && cnt>0) end = true;

  /* shifts (only if enabled + noLP disabled)*/
  if (!end && Enc->shift && !Enc->noLP) {
    cnt += shifts(Enc, str, &min);
    if (Enc->first && cnt>0) end = true;
  }

  /* if degeneracy occurs, solve it!*/
  if (!end && (Enc->end_unpr - Enc->begin_unpr)>0) {
    Enc->processed[Enc->end_pr] = str->structure;
    Enc->end_pr++;
    str->structure = Enc->unprocessed[Enc->begin_unpr];
    Enc->unprocessed[Enc->begin_unpr]=NULL;
    Enc->begin_unpr++;
    cnt += move_set(Enc, str);
  } else {
    /* write output to str*/
    copy_arr(str->structure, min.structure);
    str->energy = min.energy;
  }
  /* release minimal*/
  free(min.structure);

  /* resolve degeneracy in local minima*/
  if ((Enc->end_pr - Enc->begin_pr)>0) {
    Enc->processed[Enc->end_pr]=str->structure;
    Enc->end_pr++;

    int min = find_min(Enc->processed, Enc->begin_pr, Enc->end_pr);
    short *tmp = Enc->processed[min];
    Enc->processed[min] = Enc->processed[Enc->begin_pr];
    Enc->processed[Enc->begin_pr] = tmp;
    str->structure = Enc->processed[Enc->begin_pr];
    Enc->begin_pr++;
    free_degen(Enc);
  }

  if (Enc->verbose_lvl>1 && !(Enc->first)) { fprintf(stderr, "\n  end of MS:\n  "); print_str(stderr, str->structure); fprintf(stderr, " %d\n\n", str->energy); }

  return cnt;
}

PRIVATE void
construct_moves(Encoded *Enc, short *structure){

  /* generate all possible moves (less than n^2)*/
  Enc->num_moves = 0;
  int i;
  for (i=1; i<=structure[0]; i++) {
    if (structure[i]!=0) {
      if (structure[i]<i) continue;
      Enc->moves_from[Enc->num_moves]=-i;
      Enc->moves_to[Enc->num_moves]=-structure[i];
      Enc->num_moves++;
      /* fprintf(stderr, "add  d(%d, %d)\n", i, str.structure[i]); */
    } else {
      int j;
      for (j=i+1; j<=structure[0]; j++) {
        /* fprintf(stderr, "check (%d, %d)\n", i, j); */
        if (structure[j]==0) {
          if (try_insert_seq(Enc->seq,i,j)) {
            Enc->moves_from[Enc->num_moves]=i;
            Enc->moves_to[Enc->num_moves]=j;
            Enc->num_moves++;
            /* fprintf(stderr, "add  i(%d, %d)\n", i, j); */
            continue;
          }
        } else if (structure[j]>j) { /*  '(' */
          j = structure[j];
        } else break;
      }
    }
  }

  /* permute them */
  for (i=0; i<Enc->num_moves-1; i++) {
    int rnd = rand();
    rnd = rnd % (Enc->num_moves-i) + i;
    int swp;
    swp = Enc->moves_from[i];
    Enc->moves_from[i]=Enc->moves_from[rnd];
    Enc->moves_from[rnd]=swp;
    swp = Enc->moves_to[i];
    Enc->moves_to[i]=Enc->moves_to[rnd];
    Enc->moves_to[rnd]=swp;
  }
}

PRIVATE int
move_rset(Encoded *Enc, struct_en *str){

  /* count how many times called*/
  cnt_move++;

  /* count better neighbours*/
  int cnt = 0;

  /* deepest descent*/
  struct_en min;
  min.structure = allocopy(str->structure);
  min.energy = str->energy;
  Enc->current_en = str->energy;

  if (Enc->verbose_lvl>0) { fprintf(stderr, "  start of MR:\n  "); print_str(stderr, str->structure); fprintf(stderr, " %d\n\n", str->energy); }

  /*  construct and permute possible moves */
  construct_moves(Enc, str->structure);

  /* find first lower one*/
  int i;
  for (i=0; i<Enc->num_moves; i++) {
    Enc->bp_left = Enc->moves_from[i];
    Enc->bp_right = Enc->moves_to[i];
    cnt = update_deepest(Enc, str, &min);
    if (cnt) break;
  }

  /* if degeneracy occurs, solve it!*/
  if (!cnt && (Enc->end_unpr - Enc->begin_unpr)>0) {
    Enc->processed[Enc->end_pr] = str->structure;
    Enc->end_pr++;
    str->structure = Enc->unprocessed[Enc->begin_unpr];
    Enc->unprocessed[Enc->begin_unpr]=NULL;
    Enc->begin_unpr++;
    cnt += move_rset(Enc, str);
  } else {
    /* write output to str*/
    copy_arr(str->structure, min.structure);
    str->energy = min.energy;
  }
  /* release minimal*/
  free(min.structure);

  /* resolve degeneracy in local minima*/
  if ((Enc->end_pr - Enc->begin_pr)>0) {
    Enc->processed[Enc->end_pr]=str->structure;
    Enc->end_pr++;

    int min = find_min(Enc->processed, Enc->begin_pr, Enc->end_pr);
    short *tmp = Enc->processed[min];
    Enc->processed[min] = Enc->processed[Enc->begin_pr];
    Enc->processed[Enc->begin_pr] = tmp;
    str->structure = Enc->processed[Enc->begin_pr];
    Enc->begin_pr++;
    free_degen(Enc);
  }

  return cnt;
}

/*check if base is lone*/
PRIVATE int
lone_base(short *pt, int i){

  if (i<=0 || i>pt[0]) return 0;
  /* is not a base pair*/
  if (pt[i]==0) return 0;

  /* base is lone:*/
  if (i-1>0) {
    /* is base pair and is the same bracket*/
    if (pt[i-1]!=0 && ((pt[i-1]<pt[pt[i-1]]) == (pt[i]<pt[pt[i]]))) return 0;
  }

  if (i+1<=pt[0]) {
    if (pt[i+1]!=0 && ((pt[i-1]<pt[pt[i-1]]) == (pt[i]<pt[pt[i]]))) return 0;
  }

  return 1;
}

/* if the structure has lone pairs*/
PRIVATE int
find_lone_pair(short* str){

  int i;
  for(i=1; i<str[0]; i++) {
    if (str[i]==0) continue; /* '.'*/

    if (str[i]>str[str[i]]) {  /* '('*/
      if (i+1==str[0] || str[i+1]==0 || str[i+1]<str[str[i+1]]) {
        return i;
      } else while (i+1!=str[0] && str[i+1]!=0 && str[i+1]>str[str[i+1]]) i++;
    }

    if (str[i]<str[str[i]]) {  /* ')'*/
      if (i+1==str[0] || str[i+1]==0 || str[i+1]>str[str[i+1]]) {
        return i;
      } else while (i+1!=str[0] && str[i+1]!=0 && str[i+1]<str[str[i+1]]) i++;
    }
  }

  return -1;
}

PUBLIC int
move_standard(char *seq,
              char *struc,
              enum MOVE_TYPE type,
              int verbosity_level,
              int shifts,
              int noLP){

  make_pair_matrix();

  short int *s0 = encode_sequence(seq, 0);
  short int *s1 = encode_sequence(seq, 1);
  short int *str = vrna_ptable(struc);

  int energy = 0;
  switch (type){
  case GRADIENT: energy = move_gradient(seq, str, s0, s1, verbosity_level, shifts, noLP); break;
  case FIRST: energy = move_first(seq, str, s0, s1, verbosity_level, shifts, noLP); break;
  case ADAPTIVE: energy = move_adaptive(seq, str, s0, s1, verbosity_level); break;
  }

  int i=1;
  for (; i<=str[0]; i++) {
    if (str[i]==0) struc[i-1]='.';
    else if (str[i]>str[str[i]]) struc[i-1]='(';
      else struc[i-1]=')';
  }

  free(s0);
  free(s1);
  free(str);

  return energy;
}

PUBLIC int
move_gradient(char *string,
              short *ptable,
              short *s,
              short *s1,
              int verbosity_level,
              int shifts,
              int noLP){

  cnt_move = 0;

  Encoded enc;
  enc.seq = string;
  enc.s0 = s;
  enc.s1 = s1;

  /* moves*/
  enc.bp_left=0;
  enc.bp_right=0;
  enc.bp_left2=0;
  enc.bp_right2=0;

  /* options*/
  enc.noLP=noLP;
  enc.verbose_lvl=verbosity_level;
  enc.first=0;
  enc.shift=shifts;

  /* degeneracy*/
  enc.begin_unpr=0;
  enc.begin_pr=0;
  enc.end_unpr=0;
  enc.end_pr=0;
  enc.current_en=0;

  /*  function */
  enc.funct=NULL;

  int i;
  for (i=0; i<MAX_DEGEN; i++) enc.processed[i]=enc.unprocessed[i]=NULL;

  struct_en str;
  str.structure = allocopy(ptable);
  str.energy = energy_of_structure_pt(enc.seq, str.structure, enc.s0, enc.s1, 0);

  while (move_set(&enc, &str)!=0) {
    free_degen(&enc);
  }
  free_degen(&enc);

  copy_arr(ptable, str.structure);
  free(str.structure);

  return str.energy;
}

PUBLIC int
move_first( char *string,
            short *ptable,
            short *s,
            short *s1,
            int verbosity_level,
            int shifts,
            int noLP){

  cnt_move = 0;

  Encoded enc;
  enc.seq = string;
  enc.s0 = s;
  enc.s1 = s1;

  /* moves*/
  enc.bp_left=0;
  enc.bp_right=0;
  enc.bp_left2=0;
  enc.bp_right2=0;

  /* options*/
  enc.noLP=noLP;
  enc.verbose_lvl=verbosity_level;
  enc.first=1;
  enc.shift=shifts;

  /* degeneracy*/
  enc.begin_unpr=0;
  enc.begin_pr=0;
  enc.end_unpr=0;
  enc.end_pr=0;
  enc.current_en=0;

  /*  function */
  enc.funct=NULL;

  int i;
  for (i=0; i<MAX_DEGEN; i++) enc.processed[i]=enc.unprocessed[i]=NULL;

  struct_en str;
  str.structure = allocopy(ptable);
  str.energy = energy_of_structure_pt(enc.seq, str.structure, enc.s0, enc.s1, 0);

  while (move_set(&enc, &str)!=0) {
    free_degen(&enc);
  }
  free_degen(&enc);

  copy_arr(ptable, str.structure);
  free(str.structure);

  return str.energy;
}

PUBLIC int
move_adaptive(char *string,
              short *ptable,
              short *s,
              short *s1,
              int verbosity_level){

  srand(time(NULL));

  cnt_move = 0;

  Encoded enc;
  enc.seq = string;
  enc.s0 = s;
  enc.s1 = s1;

  /* moves*/
  enc.bp_left=0;
  enc.bp_right=0;
  enc.bp_left2=0;
  enc.bp_right2=0;

  /* options*/
  enc.noLP=0;
  enc.verbose_lvl=verbosity_level;
  enc.first=1;
  enc.shift=0;

  /* degeneracy*/
  enc.begin_unpr=0;
  enc.begin_pr=0;
  enc.end_unpr=0;
  enc.end_pr=0;
  enc.current_en=0;

  /*  function */
  enc.funct=NULL;

  /*  allocate memory for moves */
  enc.moves_from = (int*) vrna_alloc(ptable[0]*ptable[0]*sizeof(int));
  enc.moves_to = (int*) vrna_alloc(ptable[0]*ptable[0]*sizeof(int));

  int i;
  for (i=0; i<MAX_DEGEN; i++) enc.processed[i]=enc.unprocessed[i]=NULL;

  struct_en str;
  str.structure = allocopy(ptable);
  str.energy = energy_of_structure_pt(enc.seq, str.structure, enc.s0, enc.s1, 0);

  while (move_rset(&enc, &str)!=0) {
    free_degen(&enc);
  }
  free_degen(&enc);

  copy_arr(ptable, str.structure);
  free(str.structure);
  free(enc.moves_from);
  free(enc.moves_to);

  return str.energy;
}

PUBLIC int
browse_neighs(char *seq,
              char *struc,
              int verbosity_level,
              int shifts,
              int noLP,
              int (*funct) (struct_en*, struct_en*)){

  make_pair_matrix();

  short int *s0 = encode_sequence(seq, 0);
  short int *s1 = encode_sequence(seq, 1);
  short int *str = vrna_ptable(struc);

  int res = browse_neighs_pt(seq, str, s0, s1, verbosity_level, shifts, noLP, funct);

  free(s0);
  free(s1);
  free(str);

  return res;
}

PUBLIC int
browse_neighs_pt( char *string,
                  short *ptable,
                  short *s,
                  short *s1,
                  int verbosity_level,
                  int shifts,
                  int noLP,
                  int (*funct) (struct_en*, struct_en*)){

  cnt_move = 0;

  Encoded enc;
  enc.seq = string;
  enc.s0 = s;
  enc.s1 = s1;

  /* moves*/
  enc.bp_left=0;
  enc.bp_right=0;
  enc.bp_left2=0;
  enc.bp_right2=0;

  /* options*/
  enc.noLP=noLP;
  enc.verbose_lvl=verbosity_level;
  enc.first=1;
  enc.shift=shifts;

  /* degeneracy*/
  enc.begin_unpr=0;
  enc.begin_pr=0;
  enc.end_unpr=0;
  enc.end_pr=0;
  enc.current_en=0;

  /*  function */
  enc.funct=funct;

  int i;
  for (i=0; i<MAX_DEGEN; i++) enc.processed[i]=enc.unprocessed[i]=NULL;

  struct_en str;
  str.structure = allocopy(ptable);
  str.energy = energy_of_structure_pt(enc.seq, str.structure, enc.s0, enc.s1, 0);

  move_set(&enc, &str);
  free_degen(&enc);

  copy_arr(ptable, str.structure);
  free(str.structure);

  return str.energy;
}

/* printf*/
PUBLIC void
print_stren(FILE *out, struct_en *str) {
  print_str(out, str->structure);
  fprintf(out, " %6.2f\n", str->energy/100.0);
}

PUBLIC void
print_str(FILE *out, short *str) {
  int i;
  for (i=1; i<=str[0]; i++) {
    if (str[i]==0) fprintf(out, ".");
    else if (str[i]<i) fprintf(out, ")");
    else fprintf(out, "(");
  }
}


#ifdef TEST_MOVESET
/*  sample usage: */
int main() {
  char seq[20] = "ACCCCCCTCTGTAGGGGGA";
  char str[20] = ".((.(.........).)).";

  /*  move to the local minimum and display it */
  int energy = move_standard(seq, str, GRADIENT, 0, 0, 0);
  fprintf(stdout, "%s %6.2f\n\n", str, energy/100.0);

  /* now create an array of every structure in neighbourhood of str structure */
  struct_en *list = NULL;
  int list_length = 0;

  int get_list(struct_en *new_one, struct_en *old_one)
  {
    /*  enlarge the list */
    list_length++;
    list = (struct_en*) realloc(list, list_length*sizeof(struct_en));

    /*  copy the structure */
    list[list_length-1].energy = new_one->energy;
    list[list_length-1].structure = allocopy(new_one->structure);

    /*  we want to continue -> return 0 */
    return 0;
  }
  browse_neighs(seq, str, 0, 0, 0, get_list);

  /*  print them and free the memory: */
  int i;
  for (i=0; i<list_length; i++) {
    print_stren(stdout, &list[i]);
    free(list[i].structure);
  }
  free(list);

  return 0;
}

#endif

gquad.c/        0           0     0     644     30026     `
/*
  gquad.c

  Ronny Lorenz 2012

  Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

#include "fold_vars.h"
#include "data_structures.h"
#include "energy_const.h"
#include "utils.h"
#include "aln_util.h"
#include "gquad.h"

#ifndef INLINE
#ifdef __GNUC__
# define INLINE inline
#else
# define INLINE
#endif
#endif

/**
 *  Use this macro to loop over each G-quadruplex
 *  delimited by a and b within the subsequence [c,d]
 */
#define FOR_EACH_GQUAD(a, b, c, d)  \
          for((a) = (d) - VRNA_GQUAD_MIN_BOX_SIZE + 1; (a) >= (c); (a)--)\
            for((b) = (a) + VRNA_GQUAD_MIN_BOX_SIZE - 1;\
                (b) <= MIN2((d), (a) + VRNA_GQUAD_MAX_BOX_SIZE - 1);\
                (b)++)

/**
 *  This macro does almost the same as FOR_EACH_GQUAD() but keeps
 *  the 5' delimiter fixed. 'b' is the 3' delimiter of the gquad,
 *  for gquads within subsequence [a,c] that have 5' delimiter 'a'
 */
#define FOR_EACH_GQUAD_AT(a, b, c)  \
          for((b) = (a) + VRNA_GQUAD_MIN_BOX_SIZE - 1;\
              (b) <= MIN2((c), (a) + VRNA_GQUAD_MAX_BOX_SIZE - 1);\
              (b)++)


/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/

PRIVATE INLINE
int *
get_g_islands(short *S);

PRIVATE INLINE
int *
get_g_islands_sub(short *S, int i, int j);

/**
 *  IMPORTANT:
 *  If you don't know how to use this function, DONT'T USE IT!
 *
 *  The function pointer this function takes as argument is
 *  used for individual calculations with each g-quadruplex
 *  delimited by [i,j].
 *  The function it points to always receives as first 3 arguments
 *  position i, the stack size L and an array l[3] containing the
 *  individual linker sizes.
 *  The remaining 4 (void *) pointers of the callback function receive
 *  the parameters 'data', 'P', 'aux1' and 'aux2' and thus may be
 *  used to pass whatever data you like to.
 *  As the names of those parameters suggest the convention is that
 *  'data' should be used as a pointer where data is stored into,
 *  e.g the MFE or PF and the 'P' parameter should actually be a
 *  'vrna_param_t *' or 'vrna_exp_param_t *' type.
 *  However, what you actually pass obviously depends on the
 *  function the pointer is pointing to.
 *
 *  Although all of this may look like an overkill, it is found
 *  to be almost as fast as implementing g-quadruplex enumeration
 *  in each individual scenario, i.e. code duplication.
 *  Using this function, however, ensures that all g-quadruplex
 *  enumerations are absolutely identical.
 */
PRIVATE
void
process_gquad_enumeration(int *gg,
                          int i,
                          int j,
                          void (*f)(int, int, int *,
                                    void *, void *, void *, void *),
                          void *data,
                          void *P,
                          void *aux1,
                          void *aux2);

/**
 *  MFE callback for process_gquad_enumeration()
 */
PRIVATE
void
gquad_mfe(int i,
          int L,
          int *l,
          void *data,
          void *P,
          void *NA,
          void *NA2);

PRIVATE
void
gquad_mfe_pos(int i,
              int L,
              int *l,
              void *data,
              void *P,
              void *Lmfe,
              void *lmfe);

PRIVATE
void
gquad_pos_exhaustive( int i,
                      int L,
                      int *l,
                      void *data,
                      void *P,
                      void *Lex,
                      void *lex);

/**
 * Partition function callback for process_gquad_enumeration()
 */
PRIVATE
void
gquad_pf( int i,
          int L,
          int *l,
          void *data,
          void *P,
          void *NA,
          void *NA2);

/**
 * Partition function callback for process_gquad_enumeration()
 * in contrast to gquad_pf() it stores the stack size L and
 * the linker lengths l[3] of the g-quadruplex that dominates
 * the interval [i,j]
 * (FLT_OR_DBL *)data must be 0. on entry
 */
PRIVATE
void
gquad_pf_pos( int i,
              int L,
              int *l,
              void *data,
              void *pf,
              void *Lmax,
              void *lmax);

/**
 * MFE (alifold) callback for process_gquad_enumeration()
 */
PRIVATE
void
gquad_mfe_ali(int i,
              int L,
              int *l,
              void *data,
              void *P,
              void *S,
              void *n_seq);

/**
 * MFE (alifold) callback for process_gquad_enumeration()
 * with seperation of free energy and penalty contribution
 */
PRIVATE
void
gquad_mfe_ali_en( int i,
                  int L,
                  int *l,
                  void *data,
                  void *P,
                  void *S,
                  void *n_seq);

PRIVATE
void
gquad_interact( int i,
                int L,
                int *l,
                void *data,
                void *pf,
                void *index,
                void *NA2);

PRIVATE
void
gquad_count(int i,
            int L,
            int *l,
            void *data,
            void *NA,
            void *NA2,
            void *NA3);

PRIVATE
void
gquad_count_layers( int i,
                    int L,
                    int *l,
                    void *data,
                    void *NA,
                    void *NA2,
                    void *NA3);

/* other useful static functions */

PRIVATE
int
gquad_ali_penalty(int i,
                  int L,
                  int l[3],
                  const short **S,
                  vrna_param_t *P);

PRIVATE int **
create_L_matrix(short *S,
                int start,
                int maxdist,
                int n,
                int **g,
                vrna_param_t *P);

/*
#########################################
# BEGIN OF PUBLIC FUNCTION DEFINITIONS  #
#      (all available in RNAlib)        #
#########################################
*/

/********************************
  Here are the G-quadruplex energy
  contribution functions
*********************************/

PUBLIC int E_gquad( int L,
                    int l[3],
                    vrna_param_t *P){

  int i, c = INF;

  for(i=0;i<3;i++){
    if(l[i] > VRNA_GQUAD_MAX_LINKER_LENGTH) return c;
    if(l[i] < VRNA_GQUAD_MIN_LINKER_LENGTH) return c;
  }
  if(L > VRNA_GQUAD_MAX_STACK_SIZE) return c;
  if(L < VRNA_GQUAD_MIN_STACK_SIZE) return c;
  
  gquad_mfe(0, L, l,
            (void *)(&c),
            (void *)P,
            NULL,
            NULL);
  return c;
}

PUBLIC FLT_OR_DBL exp_E_gquad(int L,
                              int l[3],
                              vrna_exp_param_t *pf){

  int i;
  FLT_OR_DBL q = 0.;

  for(i=0;i<3;i++){
    if(l[i] > VRNA_GQUAD_MAX_LINKER_LENGTH) return q;
    if(l[i] < VRNA_GQUAD_MIN_LINKER_LENGTH) return q;
  }
  if(L > VRNA_GQUAD_MAX_STACK_SIZE) return q;
  if(L < VRNA_GQUAD_MIN_STACK_SIZE) return q;

  gquad_pf( 0, L, l,
            (void *)(&q),
            (void *)pf,
            NULL,
            NULL);
  return q;
}

PUBLIC int E_gquad_ali( int i,
                        int L,
                        int l[3],
                        const short **S,
                        int n_seq,
                        vrna_param_t *P){

  int en[2];
  E_gquad_ali_en(i, L, l, S, n_seq, en, P);
  return en[0] + en[1];
}


PUBLIC void E_gquad_ali_en( int i,
                            int L,
                            int l[3],
                            const short **S,
                            int n_seq,
                            int en[2],
                            vrna_param_t *P){

  int j;
  en[0] = en[1] = INF;

  for(j=0;j<3;j++){
    if(l[j] > VRNA_GQUAD_MAX_LINKER_LENGTH) return;
    if(l[j] < VRNA_GQUAD_MIN_LINKER_LENGTH) return;
  }
  if(L > VRNA_GQUAD_MAX_STACK_SIZE) return;
  if(L < VRNA_GQUAD_MIN_STACK_SIZE) return;

  gquad_mfe_ali_en( i, L, l,
                    (void *)(&(en[0])),
                    (void *)P,
                    (void *)S,
                    (void *)(&n_seq));
}

/********************************
  Now, the triangular matrix
  generators for the G-quadruplex
  contributions are following
*********************************/

PUBLIC int *get_gquad_matrix(short *S, vrna_param_t *P){

  int n, size, i, j, *gg, *my_index, *data;

  n         = S[0];
  my_index  = vrna_idx_col_wise(n);
  gg        = get_g_islands(S);
  size      = (n * (n+1))/2 + 2;
  data      = (int *)vrna_alloc(sizeof(int) * size);

  /* prefill the upper triangular matrix with INF */
  for(i = 0; i < size; i++) data[i] = INF;

  FOR_EACH_GQUAD(i, j, 1, n){
    process_gquad_enumeration(gg, i, j,
                              &gquad_mfe,
                              (void *)(&(data[my_index[j]+i])),
                              (void *)P,
                              NULL,
                              NULL);
  }

  free(my_index);
  free(gg);
  return data;
}

PUBLIC FLT_OR_DBL *get_gquad_pf_matrix( short *S,
                                        FLT_OR_DBL *scale,
                                        vrna_exp_param_t *pf){

  int n, size, *gg, i, j, *my_index;
  FLT_OR_DBL *data;


  n         = S[0];
  size      = (n * (n+1))/2 + 2;
  data      = (FLT_OR_DBL *)vrna_alloc(sizeof(FLT_OR_DBL) * size);
  gg        = get_g_islands(S);
  my_index  = vrna_idx_row_wise(n);

  FOR_EACH_GQUAD(i, j, 1, n){
    process_gquad_enumeration(gg, i, j,
                              &gquad_pf,
                              (void *)(&(data[my_index[i]-j])),
                              (void *)pf,
                              NULL,
                              NULL);
    data[my_index[i]-j] *= scale[j-i+1];
  }

  free(my_index);
  free(gg);
  return data;
}

PUBLIC int *get_gquad_ali_matrix( short *S_cons,
                                  short **S,
                                  int n_seq,
                                  vrna_param_t *P){

  int n, size, *data, *gg;
  int i, j, *my_index;


  n         = S[0][0];
  size      = (n * (n+1))/2 + 2;
  data      = (int *)vrna_alloc(sizeof(int) * size);
  gg        = get_g_islands(S_cons);
  my_index  = vrna_idx_col_wise(n);

  /* prefill the upper triangular matrix with INF */
  for(i=0;i<size;i++) data[i] = INF;

  FOR_EACH_GQUAD(i, j, 1, n){
    process_gquad_enumeration(gg, i, j,
                              &gquad_mfe_ali,
                              (void *)(&(data[my_index[j]+i])),
                              (void *)P,
                              (void *)S,
                              (void *)(&n_seq));
  }

  free(my_index);
  free(gg);
  return data;
}

PUBLIC int **get_gquad_L_matrix(short *S,
                                int start,
                                int maxdist,
                                int n,
                                int **g,
                                vrna_param_t *P){

  return create_L_matrix(S, start, maxdist, n, g, P);
}

PUBLIC void
vrna_gquad_mx_local_update( vrna_fold_compound_t *vc,
                            int start){

  vc->matrices->ggg_local = create_L_matrix(
                              vc->sequence_encoding,
                              start,
                              vc->window_size,
                              vc->length,
                              vc->matrices->ggg_local,
                              vc->params);
}

PRIVATE int **
create_L_matrix(short *S,
                int start,
                int maxdist,
                int n,
                int **g,
                vrna_param_t *P){

  int **data;
  int i, j, k, *gg;

  gg  = get_g_islands_sub(S, start, MIN2(n, start + maxdist + 4));

  if(g){ /* we just update the gquadruplex contribution for the current
            start and rotate the rest */
    data = g;
    /* we re-use the memory allocated previously */
    data[start] = data[start + maxdist + 5];
    data[start + maxdist + 5] = NULL;

    /* prefill with INF */
    for(i = 0; i < maxdist + 5; i++)
      data[start][i] = INF;

    /*  now we compute contributions for all gquads with 5' delimiter at
        position 'start'
    */
    FOR_EACH_GQUAD_AT(start, j, start + maxdist + 4){
      process_gquad_enumeration(gg, start, j,
                                &gquad_mfe,
                                (void *)(&(data[start][j-start])),
                                (void *)P,
                                NULL,
                                NULL);
    }

  } else { /* create a new matrix from scratch since this is the first
              call to this function */

    /* allocate memory and prefill with INF */
    data = (int **) vrna_alloc(sizeof(int *) * (n+1));
    for(k = n; (k>n-maxdist-5) && (k>=0); k--){
      data[k] = (int *) vrna_alloc(sizeof(int)*(maxdist+5));
      for(i = 0; i < maxdist+5; i++) data[k][i] = INF;
    }
    
    /* compute all contributions for the gquads in this interval */
    FOR_EACH_GQUAD(i, j, n - maxdist - 4, n){
      process_gquad_enumeration(gg, i, j,
                                &gquad_mfe,
                                (void *)(&(data[i][j-i])),
                                (void *)P,
                                NULL,
                                NULL);
    }
  }

  gg += start - 1;
  free(gg);
  return data;
}

PUBLIC plist *get_plist_gquad_from_db(const char *structure, float pr){
  int x, size, actual_size, L, n, ge, ee, gb, l[3];
  plist *pl;

  actual_size = 0;
  ge          = 0;
  n           = 2;
  size        = strlen(structure);
  pl          = (plist *)vrna_alloc(n*size*sizeof(plist));

  while((ee = parse_gquad(structure + ge, &L, l)) > 0){
    ge += ee;
    gb = ge - L*4 - l[0] - l[1] - l[2] + 1;
    /* add pseudo-base pair encloding gquad */
    for(x = 0; x < L; x++){
      if (actual_size >= n * size - 5){
        n *= 2;
        pl = (plist *)vrna_realloc(pl, n * size * sizeof(plist));
      }
      pl[actual_size].i = gb + x;
      pl[actual_size].j = ge + x - L + 1;
      pl[actual_size].p = pr;
      pl[actual_size++].type = 0;

      pl[actual_size].i = gb + x;
      pl[actual_size].j = gb + x + l[0] + L;
      pl[actual_size].p = pr;
      pl[actual_size++].type = 0;

      pl[actual_size].i = gb + x + l[0] + L;
      pl[actual_size].j = ge + x - 2*L - l[2] + 1;
      pl[actual_size].p = pr;
      pl[actual_size++].type = 0;

      pl[actual_size].i = ge + x - 2*L - l[2] + 1;
      pl[actual_size].j = ge + x - L + 1;
      pl[actual_size].p = pr;
      pl[actual_size++].type = 0;
    }
  } 

  pl[actual_size].i = pl[actual_size].j = 0;
  pl[actual_size++].p = 0;
  pl = (plist *)vrna_realloc(pl, actual_size * sizeof(plist));
  return pl;
}

PUBLIC void get_gquad_pattern_mfe(short *S,
                                  int i,
                                  int j,
                                  vrna_param_t *P,
                                  int *L,
                                  int l[3]){

  int *gg = get_g_islands_sub(S, i, j);
  int c = INF;

  process_gquad_enumeration(gg, i, j,
                            &gquad_mfe_pos,
                            (void *)(&c),
                            (void *)P,
                            (void *)L,
                            (void *)l);

  gg += i - 1;
  free(gg);
}

PUBLIC void
get_gquad_pattern_exhaustive( short *S,
                              int i,
                              int j,
                              vrna_param_t *P,
                              int *L,
                              int *l,
                              int threshold){

  int *gg = get_g_islands_sub(S, i, j);

  process_gquad_enumeration(gg, i, j,
                            &gquad_pos_exhaustive,
                            (void *)(&threshold),
                            (void *)P,
                            (void *)L,
                            (void *)l);

  gg += i - 1;
  free(gg);
}

PUBLIC void get_gquad_pattern_pf( short *S,
                                  int i,
                                  int j,
                                  vrna_exp_param_t *pf,
                                  int *L,
                                  int l[3]){

  int *gg = get_g_islands_sub(S, i, j);
  FLT_OR_DBL q = 0.;

  process_gquad_enumeration(gg, i, j,
                            &gquad_pf_pos,
                            (void *)(&q),
                            (void *)pf,
                            (void *)L,
                            (void *)l);

  gg += i - 1;
  free(gg);
}

PUBLIC plist *get_plist_gquad_from_pr(short *S,
                                      int gi,
                                      int gj,
                                      FLT_OR_DBL *G,
                                      FLT_OR_DBL *probs,
                                      FLT_OR_DBL *scale,
                                      vrna_exp_param_t *pf){

  int L, l[3];
  return  get_plist_gquad_from_pr_max(S, gi, gj, G, probs, scale, &L, l, pf);
}


PUBLIC plist *get_plist_gquad_from_pr_max(short *S,
                                      int gi,
                                      int gj,
                                      FLT_OR_DBL *G,
                                      FLT_OR_DBL *probs,
                                      FLT_OR_DBL *scale,
                                      int *Lmax,
                                      int lmax[3],
                                      vrna_exp_param_t *pf){ 

  int n, size, *gg, counter, i, j, *my_index;
  FLT_OR_DBL pp, *tempprobs;
  plist *pl;
  
  n         = S[0];
  size      = (n * (n + 1))/2 + 2;
  tempprobs = (FLT_OR_DBL *)vrna_alloc(sizeof(FLT_OR_DBL) * size);
  pl        = (plist *)vrna_alloc((S[0]*S[0])*sizeof(plist));
  gg        = get_g_islands_sub(S, gi, gj);
  counter   = 0;
  my_index  = vrna_idx_row_wise(n);

  process_gquad_enumeration(gg, gi, gj,
                            &gquad_interact,
                            (void *)tempprobs,
                            (void *)pf,
                            (void *)my_index,
                            NULL);

  pp = 0.;
  process_gquad_enumeration(gg, gi, gj,
                            &gquad_pf_pos,
                            (void *)(&pp),
                            (void *)pf,
                            (void *)Lmax,
                            (void *)lmax);

  pp = probs[my_index[gi]-gj] * scale[gj-gi+1] / G[my_index[gi]-gj];
  for (i=gi;i<gj; i++) {
    for (j=i; j<=gj; j++) {
      if (tempprobs[my_index[i]-j]>0.) {
        pl[counter].i=i;
        pl[counter].j=j;
        pl[counter++].p = pp * tempprobs[my_index[i]-j];
      }
    }
  }
  pl[counter].i = pl[counter].j = 0;
  pl[counter++].p = 0.;
  /* shrink memory to actual size needed */
  pl = (plist *) vrna_realloc(pl, counter * sizeof(plist));

  gg += gi - 1; free(gg);
  free(my_index);
  free (tempprobs);
  return pl;
}

PUBLIC int
get_gquad_count(short *S,
                int i,
                int j){

  int *gg     = get_g_islands_sub(S, i, j);
  int p,q,counter = 0;

  FOR_EACH_GQUAD(p, q, i, j)
    process_gquad_enumeration(gg, p, q,
                              &gquad_count,
                              (void *)(&counter),
                              NULL,
                              NULL,
                              NULL);

  gg += i - 1;
  free(gg);
  return counter;
}

PUBLIC int
get_gquad_layer_count(short *S,
                      int i,
                      int j){

  int *gg     = get_g_islands_sub(S, i, j);
  int p,q,counter = 0;

  FOR_EACH_GQUAD(p, q, i, j)
    process_gquad_enumeration(gg, p, q,
                              &gquad_count_layers,
                              (void *)(&counter),
                              NULL,
                              NULL,
                              NULL);

  gg += i - 1;
  free(gg);
  return counter;
}

PUBLIC int parse_gquad(const char *struc, int *L, int l[3]) {
  int i, il, start, end, len;

  for (i=0; struc[i] && struc[i]!='+'; i++);
  if (struc[i] == '+') { /* start of gquad */
    for (il=0; il<=3; il++) {
      start=i; /* pos of first '+' */
      while (struc[++i] == '+'){
        if((il) && (i-start == *L))
          break;
      }
      end=i; len=end-start; 
      if (il==0) *L=len;
      else if (len!=*L)
        vrna_message_error("unequal stack lengths in gquad");
      if (il==3) break;
      while (struc[++i] == '.'); /* linker */
      l[il] = i-end;
      if (struc[i] != '+')
        vrna_message_error("illegal character in gquad linker region");
    }
  }
  else return 0;
  /* printf("gquad at %d %d %d %d %d\n", end, *L, l[0], l[1], l[2]); */
  return end;
}



/*
#########################################
# BEGIN OF PRIVATE FUNCTION DEFINITIONS #
#          (internal use only)          #
#########################################
*/

PRIVATE int gquad_ali_penalty(int i,
                              int L,
                              int l[3],
                              const short **S,
                              vrna_param_t *P){

  int s, cnt;
  int penalty     = 0;
  int gg_mismatch = 0;

  /* check for compatibility in the alignment */
  for(s = 0; S[s]; s++){
    unsigned int  ld  = 0; /* !=0 if layer destruction was detected */
    int           pen = 0;

    /* check bottom layer */
    if(S[s][i] != 3)                            ld |= 1U;
    if(S[s][i + L + l[0]] != 3)                 ld |= 2U;
    if(S[s][i + 2*L + l[0] + l[1]] != 3)        ld |= 4U;
    if(S[s][i + 3*L + l[0] + l[1] + l[2]] != 3) ld |= 8U;
     /* add 1x penalty for missing bottom layer */
    if(ld) pen += VRNA_GQUAD_MISMATCH_PENALTY;

    /* check top layer */
    ld = 0;
    if(S[s][i + L - 1] != 3)                        ld |= 1U;
    if(S[s][i + 2*L + l[0] - 1] != 3)               ld |= 2U;
    if(S[s][i + 3*L + l[0] + l[1] - 1] != 3)        ld |= 4U;
    if(S[s][i + 4*L + l[0] + l[1] + l[2] - 1] != 3) ld |= 8U;
     /* add 1x penalty for missing top layer */
    if(ld) pen += VRNA_GQUAD_MISMATCH_PENALTY;

    /* check inner layers */
    for(cnt=1;cnt<L-1;cnt++){
      if(S[s][i + cnt] != 3)                            ld |= 1U;
      if(S[s][i + L + l[0] + cnt] != 3)                 ld |= 2U;
      if(S[s][i + 2*L + l[0] + l[1] + cnt] != 3)        ld |= 4U;
      if(S[s][i + 3*L + l[0] + l[1] + l[2] + cnt] != 3) ld |= 8U;
      /* add 2x penalty for missing inner layer */
      if(ld) pen += 2*VRNA_GQUAD_MISMATCH_PENALTY;
    }

    /* if all layers are missing, we have a complete gg mismatch */
    if(pen >= (2*VRNA_GQUAD_MISMATCH_PENALTY * (L-1)))
      gg_mismatch++;

    /* add the penalty to the score */
    penalty += pen;
  }
  /* if gg_mismatch exceeds maximum allowed, this g-quadruplex is forbidden */
  if(gg_mismatch > VRNA_GQUAD_MISMATCH_NUM_ALI) return INF;
  else return penalty;
}


PRIVATE void gquad_mfe( int i,
                        int L,
                        int *l,
                        void *data,
                        void *P,
                        void *NA,
                        void *NA2){

  int cc = ((vrna_param_t *)P)->gquad[L][l[0] + l[1] + l[2]];
  if(cc < *((int *)data))
    *((int *)data) = cc;
}

PRIVATE void gquad_mfe_pos( int i,
                            int L,
                            int *l,
                            void *data,
                            void *P,
                            void *Lmfe,
                            void *lmfe){

  int cc = ((vrna_param_t *)P)->gquad[L][l[0] + l[1] + l[2]];
  if(cc < *((int *)data)){
    *((int *)data)        = cc;
    *((int *)Lmfe)        = L;
    *((int *)lmfe)        = l[0];
    *(((int *)lmfe) + 1)  = l[1];
    *(((int *)lmfe) + 2)  = l[2];
  }
}

PRIVATE
void
gquad_pos_exhaustive( int i,
                      int L,
                      int *l,
                      void *data,
                      void *P,
                      void *Lex,
                      void *lex){

  int cnt;
  int cc = ((vrna_param_t *)P)->gquad[L][l[0] + l[1] + l[2]];
  if(cc <= *((int *)data)){
    /*  since Lex is an array of L values and lex an
        array of l triples we need to find out where
        the current gquad position is to be stored...
		the below implementation might be slow but we
		still use it for now
    */
    for(cnt = 0; ((int *)Lex)[cnt] != -1; cnt++);

    *((int *)Lex + cnt)           = L;
    *((int *)Lex + cnt + 1)       = -1;
    *(((int *)lex) + (3*cnt) + 0) = l[0];
    *(((int *)lex) + (3*cnt) + 1) = l[1];
    *(((int *)lex) + (3*cnt) + 2) = l[2];
  }
}

PRIVATE
void
gquad_count(int i,
            int L,
            int *l,
            void *data,
            void *NA,
            void *NA2,
            void *NA3){

  *((int *)data) += 1;
}

PRIVATE
void
gquad_count_layers( int i,
                    int L,
                    int *l,
                    void *data,
                    void *NA,
                    void *NA2,
                    void *NA3){

  *((int *)data) += L;
}


PRIVATE void gquad_pf(int i,
                      int L,
                      int *l,
                      void *data,
                      void *pf,
                      void *NA,
                      void *NA2){

  *((FLT_OR_DBL *)data) += ((vrna_exp_param_t *)pf)->expgquad[L][l[0] + l[1] + l[2]];
}

PRIVATE void gquad_pf_pos(int i,
                          int L,
                          int *l,
                          void *data,
                          void *pf,
                          void *Lmax,
                          void *lmax){

  FLT_OR_DBL gq = ((vrna_exp_param_t *)pf)->expgquad[L][l[0] + l[1] + l[2]];
  if(gq > *((FLT_OR_DBL *)data)){
    *((FLT_OR_DBL *)data) = gq;
    *((int *)Lmax)        = L;
    *((int *)lmax)        = l[0];
    *(((int *)lmax) + 1)  = l[1];
    *(((int *)lmax) + 2)  = l[2];
  }
}

PRIVATE void gquad_mfe_ali( int i,
                            int L,
                            int *l,
                            void *data,
                            void *P,
                            void *S,
                            void *n_seq){

  int j, en[2], cc;
  en[0] = en[1] = INF;

  for(j=0;j<3;j++){
    if(l[j] > VRNA_GQUAD_MAX_LINKER_LENGTH) return;
    if(l[j] < VRNA_GQUAD_MIN_LINKER_LENGTH) return;
  }
  if(L > VRNA_GQUAD_MAX_STACK_SIZE) return;
  if(L < VRNA_GQUAD_MIN_STACK_SIZE) return;

  gquad_mfe_ali_en(i, L, l, (void *)(&(en[0])), P, S, n_seq);
  if(en[1] != INF){
    cc  = en[0] + en[1];
    if(cc < *((int *)data)) *((int *)data) = cc;
  }
}

PRIVATE void gquad_mfe_ali_en(int i,
                              int L,
                              int *l,
                              void *data,
                              void *P,
                              void *S,
                              void *n_seq){

  int en[2], cc, dd;
  en[0] = ((vrna_param_t *)P)->gquad[L][l[0] + l[1] + l[2]] * (*(int *)n_seq);
  en[1] = gquad_ali_penalty(i, L, l, (const short **)S, (vrna_param_t *)P);
  if(en[1] != INF){
    cc = en[0] + en[1];
    dd = ((int *)data)[0] + ((int *)data)[1];
    if(cc < dd){
      ((int *)data)[0] = en[0];
      ((int *)data)[1] = en[1];
    }
  }
}

PRIVATE void gquad_interact(int i,
                      int L,
                      int *l,
                      void *data,
                      void *pf,
                      void *index,
                      void *NA2){

  int x, *idx;
  FLT_OR_DBL gq, *pp;

  idx = (int *)index;
  pp  = (FLT_OR_DBL *)data;
  gq  = exp_E_gquad(L, l, (vrna_exp_param_t *)pf);

  for(x = 0; x < L; x++){
    pp[idx[i + x] - (i + x + 3*L + l[0] + l[1] + l[2])] += gq;
    pp[idx[i + x] - (i + x + L + l[0])] += gq;
    pp[idx[i + x + L + l[0]] - (i + x + 2*L + l[0] + l[1])] += gq;
    pp[idx[i + x + 2*L + l[0] + l[1]] - (i + x + 3*L + l[0] + l[1] + l[2])] += gq;
  }
  
}

PRIVATE INLINE int *get_g_islands(short *S){
  return get_g_islands_sub(S, 1, S[0]);
}

PRIVATE INLINE int *get_g_islands_sub(short *S, int i, int j){
  int x, *gg;

  gg = (int *)vrna_alloc(sizeof(int)*(j-i+2));
  gg -= i - 1;

  if(S[j]==3) gg[j] = 1;
  for(x = j - 1; x >= i; x--)
    if(S[x] == 3)
      gg[x] = gg[x+1]+1;

  return gg;
}

/**
 *  We could've also created a macro that loops over all G-quadruplexes
 *  delimited by i and j. However, for the fun of it we use this function
 *  that receives a pointer to a callback function which in turn does the
 *  actual computation for each quadruplex found.
 */
PRIVATE
void
process_gquad_enumeration(int *gg,
                          int i,
                          int j,
                          void (*f)(int, int, int *,
                                    void *, void *, void *, void *),
                          void *data,
                          void *P,
                          void *aux1,
                          void *aux2){

  int L, l[3], n, max_linker, maxl0, maxl1;

  n = j - i + 1;

  if((n >= VRNA_GQUAD_MIN_BOX_SIZE) && (n <= VRNA_GQUAD_MAX_BOX_SIZE))
    for(L = MIN2(gg[i], VRNA_GQUAD_MAX_STACK_SIZE);
        L >= VRNA_GQUAD_MIN_STACK_SIZE;
        L--)
      if(gg[j-L+1] >= L){
        max_linker = n-4*L;
        if(     (max_linker >= 3*VRNA_GQUAD_MIN_LINKER_LENGTH)
            &&  (max_linker <= 3*VRNA_GQUAD_MAX_LINKER_LENGTH)){
          maxl0 = MIN2( VRNA_GQUAD_MAX_LINKER_LENGTH,
                        max_linker - 2*VRNA_GQUAD_MIN_LINKER_LENGTH
                      );
          for(l[0] = VRNA_GQUAD_MIN_LINKER_LENGTH;
              l[0] <= maxl0;
              l[0]++)
            if(gg[i+L+l[0]] >= L){
              maxl1 = MIN2( VRNA_GQUAD_MAX_LINKER_LENGTH,
                            max_linker - l[0] - VRNA_GQUAD_MIN_LINKER_LENGTH
                          );
              for(l[1] = VRNA_GQUAD_MIN_LINKER_LENGTH;
                  l[1] <= maxl1;
                  l[1]++)
                if(gg[i + 2*L + l[0] + l[1]] >= L){
                  l[2] = max_linker - l[0] - l[1];
                  f(i, L, &(l[0]), data, P, aux1, aux2);
                }
            }
        }
      }
}

eval.c/         0           0     0     644     89118     `
/** \file eval.c */


/*
                  Free energy evaluation

                  c Ivo Hofacker, Chrisoph Flamm
                  original implementation by
                  Walter Fontana

                  ViennaRNA Package >= v2.0 by Ronny Lorenz

                  Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>

#include "utils.h"
#include "structure_utils.h"
#include "energy_par.h"
#include "model.h"
#include "fold_vars.h"
#include "params.h"
#include "constraints.h"
#include "loop_energies.h"
#include "gquad.h"
#include "cofold.h"
#include "eval.h"

#define ON_SAME_STRAND(I,J,C)  (((I)>=(C))||((J)<(C)))

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/
PUBLIC  int cut_point = -1; /* set to first pos of second seq for cofolding */
PUBLIC  int eos_debug = 0;  /* verbose info from energy_of_struct */

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/
PRIVATE vrna_fold_compound_t  *backward_compat_compound = NULL;

PRIVATE int verbosity_default = 1;  /* default verbosity level */
PRIVATE int verbosity_quiet   = -1; /* verbosity level for quiet operations */

#ifdef _OPENMP

#pragma omp threadprivate(backward_compat_compound)

#endif

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/
PRIVATE int
stack_energy( vrna_fold_compound_t *vc,
              int i,
              const short *pt,
              FILE *file,
              int verbostiy_level);

PRIVATE int
energy_of_extLoop_pt( vrna_fold_compound_t *vc,
                      int i,
                      const short *pt);

PRIVATE int
energy_of_ml_pt(vrna_fold_compound_t *vc,
                int i,
                const short *pt);

PRIVATE int
cut_in_loop(int i,
            const short *pt,
            int cp);

PRIVATE int
eval_pt(vrna_fold_compound_t *vc,
        const short *pt,
        FILE *file,
        int verbosity_level);

PRIVATE int
eval_circ_pt( vrna_fold_compound_t *vc,
              const short *pt,
              FILE *file,
              int verbosity_level);

PRIVATE int
en_corr_of_loop_gquad(vrna_fold_compound_t *vc,
                      int i,
                      int j,
                      const char *structure,
                      const short *pt);

PRIVATE vrna_param_t *
get_updated_params( vrna_param_t *parameters,
                    int compat);

PRIVATE float
wrap_eval_structure(vrna_fold_compound_t *vc,
                    const char *structure,
                    const short *pt,
                    FILE *file,
                    int verbosity);

PRIVATE int
wrap_eval_loop_pt(vrna_fold_compound_t *vc,
                  int i,
                  const short *pt,
                  int verbosity);

PRIVATE INLINE int
eval_int_loop(vrna_fold_compound_t *vc,
              int i,
              int j,
              int p,
              int q);

/* consensus structure variants below */
PRIVATE int
covar_energy_of_struct_pt(vrna_fold_compound_t *vc,
                          const short *pt);

PRIVATE int
stack_energy_covar_pt(vrna_fold_compound_t *vc,
                      int i,
                      const short *ptable);

PRIVATE int
en_corr_of_loop_gquad_ali(vrna_fold_compound_t *vc,
                          int i,
                          int j,
                          const char *structure,
                          const short *pt,
                          const int *loop_idx);

PRIVATE int
covar_en_corr_of_loop_gquad(vrna_fold_compound_t *vc,
                            int i,
                            int j,
                            const char *structure,
                            const short *pt,
                            const int *loop_idx);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/


PUBLIC float
vrna_eval_structure_simple( const char *string,
                            const char *structure){

  return vrna_eval_structure_simple_v(string, structure, verbosity_quiet, NULL);
}


PUBLIC float
vrna_eval_structure_simple_verbose( const char *string,
                                    const char *structure,
                                    FILE *file){

  return vrna_eval_structure_simple_v(string, structure, verbosity_default, file);
}


PUBLIC float
vrna_eval_structure_simple_v( const char *string,
                              const char *structure,
                              int verbosity_level,
                              FILE *file){

  float e;

  /* create fold_compound with default parameters and without DP matrices */
  vrna_fold_compound_t *vc = vrna_fold_compound(string, NULL, VRNA_OPTION_EVAL_ONLY);

  /* evaluate structure */
  e = vrna_eval_structure_v(vc, structure, verbosity_level, file);

  /* free fold_compound */
  vrna_fold_compound_free(vc);

  return e;
}


PUBLIC int
vrna_eval_structure_pt_simple(const char *string,
                              const short *pt){

  return vrna_eval_structure_pt_simple_v(string, pt, verbosity_quiet, NULL);
}


PUBLIC int
vrna_eval_structure_pt_simple_verbose(const char *string,
                                      const short *pt,
                                      FILE *file){

  return vrna_eval_structure_pt_simple_v(string, pt, verbosity_default, file);
}


PUBLIC int
vrna_eval_structure_pt_simple_v(const char *string,
                                const short *pt,
                                int verbosity_level,
                                FILE *file){

  int e;

  /* create fold_compound with default parameters and without DP matrices */
  vrna_fold_compound_t *vc = vrna_fold_compound(string, NULL, VRNA_OPTION_EVAL_ONLY);

  /* evaluate structure */
  e = vrna_eval_structure_pt_v(vc, pt, verbosity_level, file);

  /* free fold_compound */
  vrna_fold_compound_free(vc);

  return e;

}


PUBLIC int
vrna_eval_move_pt_simple( const char *string,
                          short *pt,
                          int m1,
                          int m2){

  int e;

  /* create fold_compound with default parameters and without DP matrices */
  vrna_fold_compound_t *vc = vrna_fold_compound(string, NULL, VRNA_OPTION_EVAL_ONLY);

  /* evaluate structure */
  e = vrna_eval_move_pt(vc, pt, m1, m2);

  /* free fold_compound */
  vrna_fold_compound_free(vc);

  return e;

}


PUBLIC  float
vrna_eval_structure(vrna_fold_compound_t *vc,
                    const char *structure){

  return vrna_eval_structure_v(vc, structure, verbosity_quiet, NULL);
}


PUBLIC float
vrna_eval_structure_verbose(vrna_fold_compound_t *vc,
                            const char *structure,
                            FILE *file){

  return vrna_eval_structure_v(vc, structure, verbosity_default, file);
}


PUBLIC float
vrna_eval_structure_v(vrna_fold_compound_t *vc,
                      const char *structure,
                      int verbosity_level,
                      FILE *file){

  short *pt = vrna_ptable(structure);
  float en  = wrap_eval_structure(vc, structure, pt, file, verbosity_level);

  free(pt);
  return en;
}


PUBLIC float
vrna_eval_covar_structure(vrna_fold_compound_t *vc,
                          const char *structure){

  int res, gq, *loop_idx;
  short *pt;

  pt                              = vrna_ptable(structure);
  res                             = 0;
  gq                              = vc->params->model_details.gquad;
  vc->params->model_details.gquad = 0;

  if(vc->type == VRNA_VC_TYPE_ALIGNMENT){
    res = (int)((float)covar_energy_of_struct_pt(vc, pt) / (float)vc->n_seq);

    vc->params->model_details.gquad = gq;

    if(gq){
      loop_idx  =   vrna_loopidx_from_ptable(pt);
      res       +=  (int)((float)covar_en_corr_of_loop_gquad(vc, 1, vc->length, structure, pt, (const int *)loop_idx) / (float)vc->n_seq);
      free(loop_idx);
    }
  }

  free(pt);

  return (float)res/100.;
}


PUBLIC int
vrna_eval_structure_pt( vrna_fold_compound_t *vc,
                        const short *pt){

  return vrna_eval_structure_pt_v(vc, pt, verbosity_quiet, NULL);
}


PUBLIC int
vrna_eval_structure_pt_verbose( vrna_fold_compound_t *vc,
                                const short *pt,
                                FILE *file){

  return vrna_eval_structure_pt_v(vc, pt, verbosity_default, file);
}


PUBLIC int
vrna_eval_structure_pt_v( vrna_fold_compound_t *vc,
                          const short *pt,
                          int verbosity_level,
                          FILE *file){

  if(pt && vc){
    if(pt[0] != (short)vc->length)
      vrna_message_error("vrna_eval_structure_*: string and structure have unequal length");

    return eval_pt(vc, pt, file, verbosity_level);
  } else
    return INF;
}


PUBLIC int
vrna_eval_loop_pt(vrna_fold_compound_t *vc,
                  int i,
                  const short *pt){

  return wrap_eval_loop_pt(vc, i, pt, verbosity_quiet);
}


PUBLIC float
vrna_eval_move( vrna_fold_compound_t *vc,
                const char *structure,
                int m1,
                int m2){

  short   *pt;
  int     en;

  if (strlen(structure) != vc->length)
    vrna_message_error("vrna_eval_move: sequence and structure have unequal length");

  pt = vrna_ptable(structure);
  en = vrna_eval_move_pt(vc, pt, m1, m2);

  free(pt);

  return  (float)en/100.;
}


PUBLIC int
vrna_eval_move_pt(vrna_fold_compound_t *vc,
                  short *pt,
                  int m1,
                  int m2){

  /*compute change in energy given by move (m1,m2)*/
  int en_post, en_pre, i,j,k,l, len, cp;
  vrna_param_t *P;
  
  len = vc->length;
  cp  = vc->cutpoint;
  P   = vc->params;

  k = (m1>0)?m1:-m1;
  l = (m2>0)?m2:-m2;
  /* first find the enclosing pair i<k<l<j */
  for (j=l+1; j<=len; j++) {
    if (pt[j]<=0) continue; /* unpaired */
    if (pt[j]<k) break;   /* found it */
    if (pt[j]>j) j=pt[j]; /* skip substructure */
    else {
      fprintf(stderr, "%d %d %d %d ", m1, m2, j, pt[j]);
      vrna_message_error("illegal move or broken pair table in vrna_eval_move_pt()");
    }
  }
  i = (j<=len) ? pt[j] : 0;
  en_pre = vrna_eval_loop_pt(vc, i, (const short *)pt);
  en_post = 0;
  if (m1<0) { /*it's a delete move */
    en_pre += vrna_eval_loop_pt(vc, k, (const short *)pt);
    pt[k]=0;
    pt[l]=0;
  } else { /* insert move */
    pt[k]=l;
    pt[l]=k;
    en_post += vrna_eval_loop_pt(vc, k, (const short *)pt);
  }
  en_post += vrna_eval_loop_pt(vc, i, (const short *)pt);
  /*  restore pair table */
  if (m1<0) {
    pt[k]=l;
    pt[l]=k;
  } else {
    pt[k]=0;
    pt[l]=0;
  }

  /* Cofolding -- Check if move changes COFOLD-Penalty */
  if (!ON_SAME_STRAND(k, l, cp)) {
    int p, c; p=c=0;
    for (p=1; p < cp; ) { /* Count basepairs between two strands */
      if (pt[p] != 0) {
        if (ON_SAME_STRAND(p, pt[p], cp)) /* Skip stuff */
          p=pt[p];
        else if (++c > 1) break; /* Count a basepair, break if we have more than one */
      }
      p++;
    }
    if (m1<0 && c==1) /* First and only inserted basepair */
      return (en_post - en_pre - P->DuplexInit);
    else
      if (c==0) /* Must have been a delete move */
        return (en_post - en_pre + P->DuplexInit);
  }

  return (en_post - en_pre);
}

/*
#################################
# STATIC helper functions below #
#################################
*/

PRIVATE INLINE int
eval_int_loop(vrna_fold_compound_t *vc,
              int i,
              int j,
              int p,
              int q){

  int             ij, u1, u2, cp, *rtype, *indx;
  unsigned char   type, type_2;
  short           *S, si, sj, sp, sq;
  vrna_param_t    *P;
  vrna_md_t       *md;
  vrna_sc_t       *sc;

  cp      = vc->cutpoint;
  indx    = vc->jindx;
  P       = vc->params;
  md      = &(P->model_details);
  S       = vc->sequence_encoding;
  si      = S[i+1];
  sj      = S[j-1];
  sp      = S[p-1];
  sq      = S[q+1];
  ij      = indx[j] + i;
  rtype   = &(md->rtype[0]);
  type    = (unsigned char)md->pair[S[i]][S[j]];
  type_2  = rtype[(unsigned char)md->pair[S[p]][S[q]]];
  u1      = p - i - 1;
  u2      = j - q - 1;
  sc      = vc->sc;

  if(type == 0)
    type = 7;
  if(type_2 == 0)
    type_2 = 7;

  return ubf_eval_int_loop( i, j, p, q,
                            i + 1, j - 1, p - 1, q + 1,
                            si, sj, sp, sq,
                            type, type_2, rtype,
                            ij, cp,
                            P, sc);
}

PRIVATE INLINE int
eval_ext_int_loop(vrna_fold_compound_t *vc,
                  int i,
                  int j,
                  int p,
                  int q){

  int             e, u1, u2, length;
  unsigned int    s, n_seq;
  short           **SS, **S5, **S3;
  unsigned short  **a2s;
  unsigned char   type, type_2;
  short           *S, si, sj, sp, sq;
  vrna_param_t    *P;
  vrna_md_t       *md;
  vrna_sc_t       *sc, **scs;

  length  = vc->length;
  P       = vc->params;
  md      = &(P->model_details);
  S       = vc->sequence_encoding;
  e       = INF;

  switch(vc->type){
    case VRNA_VC_TYPE_SINGLE:     si      = S[j+1];
                                  sj      = S[i-1];
                                  sp      = S[p-1];
                                  sq      = S[q+1];
                                  type    = (unsigned char)md->pair[S[j]][S[i]];
                                  type_2  = (unsigned char)md->pair[S[q]][S[p]];
                                  sc      = vc->sc;

                                  if(type == 0)
                                    type = 7;
                                  if(type_2 == 0)
                                    type_2 = 7;

                                  e = ubf_eval_ext_int_loop(i, j, p, q,
                                                            i - 1, j + 1, p - 1, q + 1,
                                                            si, sj, sp, sq,
                                                            type, type_2,
                                                            length,
                                                            P, sc);
                                  break;

    case VRNA_VC_TYPE_ALIGNMENT:  n_seq = vc->n_seq;
                                  SS      = vc->S;
                                  S5      = vc->S5; /* S5[s][i] holds next base 5' of i in sequence s */
                                  S3      = vc->S3; /* Sl[s][i] holds next base 3' of i in sequence s */
                                  a2s     = vc->a2s;
                                  n_seq   = vc->n_seq;
                                  scs     = vc->scs;

                                  for (e = 0, s = 0; s < n_seq; s++) {
                                    type    = (unsigned char)md->pair[SS[s][j]][SS[s][i]];
                                    if(type == 0)
                                      type = 7;
                                    type_2  = (unsigned char)md->pair[SS[s][q]][SS[s][p]]; /* q,p not p,q! */
                                    if(type_2 == 0)
                                      type_2 = 7;

                                    sc = (scs && scs[s]) ? scs[s] : NULL;

                                    e += ubf_eval_ext_int_loop(a2s[s][i], a2s[s][j], a2s[s][p], a2s[s][q],
                                                                    a2s[s][i - 1], a2s[s][j + 1], a2s[s][p - 1], a2s[s][q + 1],
                                                                    S3[s][j], S5[s][i], S5[s][p], S3[s][q],
                                                                    type, type_2,
                                                                    a2s[s][length],
                                                                    P, sc);
                                  }

                                  break;
  }

  return e;
}

PRIVATE  vrna_param_t *
get_updated_params(vrna_param_t *parameters, int compat){
  vrna_param_t *P = NULL;
  if(parameters){
    P = vrna_params_copy(parameters);
  } else {
    vrna_md_t md;
    if(compat)
      set_model_details(&md);
    else
      vrna_md_set_default(&md);
    md.temperature = temperature;
    P = vrna_params(&md);
  }
  vrna_md_update(&(P->model_details));
  return P;
}

PRIVATE int
wrap_eval_loop_pt(vrna_fold_compound_t *vc,
                  int i,
                  const short *pt,
                  int verbosity){

  /* compute energy of a single loop closed by base pair (i,j) */
  int               j, type, p,q, energy, cp;
  short             *s;
  vrna_param_t      *P;

  P   = vc->params;
  cp  = vc->cutpoint;
  s   = vc->sequence_encoding2;

  if (i==0) { /* evaluate exterior loop */
    energy = energy_of_extLoop_pt(vc, 0, pt);
    return energy;
  }
  j = pt[i];
  if (j<i) vrna_message_error("i is unpaired in loop_energy()");
  type = P->model_details.pair[s[i]][s[j]];
  if (type==0) {
    type=7;
    if (verbosity > verbosity_quiet)
      fprintf(stderr,"WARNING: bases %d and %d (%c%c) can't pair!\n", i, j,
              vrna_nucleotide_decode(s[i], &(P->model_details)), vrna_nucleotide_decode(s[j], &(P->model_details)));
  }
  p=i; q=j;


  while (pt[++p]==0);
  while (pt[--q]==0);
  if (p>q) { /* Hairpin */
    energy = vrna_eval_hp_loop(vc, i, j);
  }
  else if (pt[q]!=(short)p) { /* multi-loop */
    int ii;
    ii = cut_in_loop(i, (const short *)pt, cp);
    energy = (ii==0) ? energy_of_ml_pt(vc, i, (const short *)pt) : energy_of_extLoop_pt(vc, ii, (const short *)pt);
  }
  else { /* found interior loop */
    int type_2;
    type_2 = P->model_details.pair[s[q]][s[p]];
    if (type_2==0) {
      type_2=7;
      if (verbosity > verbosity_quiet)
        fprintf(stderr,"WARNING: bases %d and %d (%c%c) can't pair!\n", p, q,
              vrna_nucleotide_decode(s[p], &(P->model_details)), vrna_nucleotide_decode(s[q], &(P->model_details)));
    }

    energy = eval_int_loop(vc, i, j, p, q);

  }

  return energy;
}

PRIVATE float
wrap_eval_structure(vrna_fold_compound_t *vc,
                    const char *structure,
                    const short *pt,
                    FILE *file,
                    int verbosity){

  int res;
  int gq;

  res                             = INF;
  gq                              = vc->params->model_details.gquad;
  vc->params->model_details.gquad = 0;

  switch(vc->type){
    case VRNA_VC_TYPE_SINGLE:     if(vc->params->model_details.circ){
                                    res = eval_circ_pt(vc, pt, file, verbosity);
                                  } else {
                                    res = eval_pt(vc, pt, file, verbosity);
                                  }
                                  vc->params->model_details.gquad = gq;

                                  if(gq){
                                    res += en_corr_of_loop_gquad(vc, 1, vc->length, structure, pt);
                                  }
                                  break;

    case VRNA_VC_TYPE_ALIGNMENT:  if(vc->params->model_details.circ){
                                    res = (int)((float)eval_circ_pt(vc, pt, file, verbosity) / (float)vc->n_seq);
                                  } else {
                                    res = (int)((float)eval_pt(vc, pt, file, verbosity) / (float)vc->n_seq);
                                  }
                                  vc->params->model_details.gquad = gq;

                                  if(gq){
                                    int *loop_idx = vrna_loopidx_from_ptable(pt);
                                    res += (int)((float)en_corr_of_loop_gquad_ali(vc, 1, vc->length, structure, pt, (const int *)loop_idx) / (float)vc->n_seq);
                                    free(loop_idx);
                                  }
                                  break;

    default:                      /* do nothing */
                                  break;
  }
  return (float)res/100.;
}

PRIVATE int
eval_pt(vrna_fold_compound_t *vc,
        const short *pt,
        FILE *file,
        int verbosity_level){

  int   i, length, energy, cp;
  FILE  *out;

  out     = (file) ? file : stdout;
  length  = vc->length;
  cp      = vc->cutpoint;

  if(vc->params->model_details.gquad)
    vrna_message_warning("vrna_eval_*_pt: No gquadruplex support!\nIgnoring potential gquads in structure!\nUse e.g. vrna_eval_structure() instead!");

  energy = vc->params->model_details.backtrack_type=='M' ? energy_of_ml_pt(vc, 0, pt) : energy_of_extLoop_pt(vc, 0, pt);

  if (verbosity_level>0)
    fprintf(out, "External loop                           : %5d\n", energy);
  for (i=1; i<=length; i++) {
    if (pt[i]==0) continue;
    energy += stack_energy(vc, i, pt, out, verbosity_level);
    i=pt[i];
  }
  for (i=1; !ON_SAME_STRAND(i,length, cp); i++) {
    if (!ON_SAME_STRAND(i,pt[i], cp)) {
      energy += vc->params->DuplexInit;
      break;
    }
  }

  return energy;
}

PRIVATE int
eval_circ_pt( vrna_fold_compound_t *vc,
              const short *pt,
              FILE *file,
              int verbosity_level){

  unsigned int      s, n_seq;
  int               i, j, length, energy, en0, degree;
  unsigned short    **a2s;
  vrna_param_t      *P;
  vrna_sc_t         *sc, **scs;
  FILE              *out;

  energy        = 0;
  en0           = 0;
  degree        = 0;
  length        = vc->length;
  P             = vc->params;
  sc            = (vc->type == VRNA_VC_TYPE_SINGLE) ? vc->sc : NULL;
  scs           = (vc->type == VRNA_VC_TYPE_ALIGNMENT) ? vc->scs : NULL;
  out           = (file) ? file : stdout;

  if(P->model_details.gquad)
    vrna_message_warning("vrna_eval_*_pt: No gquadruplex support!\nIgnoring potential gquads in structure!\nUse e.g. vrna_eval_structure() instead!");

  /* evaluate all stems in exterior loop */
  for (i=1; i<=length; i++) {
    if (pt[i]==0) continue;
    degree++;
    energy += stack_energy(vc, i, (const short *)pt, out, verbosity_level);
    i=pt[i];
  }

  /* find first stem */
  for (i=1; pt[i]==0; i++);
  j = pt[i];

  /* evaluate exterior loop itself */
  switch(degree){
    case 0:   /* unstructured */
              switch(vc->type){
                case VRNA_VC_TYPE_SINGLE:     if(sc){
                                                if(sc->energy_up)
                                                  en0 += sc->energy_up[1][length];
                                              }
                                              break;

                case VRNA_VC_TYPE_ALIGNMENT:  n_seq = vc->n_seq;
                                              a2s   = vc->a2s;
                                              if(scs)
                                                for(s = 0; s < n_seq; s++){
                                                  if(scs[s] && scs[s]->energy_up)
                                                    en0 += scs[s]->energy_up[1][a2s[s][length]];
                                                }
                                              break;
              }
              break;
    case 1:   /* hairpin loop */
              en0 = vrna_eval_ext_hp_loop(vc, i, j);
              break;

    case 2:   /* interior loop */
              {
                int p,q;
                /* seek to next pair */
                for (p=j+1; pt[p]==0; p++);
                q=pt[p];

                en0 = eval_ext_int_loop(vc, i, j, p, q);
              }
              break;

    default:  /* multibranch loop */
              en0 = energy_of_ml_pt(vc, 0, (const short *)pt);

              if(vc->type == VRNA_VC_TYPE_SINGLE)
                en0 -= E_MLstem(0, -1, -1, P); /* remove virtual closing pair */
              break;
  }

  if (verbosity_level>0)
    fprintf(out, "External loop                           : %5d\n", en0);

  energy += en0;

  return energy;
}



/*---------------------------------------------------------------------------*/
/*  returns a correction term that may be added to the energy retrieved
    from energy_of_struct_par() to correct misinterpreted loops. This
    correction is necessary since energy_of_struct_par() will forget
    about the existance of gquadruplexes and just treat them as unpaired
    regions.

    recursive variant
*/
PRIVATE int
en_corr_of_loop_gquad(vrna_fold_compound_t *vc,
                      int i,
                      int j,
                      const char *structure,
                      const short *pt){

  int               pos, energy, p, q, r, s, u, type, type2, L, l[3], *rtype, *loop_idx;
  int               num_elem, num_g, elem_i, elem_j, up_mis;
  short             *s1;
  vrna_param_t      *P;
  vrna_md_t         *md;

  loop_idx  = vrna_loopidx_from_ptable(pt);
  s1        = vc->sequence_encoding;
  P         = vc->params;
  md        = &(P->model_details);
  rtype     = &(md->rtype[0]);

  energy = 0;
  q = i;
  while((pos = parse_gquad(structure + q-1, &L, l)) > 0){
    q += pos-1;
    p = q - 4*L - l[0] - l[1] - l[2] + 1;
    if(q > j) break;
    /* we've found the first g-quadruplex at position [p,q] */
    energy += E_gquad(L, l, P);
    /* check if it's enclosed in a base pair */
    if(loop_idx[p] == 0){ q++; continue; /* g-quad in exterior loop */}
    else{
      energy += E_MLstem(0, -1, -1, P); /*  do not forget to remove this energy if
                                            the gquad is the only one surrounded by
                                            the enclosing pair
                                        */

      /*  find its enclosing pair */
      num_elem  = 0;
      num_g     = 1;
      r         = p - 1;
      up_mis    = q - p + 1;

      /* seek for first pairing base located 5' of the g-quad */
      for(r = p - 1; !pt[r] && (r >= i); r--);
      if(r < i) vrna_message_error("this should not happen");

      if(r < pt[r]){ /* found the enclosing pair */
        s = pt[r];
      } else {
        num_elem++;
        elem_i = pt[r];
        elem_j = r;
        r = pt[r]-1 ;
        /* seek for next pairing base 5' of r */
        for(; !pt[r] && (r >= i); r--);
        if(r < i) vrna_message_error("so nich");
        if(r < pt[r]){ /* found the enclosing pair */
          s = pt[r];
        } else {
          /* hop over stems and unpaired nucleotides */
          while((r > pt[r]) && (r >= i)){
            if(pt[r]){ r = pt[r]; num_elem++;}
            r--;
          }
          if(r < i) vrna_message_error("so nich");
          s = pt[r]; /* found the enclosing pair */
        }
      }
      /* now we have the enclosing pair (r,s) */

      u = q+1;
      /* we know everything about the 5' part of this loop so check the 3' part */
      while(u<s){
        if(structure[u-1] == '.') u++;
        else if (structure[u-1] == '+'){ /* found another gquad */
          pos = parse_gquad(structure + u - 1, &L, l);
          if(pos > 0){
            energy += E_gquad(L, l, P) + E_MLstem(0, -1, -1, P);
            up_mis += pos;
            u += pos;
            num_g++;
          }
        } else { /* we must have found a stem */
          if(!(u < pt[u])) vrna_message_error("wtf!");
          num_elem++; elem_i = u; elem_j = pt[u];
          energy += en_corr_of_loop_gquad(vc, u, pt[u], structure, pt);
          u = pt[u] + 1;
        }
      }
      if(u!=s) vrna_message_error("what the hell");
      else{ /* we are done since we've found no other 3' structure element */
        switch(num_elem){
          /* g-quad was misinterpreted as hairpin closed by (r,s) */
          case 0:   /* if(num_g == 1)
                      if((p-r-1 == 0) || (s-q-1 == 0))
                        vrna_message_error("too few unpaired bases");
                    */
                    type = md->pair[s1[r]][s1[s]];
                    if(dangles == 2)
                      energy += P->mismatchI[type][s1[r+1]][s1[s-1]];
                    if(type > 2)
                      energy += P->TerminalAU;
                    energy += P->internal_loop[s - r - 1 - up_mis];
                    energy -= E_MLstem(0, -1, -1, P);
                    energy -= vrna_eval_hp_loop(vc, r, s);

                    break;
          /* g-quad was misinterpreted as interior loop closed by (r,s) with enclosed pair (elem_i, elem_j) */
          case 1:   type = md->pair[s1[r]][s1[s]];
                    type2 = md->pair[s1[elem_i]][s1[elem_j]];
                    energy += P->MLclosing
                              + E_MLstem(rtype[type], s1[s-1], s1[r+1], P)
                              + (elem_i - r - 1 + s - elem_j - 1 - up_mis) * P->MLbase
                              + E_MLstem(type2, s1[elem_i-1], s1[elem_j+1], P);
                    energy -= eval_int_loop(vc, r, s, elem_i, elem_j);

                    break;
          /* gquad was misinterpreted as unpaired nucleotides in a multiloop */
          default:  energy -= (up_mis) * P->MLbase;
                    break;
        }
      }
      q = s+1;
    }
  }

  free(loop_idx);
  return energy;
}



PRIVATE int
stack_energy( vrna_fold_compound_t *vc,
              int i,
              const short *pt,
              FILE *file,
              int verbosity_level){

  /* recursively calculate energy of substructure enclosed by (i,j) */

  int               ee, energy, j, p, q, type, *rtype, *types, cp, ss, n_seq;
  char              *string, **Ss;
  short             *s, **S, **S5, **S3;
  unsigned short    **a2s;
  FILE              *out;
  vrna_param_t      *P;
  vrna_md_t         *md;

  cp      = vc->cutpoint;
  s       = vc->sequence_encoding2;
  P       = vc->params;
  md      = &(P->model_details);
  rtype   = &(md->rtype[0]);
  types   = NULL;
  energy  = 0;
  out     = (file) ? file : stdout;

  j = pt[i];

  switch(vc->type){
    case VRNA_VC_TYPE_SINGLE:     string  = vc->sequence;
                                  type    = md->pair[s[i]][s[j]];
                                  if(type == 0){
                                    type = 7;
                                    if(verbosity_level > verbosity_quiet)
                                      fprintf(stderr,
                                              "WARNING: bases %d and %d (%c%c) can't pair!\n",
                                              i, j,
                                              string[i - 1], string[j - 1]);
                                  }
                                  break;

    case VRNA_VC_TYPE_ALIGNMENT:  string  = vc->cons_seq;
                                  S       = vc->S;
                                  S5      = vc->S5; /* S5[s][i] holds next base 5' of i in sequence s */
                                  S3      = vc->S3; /* Sl[s][i] holds next base 3' of i in sequence s */
                                  Ss      = vc->Ss;
                                  a2s     = vc->a2s;
                                  n_seq   = vc->n_seq;
                                  types   = (int *)vrna_alloc(n_seq * sizeof(int));

                                  for(ss = 0; ss < n_seq; ss++){
                                    types[ss] = md->pair[S[ss][i]][S[ss][j]];
                                    if(types[ss] == 0){
                                      types[ss] = 7;
                                    }
                                  }
                                  break;

    default:                      return INF;
                                  break;
  }

  p = i;
  q = j;

  while(p < q){ /* process all stacks and interior loops */
    int type_2;
    while(pt[++p] == 0);
    while(pt[--q] == 0);
    if((pt[q] != (short)p) || (p > q))
      break;
    ee = 0;
    switch(vc->type){
      case VRNA_VC_TYPE_SINGLE:     type_2 = md->pair[s[q]][s[p]];
                                    if(type_2 == 0){
                                      type_2 = 7;
                                      if(verbosity_level > verbosity_quiet)
                                        fprintf(stderr,
                                                "WARNING: bases %d and %d (%c%c) can't pair!\n",
                                                p, q,
                                                string[p - 1], string[q - 1]);
                                    }
                                    ee = eval_int_loop(vc, i, j, p, q);

                                    type = rtype[type_2];
                                    break;

      case VRNA_VC_TYPE_ALIGNMENT:  for(ss = 0; ss < n_seq; ss++){
                                      type_2 = md->pair[S[ss][q]][S[ss][p]];
                                      if(type_2 == 0){
                                        type_2 = 7;
                                      }
                                      ee += E_IntLoop(a2s[ss][p - 1] - a2s[ss][i],
                                                      a2s[ss][j - 1] - a2s[ss][q],
                                                      types[ss],
                                                      type_2,
                                                      S3[ss][i],
                                                      S5[ss][j],
                                                      S5[ss][p],
                                                      S3[ss][q],
                                                      P);
                                    }

                                    for(ss = 0; ss < n_seq; ss++){
                                      types[ss] = md->pair[S[ss][p]][S[ss][q]];
                                      if(types[ss] == 0)
                                        types[ss] = 7;
                                    }
                                    break;

      default:                      break; /* this should never happen */
    }

    if(verbosity_level > 0)
      fprintf(out,
              "Interior loop (%3d,%3d) %c%c; (%3d,%3d) %c%c: %5d\n",
              i, j,
              string[i - 1], string[j - 1],
              p, q,
              string[p - 1], string[q - 1],
              ee);

    energy += ee;
    i = p;
    j = q;
  } /* end while */

  /* p,q don't pair must have found hairpin or multiloop */

  if(p > q){  /* hairpin */
    ee      = vrna_eval_hp_loop(vc, i, j);
    energy  += ee;

    if(verbosity_level > 0)
      fprintf(out,
              "Hairpin  loop (%3d,%3d) %c%c              : %5d\n",
              i, j,
              string[i - 1], string[j - 1],
              ee);

    free(types);

    return energy;
  }

  /* (i,j) is exterior pair of multiloop */
  while(p < j){
    /* add up the contributions of the substructures of the ML */
    energy += stack_energy(vc, p, pt, out, verbosity_level);
    p = pt[p];
    /* search for next base pair in multiloop */
    while(pt[++p] == 0);
  }
  
  switch(vc->type){
    case VRNA_VC_TYPE_SINGLE:     {
                                    int ii = cut_in_loop(i, pt, cp);
                                    ee = (ii==0) ? energy_of_ml_pt(vc, i, pt) : energy_of_extLoop_pt(vc, ii, pt);
                                  }
                                  break;

    case VRNA_VC_TYPE_ALIGNMENT:  ee = energy_of_ml_pt(vc, i, pt);
                                  break;

    default:                      break; /* this should never happen */
  }

  energy += ee;
  if(verbosity_level > 0)
    fprintf(out, "Multi    loop (%3d,%3d) %c%c              : %5d\n",
            i, j,
            string[i - 1], string[j - 1],
            ee);

  free(types);

  return energy;
}

/*---------------------------------------------------------------------------*/



/**
*** Calculate the energy contribution of
*** stabilizing dangling-ends/mismatches
*** for all stems branching off the exterior
*** loop
**/
PRIVATE int
energy_of_extLoop_pt( vrna_fold_compound_t *vc,
                      int i,
                      const short *pt){

  int               energy, mm5, mm3, bonus, p, q, q_prev, length, dangle_model, n_seq, cp, ss, u, start;
  short             *s, *s1, **S, **S5, **S3;
  unsigned short    **a2s;
  vrna_param_t      *P;
  vrna_md_t         *md;
  vrna_sc_t         *sc, **scs;


  /* helper variables for dangles == 1 case */
  int E3_available;  /* energy of 5' part where 5' mismatch is available for current stem */
  int E3_occupied;   /* energy of 5' part where 5' mismatch is unavailable for current stem */


  /* initialize vars */
  length        = vc->length;
  cp            = vc->cutpoint;
  P             = vc->params;
  md            = &(P->model_details);
  dangle_model  = md->dangles;

  energy        = 0;
  bonus         = 0;
  p = start     = (i==0) ? 1 : i;
  q_prev        = -1;

  if(dangle_model % 2 == 1){
    E3_available = INF;
    E3_occupied  = 0;
  }

  /* seek to opening base of first stem */
  while(p <= length && !pt[p]) p++;

  switch(vc->type){
    case VRNA_VC_TYPE_SINGLE:     s  = vc->sequence_encoding2;
                                  s1 = vc->sequence_encoding;
                                  sc = vc->sc;

                                  /* add soft constraints for first unpaired nucleotides */
                                  if(sc){
                                    if(sc->energy_up)
                                      bonus += sc->energy_up[start][p - start];
                                    /* how do we handle generalized soft constraints here ? */
                                  }
                                  break;

    case VRNA_VC_TYPE_ALIGNMENT:  S     = vc->S;
                                  S5    = vc->S5;     /* S5[s][i] holds next base 5' of i in sequence s */
                                  S3    = vc->S3;     /* Sl[s][i] holds next base 3' of i in sequence s */
                                  a2s   = vc->a2s;
                                  n_seq = vc->n_seq;
                                  scs   = vc->scs;

                                  /* add soft constraints for first unpaired nucleotides */
                                  if(scs){
                                    for(ss = 0; ss < n_seq; ss++){
                                      if(scs[ss]){
                                        if(scs[ss]->energy_up){
                                          u      = a2s[ss][p] - a2s[ss][start];
                                          bonus += scs[ss]->energy_up[a2s[ss][start]][u];
                                        }
                                        /* how do we handle generalized soft constraints here ? */
                                      }
                                    }
                                  }
                                  break;

    default:                      return INF;
                                  break;
  }

  while(p < length){
    int tt;
    /* p must have a pairing partner */
    q  = (int)pt[p];
    
    switch(vc->type){
      case VRNA_VC_TYPE_SINGLE:     /* get type of base pair (p,q) */
                                    tt = md->pair[s[p]][s[q]];
                                    if(tt == 0)
                                      tt = 7;

                                    switch(dangle_model){
                                      /* no dangles */
                                      case 0:   energy += E_ExtLoop(tt, -1, -1, P);
                                                break;

                                      /* the beloved double dangles */
                                      case 2:   mm5 = ((ON_SAME_STRAND(p - 1, p, cp)) && (p>1))       ? s1[p-1] : -1;
                                                mm3 = ((ON_SAME_STRAND(q, q + 1, cp)) && (q<length))  ? s1[q+1] : -1;
                                                energy += E_ExtLoop(tt, mm5, mm3, P);
                                                break;

                                      default:  {
                                                  int tmp;
                                                  if(q_prev + 2 < p){
                                                    E3_available = MIN2(E3_available, E3_occupied);
                                                    E3_occupied  = E3_available;
                                                  }
                                                  mm5 = ((ON_SAME_STRAND(p - 1, p, cp)) && (p>1) && !pt[p-1])       ? s1[p-1] : -1;
                                                  mm3 = ((ON_SAME_STRAND(q, q + 1, cp)) && (q<length) && !pt[q+1])  ? s1[q+1] : -1;
                                                  tmp = MIN2(
                                                                                E3_occupied  + E_ExtLoop(tt, -1, mm3, P),
                                                                                E3_available + E_ExtLoop(tt, mm5, mm3, P)
                                                                              );
                                                  E3_available =       MIN2(
                                                                                E3_occupied  + E_ExtLoop(tt, -1, -1, P),
                                                                                E3_available + E_ExtLoop(tt, mm5, -1, P)
                                                                              );
                                                  E3_occupied = tmp;
                                                }
                                                break;

                                    } /* end switch dangle_model */
                                    break;

      case VRNA_VC_TYPE_ALIGNMENT:  for(ss = 0; ss < n_seq; ss++){
                                      /* get type of base pair (p,q) */
                                      tt = md->pair[S[ss][p]][S[ss][q]];
                                      if(tt == 0)
                                        tt = 7;

                                      switch(dangle_model){
                                        case 0:   energy += E_ExtLoop(tt, -1, -1, P);
                                                  break;
                                        
                                        case 2:   mm5 = (a2s[ss][p] > 1) && (tt != 0) ? S5[ss][p] : -1;
                                                  mm3 = (a2s[ss][q] < a2s[ss][S[0][0]]) ? S3[ss][q] : -1; /* why S[0][0] ??? */
                                                  energy += E_ExtLoop(tt, mm5, mm3, P);
                                                  break;

                                        default:  break; /* odd dangles not implemented yet */
                                      }
                                    }
                                    break;

      default:                      break; /* this should never happen */
    }

    /* seek to the next stem */
    p = q + 1;
    q_prev = q;
    while (p <= length && !pt[p]) p++;

    switch(vc->type){
      case VRNA_VC_TYPE_SINGLE:     /* add soft constraints for unpaired region */
                                    if(sc && (q_prev + 1 <= length)){
                                      if(sc->energy_up){
                                        bonus += sc->energy_up[q_prev + 1][p - q_prev - 1];
                                      }
                                      /* how do we handle generalized soft constraints here ? */
                                    }
                                    break;

      case VRNA_VC_TYPE_ALIGNMENT:  if(scs){
                                      for(ss = 0; ss < n_seq; ss++){
                                        if(scs[ss]){
                                          if(scs[ss]->energy_up){
                                            u = a2s[ss][p] - a2s[ss][q_prev + 1];
                                            bonus += scs[ss]->energy_up[a2s[ss][q_prev + 1]][u];
                                          }
                                        }
                                      }
                                    }
                                    break;

      default:                      break; /* this should never happen */
    }

    if(p == i)
      break; /* cut was in loop */
  }

  if(dangle_model % 2 == 1)
    energy = MIN2(E3_occupied, E3_available);

  return energy + bonus;
}

/**
*** i is the 5'-base of the closing pair
***
*** since each helix can coaxially stack with at most one of its
*** neighbors we need an auxiliarry variable  cx_energy
*** which contains the best energy given that the last two pairs stack.
*** energy  holds the best energy given the previous two pairs do not
*** stack (i.e. the two current helices may stack)
*** We don't allow the last helix to stack with the first, thus we have to
*** walk around the Loop twice with two starting points and take the minimum
***/
PRIVATE int
energy_of_ml_pt(vrna_fold_compound_t *vc,
                int i,
                const short *pt){

  int               energy, cx_energy, tmp, tmp2, best_energy=INF, bonus, *idx, cp, dangle_model, logML, circular, *rtype, ss, n, n_seq;
  int               i1, j, p, q, q_prev, q_prev2, u, uu, x, type, count, mm5, mm3, tt, ld5, new_cx, dang5, dang3, dang;
  int               e_stem, e_stem5, e_stem3, e_stem53;
  int               mlintern[NBPAIRS+1];
  short             *s, *s1, **S, **S5, **S3;
  unsigned short    **a2s;
  vrna_param_t      *P;
  vrna_md_t         *md;
  vrna_sc_t         *sc, **scs;

  /* helper variables for dangles == 1|5 case */
  int E_mm5_available;  /* energy of 5' part where 5' mismatch of current stem is available */
  int E_mm5_occupied;   /* energy of 5' part where 5' mismatch of current stem is unavailable */
  int E2_mm5_available; /* energy of 5' part where 5' mismatch of current stem is available with possible 3' dangle for enclosing pair (i,j) */
  int E2_mm5_occupied;  /* energy of 5' part where 5' mismatch of current stem is unavailable with possible 3' dangle for enclosing pair (i,j) */

  n   = vc->length;
  cp  = vc->cutpoint;
  P   = vc->params;
  md  = &(P->model_details);
  idx = vc->jindx;

  circular      = md->circ;
  dangle_model  = md->dangles;
  logML         = md->logML;
  rtype         = &(md->rtype[0]);

  bonus = 0;

  if(i >= pt[i]){
    vrna_message_warning("energy_of_ml_pt: i is not 5' base of a closing pair!");
    return INF;
  }

  j = (i == 0) ? n + 1 : (int)pt[i];

  switch(vc->type){
    case VRNA_VC_TYPE_SINGLE:     s   = vc->sequence_encoding2;
                                  s1  = vc->sequence_encoding;
                                  sc  = vc->sc;

                                  if(i != 0){ /* (i,j) is closing pair of multibranch loop, add soft constraints */
                                    if(sc){
                                      if(sc->energy_bp)
                                        bonus += sc->energy_bp[idx[j] + i];
                                    }
                                  }
                                  break;

    case VRNA_VC_TYPE_ALIGNMENT:  S     = vc->S;
                                  S5    = vc->S5;
                                  S3    = vc->S3;
                                  a2s   = vc->a2s;
                                  n_seq = vc->n_seq;
                                  scs   = vc->scs;

                                  if((dangle_model % 2) || (dangle_model > 2) || (dangle_model < 0)){
                                    vrna_message_warning("consensus structure evaluation for odd dangle models not implemented (yet)!");
                                    return INF;
                                  }

                                  if(i != 0){ /* (i,j) is closing pair of multibranch loop, add soft constraints */
                                    if(scs){
                                      for(ss = 0; ss < n_seq; ss++){
                                        if(scs[ss] && scs[ss]->energy_bp)
                                          bonus += scs[ss]->energy_bp[idx[j] + i];
                                      }
                                    }
                                  }
                                  break;

    default:                      return INF;
                                  break;
  }

  /* init the variables */
  energy      = 0;
  u           = 0; /* the total number of unpaired nucleotides */
  p           = i+1;
  q_prev      = i-1;
  q_prev2     = i;


  for (x = 0; x <= NBPAIRS; x++)
    mlintern[x] = P->MLintern[x];

  /* seek to opening base of first stem */
  while(p <= j && !pt[p])
    p++;

  /* add bonus energies for first stretch of unpaired nucleotides */
  switch(vc->type){
    case VRNA_VC_TYPE_SINGLE:     u += p - i - 1;
                                  if(sc){
                                    if(sc->energy_up)
                                      bonus += sc->energy_up[i + 1][u];
                                  }
                                  break;

    case VRNA_VC_TYPE_ALIGNMENT:  if(scs){
                                    for(ss = 0; ss < n_seq; ss++){
                                      uu = a2s[ss][p] - a2s[ss][i + 1];
                                      if(scs[ss] && scs[ss]->energy_up){
                                        bonus += scs[ss]->energy_up[a2s[ss][i + 1]][uu];
                                      }
                                      u += uu;
                                    }
                                  } else {
                                    for(ss = 0; ss < n_seq; ss++){
                                      u += a2s[ss][p] - a2s[ss][i + 1];
                                    }
                                  }
                                  break;

    default:                      break; /* this should never happen */
  }

  switch(dangle_model){
    case 0:   switch(vc->type){
                case VRNA_VC_TYPE_SINGLE:     while(p < j){
                                                /* p must have a pairing partner */
                                                q  = (int)pt[p];
                                                /* get type of base pair (p,q) */
                                                tt = md->pair[s[p]][s[q]];
                                                if(tt==0) tt=7;
                                                energy += E_MLstem(tt, -1, -1, P);

                                                /* seek to the next stem */
                                                p = q + 1;
                                                q_prev = q_prev2 = q;
                                                while (p <= j && !pt[p]) p++;
                                                u += p - q - 1; /* add unpaired nucleotides */

                                                if(sc){
                                                  if(sc->energy_up)
                                                    bonus += sc->energy_up[q+1][p-q-1];
                                                }
                                              }

                                              /* now lets get the energy of the enclosing stem */
                                              if(i > 0){  /* actual closing pair */
                                                tt = md->pair[s[j]][s[i]];
                                                if(tt == 0)
                                                  tt = 7;
                                                energy += E_MLstem(tt, -1, -1, P);

                                              } else {  /* virtual closing pair */
                                                energy += E_MLstem(0, -1, -1, P);
                                              }
                                              break;

                case VRNA_VC_TYPE_ALIGNMENT:  while(p < j){
                                                /* p must have a pairing partner */
                                                q  = (int)pt[p];
                                                for(ss = 0; ss < n_seq; ss++){
                                                  /* get type of base pair (p,q) */
                                                  tt = md->pair[S[ss][p]][S[ss][q]];
                                                  if(tt == 0)
                                                    tt = 7;
                                                  energy += E_MLstem(tt, -1, -1, P);
                                                }

                                                /* seek to the next stem */
                                                p = q + 1;
                                                q_prev = q_prev2 = q;
                                                while (p <= j && !pt[p]) p++;
                                                
                                                /* add unpaired nucleotides and possible soft constraints */
                                                if(scs){
                                                  for(ss = 0; ss < n_seq; ss++){
                                                    uu = a2s[ss][p] - a2s[ss][q + 1]; 
                                                    if(scs[ss] && scs[ss]->energy_up){
                                                      bonus += sc->energy_up[a2s[ss][q + 1]][uu];
                                                    }
                                                    u += uu;
                                                  }
                                                } else {
                                                  for(ss = 0; ss < n_seq; ss++){
                                                    u += a2s[ss][p] - a2s[ss][q + 1];
                                                  }
                                                }
                                              }

                                              /* now lets get the energy of the enclosing stem */
                                              if(i > 0){  /* actual closing pair */
                                                for(ss = 0; ss < n_seq; ss++){
                                                  tt = md->pair[S[ss][j]][S[ss][i]];
                                                  if(tt == 0)
                                                    tt = 7;
                                                  energy += E_MLstem(tt, -1, -1, P);
                                                }
                                              }
                                              break;

                default:                      break; /* this should never happen */
              }
              break;

    case 2:   switch(vc->type){
                case VRNA_VC_TYPE_SINGLE:     while(p < j){
                                                /* p must have a pairing partner */
                                                q  = (int)pt[p];
                                                /* get type of base pair (p,q) */
                                                tt = md->pair[s[p]][s[q]];
                                                if(tt == 0)
                                                  tt = 7;
                                                mm5 = ON_SAME_STRAND(p - 1, p, cp) ? s1[p-1] : -1;
                                                mm3 = ON_SAME_STRAND(q, q + 1, cp) ? s1[q+1] : -1;
                                                energy += E_MLstem(tt, mm5, mm3, P);

                                                /* seek to the next stem */
                                                p = q + 1;
                                                q_prev = q_prev2 = q;
                                                while (p <= j && !pt[p]) p++;
                                                u += p - q - 1; /* add unpaired nucleotides */

                                                if(sc){
                                                  if(sc->energy_up)
                                                    bonus += sc->energy_up[q+1][p-q-1];
                                                }
                                              }
                                              if(i > 0){  /* actual closing pair */
                                                tt = md->pair[s[j]][s[i]];
                                                if(tt == 0)
                                                  tt = 7;
                                                mm5 = ON_SAME_STRAND(j - 1, j, cp) ? s1[j-1] : -1;
                                                mm3 = ON_SAME_STRAND(i, i + 1, cp) ? s1[i+1] : -1;
                                                energy += E_MLstem(tt, mm5, mm3, P);

                                              } else {  /* virtual closing pair */
                                                energy += E_MLstem(0, -1, -1, P);
                                              }
                                              break;

                case VRNA_VC_TYPE_ALIGNMENT:  while(p < j){
                                                /* p must have a pairing partner */
                                                q  = (int)pt[p];
                                                
                                                for(ss = 0; ss < n_seq; ss++){
                                                  /* get type of base pair (p,q) */
                                                  tt = md->pair[S[ss][p]][S[ss][q]];
                                                  if(tt == 0)
                                                    tt = 7;

                                                  mm5 = ((a2s[ss][p] > 1) || circular) ? S5[ss][p] : -1;
                                                  mm3 = ((a2s[ss][q] < a2s[ss][S[0][0]]) || circular) ? S3[ss][q] : -1;
                                                  energy += E_MLstem(tt, mm5, mm3, P);
                                                }

                                                /* seek to the next stem */
                                                p = q + 1;
                                                q_prev = q_prev2 = q;
                                                while (p <= j && !pt[p]) p++;

                                                /* add unpaired nucleotides and possible soft constraints */
                                                if(scs){
                                                  for(ss = 0; ss < n_seq; ss++){
                                                    uu = a2s[ss][p] - a2s[ss][q + 1]; 
                                                    if(scs[ss] && scs[ss]->energy_up){
                                                      bonus += sc->energy_up[a2s[ss][q + 1]][uu];
                                                    }
                                                    u += uu;
                                                  }
                                                } else {
                                                  for(ss = 0; ss < n_seq; ss++){
                                                    u += a2s[ss][p] - a2s[ss][q + 1];
                                                  }
                                                }
                                              }

                                              if(i > 0){  /* actual closing pair */
                                                for(ss = 0; ss < n_seq; ss++){
                                                  tt = md->pair[S[ss][j]][S[ss][i]];
                                                  if(tt == 0)
                                                    tt = 7;

                                                  mm5 = S5[ss][j];
                                                  mm3 = S3[ss][i];
                                                  energy += E_MLstem(tt, mm5, mm3, P);
                                                }
                                              }
                                              break;

                default:                      break; /* this should never happen */
              }
              break;

    case 3:   /* we treat helix stacking different */
              for (count=0; count<2; count++) { /* do it twice */
                ld5 = 0; /* 5' dangle energy on prev pair (type) */
                if ( i==0 ) {
                  j = (unsigned int)pt[0]+1;
                  type = 0;  /* no pair */
                }
                else {
                  j = (unsigned int)pt[i];
                  type = P->model_details.pair[s[j]][s[i]]; if (type==0) type=7;
                  /* prime the ld5 variable */
                  if (ON_SAME_STRAND(j - 1, j, cp)) {
                    ld5 = P->dangle5[type][s1[j-1]];
                    if ((p=(unsigned int)pt[j-2]) && ON_SAME_STRAND(j - 2, j - 1, cp))
                    if (P->dangle3[P->model_details.pair[s[p]][s[j-2]]][s1[j-1]]<ld5) ld5 = 0;
                  }
                }
                i1=i; p = i+1; u=0;
                energy = 0; cx_energy=INF;
                do { /* walk around the multi-loop */
                  new_cx = INF;

                  /* hop over unpaired positions */
                  while (p <= (unsigned int)pt[0] && pt[p]==0) p++;

                  /* memorize number of unpaired positions */
                  u += p-i1-1;

                  if(sc){
                    if(sc->energy_up)
                      bonus += sc->energy_up[i1+1][p-i1-1];
                  }

                  /* get position of pairing partner */
                  if ( p == (unsigned int)pt[0]+1 ){
                    q = 0;tt = 0; /* virtual root pair */
                  } else {
                    q  = (unsigned int)pt[p];
                    /* get type of base pair P->q */
                    tt = P->model_details.pair[s[p]][s[q]]; if (tt==0) tt=7;
                  }

                  energy += mlintern[tt];
                  cx_energy += mlintern[tt];

                  dang5=dang3=0;
                  if ((ON_SAME_STRAND(p - 1, p, cp))&&(p>1))
                    dang5=P->dangle5[tt][s1[p-1]];      /* 5'dangle of pq pair */
                  if ((ON_SAME_STRAND(i1, i1 + 1, cp))&&(i1<(unsigned int)s[0]))
                    dang3 = P->dangle3[type][s1[i1+1]]; /* 3'dangle of previous pair */

                  switch (p-i1-1) {
                    case 0:   /* adjacent helices */
                              if (i1!=0){
                                if (ON_SAME_STRAND(i1, p, cp)) {
                                  new_cx = energy + P->stack[rtype[type]][rtype[tt]];
                                  /* subtract 5'dangle and TerminalAU penalty */
                                  new_cx += -ld5 - mlintern[tt]-mlintern[type]+2*mlintern[1];
                                }
                                ld5=0;
                                energy = MIN2(energy, cx_energy);
                              }
                              break;
                    case 1:   /* 1 unpaired base between helices */
                              dang = MIN2(dang3, dang5);
                              energy = energy +dang; ld5 = dang - dang3;
                              /* may be problem here: Suppose
                                cx_energy>energy, cx_energy+dang5<energy
                                and the following helices are also stacked (i.e.
                                we'll subtract the dang5 again */
                              if (cx_energy+dang5 < energy) {
                                energy = cx_energy+dang5;
                                ld5 = dang5;
                              }
                              new_cx = INF;  /* no coax stacking with mismatch for now */
                              break;
                    default:  /* many unpaired base between helices */
                              energy += dang5 +dang3;
                              energy = MIN2(energy, cx_energy + dang5);
                              new_cx = INF;  /* no coax stacking possible */
                              ld5 = dang5;
                              break;
                  }
                  type = tt;
                  cx_energy = new_cx;
                  i1 = q; p=q+1;
                } while (q!=i);
                best_energy = MIN2(energy, best_energy); /* don't use cx_energy here */
                /* fprintf(stderr, "%6.2d\t", energy); */
                /* skip a helix and start again */
                while (pt[p]==0) p++;
                if (i == (unsigned int)pt[p]) break;
                i = (unsigned int)pt[p];
              } /* end doing it twice */
              energy = best_energy;
              break;

    default:  E_mm5_available = E2_mm5_available  = INF;
              E_mm5_occupied  = E2_mm5_occupied   = 0;
              while(p < j){
                /* p must have a pairing partner */
                q  = (int)pt[p];
                /* get type of base pair (p,q) */
                tt = P->model_details.pair[s[p]][s[q]];
                if(tt==0) tt=7;
                if(q_prev + 2 < p){
                  E_mm5_available = MIN2(E_mm5_available, E_mm5_occupied);
                  E_mm5_occupied  = E_mm5_available;
                }
                if(q_prev2 + 2 < p){
                  E2_mm5_available  = MIN2(E2_mm5_available, E2_mm5_occupied);
                  E2_mm5_occupied   = E2_mm5_available;
                }
                mm5 = ((ON_SAME_STRAND(p - 1, p, cp)) && !pt[p-1])  ? s1[p-1] : -1;
                mm3 = ((ON_SAME_STRAND(q, q + 1, cp)) && !pt[q+1])  ? s1[q+1] : -1;
                e_stem    = E_MLstem(tt, -1, -1, P);
                e_stem5   = E_MLstem(tt, mm5, -1, P);
                e_stem3   = E_MLstem(tt, -1, mm3, P);
                e_stem53  = E_MLstem(tt, mm5, mm3, P);

                tmp   = E_mm5_occupied + e_stem3;
                tmp   = MIN2(tmp, E_mm5_available + e_stem53);
                tmp   = MIN2(tmp, E_mm5_available + e_stem3);
                tmp2  = E_mm5_occupied + e_stem;
                tmp2  = MIN2(tmp2, E_mm5_available + e_stem5);
                tmp2  = MIN2(tmp2, E_mm5_available + e_stem);

                E_mm5_occupied  = tmp;
                E_mm5_available = tmp2;

                tmp   = E2_mm5_occupied + e_stem3;
                tmp   = MIN2(tmp, E2_mm5_available + e_stem53);
                tmp   = MIN2(tmp, E2_mm5_available + e_stem3);
                tmp2  = E2_mm5_occupied + e_stem;
                tmp2  = MIN2(tmp2, E2_mm5_available + e_stem5);
                tmp2  = MIN2(tmp2, E2_mm5_available + e_stem);

                E2_mm5_occupied   = tmp;
                E2_mm5_available  = tmp2;

                /* seek to the next stem */
                p = q + 1;
                q_prev = q_prev2 = q;
                while (p <= j && !pt[p]) p++;
                u += p - q - 1; /* add unpaired nucleotides */

                if(sc){
                  if(sc->energy_up)
                    bonus += sc->energy_up[q+1][p-q-1];
                }
              }
              if(i > 0){  /* actual closing pair */
                type = P->model_details.pair[s[j]][s[i]]; if (type==0) type=7;
                mm5 = ((ON_SAME_STRAND(j - 1, j, cp)) && !pt[j-1])  ? s1[j-1] : -1;
                mm3 = ((ON_SAME_STRAND(i, i + 1, cp)) && !pt[i+1])  ? s1[i+1] : -1;
                if(q_prev + 2 < p){
                  E_mm5_available = MIN2(E_mm5_available, E_mm5_occupied);
                  E_mm5_occupied  = E_mm5_available;
                }
                if(q_prev2 + 2 < p){
                  E2_mm5_available  = MIN2(E2_mm5_available, E2_mm5_occupied);
                  E2_mm5_occupied   = E2_mm5_available;
                }
                e_stem    = E_MLstem(type, -1, -1, P);
                e_stem5   = E_MLstem(type, mm5, -1, P);
                e_stem3   = E_MLstem(type, -1, mm3, P);
                e_stem53  = E_MLstem(type, mm5, mm3, P);
              } else {  /* virtual closing pair */
                e_stem = e_stem5 = e_stem3 = e_stem53 = E_MLstem(0, -1, -1, P);
              }
              /* now lets see how we get the minimum including the enclosing stem */
              energy = E_mm5_occupied  + e_stem;
              energy = MIN2(energy, E_mm5_available   + e_stem5);
              energy = MIN2(energy, E_mm5_available   + e_stem);
              energy = MIN2(energy, E2_mm5_occupied   + e_stem3);
              energy = MIN2(energy, E2_mm5_occupied   + e_stem);
              energy = MIN2(energy, E2_mm5_available  + e_stem53);
              energy = MIN2(energy, E2_mm5_available  + e_stem3);
              energy = MIN2(energy, E2_mm5_available  + e_stem5);
              energy = MIN2(energy, E2_mm5_available  + e_stem);
              break;
  }/* end switch dangle_model */

  switch(vc->type){
    case VRNA_VC_TYPE_SINGLE:     energy += P->MLclosing;
                                  break;

    case VRNA_VC_TYPE_ALIGNMENT:  energy += P->MLclosing * n_seq;
                                  break;

    default:                      break;
  }

  /* logarithmic ML loop energy if logML */
  /* does this work for comparative predictions as well? */
  if(logML && (u>6))
    energy += 6*P->MLbase+(int)(P->lxc*log((double)u/6.));
  else
    energy += (u*P->MLbase);

  return energy + bonus;
}



PRIVATE int
cut_in_loop(int i, const short *pt, int cp){

  /* walk around the loop;  return j pos of pair after cut if
     cut_point in loop else 0 */
  int  p, j;
  p = j = pt[i];
  do {
    i  = pt[p];  p = i+1;
    while ( pt[p]==0 ) p++;
  } while (p!=j && ON_SAME_STRAND(i, p, cp));
  return ON_SAME_STRAND(i, p, cp) ? 0 : j;
}

/* below are the consensus structure evaluation functions */

PRIVATE int
covar_energy_of_struct_pt(vrna_fold_compound_t *vc,
                              const short *pt){

  int e       = 0;
  int length  = vc->length;
  int i;

  for (i=1; i<=length; i++) {
    if (pt[i]==0) continue;
    e += stack_energy_covar_pt(vc, i, pt);
    i=pt[i];
  }

  return e;
}


PRIVATE int
en_corr_of_loop_gquad_ali(vrna_fold_compound_t *vc,
                      int i,
                      int j,
                      const char *structure,
                      const short *pt,
                      const int *loop_idx){

  int pos, energy, p, q, r, s, u, type, type2, gq_en[2];
  int num_elem, num_g, elem_i, elem_j, up_mis;
  int L, l[3];

  short           **S           = vc->S;
  short           **S5          = vc->S5;     /*S5[s][i] holds next base 5' of i in sequence s*/
  short           **S3          = vc->S3;     /*Sl[s][i] holds next base 3' of i in sequence s*/
  char            **Ss          = vc->Ss;
  unsigned short  **a2s         = vc->a2s;
  vrna_param_t    *P            = vc->params;
  vrna_md_t       *md           = &(P->model_details);
  int             n_seq         = vc->n_seq;
  int             dangle_model  = md->dangles;

  energy = 0;
  q = i;
  while((pos = parse_gquad(structure + q-1, &L, l)) > 0){
    q += pos-1;
    p = q - 4*L - l[0] - l[1] - l[2] + 1;
    if(q > j) break;
    /* we've found the first g-quadruplex at position [p,q] */
    E_gquad_ali_en(p, L, l, (const short **)S, n_seq, gq_en, P);
    energy    += gq_en[0];
    /* check if it's enclosed in a base pair */
    if(loop_idx[p] == 0){ q++; continue; /* g-quad in exterior loop */}
    else{
      energy += E_MLstem(0, -1, -1, P) * n_seq;
      /*  find its enclosing pair */
      num_elem  = 0;
      num_g     = 1;
      r         = p - 1;
      up_mis    = q - p + 1;

      /* seek for first pairing base located 5' of the g-quad */
      for(r = p - 1; !pt[r] && (r >= i); r--);
      if(r < i) vrna_message_error("this should not happen");

      if(r < pt[r]){ /* found the enclosing pair */
        s = pt[r];
      } else {
        num_elem++;
        elem_i = pt[r];
        elem_j = r;
        r = pt[r]-1 ;
        /* seek for next pairing base 5' of r */
        for(; !pt[r] && (r >= i); r--);
        if(r < i) vrna_message_error("so nich");
        if(r < pt[r]){ /* found the enclosing pair */
          s = pt[r];
        } else {
          /* hop over stems and unpaired nucleotides */
          while((r > pt[r]) && (r >= i)){
            if(pt[r]){ r = pt[r]; num_elem++;}
            r--;
          }
          if(r < i) vrna_message_error("so nich");
          s = pt[r]; /* found the enclosing pair */
        }
      }
      /* now we have the enclosing pair (r,s) */

      u = q+1;
      /* we know everything about the 5' part of this loop so check the 3' part */
      while(u<s){
        if(structure[u-1] == '.') u++;
        else if (structure[u-1] == '+'){ /* found another gquad */
          pos = parse_gquad(structure + u - 1, &L, l);
          if(pos > 0){
            E_gquad_ali_en(u, L, l, (const short **)S, n_seq, gq_en, P);
            energy += gq_en[0] + E_MLstem(0, -1, -1, P) * n_seq;
            up_mis += pos;
            u += pos;
            num_g++;
          }
        } else { /* we must have found a stem */
          if(!(u < pt[u])) vrna_message_error("wtf!");
          num_elem++;
          elem_i = u;
          elem_j = pt[u];
          energy += en_corr_of_loop_gquad_ali(vc,
                                u,
                                pt[u],
                                structure,
                                pt,
                                loop_idx);
          u = pt[u] + 1;
        }
      }
      if(u!=s) vrna_message_error("what the ...");
      else{ /* we are done since we've found no other 3' structure element */
        switch(num_elem){
          /* g-quad was misinterpreted as hairpin closed by (r,s) */
          case 0:   /*if(num_g == 1)
                      if((p-r-1 == 0) || (s-q-1 == 0))
                        vrna_message_error("too few unpaired bases");
                    */
                    {
                      int ee = 0;
                      int cnt;
                      for(cnt=0;cnt<n_seq;cnt++){
                        type = md->pair[S[cnt][r]][S[cnt][s]];
                        if(type == 0) type = 7;
                        if ((a2s[cnt][s-1]-a2s[cnt][r])<3) ee+=600;
                        else ee += E_Hairpin( a2s[cnt][s-1] - a2s[cnt][r],
                                              type,
                                              S3[cnt][r],
                                              S5[cnt][s],
                                              Ss[cnt] + a2s[cnt][r-1],
                                              P);
                      }
                      energy -= ee;
                      ee = 0;
                      for(cnt=0;cnt < n_seq; cnt++){
                        type = md->pair[S[cnt][r]][S[cnt][s]];
                        if(type == 0) type = 7;
                        if(dangle_model == 2)
                          ee += P->mismatchI[type][S3[cnt][r]][S5[cnt][s]];
                        if(type > 2)
                          ee += P->TerminalAU;
                      }
                      energy += ee;
                    }
                    energy += n_seq * P->internal_loop[s-r-1-up_mis];
                    break;
          /* g-quad was misinterpreted as interior loop closed by (r,s) with enclosed pair (elem_i, elem_j) */
          case 1:   {
                      int ee = 0;
                      int cnt;
                      for(cnt = 0; cnt<n_seq;cnt++){
                        type = md->pair[S[cnt][r]][S[cnt][s]];
                        if(type == 0) type = 7;
                        type2 = md->pair[S[cnt][elem_j]][S[cnt][elem_i]];
                        if(type2 == 0) type2 = 7;
                        ee += E_IntLoop(a2s[cnt][elem_i-1] - a2s[cnt][r],
                                        a2s[cnt][s-1] - a2s[cnt][elem_j],
                                        type,
                                        type2,
                                        S3[cnt][r],
                                        S5[cnt][s],
                                        S5[cnt][elem_i],
                                        S3[cnt][elem_j],
                                        P);
                      }
                      energy -= ee;
                      ee = 0;
                      for(cnt = 0; cnt < n_seq; cnt++){
                        type = md->pair[S[cnt][s]][S[cnt][r]];
                        if(type == 0) type = 7;
                        ee += E_MLstem(type, S5[cnt][s], S3[cnt][r], P);
                        type = md->pair[S[cnt][elem_i]][S[cnt][elem_j]];
                        if(type == 0) type = 7;
                        ee += E_MLstem(type, S5[cnt][elem_i], S3[cnt][elem_j], P);
                      }
                      energy += ee;
                    }
                    energy += (P->MLclosing + (elem_i-r-1+s-elem_j-1-up_mis) * P->MLbase) * n_seq;
                    break;
          /* gquad was misinterpreted as unpaired nucleotides in a multiloop */
          default:  energy -= (up_mis) * P->MLbase * n_seq;
                    break;
        }
      }
      q = s+1;
    }
  }

  return energy;

}

PRIVATE int
covar_en_corr_of_loop_gquad(vrna_fold_compound_t *vc,
                            int i,
                            int j,
                            const char *structure,
                            const short *pt,
                            const int *loop_idx){

  int pos, en_covar, p, q, r, s, u, gq_en[2];
  int num_elem, num_g, up_mis;
  int L, l[3];

  short           **S           = vc->S;
  vrna_param_t    *P            = vc->params;
  int             n_seq         = vc->n_seq;

  en_covar = 0;
  q = i;
  while((pos = parse_gquad(structure + q-1, &L, l)) > 0){
    q += pos-1;
    p = q - 4*L - l[0] - l[1] - l[2] + 1;
    if(q > j) break;
    /* we've found the first g-quadruplex at position [p,q] */
    E_gquad_ali_en(p, L, l, (const short **)S, n_seq, gq_en, P);
    en_covar  += gq_en[1];
    /* check if it's enclosed in a base pair */
    if(loop_idx[p] == 0){ q++; continue; /* g-quad in exterior loop */}
    else{
      /*  find its enclosing pair */
      num_elem  = 0;
      num_g     = 1;
      r         = p - 1;
      up_mis    = q - p + 1;

      /* seek for first pairing base located 5' of the g-quad */
      for(r = p - 1; !pt[r] && (r >= i); r--);
      if(r < i) vrna_message_error("this should not happen");

      if(r < pt[r]){ /* found the enclosing pair */
        s = pt[r];
      } else {
        num_elem++;
        r = pt[r]-1 ;
        /* seek for next pairing base 5' of r */
        for(; !pt[r] && (r >= i); r--);
        if(r < i) vrna_message_error("so nich");
        if(r < pt[r]){ /* found the enclosing pair */
          s = pt[r];
        } else {
          /* hop over stems and unpaired nucleotides */
          while((r > pt[r]) && (r >= i)){
            if(pt[r]){ r = pt[r]; num_elem++;}
            r--;
          }
          if(r < i) vrna_message_error("so nich");
          s = pt[r]; /* found the enclosing pair */
        }
      }
      /* now we have the enclosing pair (r,s) */

      u = q+1;
      /* we know everything about the 5' part of this loop so check the 3' part */
      while(u<s){
        if(structure[u-1] == '.') u++;
        else if (structure[u-1] == '+'){ /* found another gquad */
          pos = parse_gquad(structure + u - 1, &L, l);
          if(pos > 0){
            E_gquad_ali_en(u, L, l, (const short **)S, n_seq, gq_en, P);
            en_covar += gq_en[1];
            up_mis += pos;
            u += pos;
            num_g++;
          }
        } else { /* we must have found a stem */
          if(!(u < pt[u])) vrna_message_error("wtf!");
          num_elem++;
          en_covar += covar_en_corr_of_loop_gquad(vc,
                                u,
                                pt[u],
                                structure,
                                pt,
                                loop_idx);
          u = pt[u] + 1;
        }
      }
      if(u!=s) vrna_message_error("what the ...");
      else{
        /* we are done since we've found no other 3' structure element */
      }
      q = s+1;
    }
  }

  return en_covar;
}


PRIVATE int
stack_energy_covar_pt(vrna_fold_compound_t *vc,
                      int i,
                      const short *pt){

  /* calculate energy of substructure enclosed by (i,j) */
  int             *indx       = vc->jindx;     /* index for moving in the triangle matrices c[] and fMl[]*/
  int             *pscore     = vc->pscore;     /* precomputed array of pair types */

  int energy = 0;
  int j, p, q;

  j = pt[i];
  p=i; q=j;
  while (p<q) { /* process all stacks and interior loops */
    while (pt[++p]==0);
    while (pt[--q]==0);
    if ((pt[q]!=(short)p)||(p>q)) break;
    energy += pscore[indx[j]+i];
    i=p; j=q;
  }  /* end while */

  /* p,q don't pair must have found hairpin or multiloop */

  if (p>q) { /* hairpin case */
    energy += pscore[indx[j]+i];
    return energy;
  }

  /* (i,j) is exterior pair of multiloop */
  energy += pscore[indx[j]+i];
  while (p<j) {
    /* add up the contributions of the substructures of the ML */
    energy += stack_energy_covar_pt(vc, p, pt);
    p = pt[p];
    /* search for next base pair in multiloop */
    while (pt[++p]==0);
  }

  return energy;
}


/*
#################################
# DEPRECATED functions below    #
#################################
*/

PRIVATE vrna_fold_compound_t *
recycle_last_call(const char *string,
                  vrna_param_t *P){

  vrna_fold_compound_t  *vc;
  vrna_md_t           *md;
  int                 cleanup;
  char                *seq;

  vc      = NULL;
  cleanup = 0;

  if(P){
    md = &(P->model_details);
  } else {
    md = (vrna_md_t *)vrna_alloc(sizeof(vrna_md_t));
    set_model_details(md);
    cleanup = 1;
  }

  if(string){
    if(backward_compat_compound){
      if(!strcmp(string, backward_compat_compound->sequence)){ /* check if sequence is the same as before */
        md->window_size = (int)backward_compat_compound->length;
        if(!memcmp(md, &(backward_compat_compound->params->model_details), sizeof(vrna_md_t))){ /* check if model_details are the same as before */
          vc = backward_compat_compound; /* re-use previous vrna_fold_compound_t */
        }
      }
    }
  }

  /* prepare a new global vrna_fold_compound_t with current settings */
  if(!vc){
    vrna_fold_compound_free(backward_compat_compound);
    seq = vrna_cut_point_insert(string, cut_point);
    backward_compat_compound = vc = vrna_fold_compound(seq, md, VRNA_OPTION_EVAL_ONLY);
    if(P){
      free(vc->params);
      vc->params = get_updated_params(P, 1);
    }
    free(seq);
  }

  if(cleanup)
    free(md);

  return vc;
}


PUBLIC float
energy_of_struct( const char *string,
                  const char *structure){

  float               en;
  vrna_fold_compound_t  *vc;

  vc = recycle_last_call(string, NULL);

  if(eos_debug > 0)
    en = vrna_eval_structure_verbose(vc, structure, NULL);
  else
    en = vrna_eval_structure(vc, structure);

  return en;
}

PUBLIC int
energy_of_struct_pt(const char *string,
                    short *pt,
                    short *s,
                    short *s1){

  int                 en;
  vrna_fold_compound_t  *vc;

  if(pt && string){
    if(pt[0] != (short)strlen(string))
      vrna_message_error("energy_of_structure_pt: string and structure have unequal length");

    vc  = recycle_last_call(string, NULL);
    en  = eval_pt(vc, pt, NULL, eos_debug);

    return en;
  } else
    return INF;
}

PUBLIC float
energy_of_circ_struct(const char *string,
                      const char *structure){

  float               en;
  vrna_fold_compound_t  *vc;

  vc = recycle_last_call(string, NULL);

  vc->params->model_details.circ = 1;

  if(eos_debug > 0)
    en = vrna_eval_structure_verbose(vc, structure, NULL);
  else
    en = vrna_eval_structure(vc, structure);

  return en;
}

PUBLIC  float
energy_of_structure(const char *string,
                    const char *structure,
                    int verbosity_level){

  float               en;
  vrna_fold_compound_t  *vc;

  vc = recycle_last_call(string, NULL);

  return vrna_eval_structure_v(vc, structure, verbosity_level, NULL);
}

PUBLIC float
energy_of_struct_par( const char *string,
                      const char *structure,
                      vrna_param_t *parameters,
                      int verbosity_level){

  float               en;
  vrna_fold_compound_t  *vc;

  vc = recycle_last_call(string, parameters);

  return vrna_eval_structure_v(vc, structure, verbosity_level, NULL);
}


PUBLIC float
energy_of_gquad_structure(const char *string,
                          const char *structure,
                          int verbosity_level){

  float               en;
  vrna_fold_compound_t  *vc;

  vc = recycle_last_call(string, NULL);

  vc->params->model_details.gquad = 1;

  return vrna_eval_structure_v(vc, structure, verbosity_level, NULL);
}

PUBLIC float
energy_of_gquad_struct_par( const char *string,
                            const char *structure,
                            vrna_param_t *parameters,
                            int verbosity_level){


  float               en;
  vrna_fold_compound_t  *vc;

  vc = recycle_last_call(string, parameters);

  vc->params->model_details.gquad = 1;

  return vrna_eval_structure_v(vc, structure, verbosity_level, NULL);
}

PUBLIC int
energy_of_structure_pt( const char *string,
                        short *pt,
                        short *s,
                        short *s1,
                        int verbosity_level){

  int                 en;
  vrna_fold_compound_t  *vc;

  if(pt && string){
    if(pt[0] != (short)strlen(string))
      vrna_message_error("energy_of_structure_pt: string and structure have unequal length");

    vc  = recycle_last_call(string, NULL);
    en  = eval_pt(vc, pt, NULL, verbosity_level);

    return en;
  } else
    return INF;
}

PUBLIC int
energy_of_struct_pt_par(const char *string,
                        short *pt,
                        short *s,
                        short *s1,
                        vrna_param_t *parameters,
                        int verbosity_level){

  int en;
  vrna_fold_compound_t *vc;

  if(pt && string){
    if(pt[0] != (short)strlen(string))
      vrna_message_error("energy_of_structure_pt: string and structure have unequal length");

    vc  = recycle_last_call(string, parameters);
    en  = eval_pt(vc, pt, NULL, verbosity_level);

    return en;
  } else
    return INF;
}

PUBLIC float
energy_of_circ_structure( const char *string,
                          const char *structure,
                          int verbosity_level){

  float               en;
  vrna_fold_compound_t  *vc;

  vc = recycle_last_call(string, NULL);

  vc->params->model_details.circ = 1;

  return vrna_eval_structure_v(vc, structure, verbosity_level, NULL);
}

PUBLIC float
energy_of_circ_struct_par(const char *string,
                          const char *structure,
                          vrna_param_t *parameters,
                          int verbosity_level){

  float               en;
  vrna_fold_compound_t  *vc;

  vc = recycle_last_call(string, parameters);

  vc->params->model_details.circ = 1;

  return vrna_eval_structure_v(vc, structure, verbosity_level, NULL);
}

PUBLIC int
loop_energy(short *pt,
            short *s,
            short *s1,
            int i){

  int                 en, u;
  char                *seq;
  vrna_md_t           md;
  vrna_fold_compound_t  *vc;

  set_model_details(&md);

  /* convert encoded sequence back to actual string */
  seq = (char *)vrna_alloc(sizeof(char) * (s[0]+1));
  for(u = 1; u <= s[0]; u++){
    seq[u-1] = vrna_nucleotide_decode(s[u], &md);
  }
  seq[u-1] = '\0';

  vc  = recycle_last_call(seq, NULL);
  en  = wrap_eval_loop_pt(vc, i, pt, eos_debug);

  free(seq);

  return en;
}


PUBLIC float
energy_of_move( const char *string,
                const char *structure,
                int m1,
                int m2){

  float               en;
  vrna_fold_compound_t  *vc;

  vc  = recycle_last_call(string, NULL);
  en  = vrna_eval_move(vc, structure, m1, m2);

  return en;
}

PUBLIC int
energy_of_move_pt(short *pt,
                  short *s,
                  short *s1,
                  int m1,
                  int m2){

  int                 en, u;
  char                *seq;
  vrna_md_t           md;
  vrna_fold_compound_t  *vc;

  set_model_details(&md);

  /* convert encoded sequence back to actual string */
  seq = (char *)vrna_alloc(sizeof(char) * (s[0]+1));
  for(u = 1; u <= s[0]; u++){
    seq[u-1] = vrna_nucleotide_decode(s[u], &md);
  }
  seq[u-1] = '\0';

  vc  = recycle_last_call(seq, NULL);
  en  = vrna_eval_move_pt(vc, pt, m1, m2);

  free(seq);

  return en;
}

constraints.c/  0           0     0     644     4874      `
/* constraints handling */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>

#include "utils.h"
#include "file_formats.h"
#include "constraints.h"


/*
#################################
# GLOBAL VARIABLES              #
#################################
*/

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/
PUBLIC  void
vrna_constraints_add( vrna_fold_compound_t *vc,
                      const char *constraint,
                      unsigned int options){

  int         i, d;

  if(vc){
    if(!vc->hc)
      vrna_hc_init(vc);

    if(options & VRNA_CONSTRAINT_DB){ /* apply hard constraints from dot-bracket notation */
      vrna_hc_add_from_db(vc, constraint, options);
    } else { /* constraints from file is the default */
      plist *p, *c = vrna_file_constraints_read(constraint, vc->length, 0);

      /* now do something with the constraints we've just read */
      if(c){
        FLT_OR_DBL  **sc_bp       = (FLT_OR_DBL **)vrna_alloc(sizeof(FLT_OR_DBL *) * (vc->length + 1));
        FLT_OR_DBL  *sc_up        = (FLT_OR_DBL *)vrna_alloc(sizeof(FLT_OR_DBL) * (vc->length + 1));
        int     sc_up_present = 0;
        int     sc_bp_present = 0;
        int     num_hc_up     = 0;
        int     mem_hc_up     = 10;
        vrna_hc_up_t  *hc_up  = NULL;

        hc_up = vrna_alloc(sizeof(vrna_hc_up_t) * mem_hc_up);

        for(i = 0; i <= vc->length; i++)
          sc_bp[i] = (FLT_OR_DBL *)vrna_alloc(sizeof(FLT_OR_DBL) * (vc->length + 1));

        for(p = c; p->i; p++){
          if(p->type & 4096){ /* soft constraint */

            if(num_hc_up > 0){ /* apply previously collected hc_up */
              hc_up[num_hc_up].position = 0; /* mark end of list */
              vrna_hc_add_up_batch(vc, hc_up);
              num_hc_up   = 0;
            }

            if(p->j == 0){  /* pseudo energy for unpairedness */
              sc_up_present = 1;
              sc_up[p->i] += (FLT_OR_DBL)p->p;
            } else { /* pseudo energy for base pair */
              sc_bp_present = 1;
              sc_bp[p->i][p->j] += (FLT_OR_DBL)p->p;
            }
          } else {  /* hard constraint */
            if(p->j == 0){ /* collect successive hard constraints for single unpaired nucleotides */
              hc_up[num_hc_up].position = p->i;
              hc_up[num_hc_up].options  = (char)p->type;
              num_hc_up++;
              if(num_hc_up == mem_hc_up){
                mem_hc_up = (int)(1.2 * mem_hc_up);
                hc_up  = (vrna_hc_up_t *)vrna_realloc(hc_up, sizeof(vrna_hc_up_t) * mem_hc_up);
              }
            } else {

              if(num_hc_up > 0){ /* apply previously collected hc_up */
                hc_up[num_hc_up].position = 0; /* mark end of list */
                vrna_hc_add_up_batch(vc, hc_up);
                num_hc_up   = 0;
              }

              if(p->i == p->j){ 
                d = 0;
                if(1024 & p->type)
                  d = -1;
                else if(2048 & p->type)
                  d = 1;
                if(p->type & 8192)
                  vrna_hc_add_bp_nonspecific(vc, p->i, d, (char)(p->type) | VRNA_CONSTRAINT_CONTEXT_NO_REMOVE);
                else
                  vrna_hc_add_bp_nonspecific(vc, p->i, d, (char)(p->type));
              } else {
                if(p->type & 8192){
                  vrna_hc_add_bp(vc, p->i, p->j, (char)(p->type) | VRNA_CONSTRAINT_CONTEXT_NO_REMOVE);
                } else {
                  vrna_hc_add_bp(vc, p->i, p->j, (char)(p->type));
                }
              }
            }
          }
        }

        /* ############################### */
        /* add hard constraints            */
        /* ############################### */
        if(num_hc_up > 0){
          hc_up[num_hc_up].position = 0; /* mark end of list */
          vrna_hc_add_up_batch(vc, hc_up);
        }
        free(hc_up);

        /* ############################### */
        /* init empty soft constraints     */
        /* ############################### */
        if(sc_up_present || sc_bp_present){
          vrna_sc_init(vc);
          if(sc_bp_present)
            vrna_sc_add_bp(vc, (const FLT_OR_DBL **)sc_bp, options);
          if(sc_up_present)
            vrna_sc_add_up(vc, (const FLT_OR_DBL *)sc_up, options);
        }
        /* clean up */
        for(i = 0; i <= vc->length; i++)
          free(sc_bp[i]);
        free(sc_bp);
        free(sc_up);
      }

      free(c);
    }
  }
}
ligand.c/       0           0     0     644     19818     `
/*
 * Reference implementation for including ligand binding to hairpins, or
 * interior loops, with known sequence and/or structure motif, and
 * binding free energy utilizing generic soft constraint feature
 *
 * (c) 2015 Ronny Lorenz - ViennaRNA Package
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

#include "utils.h"
#include "model.h"
#include "constraints.h"
#include "eval.h"
#include "ligand.h"


/*
#################################
# PRIVATE DATA STRUCTURES       #
#################################
*/

typedef struct{
  int i;
  int j;
  int k;
  int l;
} quadruple_position;

typedef struct{
  char  *seq_motif_5;
  char  *seq_motif_3;
  char  *struct_motif_5;
  char  *struct_motif_3;
  int   energy;
  int   energy_alt;
  int   pair_count;
  vrna_basepair_t *pairs;

  quadruple_position *positions;
} ligand_data;

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/

static void
split_sequence( const char *string,
                      char **seq1,
                      char **seq2,
                      int cp);

static void
correctMotifContribution( const char *seq,
                          const char *struct_motif,
                          const char *struct_motif_alt,
                          int *contribution,
                          int *contribution_alt,
                          vrna_md_t *md);

static void
delete_ligand_data(void *data);

static int
AptamerContrib(int i, int j, int k, int l, char d, void *data);

static int
AptamerContribHairpin(int i, int j, int k, int l, char d, void *data);

static FLT_OR_DBL
expAptamerContrib(int i, int j, int k, int l, char d, void *data);

static FLT_OR_DBL
expAptamerContribHairpin(int i, int j, int k, int l, char d, void *data);

static vrna_basepair_t *
backtrack_int_motif(int i, int j, int k, int l, char d, void *data);

static vrna_basepair_t *
backtrack_hp_motif(int i, int j, int k, int l, char d, void *data);

static quadruple_position *
scanForMotif( const char *seq,
              const char *motif1,
              const char *motif2);

static vrna_basepair_t *
scanForPairs( const char  *motif5,
              const char  *motif3,
              int         *pair_count);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PUBLIC int
vrna_sc_detect_hi_motif(vrna_fold_compound_t *vc,
                        const char *structure,
                        int *i,
                        int *j,
                        int *k,
                        int *l){

  int p, q, n;
  quadruple_position  *pos;
  ligand_data         *ldata;

  if(vc && vc->sc && vc->sc->data){
    n = vc->length;
    ldata = (ligand_data *)vc->sc->data;

    for(p = *i; p < n; p++){
      for(pos = ldata->positions; pos->i; pos++){
        if(pos->i == p){
          /* check whether we find the motif in the provided structure */
          int i_m, j_m, k_m, l_m;
          i_m = pos->i;
          j_m = pos->j;
          k_m = pos->k;
          l_m = pos->l;
          for(q = 0; q < strlen(ldata->struct_motif_5); q++){
            if(ldata->struct_motif_5[q] != structure[i_m+q-1])
              break;
          }
          if(q == strlen(ldata->struct_motif_5)){ /* 5' motif detected */
            if(k_m > 0){
              for(q = 0; q < strlen(ldata->struct_motif_3); q++){
                if(ldata->struct_motif_3[q] != structure[l_m+q-1])
                  break;
              }
              if(q == strlen(ldata->struct_motif_3)){ /* 3' motif detected */
                *i = i_m;
                *j = j_m;
                *k = k_m;
                *l = l_m;
                return 1;
              }
            } else {
                *i = i_m;
                *j = j_m;
                *k = k_m;
                *l = l_m;
                return 1;
            }
          }
        }
      }
    }
      
  }
  return 0;
}

PUBLIC int
vrna_sc_get_hi_motif( vrna_fold_compound_t *vc,
                      int *i,
                      int *j,
                      int *k,
                      int *l){

  int p, n;
  quadruple_position  *pos;
  ligand_data         *ldata;

  if(vc && vc->sc && vc->sc->data){
    n = vc->length;
    ldata = (ligand_data *)vc->sc->data;

    for(p = *i; p < n; p++){
      for(pos = ldata->positions; pos->i; pos++){
        if(pos->i == p){
          *i = pos->i;
          *j = pos->j;
          *k = pos->k;
          *l = pos->l;
          return 1;
        }
      }
    }
  }
  return 0;
}

PUBLIC int
vrna_sc_add_hi_motif( vrna_fold_compound_t *vc,
                      const char *seq,
                      const char *structure,
                      FLT_OR_DBL energy,
                      unsigned int options){

    int                   i, cp, cp2;
    char                  *sequence, *motif, *motif_alt;
    vrna_md_t             *md_p;
    ligand_data           *ldata;

    sequence              = NULL;
    motif                 = NULL;
    motif_alt             = NULL;
    ldata                 = NULL;
    md_p                  = NULL;

    sequence  = vrna_cut_point_remove(seq, &cp);                /* ligand sequence motif  */
    motif     = vrna_cut_point_remove(structure, &cp2);         /* ligand structure motif */

    /* check for obvious inconsistencies in input sequence/structure motif */
    if(cp != cp2){
      vrna_message_warning("vrna_sc_add_ligand_binding@ligand.c: Cutpoint in sequence and structure motif differ!");
      goto hi_motif_error;
    } else if(strlen(seq) != strlen(structure)){
      vrna_message_warning("vrna_sc_add_ligand_binding@ligand.c: length of sequence and structure motif differ!");
      goto hi_motif_error;
    }

    /* create auxiliary soft constraints data structure */
    ldata                 = vrna_alloc(sizeof(ligand_data));
    ldata->seq_motif_5    = NULL;
    ldata->seq_motif_3    = NULL;
    ldata->struct_motif_5 = NULL;
    ldata->struct_motif_3 = NULL;
    ldata->positions      = NULL;
    ldata->energy         = (int)(energy * 100.);

    split_sequence(sequence, &(ldata->seq_motif_5), &(ldata->seq_motif_3), cp);
    split_sequence(motif, &(ldata->struct_motif_5), &(ldata->struct_motif_3), cp);

    motif_alt = vrna_alloc(sizeof(char) * (strlen(motif) + 1)); /* alternative structure motif */
    memset(motif_alt, '.', strlen(motif) - 1);

    if(cp > 0){
      if((motif[0] != '(') || (motif[strlen(motif) - 1] != ')') || (motif[cp-2] != '(') || (motif[cp-1] != ')')){
        vrna_message_warning("vrna_sc_add_ligand_binding@ligand.c: No closing and/or enclosed pair in interior loop motif!");
        goto hi_motif_error;
      }
      /* construct corresponding alternative interior loop motif (....(&)...) */
      motif_alt[0] = '(';
      motif_alt[cp-2] = '(';
      motif_alt[cp-1] = ')';
      motif_alt[strlen(motif) - 1] = ')';
      motif_alt[strlen(motif)] = '\0';

      vrna_sc_add_bt(vc, &backtrack_int_motif);
      vrna_sc_add_f(vc, &AptamerContrib);
      vrna_sc_add_exp_f(vc, &expAptamerContrib);

    } else {
      if((motif[0] != '(') || (motif[strlen(motif) - 1] != ')')){
        vrna_message_warning("vrna_sc_add_ligand_binding@ligand.c: No closing pair in hairpin motif!");
        goto hi_motif_error;
      }

      /* construct corresponding alternative hairpin motif (....) */
      motif_alt[0] = '(';
      motif_alt[strlen(motif) - 1] = ')';
      motif_alt[strlen(motif)] = '\0';

      vrna_sc_add_bt(vc, &backtrack_hp_motif);
      vrna_sc_add_f(vc, &AptamerContribHairpin);
      vrna_sc_add_exp_f(vc, &expAptamerContribHairpin);
    }

    /* correct motif contributions */
    if(vc->params)
      md_p = &(vc->params->model_details);
    else
      md_p = &(vc->exp_params->model_details);

    correctMotifContribution(seq, motif, motif_alt, &(ldata->energy), &(ldata->energy_alt), md_p);

    /* scan for sequence motif positions */
    ldata->positions = scanForMotif(vc->sequence, ldata->seq_motif_5, ldata->seq_motif_3);

    /* scan for additional base pairs in the structure motif */
    int pair_count = 0;
    vrna_basepair_t *pairs = scanForPairs(ldata->struct_motif_5, ldata->struct_motif_3, &pair_count);
    if((pair_count > 0) && (pairs == NULL)){ /* error while parsing structure motif */
      vrna_message_warning("vrna_sc_add_ligand_binding@ligand.c: Error while parsing additional pairs in structure motif");
      goto hi_motif_error;
    }

    ldata->pairs      = pairs;
    ldata->pair_count = pair_count;

    /* add generalized soft-constraint data structure and corresponding 'delete' function */
    vrna_sc_add_data(vc, (void *)ldata, &delete_ligand_data);

    free(sequence);
    free(motif);
    free(motif_alt);

    return 1; /* success */

/* exit with error */
hi_motif_error:

    free(sequence);
    free(motif);
    free(motif_alt);
    delete_ligand_data(ldata);

    return 0;
}

static void
split_sequence( const char *string,
                      char **seq1,
                      char **seq2,
                      int cp){

  int l = (int)strlen(string);
  *seq1 = NULL;
  *seq2 = NULL;

  if(cp > 0){
    if(cp < l){
      *seq1 = vrna_alloc(sizeof(char) * cp);
      strncpy(*seq1, string, cp - 1);
      (*seq1)[cp - 1] = '\0';
      *seq2 = vrna_alloc(sizeof(char) * (l - cp + 2));
      strncpy(*seq2, string + cp - 1, (l - cp + 1));
      (*seq2)[l - cp + 1] = '\0';
    }
  } else {
    *seq1 = vrna_alloc(sizeof(char) * (l+1));
    strncpy(*seq1, string, l);
    (*seq1)[l] = '\0';
  }
}

static void
correctMotifContribution( const char *seq,
                          const char *struct_motif,
                          const char *struct_motif_alt,
                          int *contribution,
                          int *contribution_alt,
                          vrna_md_t *md){

  float                 alt, corr, energy;
  vrna_fold_compound_t  *tmp_vc;

  tmp_vc  = vrna_fold_compound(seq, md, VRNA_OPTION_EVAL_ONLY);
  alt     = vrna_eval_structure(tmp_vc, struct_motif_alt);
  corr    = vrna_eval_structure(tmp_vc, struct_motif);
  energy  = corr - alt;

  *contribution     += (int)(energy * 100.);
  *contribution_alt  = (int)(alt    * 100.);

  vrna_fold_compound_free(tmp_vc);
}

static void
delete_ligand_data(void *data){

  ligand_data *ldata = (ligand_data *)data;

  free(ldata->seq_motif_5);
  free(ldata->seq_motif_3);
  free(ldata->struct_motif_5);
  free(ldata->struct_motif_3);
  free(ldata->positions);
  free(ldata->pairs);

  free(data);
}

static int
AptamerContrib(int i, int j, int k, int l, char d, void *data){

  quadruple_position  *pos;
  ligand_data         *ldata;

  if(d == VRNA_DECOMP_PAIR_IL){
    ldata = (ligand_data *)data;
    for(pos = ((ligand_data *)data)->positions; pos->i; pos++){
      if((pos->i == i) && (pos->j == j) && (pos->k == k) && (pos->l == l)){
        return ldata->energy;
      }
    }
  }

  return 0;
}

static int
AptamerContribHairpin(int i, int j, int k, int l, char d, void *data){

  quadruple_position  *pos;
  ligand_data         *ldata;

  if(d == VRNA_DECOMP_PAIR_HP){
    ldata = (ligand_data *)data;
    for(pos = ((ligand_data *)data)->positions; pos->i; pos++){
      if((pos->i == i) && (pos->j == j)){
        return ldata->energy;
      }
    }
  }

  return 0;
}

static FLT_OR_DBL
expAptamerContrib(int i, int j, int k, int l, char d, void *data){

  quadruple_position  *pos;
  ligand_data         *ldata;
  FLT_OR_DBL          exp_e;
  double              kT;

  exp_e = 1.;

  if(d == VRNA_DECOMP_PAIR_IL){
    ldata = (ligand_data *)data;
    kT    = (37. + K0) * GASCONST;

    for(pos = ldata->positions; pos->i; pos++){
      if((pos->i == i) && (pos->j == j) && (pos->k == k) && (pos->l == l)){
        exp_e =   (FLT_OR_DBL)exp((double) (-ldata->energy) * 10./kT);
        exp_e +=  (FLT_OR_DBL)exp((double) (-ldata->energy_alt) * 10./kT); /* add alternative, i.e. unbound ligand */
        break;
      }
    }
  }

  return exp_e;
}

static FLT_OR_DBL
expAptamerContribHairpin(int i, int j, int k, int l, char d, void *data){

  quadruple_position  *pos;
  ligand_data         *ldata;
  FLT_OR_DBL          exp_e;
  double              kT;

  exp_e = 1.;

  if(d == VRNA_DECOMP_PAIR_HP){
    ldata = (ligand_data *)data;
    kT    = (37. + K0) * GASCONST;

    for(pos = ldata->positions; pos->i; pos++){
      if((pos->i == i) && (pos->j == j)){
        exp_e =   (FLT_OR_DBL)exp((double) (-ldata->energy) * 10./kT);
        exp_e +=  (FLT_OR_DBL)exp((double) (-ldata->energy_alt) * 10./kT); /* add alternative, i.e. unbound ligand */
        break;
      }
    }
  }

  return exp_e;
}

static vrna_basepair_t *
backtrack_int_motif(int i, int j, int k, int l, char d, void *data){

  int                 bp_size = 15;
  vrna_basepair_t     *pairs = NULL;
  quadruple_position  *pos;
  ligand_data         *ldata;

  if(d == VRNA_DECOMP_PAIR_IL){
    ldata = (ligand_data *)data;
    for(pos = ldata->positions; pos->i; pos++){
      if((pos->i == i) && (pos->j == j) && (pos->k == k) && (pos->l == l)){
        /* found motif in our list, lets create pairs */
        char  *ptr;
#if 0
        int   actual_size = 0;
        pairs = vrna_alloc(sizeof(vrna_basepair_t) * bp_size);

        for(ptr=ldata->struct_motif_5; *ptr != '\0'; ptr++, i++){
          if(*ptr == '.'){
            pairs[actual_size].i = pairs[actual_size].j = i;
            actual_size++;
            if(actual_size == bp_size){
              bp_size *= 2;
              pairs = vrna_realloc(pairs, sizeof(vrna_basepair_t) * bp_size);
            }
          }
        }
        for(ptr=ldata->struct_motif_3; *ptr != '\0'; ptr++, l++){
          if(*ptr == '.'){
            pairs[actual_size].i = pairs[actual_size].j = l;
            actual_size++;
            if(actual_size == bp_size){
              bp_size *= 2;
              pairs = vrna_realloc(pairs, sizeof(vrna_basepair_t) * bp_size);
            }
          }
        }
        pairs = vrna_realloc(pairs, sizeof(vrna_basepair_t) * (actual_size + 1));
        pairs[actual_size].i = pairs[actual_size].j = -1;
#else
        pairs = vrna_alloc(sizeof(vrna_basepair_t) * (ldata->pair_count + 1));
        vrna_basepair_t *pptr;
        int             count;
        for(count = 0,pptr = ldata->pairs; pptr && (pptr->i != 0); pptr++, count++){
          pairs[count].i = (pptr->i < 0) ? j + pptr->i : i + pptr->i - 1;
          pairs[count].j = (pptr->j < 0) ? j + pptr->j : i + pptr->j - 1;
        }
        pairs[count].i = pairs[count].j = 0;
#endif

        return pairs;
      }
    }
  }

  return pairs;
}

static vrna_basepair_t *
backtrack_hp_motif(int i, int j, int k, int l, char d, void *data){

  int                 count;
  vrna_basepair_t     *pairs = NULL;
  quadruple_position  *pos;
  ligand_data         *ldata;
  vrna_basepair_t     *pptr;

  if(d == VRNA_DECOMP_PAIR_HP){
    ldata = (ligand_data *)data;
    for(pos = ldata->positions; pos->i; pos++){
      if((pos->i == i) && (pos->j == j)){
        /* found motif in our list, lets create pairs */
        pairs = vrna_alloc(sizeof(vrna_basepair_t) * (ldata->pair_count + 1));
        for(count = 0,pptr = ldata->pairs; pptr && (pptr->i != 0); pptr++, count++){
          pairs[count].i = i + pptr->i - 1;
          pairs[count].j = i + pptr->j - 1;
        }
        pairs[count].i = pairs[count].j = 0;
        return pairs;
      }
    }
  }

  return pairs;
}

static quadruple_position *
scanForMotif( const char *seq,
              const char *motif1,
              const char *motif2){

  int   i, j, k, l, l1, l2, n, cnt, cnt2;
  char  *ptr;
  quadruple_position *pos;
  
  n     = (int) strlen(seq);
  l1    = (int) strlen(motif1);
  l2    = (motif2) ? (int) strlen(motif2) : 0;
  cnt   = 0;
  cnt2  = 5; /* initial guess how many matching motifs we might encounter */

  pos = (quadruple_position *)vrna_alloc(sizeof(quadruple_position) * cnt2);

  for(i = 0; i <= n - l1 - l2; i++){
    if(seq[i] == motif1[0]){
      for(j = i+1; j < i + l1; j++){
        if(seq[j] == motif1[j-i]){
          continue;
        }
        else goto next_i;
      }
      /* found 5' motif */
      if(motif2){
        for(k = j + 1; k <= n - l2; k++){
          if(seq[k] == motif2[0]){
            for(l = k + 1; l < k + l2; l++){
              if(seq[l] == motif2[l-k]){
                continue;
              }
              else goto next_k;
            }
            /* we found a quadruple, so store it */
            pos[cnt].i   = i + 1;
            pos[cnt].j   = l;
            pos[cnt].k   = j;
            pos[cnt++].l = k + 1;

            /* allocate more memory if necessary */
            if(cnt == cnt2){
              cnt2 *= 2;
              pos = (quadruple_position *)vrna_realloc(pos, sizeof(quadruple_position) * cnt2);
            }
          }
/* early exit from l loop */
next_k: continue;
        }
      } else { /* hairpin loop motif */
        /* store it */
        pos[cnt].i   = i + 1;
        pos[cnt].j   = j;
        pos[cnt].k   = 0;
        pos[cnt++].l = 0;

        /* allocate more memory if necessary */
        if(cnt == cnt2){
          cnt2 *= 2;
          pos = (quadruple_position *)vrna_realloc(pos, sizeof(quadruple_position) * cnt2);
        }
      }
    }
/* early exit from j loop */
next_i: continue;
  }

  /* reallocate to actual size */
  pos = (quadruple_position *)vrna_realloc(pos, sizeof(quadruple_position) * (cnt + 1));

  /* set end marker */
  pos[cnt].i = pos[cnt].j = pos[cnt].k = pos[cnt].l = 0;

  return pos;
}

static vrna_basepair_t *
scanForPairs( const char  *motif5,
              const char  *motif3,
              int         *pair_count){

  int             i, l5, l3, stack_size, stack_count, *stack;
  vrna_basepair_t *pairs;

  l5          = (motif5) ? strlen(motif5) : 0;
  l3          = (motif3) ? strlen(motif3) : 0;
  stack_count = 0;
  stack_size  = l5 + l3 + 1;
  *pair_count = 0;
  stack       = vrna_alloc(sizeof(int)              * stack_size);
  pairs       = vrna_alloc(sizeof(vrna_basepair_t)  * stack_size);

  /* go through 5' side of structure motif */
  for(i = 2; i < l5; i++){
    if(motif5[i - 1] == '('){
      stack[stack_count++] = i;
    } else if(motif5[i - 1] == ')'){
      pairs[*pair_count].i = stack[--stack_count];
      pairs[*pair_count].j = i;
      /* printf("5' p[%d, %d]\n", pairs[*pair_count].i, pairs[*pair_count].j); */
      (*pair_count)++;
      if(stack_count < 0){
        vrna_message_warning("vrna_sc_add_ligand_binding@ligand.c: 5' structure motif contains unbalanced brackets");
        free(stack);
        free(pairs);
        return NULL;
      }
    }
  }

  if(motif3){
    for(i = 2; i < l3; i++){ /* go through 3' side of motif */
      if(motif3[i-1] == '('){
        stack[stack_count++] = -(l3 - i);
      } else if(motif3[i-1] == ')'){
        pairs[*pair_count].i = stack[--stack_count];
        pairs[*pair_count].j = -(l3 - i);
        /* printf("3' p[%d, %d]\n", pairs[*pair_count].i, pairs[*pair_count].j); */
        (*pair_count)++;
        if(stack_count < 0){
          vrna_message_warning("vrna_sc_add_ligand_binding@ligand.c: 3' structure motif contains unbalanced brackets");
          free(stack);
          free(pairs);
          return NULL;
        }
      }
    }
  }

  if(stack_count != 0){
    vrna_message_warning("vrna_sc_add_ligand_binding@ligand.c: structure motif contains unbalanced brackets");
    (*pair_count)++;
    free(stack);
    free(pairs);
    return NULL;
  }

  if(*pair_count > 0){
    pairs = vrna_realloc(pairs, sizeof(vrna_basepair_t) * (*pair_count + 1));
    pairs[*pair_count].i = pairs[*pair_count].j = 0;
  } else {
    free(pairs);
    pairs = NULL;
  }

  free(stack);

  return pairs;
}

/62             0           0     0     644     14911     `

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include "perturbation_fold.h"
#include "eval.h"
#include "fold_vars.h"
#include "constraints.h"
#include "fold.h"
#include "part_func.h"
#include "utils.h"
#include "params.h"

#include <assert.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WITH_GSL
#include <gsl/gsl_multimin.h>
#endif

static void calculate_probability_unpaired(vrna_fold_compound_t *vc, double *probability)
{
  int length = vc->length;
  FLT_OR_DBL *probs = vc->exp_matrices->probs;
  int *iidx = vc->iindx;
  int i, j;

  for (i = 0; i <= length; ++i)
    probability[i] = 1;

  for (i = 1; i <= length; ++i)
    for (j = i + 1; j <= length; ++j)
    {
      probability[i] -= probs[iidx[i]-j];
      probability[j] -= probs[iidx[i]-j];
    }
}

static double calculate_norm(double *vector, int length)
{
  double sum = 0;
  int i;

  for (i = 1; i <= length; ++i)
    sum += vector[i] * vector[i];

  return sqrt(sum);
}

static void addSoftConstraint(vrna_fold_compound_t *vc, const double *epsilon, int length)
{
  vrna_sc_t *sc;
  int i, j;
  double kT = vc->exp_params->kT / 1000;

  sc = vrna_alloc(sizeof(vrna_sc_t));

  sc->exp_energy_up = vrna_alloc(sizeof(FLT_OR_DBL*) * (length + 2));
  sc->exp_energy_up[0] = vrna_alloc(1);
  for (i = 1; i <= length; ++i)
    sc->exp_energy_up[i] = vrna_alloc(sizeof(FLT_OR_DBL) * (length - i + 2));

  for (i = 1; i <= length; ++i)
  {
    sc->exp_energy_up[i][0] = 1;
    for (j = 1; j <= length - i + 1; ++j)
      sc->exp_energy_up[i][j] = sc->exp_energy_up[i][j-1] * exp(-(epsilon[i + j - 1]) / kT);
  }

  /* also add sc for MFE computation */
  sc->energy_up = vrna_alloc(sizeof(int*) * (length + 2));
  sc->energy_up[0] = vrna_alloc(sizeof(int));
  for (i = 1; i <= length; ++i)
    sc->energy_up[i] = vrna_alloc(sizeof(int) * (length - i + 2));

  for (i = 1; i <= length; ++i){
    sc->energy_up[i][0] = 0;
    for (j = 1; j <= length - i + 1; ++j)
      sc->energy_up[i][j] = sc->energy_up[i][j-1] + (epsilon[i + j - 1]*100.);
  }

  vc->sc = sc;
}

static double evaluate_objective_function_contribution(double value, int objective_function)
{
  if (objective_function == VRNA_OBJECTIVE_FUNCTION_QUADRATIC)
    return value * value;
  if (objective_function == VRNA_OBJECTIVE_FUNCTION_ABSOLUTE)
    return fabs(value);

  assert(0);
  return 0;
}

static double evaluate_perturbation_vector_score(vrna_fold_compound_t *vc, const double *epsilon, const double *q_prob_unpaired, double sigma_squared, double tau_squared, int objective_function)
{
  double kT, ret = 0;
  double ret2 = 0.;
  double *p_prob_unpaired;
  int i;
  int length = vc->length;

  /* calculate pairing probabilty in the pertubated energy model */
  p_prob_unpaired = vrna_alloc(sizeof(double) * (length + 1));

  addSoftConstraint(vc, epsilon, length);

  vc->exp_params->model_details.compute_bpp = 1;

  /* get new (constrained) MFE to scale pf computations properly */
  double mfe = (double)vrna_mfe(vc, NULL);
  vrna_exp_params_rescale(vc, &mfe);

  vrna_pf(vc, NULL);

  calculate_probability_unpaired(vc, p_prob_unpaired);

  vrna_sc_remove(vc);

  
  for (i = 1; i <= length; ++i)
  {
    /* add penalty for pertubation energies */
    ret += evaluate_objective_function_contribution(epsilon[i], objective_function) / tau_squared;

    /* add penalty for mismatches between observed and predicted probabilities */
    if (q_prob_unpaired[i] >= 0) /* ignore positions with missing data */
      ret2 += evaluate_objective_function_contribution(p_prob_unpaired[i] - q_prob_unpaired[i], objective_function) / sigma_squared;
  }

  fprintf(stderr, "Score: pertubation: %g\tdiscrepancy: %g\n", ret, ret2);
  free(p_prob_unpaired);

  return ret + ret2;
}

static void pairing_probabilities_from_restricted_pf(vrna_fold_compound_t *vc, const double *epsilon, double *prob_unpaired, double **conditional_prob_unpaired)
{
  int length = vc->length;
  int i;

  addSoftConstraint(vc, epsilon, length);
  vc->exp_params->model_details.compute_bpp = 1;

  /* get new (constrained) MFE to scale pf computations properly */
  double mfe = (double)vrna_mfe(vc, NULL);
  vrna_exp_params_rescale(vc, &mfe);

  vrna_pf(vc, NULL);

  calculate_probability_unpaired(vc, prob_unpaired);

#ifdef _OPENMP
  #pragma omp parallel for private(i)
#endif
  for (i = 1; i <= length; ++i)
  {
    vrna_fold_compound_t *restricted_vc;
    char *hc_string;
    unsigned int constraint_options = VRNA_CONSTRAINT_DB
                                      | VRNA_CONSTRAINT_DB_PIPE
                                      | VRNA_CONSTRAINT_DB_DOT
                                      | VRNA_CONSTRAINT_DB_X
                                      | VRNA_CONSTRAINT_DB_ANG_BRACK
                                      | VRNA_CONSTRAINT_DB_RND_BRACK;

    hc_string = vrna_alloc(sizeof(char) * (length + 1));
    memset(hc_string, '.', length);
    hc_string[i - 1] = 'x';

    restricted_vc = vrna_fold_compound(vc->sequence, &(vc->exp_params->model_details), VRNA_OPTION_PF);
    vrna_constraints_add(restricted_vc, hc_string, constraint_options);
    free(hc_string);

    vrna_exp_params_subst(restricted_vc, vc->exp_params);

    vrna_pf(restricted_vc, NULL);
    calculate_probability_unpaired(restricted_vc, conditional_prob_unpaired[i]);

    restricted_vc->sc = NULL;
    vrna_fold_compound_free(restricted_vc);
  }

  vrna_sc_remove(vc);
}

static void pairing_probabilities_from_sampling(vrna_fold_compound_t *vc, const double *epsilon, int sample_size, double *prob_unpaired, double **conditional_prob_unpaired)
{
  double kT;
  int length = vc->length;
  int i, j, s;
  st_back = 1; /* is this really required? */

  addSoftConstraint(vc, epsilon, length);

  vc->exp_params->model_details.compute_bpp = 0;

  /* get new (constrained) MFE to scale pf computations properly */
  double mfe = (double)vrna_mfe(vc, NULL);
  vrna_exp_params_rescale(vc, &mfe);

  vrna_pf(vc, NULL);


#ifdef _OPENMP
  #pragma omp parallel for private(s)
#endif
  for (s = 0; s < sample_size; ++s)
  {
    char *sample = vrna_pbacktrack(vc);

#ifdef _OPENMP
    #pragma omp critical
#endif
    {
      for (i = 1; i <= length; ++i)
      {
        if (sample[i-1] != '.')
          continue;

        ++prob_unpaired[i];

        for (j = 1; j <= length; ++j)
          if (sample[j-1] == '.')
            ++conditional_prob_unpaired[i][j];
      }
    }

    free(sample);
  }

  for (i = 1; i <= length; ++i)
  {
    if (prob_unpaired[i])
      for (j = 1; j <= length; ++j)
        conditional_prob_unpaired[i][j] /= prob_unpaired[i];

    prob_unpaired[i] /= sample_size;

    assert(prob_unpaired[i] >= 0 && prob_unpaired[i] <= 1);
  }

  vrna_sc_remove(vc);
}

static void allocateProbabilityArrays(double **unpaired, double ***conditional_unpaired, int length)
{
  int i;

  *unpaired = vrna_alloc(sizeof(double) * (length + 1));
  *conditional_unpaired = vrna_alloc(sizeof(double*) * (length + 1));

  for (i = 1; i <= length; ++i)
    (*conditional_unpaired)[i] = vrna_alloc(sizeof(double) * (length + 1));
}

static void freeProbabilityArrays(double *unpaired, double **conditional_unpaired, int length)
{
  int i;

  free(unpaired);
  for (i = 1; i <= length; ++i)
    free(conditional_unpaired[i]);
  free(conditional_unpaired);
}

static void evaluate_perturbation_vector_gradient(vrna_fold_compound_t *vc, const double *epsilon, const double *q_prob_unpaired, double sigma_squared, double tau_squared, int objective_function, int sample_size, double *gradient)
{
  double *p_prob_unpaired;
  double **p_conditional_prob_unpaired;
  int i, mu;
  int length = vc->length;
  double kT = vc->exp_params->kT / 1000;

  allocateProbabilityArrays(&p_prob_unpaired, &p_conditional_prob_unpaired, length);

  if (sample_size > 0)
    pairing_probabilities_from_sampling(vc, epsilon, sample_size, p_prob_unpaired, p_conditional_prob_unpaired);
  else
    pairing_probabilities_from_restricted_pf(vc, epsilon, p_prob_unpaired, p_conditional_prob_unpaired);

  for (mu = 1; mu <= length; ++mu)
  {
    double sum = 0;

    if (objective_function == VRNA_OBJECTIVE_FUNCTION_QUADRATIC)
    {
      for (i = 1; i <= length; ++i)
      {
        if (q_prob_unpaired[i] < 0) /* ignore positions with missing data */
          continue;

        sum += (p_prob_unpaired[i] - q_prob_unpaired[i])
               * p_prob_unpaired[i] * (p_prob_unpaired[mu] - p_conditional_prob_unpaired[i][mu])
               / sigma_squared;
      }

      gradient[mu] = 2 * (epsilon[mu] / tau_squared + sum/kT);
    }
    else if (objective_function == VRNA_OBJECTIVE_FUNCTION_ABSOLUTE)
    {
      for (i = 1; i <= length; ++i)
        if (q_prob_unpaired[i] >= 0 && p_prob_unpaired[i] != q_prob_unpaired[i])
          sum += (p_prob_unpaired[i] * (p_prob_unpaired[mu] - p_conditional_prob_unpaired[i][mu])) / kT
                 / sigma_squared
                 * (p_prob_unpaired[i] > q_prob_unpaired[i] ? 1. : -1.);

      if (epsilon[mu])
        sum += (epsilon[mu] > 0 ? 1. : -1.) / tau_squared;

      gradient[mu] = sum;
    }
  }

  freeProbabilityArrays(p_prob_unpaired, p_conditional_prob_unpaired, length);
}

#ifdef WITH_GSL
typedef struct parameters_gsl {
  vrna_fold_compound_t *vc;
  const double *q_prob_unpaired;
  double sigma_squared;
  double tau_squared;
  int objective_function;
  int sample_size;
} parameters_gsl;

static double f_gsl(const gsl_vector *x, void *params)
{
  parameters_gsl *p = params;

  return evaluate_perturbation_vector_score(p->vc, x->data, p->q_prob_unpaired, p->sigma_squared, p->tau_squared, p->objective_function);
}

static void df_gsl(const gsl_vector *x, void *params, gsl_vector *df)
{
  parameters_gsl *p = params;

  gsl_vector_set(df, 0, 0);
  evaluate_perturbation_vector_gradient(p->vc, x->data, p->q_prob_unpaired, p->sigma_squared, p->tau_squared, p->objective_function, p->sample_size, df->data);
}

static void fdf_gsl(const gsl_vector *x, void *params, double *f, gsl_vector *g)
{
  *f = f_gsl(x, params);
  df_gsl(x, params, g);
}
#endif /* WITH_GSL */

PUBLIC void
vrna_sc_minimize_pertubation(vrna_fold_compound_t *vc,
                              const double *q_prob_unpaired,
                              int objective_function,
                              double sigma_squared,
                              double tau_squared,
                              int algorithm,
                              int sample_size,
                              double *epsilon,
                              double initialStepSize,
                              double minStepSize,
                              double minImprovement,
                              double minimizerTolerance,
                              progress_callback callback){

  int iteration_count = 0;
  const int max_iterations = 100;
  int length = vc->length;

#ifdef WITH_GSL
  const gsl_multimin_fdfminimizer_type *minimizer_type = 0;

  struct {int type; const gsl_multimin_fdfminimizer_type *gsl_type;} algorithms[] = {{VRNA_MINIMIZER_CONJUGATE_FR, gsl_multimin_fdfminimizer_conjugate_fr},
                                                                                     {VRNA_MINIMIZER_CONJUGATE_PR, gsl_multimin_fdfminimizer_conjugate_pr},
                                                                                     {VRNA_MINIMIZER_VECTOR_BFGS, gsl_multimin_fdfminimizer_vector_bfgs},
                                                                                     {VRNA_MINIMIZER_VECTOR_BFGS2, gsl_multimin_fdfminimizer_vector_bfgs2},
                                                                                     {VRNA_MINIMIZER_STEEPEST_DESCENT, gsl_multimin_fdfminimizer_steepest_descent},
                                                                                     {0, NULL}};
  int i;
  for (i = 0; algorithms[i].type; ++i)
    if (algorithms[i].type == algorithm)
    {
      minimizer_type = algorithms[i].gsl_type;
      break;
    }

  if (minimizer_type)
  {
    parameters_gsl parameters;
    gsl_multimin_function_fdf fdf;
    gsl_multimin_fdfminimizer *minimizer;
    gsl_vector *vector;

    int status;

    parameters.vc = vc;
    parameters.q_prob_unpaired = q_prob_unpaired;
    parameters.sigma_squared = sigma_squared;
    parameters.tau_squared = tau_squared;
    parameters.objective_function = objective_function;
    parameters.sample_size = sample_size;

    fdf.n = length + 1;
    fdf.f = &f_gsl;
    fdf.df = &df_gsl;
    fdf.fdf = &fdf_gsl;
    fdf.params = (void*)&parameters;

    minimizer = gsl_multimin_fdfminimizer_alloc(minimizer_type, length + 1);
    vector = gsl_vector_calloc(length + 1);

    /* gsl_multimin_fdfminimizer_set(minimizer, &fdf, vector, 0.01, 1e-4); */
    gsl_multimin_fdfminimizer_set(minimizer, &fdf, vector, initialStepSize, minimizerTolerance);

    if (callback)
      callback(0, minimizer->f, minimizer->x->data);

    do
    {
      ++iteration_count;
      status = gsl_multimin_fdfminimizer_iterate(minimizer);

      if (callback)
        callback(iteration_count, minimizer->f, minimizer->x->data);

      if (status)
        break;

      status = gsl_multimin_test_gradient(minimizer->gradient, minimizerTolerance);
    }
    while (status == GSL_CONTINUE && iteration_count < max_iterations);

    memcpy(epsilon, minimizer->x->data, sizeof(double) * (length + 1));

    gsl_multimin_fdfminimizer_free(minimizer);
    gsl_vector_free(vector);

    return;
  }
#endif /* WITH_GSL */

  double improvement;
  const double min_improvement = minImprovement;

  double *new_epsilon = vrna_alloc(sizeof(double) * (length + 1));
  double *gradient = vrna_alloc(sizeof(double) * (length + 1));

  double score = evaluate_perturbation_vector_score(vc, epsilon, q_prob_unpaired, sigma_squared, tau_squared, objective_function);

  if (callback)
    callback(0, score, epsilon);

  do
  {
    double new_score;
    double step_size;

    ++iteration_count;

    evaluate_perturbation_vector_gradient(vc, epsilon, q_prob_unpaired, sigma_squared, tau_squared, objective_function, sample_size, gradient);

    /*    step_size = 0.5 / calculate_norm(gradient, length);*/
    step_size = initialStepSize;

    do
    {
      int i;
      for (i = 1; i <= length; ++i)
        new_epsilon[i] = epsilon[i] - step_size * gradient[i];

      new_score = evaluate_perturbation_vector_score(vc, new_epsilon, q_prob_unpaired, sigma_squared, tau_squared, objective_function);
      improvement = 1 - new_score / score;
      step_size /= 2;
    } while ((improvement < min_improvement) && (step_size >= minStepSize));

    if (new_score > score)
      break;

    if (callback)
      callback(iteration_count, new_score, new_epsilon);

    score = new_score;
    memcpy(epsilon, new_epsilon, sizeof(double) * (length+1));
  } while (improvement >= min_improvement && iteration_count < max_iterations);

  free(gradient);
  free(new_epsilon);
}


centroid.c/     0           0     0     644     5414      `
/*
                  centroid structure prediction

                  Ivo L Hofacker + Ronny Lorenz
                  Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "utils.h"
#include "fold_vars.h"
#include "gquad.h"
#include "centroid.h"

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PUBLIC char *
vrna_centroid_from_plist( int length,
                          double *dist,
                          vrna_plist_t *pl){

  /* compute the centroid structure of the ensemble, i.e. the strutcure
     with the minimal average distance to all other structures
     <d(S)> = \sum_{(i,j) \in S} (1-p_{ij}) + \sum_{(i,j) \notin S} p_{ij}
     Thus, the centroid is simply the structure containing all pairs with
     p_ij>0.5 */
  int i;
  char *centroid;

  if (pl==NULL)
    vrna_message_error("vrna_centroid_from_plist@centroid.c: pl==NULL!");

  *dist = 0.;
  centroid = (char *) vrna_alloc((length+1)*sizeof(char));
  for (i=0; i<length; i++) centroid[i]='.';
  for (i=0; pl[i].i>0; i++){
    if ((pl[i].p)>0.5) {
      centroid[pl[i].i-1] = '(';
      centroid[pl[i].j-1] = ')';
      *dist += (1-pl[i].p);
    } else
      *dist += pl[i].p;
  }
  centroid[length] = '\0';
  return centroid;
}

PUBLIC char *
vrna_centroid_from_probs( int length,
                          double *dist,
                          FLT_OR_DBL *probs){

  /* compute the centroid structure of the ensemble, i.e. the strutcure
     with the minimal average distance to all other structures
     <d(S)> = \sum_{(i,j) \in S} (1-p_{ij}) + \sum_{(i,j) \notin S} p_{ij}
     Thus, the centroid is simply the structure containing all pairs with
     p_ij>0.5 */
  int i,j;
  FLT_OR_DBL p;
  char  *centroid;
  int   *index = vrna_idx_row_wise(length);

  if (probs == NULL)
    vrna_message_error("vrna_centroid_from_probs@centroid.c: probs==NULL!");

  *dist = 0.;
  centroid = (char *) vrna_alloc((length+1)*sizeof(char));
  for (i=0; i<length; i++) centroid[i]='.';
  for (i=1; i<=length; i++)
    for (j=i+TURN+1; j<=length; j++) {
      if ((p=probs[index[i]-j])>0.5) {
        centroid[i-1] = '(';
        centroid[j-1] = ')';
        *dist += (1-p);
      } else
        *dist += p;
    }
  free(index);
  centroid[length] = '\0';
  return centroid;
}

PUBLIC char *
vrna_centroid(vrna_fold_compound_t *vc,
             double *dist){

  /* compute the centroid structure of the ensemble, i.e. the strutcure
     with the minimal average distance to all other structures
     <d(S)> = \sum_{(i,j) \in S} (1-p_{ij}) + \sum_{(i,j) \notin S} p_{ij}
     Thus, the centroid is simply the structure containing all pairs with
     p_ij>0.5 */
  int i,j, k, length;
  FLT_OR_DBL p;
  char  *centroid;
  short *S;
  vrna_mx_pf_t      *matrices;
  FLT_OR_DBL        *probs;
  int               *my_iindx;
  vrna_exp_param_t  *pf_params;


  if(!vc){
    vrna_message_error("vrna_centroid@centroid.c: run vrna_pf_fold first!");
  } else if( !vc->exp_matrices->probs){
    vrna_message_error("vrna_centroid@centroid.c: probs==NULL!");
  }

  length      = vc->length;
  pf_params   = vc->exp_params;
  S           = vc->sequence_encoding2;
  my_iindx    = vc->iindx;

  matrices    = vc->exp_matrices;
  probs       = matrices->probs;

  *dist = 0.;
  centroid = (char *) vrna_alloc((length+1)*sizeof(char));
  for (i=0; i<length; i++) centroid[i]='.';
  for (i=1; i<=length; i++)
    for (j=i+TURN+1; j<=length; j++) {
      if ((p=probs[my_iindx[i]-j])>0.5) {
        if(pf_params->model_details.gquad){
          /* check for presence of gquadruplex */
          if((S[i] == 3) && (S[j] == 3)){
            int L, l[3];
            get_gquad_pattern_pf(S, i, j, pf_params, &L, l);
            for(k=0;k<L;k++){
              centroid[i+k-1]\
              = centroid[i+k+L+l[0]-1]\
              = centroid[i+k+2*L+l[0]+l[1]-1]\
              = centroid[i+k+3*L+l[0]+l[1]+l[2]-1]\
              = '+';
            }
            /* skip everything within the gquad */
            i = j; j = j+TURN+1;
            *dist += (1-p); /* right? */
            break;
          }
        }
        /* regular base pair */
        centroid[i-1] = '(';
        centroid[j-1] = ')';
        *dist += (1-p);
      } else
        *dist += p;
    }

  centroid[length] = '\0';
  return centroid;
}


/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/


/* this function is a threadsafe replacement for centroid() */
PUBLIC char *
get_centroid_struct_pl( int length,
                        double *dist,
                        vrna_plist_t *pl){

  return vrna_centroid_from_plist(length, dist, pl);
}

/* this function is a threadsafe replacement for centroid() */
PUBLIC char *
get_centroid_struct_pr( int length,
                        double *dist,
                        FLT_OR_DBL *probs){

  return vrna_centroid_from_probs(length, dist, probs);
}

/83             0           0     0     644     25454     `
/*
    structure_utils.c

    Various functions to convert, parse, encode secondary structures

    c  Ivo L Hofacker, Walter Fontana, Ronny Lorenz
                Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "fold_vars.h"
#include "utils.h"
#include "params.h"
#include "gquad.h"
#include "structure_utils.h"

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/
PRIVATE vrna_plist_t *
wrap_get_plist( vrna_mx_pf_t *matrices,
                int length,
                int *index,
                short *S,
                vrna_exp_param_t *pf_params,
                double cut_off);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PUBLIC char *
vrna_db_pack(const char *struc){

  /* 5:1 compression using base 3 encoding */
  int i,j,l,pi;
  unsigned char *packed;

  l = (int) strlen(struc);
  packed = (unsigned char *) vrna_alloc(((l+4)/5+1)*sizeof(unsigned char));

  j=i=pi=0;
  while (i<l) {
    register int p;
    for (p=pi=0; pi<5; pi++) {
      p *= 3;
      switch (struc[i]) {
      case '(':
      case '\0':
        break;
      case '.':
        p++;
        break;
      case ')':
        p += 2;
        break;
      default: vrna_message_error("pack_structure: illegal character in structure");
      }
      if (i<l) i++;
    }
    packed[j++] = (unsigned char) (p+1); /* never use 0, so we can use
                                            strcmp()  etc. */
  }
  packed[j] = '\0';      /* for str*() functions */
  return (char *) packed;
}

PUBLIC char *
vrna_db_unpack(const char *packed){

  /* 5:1 compression using base 3 encoding */
  int i,j,l;
  char *struc;
  unsigned const char *pp;
  char code[3] = {'(', '.', ')'};

  l = (int) strlen(packed);
  pp = (const unsigned char *) packed;
  struc = (char *) vrna_alloc((l*5+1)*sizeof(char));   /* up to 4 byte extra */

  for (i=j=0; i<l; i++) {
    register int p, c, k;

    p = (int) pp[i] - 1;
    for (k=4; k>=0; k--) {
      c = p % 3;
      p /= 3;
      struc[j+k] = code[c];
    }
    j += 5;
  }
  struc[j--] = '\0';
  while (struc[j] == '(') /* strip trailing ( */
    struc[j--] = '\0';

  return struc;
}

PUBLIC short *
vrna_ptable(const char *structure){

    /* returns array representation of structure.
       table[i] is 0 if unpaired or j if (i.j) pair.  */
   short i,j,hx;
   short length;
   short *stack;
   short *table;

   length = (short) strlen(structure);
   stack = (short *) vrna_alloc(sizeof(short)*(length+1));
   table = (short *) vrna_alloc(sizeof(short)*(length+2));
   table[0] = length;

   for (hx=0, i=1; i<=length; i++) {
      switch (structure[i-1]) {
       case '(':
         stack[hx++]=i;
         break;
       case ')':
         j = stack[--hx];
         if (hx<0) {
            fprintf(stderr, "%s\n", structure);
            vrna_message_error("unbalanced brackets in make_pair_table");
         }
         table[i]=j;
         table[j]=i;
         break;
       default:   /* unpaired base, usually '.' */
         table[i]= 0;
         break;
      }
   }
   if (hx!=0) {
      fprintf(stderr, "%s\n", structure);
      vrna_message_error("unbalanced brackets in make_pair_table");
   }
   free(stack);
   return(table);
}

PUBLIC short *
vrna_pt_pk_get(const char *structure){

   short i,j,hx, hx2;
   short length;
   short *stack;
   short *stack2;
   short *table;

   length = (short) strlen(structure);
   stack  = (short *) vrna_alloc(sizeof(short)*(length+1));
   stack2 = (short *) vrna_alloc(sizeof(short)*(length+1));
   table  = (short *) vrna_alloc(sizeof(short)*(length+2));
   table[0] = length;

   for (hx=0, hx2=0, i=1; i<=length; i++) {
      switch (structure[i-1]) {
       case '(':
         stack[hx++]=i;
         break;
       case ')':
         j = stack[--hx];
         if (hx<0) {
            fprintf(stderr, "%s\n", structure);
            vrna_message_error("unbalanced '()' brackets in make_pair_table_pk");
         }
         table[i]=j;
         table[j]=i;
         break;
       case '[':
         stack2[hx2++]=i;
         break;
       case ']':
         j = stack2[--hx2];
         if (hx2<0) {
            fprintf(stderr, "%s\n", structure);
            vrna_message_error("unbalanced '[]' brackets in make_pair_table_pk");
         }
         table[i]=j;
         table[j]=i;
         break;
       default:   /* unpaired base, usually '.' */
         table[i]= 0;
         break;
      }
   }
   if (hx!=0) {
      fprintf(stderr, "%s\n", structure);
      vrna_message_error("unbalanced '()' brackets in make_pair_table_pk");
   } else if (hx2!=0) {
      fprintf(stderr, "%s\n", structure);
      vrna_message_error("unbalanced '[]' brackets in make_pair_table_pk");
   }
   free(stack);
   free(stack2);
   return(table);
}


PUBLIC short *
vrna_pt_snoop_get(const char *structure){

    /* returns array representation of structure.
       table[i] is 0 if unpaired or j if (i.j) pair.  */
   short i,j,hx;
   short length;
   short *stack;
   short *table;

   length = (short) strlen(structure);
   stack = (short *) vrna_alloc(sizeof(short)*(length+1));
   table = (short *) vrna_alloc(sizeof(short)*(length+2));
   table[0] = length;

   for (hx=0, i=1; i<=length; i++) {
     switch (structure[i-1]) {
     case '<':
       stack[hx++]=i;
       break;
     case '>':
       j = stack[--hx];
       if (hx<0) {
         fprintf(stderr, "%s\n", structure);
         vrna_message_error("unbalanced brackets in make_pair_table");
       }
       table[i]=j;
       table[j]=i;
       break;
     default:   /* unpaired base, usually '.' */
       table[i]= table[i];
       break;
     }
   }
   if (hx!=0) {
     fprintf(stderr, "%s\n", structure);
     vrna_message_error("unbalanced brackets in make_pair_table");
   }
   free(stack);
   return table ;
}



PUBLIC short *
vrna_pt_ali_get(const char *structure){

    /* returns array representation of structure.
       table[i] is 0 if unpaired or j if (i.j) pair.  */
   short i,j,hx;
   short length;
   short *stack;
   short *table;

   length = (short) strlen(structure);
   stack = (short *) vrna_alloc(sizeof(short)*(length+1));
   table = (short *) vrna_alloc(sizeof(short)*(length+2));
   table[0] = length;

   for (hx=0, i=1; i<=length; i++) {
      switch (structure[i-1]) {
       case '(':
         stack[hx++]=i;
         break;
       case ')':
         j = stack[--hx];
         if (hx<0) {
            fprintf(stderr, "%s\n", structure);
            vrna_message_error("unbalanced brackets in make_pair_table");
         }
         table[i]=j;
         table[j]=i;
         break;
       default:   /* unpaired base, usually '.' */
         table[i]= 0;
         break;
      }
   }
   for (hx=0, i=1; i<=length; i++) {
      switch (structure[i-1]) {
       case '<':
         stack[hx++]=i;
         break;
       case '>':
         j = stack[--hx];
         if (hx<0) {
            fprintf(stderr, "%s\n", structure);
            vrna_message_error("unbalanced brackets in make_pair_table");
         }
         table[i]=j;
         table[j]=i;
         break;
       default:   /* unpaired base, usually '.' */
         table[i]= table[i];
         break;
      }
   }
   for (hx=0, i=1; i<=length; i++) {
     switch (structure[i-1]) {
     case '[':
       stack[hx++]=i;
       break;
     case ']':
       j = stack[--hx];
       if (hx<0) {
         fprintf(stderr, "%s\n", structure);
         vrna_message_error("unbalanced brackets in make_pair_table");
       }
       table[i]=j;
       table[j]=i;
       break;
     default:   /* unpaired base, usually '.' */
       break;
     }
   }
   if (hx!=0) {
      fprintf(stderr, "%s\n", structure);
      vrna_message_error("unbalanced brackets in make_pair_table");
   }
   free(stack);
   return(table);
}

PUBLIC short *
vrna_ptable_copy(const short *pt){
  short *table = (short *)vrna_alloc(sizeof(short) * (pt[0]+2));
  memcpy(table, pt, sizeof(short)*(pt[0]+2));
  return table;
}


PUBLIC int *
vrna_loopidx_from_ptable(const short *pt){

  /* number each position by which loop it belongs to (positions start
     at 1) */
  int i,hx,l,nl;
  int length;
  int *stack = NULL;
  int *loop = NULL;

  length = pt[0];
  stack  = (int *) vrna_alloc(sizeof(int)*(length+1));
  loop   = (int *) vrna_alloc(sizeof(int)*(length+2));
  hx=l=nl=0;

  for (i=1; i<=length; i++) {
    if ((pt[i] != 0) && (i < pt[i])) { /* ( */
      nl++; l=nl;
      stack[hx++]=i;
    }
    loop[i]=l;

    if ((pt[i] != 0) && (i > pt[i])) { /* ) */
      --hx;
      if (hx>0)
        l = loop[stack[hx-1]];  /* index of enclosing loop   */
      else l=0;                 /* external loop has index 0 */
      if (hx<0) {
        vrna_message_error("unbalanced brackets in make_pair_table");
      }
    }
  }
  loop[0] = nl;
  free(stack);
  return (loop);
}

PUBLIC char *
vrna_db_from_ptable(short *pt){

  int i;
  char *dotbracket = NULL;
  if(pt){
    dotbracket = (char *)vrna_alloc((pt[0]+1)*sizeof(char));
    memset(dotbracket, '.', pt[0]);

    for(i=1; i<=pt[0]; i++){
      if(pt[i] > i){
        dotbracket[i-1] = '(';
        dotbracket[pt[i]-1] = ')';
      }
    }
    dotbracket[i-1] = '\0';
  }
  return dotbracket;
}

/*---------------------------------------------------------------------------*/

PUBLIC int
vrna_bp_distance(const char *str1, const char *str2){

  /* dist = {number of base pairs in one structure but not in the other} */
  /* same as edit distance with pair_open pair_close as move set */
   int dist;
   short i,l;
   short *t1, *t2;

   dist = 0;
   t1 = vrna_ptable(str1);
   t2 = vrna_ptable(str2);

   l = (t1[0]<t2[0])?t1[0]:t2[0];    /* minimum of the two lengths */

   for (i=1; i<=l; i++)
     if (t1[i]!=t2[i]) {
       if (t1[i]>i) dist++;
       if (t2[i]>i) dist++;
     }
   free(t1); free(t2);
   return dist;
}

/* get a matrix containing the number of basepairs of a reference structure for each interval [i,j] with i<j
*  access it via iindx!!!
*/
PUBLIC unsigned int *
vrna_refBPcnt_matrix( const short *reference_pt,
                      unsigned int turn){

  unsigned int i,j,k,ij,length;
  int *iindx;
  unsigned int *array;
  unsigned int size;
  length = (unsigned int)reference_pt[0];
  size  = ((length+1)*(length+2))/2;
  iindx = vrna_idx_row_wise(length);
  array = (unsigned int *) vrna_alloc(sizeof(unsigned int)*size);    /* matrix containing number of basepairs of reference structure1 in interval [i,j] */;
  for (k=0; k<=turn; k++)
    for (i=1; i<=length-k; i++) {
      j=i+k;
      ij = iindx[i]-j;
      array[ij] = 0;
    }

  for (i = length-turn-1; i >= 1; i--)
    for (j = i+turn+1; j <= length; j++){
      int bps;
      ij = iindx[i]-j;
      bps = array[ij+1];
      if((i<=(unsigned int)reference_pt[j]) && ((unsigned int)reference_pt[j] < j))
        bps++;
      array[ij] = bps;
    }
  free(iindx);
  return array;
}


PUBLIC unsigned int *
vrna_refBPdist_matrix(const short *pt1,
                      const short *pt2,
                      unsigned int turn){

  unsigned int *array;
  unsigned int n, size, i, j, ij, d;
  n = (unsigned int)pt1[0];
  size = ((n+1)*(n+2))/2;
  array = (unsigned int *)vrna_alloc(sizeof(unsigned int) * size);
  int *iindx = vrna_idx_row_wise(n);
  for(i = n - turn - 1; i>=1; i--){
    d = 0;
    for(j = i+turn+1; j <= n; j++){
      ij = iindx[i]-j;
      d = array[ij+1];
      if(pt1[j] != pt2[j]){
        if(i <= (unsigned int)pt1[j] && (unsigned int)pt1[j] < j){
          /* we got an additional base pair in reference structure 1 */
          d++;
        }
        if(i <= (unsigned int)pt2[j] && (unsigned int)pt2[j] < j){
          /* we got another base pair in reference structure 2 */
          d++;
        }
      }
      array[ij] = d;

    }
  }
  free(iindx);
  return array;
}

PUBLIC char
vrna_bpp_symbol(const float *x){

/*  if( ((x[1]-x[2])*(x[1]-x[2]))<0.1&&x[0]<=0.677) return '|'; */
  if( x[0] > 0.667 )  return '.';
  if( x[1] > 0.667 )  return '(';
  if( x[2] > 0.667 )  return ')';
  if( (x[1]+x[2]) > x[0] ) {
    if( (x[1]/(x[1]+x[2])) > 0.667) return '{';
    if( (x[2]/(x[1]+x[2])) > 0.667) return '}';
    else return '|';
  }
  if( x[0] > (x[1]+x[2]) ) return ',';
  return ':';
}

PUBLIC char *
vrna_db_from_probs(const FLT_OR_DBL *p,
                    unsigned int length){

  int    i, j, *index;
  float  P[3];   /* P[][0] unpaired, P[][1] upstream p, P[][2] downstream p */
  char  *s;

  index = vrna_idx_row_wise(length);
  s     = (char *)vrna_alloc(sizeof(char) * (length + 1));

  for( j=1; j<=length; j++ ) {
    P[0] = 1.0;
    P[1] = P[2] = 0.0;
    for( i=1; i<j; i++) {
      P[2] += (float)p[index[i]-j];    /* j is paired downstream */
      P[0] -= (float)p[index[i]-j];    /* j is unpaired */
    }
    for( i=j+1; i<=length; i++ ) {
      P[1] += (float)p[index[j]-i];    /* j is paired upstream */
      P[0] -= (float)p[index[j]-i];    /* j is unpaired */
    }
    s[j-1] = vrna_bpp_symbol(P);
  }
  s[length] = '\0';
  free(index);

  return s;
}

PUBLIC void
vrna_letter_structure(char *structure,
                      vrna_bp_stack_t *bp,
                      unsigned int length){

  int   n, k, x, y;
  char  alpha[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

  memset(structure, '.', length);
  structure[length] = '\0';

  for (n = 0, k = 1; k <= bp[0].i; k++) {
    y = bp[k].j;
    x = bp[k].i;
    if (x-1 > 0 && y+1 <= length) {
      if (structure[x-2] != ' ' && structure[y] == structure[x-2]) {
        structure[x-1] = structure[x-2];
        structure[y-1] = structure[x-1];
        continue;
      }
    }
    if (structure[x] != ' ' && structure[y-2] == structure[x]) {
      structure[x-1] = structure[x];
      structure[y-1] = structure[x-1];
      continue;
    }
    n++;
    structure[x-1] = alpha[n-1];
    structure[y-1] = alpha[n-1];
  }
}

/*---------------------------------------------------------------------------*/

PUBLIC char *
vrna_db_from_bp_stack(vrna_bp_stack_t *bp,
                      unsigned int length){

  int k, i, j, temp;
  char *structure;

  structure = vrna_alloc(sizeof(char) * (length + 1));

  if(length > 0)
    memset(structure, '.', length);

  structure[length] = '\0';

  for (k = 1; k <= bp[0].i; k++) {
    i=bp[k].i;
    j=bp[k].j;
    if (i>length) i-=length;
    if (j>length) j-=length;
    if (i>j) {
      temp=i; i=j; j=temp;
    }
    if(i == j){ /* Gquad bonds are marked as bp[i].i == bp[i].j */
      structure[i-1] = '+';
    } else { /* the following ones are regular base pairs */
      structure[i-1] = '(';
      structure[j-1] = ')';
    }
  }
  return structure;
}

PUBLIC vrna_plist_t *
vrna_plist( const char *struc,
                        float pr){

  /* convert bracket string to plist */
  short *pt;
  int i, k = 0, size, n;
  vrna_plist_t *gpl, *ptr, *pl;

  size  = strlen(struc);
  n     = 2;

  pt  = vrna_ptable(struc);
  pl = (vrna_plist_t *)vrna_alloc(n*size*sizeof(vrna_plist_t));
  for(i = 1; i < size; i++){
    if(pt[i]>i){
      (pl)[k].i      = i;
      (pl)[k].j      = pt[i];
      (pl)[k].p      = pr;
      (pl)[k++].type = 0;
    }
  }

  gpl = get_plist_gquad_from_db(struc, pr);
  for(ptr = gpl; ptr->i != 0; ptr++){
    if (k == n * size - 1){
      n *= 2;
      pl = (vrna_plist_t *)vrna_realloc(pl, n * size * sizeof(vrna_plist_t));
    }
    (pl)[k].i      = ptr->i;
    (pl)[k].j      = ptr->j;
    (pl)[k].p       = ptr->p;
    (pl)[k++].type = ptr->type;
  }
  free(gpl);

  (pl)[k].i      = 0;
  (pl)[k].j      = 0;
  (pl)[k].p      = 0.;
  (pl)[k++].type = 0.;
  free(pt);
  pl = (vrna_plist_t *)vrna_realloc(pl, k * sizeof(vrna_plist_t));

  return pl;
}

PUBLIC vrna_plist_t *
vrna_plist_from_probs(vrna_fold_compound_t *vc,
                    double cut_off){

  if(!vc){
    vrna_message_error("vrna_pl_get_from_pr: run vrna_pf_fold first!");
  } else if( !vc->exp_matrices->probs){
    vrna_message_error("vrna_pl_get_from_pr: probs==NULL!");
  }

  return wrap_get_plist(vc->exp_matrices,
                        vc->length,
                        vc->iindx,
                        vc->sequence_encoding2,
                        vc->exp_params,
                        cut_off);
}

PUBLIC  char *
vrna_db_from_plist(vrna_plist_t *pairs,
              unsigned int n){

  vrna_plist_t *ptr;
  char  *structure = NULL;
  int   i;

  if(n > 0){
    structure = (char *)vrna_alloc(sizeof(char) * (n+1));
    memset(structure, '.', n);
    structure[n] = '\0';

    for(ptr = pairs; (*ptr).i; ptr++){
      if(((*ptr).i < n) && ((*ptr).j <= n)){
        structure[(*ptr).i - 1] = '(';
        structure[(*ptr).j - 1] = ')';
      }
    }
  }
  return structure;
}

PRIVATE vrna_plist_t *
wrap_get_plist( vrna_mx_pf_t *matrices,
                int length,
                int *index,
                short *S,
                vrna_exp_param_t *pf_params,
                double cut_off){

  int i, j, k, n, count, gquad;
  FLT_OR_DBL  *probs, *G, *scale;
  vrna_plist_t         *pl;

  probs     = matrices->probs;
  G         = matrices->G;
  scale     = matrices->scale;
  gquad     = pf_params->model_details.gquad;

  count = 0;
  n     = 2;

  /* first guess of the size needed for pl */
  pl = (vrna_plist_t *)vrna_alloc(n*length*sizeof(vrna_plist_t));

  for (i=1; i<length; i++) {
    for (j=i+1; j<=length; j++) {
      /* skip all entries below the cutoff */
      if (probs[index[i]-j] < (FLT_OR_DBL)cut_off) continue;

      /* do we need to allocate more memory? */
      if (count == n * length - 1){
        n *= 2;
        pl = (vrna_plist_t *)vrna_realloc(pl, n * length * sizeof(vrna_plist_t));
      }

      /* check for presence of gquadruplex */
      if(gquad && (S[i] == 3) && (S[j] == 3)){
        /* add probability of a gquadruplex at position (i,j)
           for dot_plot
        */
        (pl)[count].i      = i;
        (pl)[count].j      = j;
        (pl)[count].p      = (float)probs[index[i] - j];
        (pl)[count++].type = 1;
        /* now add the probabilies of it's actual pairing patterns */
        vrna_plist_t *inner, *ptr;
        inner = get_plist_gquad_from_pr(S, i, j, G, probs, scale, pf_params);
        for(ptr=inner; ptr->i != 0; ptr++){
            if (count == n * length - 1){
              n *= 2;
              pl = (vrna_plist_t *)vrna_realloc(pl, n * length * sizeof(vrna_plist_t));
            }
            /* check if we've already seen this pair */
            for(k = 0; k < count; k++)
              if(((pl)[k].i == ptr->i) && ((pl)[k].j == ptr->j))
                break;
            (pl)[k].i      = ptr->i;
            (pl)[k].j      = ptr->j;
            (pl)[k].type = 0;
            if(k == count){
              (pl)[k].p  = ptr->p;
              count++;
            } else
              (pl)[k].p  += ptr->p;
        }
      } else {
          (pl)[count].i      = i;
          (pl)[count].j      = j;
          (pl)[count].p      = (float)probs[index[i] - j];
          (pl)[count++].type = 0;
      }
    }
  }
  /* mark the end of pl */
  (pl)[count].i    = 0;
  (pl)[count].j    = 0;
  (pl)[count].type = 0;
  (pl)[count++].p  = 0.;
  /* shrink memory to actual size needed */
  pl = (vrna_plist_t *)vrna_realloc(pl, count * sizeof(vrna_plist_t));

  return pl;
}

PUBLIC vrna_hx_t *
vrna_hx_from_ptable(short *pt){

  int i, k, n, l, s, *stack;
  vrna_hx_t *list;

  n = pt[0];
  l = 0;
  s = 1;
  list  = (vrna_hx_t *)vrna_alloc(sizeof(vrna_hx_t) * n/2);
  stack = (int *)vrna_alloc(sizeof(int) * n/2);

  stack[s] = 1;

  do{
    for(i = stack[s--]; i <= n; i++){
      if(pt[i] > (short)i){  /* found a base pair */
        k = i;
        /* go through stack */
        for(;pt[k+1] == pt[k] - 1; k++);
        list[l].start  = i;
        list[l].end    = pt[i];
        list[l].length = k - i + 1;
        list[l].up5 = list[l].up3 = 0;
        l++;
        stack[++s] = pt[i] + 1;
        stack[++s] = k + 1;
        break;
      } else if(pt[i]) { /* end of region */
        break;
      }
    }
  } while (s > 0);

  list = vrna_realloc(list, (l+1)*sizeof(vrna_hx_t));
  list[l].start = list[l].end = list[l].length = list[l].up5 = list[l].up3 = 0;

  free(stack);
  return list;
}

PUBLIC vrna_hx_t *
vrna_hx_merge(const vrna_hx_t *list, int maxdist){
  int merged, i, j, s, neighbors, n;
  vrna_hx_t *merged_list;

  for(n=0; list[n].length > 0; n++); /* check size of list */

  merged_list = (vrna_hx_t *)vrna_alloc(sizeof(vrna_hx_t) * (n+1));
  memcpy(merged_list, list, sizeof(vrna_hx_t) * (n+1));

  s = n+1;

  do{
    merged = 0;
    for(i = 1; merged_list[i].length > 0; i++){
      /*
        GOAL: merge two consecutive helices i and i-1, if i-1
        subsumes i, and not more than i
      */

      /* 1st, check for neighbors */
      neighbors = 0;
      for(j = i + 1; merged_list[j].length > 0; j++){
        if(merged_list[j].start > merged_list[i-1].end) break;
        if(merged_list[j].start < merged_list[i].end) continue;
        neighbors = 1;
      }
      if(neighbors) continue;

      /* check if we may merge i with i-1 */
      if(merged_list[i].end < merged_list[i-1].end){
        merged_list[i-1].up5 += merged_list[i].start
                                - merged_list[i-1].start
                                - merged_list[i-1].length
                                - merged_list[i-1].up5
                                + merged_list[i].up5;
        merged_list[i-1].up3 += merged_list[i-1].end
                                - merged_list[i-1].length
                                - merged_list[i-1].up3
                                - merged_list[i].end
                                + merged_list[i].up3;
        merged_list[i-1].length += merged_list[i].length;
        /* splice out helix i */
        memmove(merged_list+i, merged_list+i+1, sizeof(vrna_hx_t)*(n-i));
        s--;
        merged = 1;
        break;
      }
    }
  } while(merged);

  merged_list = vrna_realloc(merged_list, sizeof(vrna_hx_t) * s);

  return merged_list;
}

#ifdef  VRNA_BACKWARD_COMPAT

/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/


PUBLIC char *
pack_structure(const char *struc){

  return vrna_db_pack(struc);
}

PUBLIC char *
unpack_structure(const char *packed){

  return vrna_db_unpack(packed);
}

PUBLIC void
parenthesis_structure(char *structure,
                      vrna_bp_stack_t *bp,
                      int length){

  char *s = vrna_db_from_bp_stack(bp, length);
  strncpy(structure, s, length + 1);
  free(s);
}

PUBLIC void
letter_structure( char *structure,
                  vrna_bp_stack_t *bp,
                  int length){

  vrna_letter_structure(structure, bp, length);
}

PUBLIC void
parenthesis_zuker(char *structure,
                  vrna_bp_stack_t *bp,
                  int length){

  char *s = vrna_db_from_bp_stack(bp, length);
  strncpy(structure, s, length + 1);
  free(s);
}

PUBLIC void
assign_plist_from_pr( vrna_plist_t **pl,
                      FLT_OR_DBL *probs,
                      int length,
                      double cut_off){

  int              *index;
  vrna_mx_pf_t     *matrices;
  vrna_md_t        md;
  vrna_exp_param_t *pf_params;

  index     = vrna_idx_row_wise(length);
  matrices  = (vrna_mx_pf_t *)vrna_alloc(sizeof(vrna_mx_pf_t));

  set_model_details(&md);
  md.gquad        = 0;
  pf_params       = vrna_exp_params(&md);
  matrices->probs = probs;

  *pl = wrap_get_plist( matrices,
                        length,
                        index,
                        NULL,
                        pf_params,
                        cut_off);

  free(index);
  free(pf_params);
  free(matrices);
}

PUBLIC void
assign_plist_from_db( vrna_plist_t **pl,
                      const char *struc,
                      float pr){

  *pl = vrna_plist(struc, pr);
}

PUBLIC short *
make_pair_table(const char *structure){

  return vrna_ptable(structure);
}

PUBLIC short *
copy_pair_table(const short *pt){

  return vrna_ptable_copy(pt);
}

PUBLIC short *
make_pair_table_pk(const char *structure){

  return vrna_pt_pk_get(structure);
}

PUBLIC short *
make_pair_table_snoop(const char *structure){

  return vrna_pt_snoop_get(structure);
}

PUBLIC short *
alimake_pair_table(const char *structure){

  return vrna_pt_ali_get(structure);
}

PUBLIC int *
make_loop_index_pt(short *pt){

  return vrna_loopidx_from_ptable((const short*)pt);
}

PUBLIC int
bp_distance(const char *str1, const char *str2){

  return vrna_bp_distance(str1, str2);
}

PUBLIC unsigned int *
make_referenceBP_array( short *reference_pt,
                        unsigned int turn){

  return vrna_refBPcnt_matrix((const short *)reference_pt, turn);
}

PUBLIC unsigned int *
compute_BPdifferences(short *pt1,
                      short *pt2,
                      unsigned int turn){

  return vrna_refBPdist_matrix((const short *)pt1, (const short *)pt2, turn);
}

PUBLIC char
bppm_symbol(const float *x){

  return vrna_bpp_symbol(x);
}

PUBLIC void
bppm_to_structure(char *structure,
                  FLT_OR_DBL *p,
                  unsigned int length){

  char *s = vrna_db_from_probs((const FLT_OR_DBL *)p, length);
  memcpy(structure, s, length);
  structure[length] = '\0';
  free(s);
}

#endif
model.c/        0           0     0     644     22096     `
/*
                  Model Details structure creation/modification/destruction

                  This file contains everything which is necessary to
                  obtain, modify, and destroy the model_details datastructure
                  used in the folding recurrences throughout the ViennaRNA
                  Package

                  c Ronny Lorenx

                  Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>

#include "energy_const.h"
#include "utils.h"
#include "model.h"

/*
#################################
# PRIVATE MACROS                #
#################################
*/

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/

#ifdef  VRNA_BACKWARD_COMPAT

/*  below are the evil global variables that will vanish
    as soon as we drop backward compatibility in ViennaRNA
    Package v3
*/

double  temperature     = VRNA_MODEL_DEFAULT_TEMPERATURE;
double  pf_scale        = VRNA_MODEL_DEFAULT_PF_SCALE;
int     dangles         = VRNA_MODEL_DEFAULT_DANGLES;
int     tetra_loop      = VRNA_MODEL_DEFAULT_SPECIAL_HP;
int     noLonelyPairs   = VRNA_MODEL_DEFAULT_NO_LP;
int     noGU            = VRNA_MODEL_DEFAULT_NO_GU;
int     no_closingGU    = VRNA_MODEL_DEFAULT_NO_GU_CLOSURE;
int     circ            = VRNA_MODEL_DEFAULT_CIRC;
int     gquad           = VRNA_MODEL_DEFAULT_GQUAD;
int     canonicalBPonly = VRNA_MODEL_DEFAULT_CANONICAL_BP;
int     uniq_ML         = VRNA_MODEL_DEFAULT_UNIQ_ML;
int     energy_set      = VRNA_MODEL_DEFAULT_ENERGY_SET;
int     do_backtrack    = VRNA_MODEL_DEFAULT_COMPUTE_BPP;
char    backtrack_type  = VRNA_MODEL_DEFAULT_BACKTRACK_TYPE;
char    *nonstandards   = (char *)0;
int     max_bp_span     = VRNA_MODEL_DEFAULT_MAX_BP_SPAN;
int     oldAliEn        = VRNA_MODEL_DEFAULT_ALI_OLD_EN;
int     ribo            = VRNA_MODEL_DEFAULT_ALI_RIBO;
double  cv_fact         = VRNA_MODEL_DEFAULT_ALI_CV_FACT;
double  nc_fact         = VRNA_MODEL_DEFAULT_ALI_NC_FACT;
int     logML           = VRNA_MODEL_DEFAULT_LOG_ML;

/* below are some more deprecated global symbols we need to get rid off */

int         james_rule = 1;       /* interior loops of size 2 get energy 0.8Kcal and
                                    no mismatches (no longer used) */
char        *RibosumFile = NULL;  /* TODO: compile ribosums into program
                                    Warning: this variable will vanish */
int         csv = 0;              /*generate comma seperated output*/
vrna_bp_stack_t       *base_pair = NULL;
FLT_OR_DBL  *pr = NULL;           /* base pairing prob. matrix */
int         *iindx = NULL;        /* pr[i,j] -> pr[iindx[i]-j] */
int         fold_constrained = 0; /* fold with constraints */
int         *cut_points;
int         *strand;

#endif

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/
PRIVATE int rtype[8] = {0, 2, 1, 4, 3, 6, 5, 7};
PRIVATE int BP_pair[NBASES][NBASES]=
/* _  A  C  G  U  X  K  I */
{{ 0, 0, 0, 0, 0, 0, 0, 0},
 { 0, 0, 0, 0, 5, 0, 0, 5},
 { 0, 0, 0, 1, 0, 0, 0, 0},
 { 0, 0, 2, 0, 3, 0, 0, 0},
 { 0, 6, 0, 4, 0, 0, 0, 6},
 { 0, 0, 0, 0, 0, 0, 2, 0},
 { 0, 0, 0, 0, 0, 1, 0, 0},
 { 0, 6, 0, 0, 5, 0, 0, 0}};

PRIVATE vrna_md_t defaults = {
  VRNA_MODEL_DEFAULT_TEMPERATURE,
  1.,
  VRNA_MODEL_DEFAULT_DANGLES,
  VRNA_MODEL_DEFAULT_SPECIAL_HP,
  VRNA_MODEL_DEFAULT_NO_LP,
  VRNA_MODEL_DEFAULT_NO_GU,
  VRNA_MODEL_DEFAULT_NO_GU_CLOSURE,
  VRNA_MODEL_DEFAULT_LOG_ML,
  VRNA_MODEL_DEFAULT_CIRC,
  VRNA_MODEL_DEFAULT_GQUAD,
  VRNA_MODEL_DEFAULT_CANONICAL_BP,
  VRNA_MODEL_DEFAULT_UNIQ_ML,
  VRNA_MODEL_DEFAULT_ENERGY_SET,
  VRNA_MODEL_DEFAULT_BACKTRACK,
  VRNA_MODEL_DEFAULT_BACKTRACK_TYPE,
  VRNA_MODEL_DEFAULT_COMPUTE_BPP,
  {0},
  VRNA_MODEL_DEFAULT_MAX_BP_SPAN,
  TURN,
  VRNA_MODEL_DEFAULT_WINDOW_SIZE,
  VRNA_MODEL_DEFAULT_ALI_OLD_EN,
  VRNA_MODEL_DEFAULT_ALI_RIBO,
  VRNA_MODEL_DEFAULT_ALI_CV_FACT,
  VRNA_MODEL_DEFAULT_ALI_NC_FACT,
  1.07,
  {0, 2, 1, 4, 3, 6, 5, 7},
  {0, 1, 2, 3, 4, 3, 2, 0},
  {
    { 0, 0, 0, 0, 0, 0, 0, 0},
    { 0, 0, 0, 0, 5, 0, 0, 5},
    { 0, 0, 0, 1, 0, 0, 0, 0},
    { 0, 0, 2, 0, 3, 0, 0, 0},
    { 0, 6, 0, 4, 0, 0, 0, 6},
    { 0, 0, 0, 0, 0, 0, 2, 0},
    { 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 6, 0, 0, 5, 0, 0, 0}
  }
};

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/

/* Fill the base pair type encodings according to the model details */
PRIVATE void fill_pair_matrices(vrna_md_t *md);
PRIVATE void copy_nonstandards(vrna_md_t *md, const char *ns);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PUBLIC void
vrna_md_set_default(vrna_md_t *md){

  int i = 0;

  if(md){
    /* copy over defaults */
    memcpy(md, &defaults, sizeof(vrna_md_t));

    /* set default values for the pair/rtype[pair] stuff */
    memcpy(md->rtype, &(rtype[0]), 8 * sizeof(int));
    memset(md->alias, 0, (MAXALPHA + 1) * sizeof(short));
    for(i = 0;i <= MAXALPHA; i++)
      memset(md->pair[i], 0, (MAXALPHA + 1) * sizeof(int));

    vrna_md_update(md);

  }
}

PUBLIC char *
vrna_md_option_string(vrna_md_t  *md){
  static char options[255];
  *options = '\0';

  if(md){
    if(md->dangles != VRNA_MODEL_DEFAULT_DANGLES)
      sprintf(options + strlen(options), "-d%d ", md->dangles);
    if(!md->special_hp)
      strcat(options, "-4 ");
    if(md->noLP)
      strcat(options, "--noLP ");
    if(md->noGU)
      strcat(options, "--noGU ");
    if(md->noGUclosure)
      strcat(options, "--noClosingGU ");
    if(md->temperature != VRNA_MODEL_DEFAULT_TEMPERATURE)
      sprintf(options + strlen(options), "-T %f ", md->temperature);
  }

  return options;
}

PRIVATE void
copy_nonstandards(vrna_md_t *md, const char *ns){

  unsigned int n = strlen(ns);
  if(n < 64){
    memcpy(md->nonstandards, ns, strlen(ns)*sizeof(char));
    md->nonstandards[n] = '\0';
  }
}

PUBLIC void
vrna_md_set_nonstandards(vrna_md_t *md, const char *ns_bases){

  const char    *c;
  unsigned int  n;
  int           i, sym;

  if(md){
    if(ns_bases){
      n = strlen(ns_bases);
      if(n < 33){ /* parse the ns_bases list */
        c = ns_bases;
        i = sym = 0;
        if(*c == '-'){
          sym=1;
          c++;
        }

        while(*c != '\0'){
          if(*c != ','){
            md->nonstandards[i++] = *c++;
            md->nonstandards[i++] = *c;
            if((sym) && (*c != *(c-1))){
              md->nonstandards[i++] = *c;
              md->nonstandards[i++] = *(c-1);
            }
          }
          c++;
        }
        md->nonstandards[i] = (char)0;

#ifdef  VRNA_BACKWARD_COMPAT
        free(nonstandards);
        nonstandards = vrna_alloc(33);
        memcpy(nonstandards, &(md->nonstandards[0]), 33*sizeof(char));
#endif
      } else {
        vrna_message_warning("vrna_md_set_nonstandards: list too long, dropping nonstandards!");
      }
    } else { /* remove nonstandards */
      md->nonstandards[0] = (char)0;
#ifdef  VRNA_BACKWARD_COMPAT
      free(nonstandards);
      nonstandards = (char)0;
#endif
    }
  }
}

PUBLIC void
vrna_md_defaults_reset(vrna_md_t *md_p){

  int i = 0;

  /* first, reset to factory defaults */
  defaults.dangles           = VRNA_MODEL_DEFAULT_DANGLES;
  defaults.special_hp        = VRNA_MODEL_DEFAULT_SPECIAL_HP;
  defaults.noLP              = VRNA_MODEL_DEFAULT_NO_LP;
  defaults.noGU              = VRNA_MODEL_DEFAULT_NO_GU;
  defaults.noGUclosure       = VRNA_MODEL_DEFAULT_NO_GU_CLOSURE;
  defaults.logML             = VRNA_MODEL_DEFAULT_LOG_ML;
  defaults.gquad             = VRNA_MODEL_DEFAULT_GQUAD;
  defaults.canonicalBPonly   = VRNA_MODEL_DEFAULT_CANONICAL_BP;
  defaults.circ              = VRNA_MODEL_DEFAULT_CIRC;
  defaults.uniq_ML           = VRNA_MODEL_DEFAULT_UNIQ_ML;
  defaults.compute_bpp       = VRNA_MODEL_DEFAULT_COMPUTE_BPP;
  defaults.backtrack         = VRNA_MODEL_DEFAULT_BACKTRACK;
  defaults.backtrack_type    = VRNA_MODEL_DEFAULT_BACKTRACK_TYPE;
  defaults.energy_set        = VRNA_MODEL_DEFAULT_ENERGY_SET;
  defaults.max_bp_span       = VRNA_MODEL_DEFAULT_MAX_BP_SPAN;
  defaults.min_loop_size     = TURN;
  defaults.window_size       = VRNA_MODEL_DEFAULT_WINDOW_SIZE;
  defaults.oldAliEn          = VRNA_MODEL_DEFAULT_ALI_OLD_EN;
  defaults.ribo              = VRNA_MODEL_DEFAULT_ALI_RIBO;
  defaults.cv_fact           = VRNA_MODEL_DEFAULT_ALI_CV_FACT;
  defaults.nc_fact           = VRNA_MODEL_DEFAULT_ALI_NC_FACT;
  defaults.temperature       = VRNA_MODEL_DEFAULT_TEMPERATURE;
  defaults.betaScale         = VRNA_MODEL_DEFAULT_BETA_SCALE;
  defaults.sfact             = 1.07;
  defaults.nonstandards[0]   = (char)0;

  if(md_p){ /* now try to apply user settings */
    vrna_md_defaults_dangles(md_p->dangles);
    vrna_md_defaults_special_hp(md_p->special_hp);
    vrna_md_defaults_noLP(md_p->noLP);
    vrna_md_defaults_noGU(md_p->noGU);
    vrna_md_defaults_noGUclosure(md_p->noGUclosure);
    vrna_md_defaults_logML(md_p->logML);
    vrna_md_defaults_gquad(md_p->gquad);
    defaults.canonicalBPonly = md_p->canonicalBPonly;
    vrna_md_defaults_circ(md_p->circ);
    vrna_md_defaults_uniq_ML(md_p->uniq_ML);
    vrna_md_defaults_compute_bpp(md_p->compute_bpp);
    vrna_md_defaults_backtrack(md_p->backtrack);
    vrna_md_defaults_backtrack_type(md_p->backtrack_type);
    vrna_md_defaults_energy_set(md_p->energy_set);
    vrna_md_defaults_max_bp_span(md_p->max_bp_span);
    vrna_md_defaults_min_loop_size(md_p->min_loop_size);
    vrna_md_defaults_window_size(md_p->window_size);
    vrna_md_defaults_oldAliEn(md_p->oldAliEn);
    vrna_md_defaults_ribo(md_p->ribo);
    vrna_md_defaults_cv_fact(md_p->cv_fact);
    vrna_md_defaults_nc_fact(md_p->nc_fact);
    vrna_md_defaults_temperature(md_p->temperature);
    vrna_md_defaults_betaScale(md_p->betaScale);
    vrna_md_defaults_sfact(md_p->sfact);
    copy_nonstandards(&defaults, &(md_p->nonstandards[0]));
  }

  /* set default values for the pair/rtype[pair] stuff */
  memcpy(defaults.rtype, &(rtype[0]), 8 * sizeof(int));
  memset(defaults.alias, 0, (MAXALPHA + 1) * sizeof(short));
  for(i = 0;i <= MAXALPHA; i++)
    memset(defaults.pair[i], 0, (MAXALPHA + 1) * sizeof(int));

  vrna_md_update(&defaults);

#ifdef  VRNA_BACKWARD_COMPAT
  temperature     = defaults.temperature;
  pf_scale        = VRNA_MODEL_DEFAULT_PF_SCALE;
  dangles         = defaults.dangles;
  tetra_loop      = defaults.special_hp;
  noLonelyPairs   = defaults.noLP;
  noGU            = defaults.noGU;
  no_closingGU    = defaults.noGUclosure;
  circ            = defaults.circ;
  gquad           = defaults.gquad;
  canonicalBPonly = defaults.canonicalBPonly;
  uniq_ML         = defaults.uniq_ML;
  energy_set      = defaults.energy_set;
  do_backtrack    = defaults.compute_bpp;
  backtrack_type  = defaults.backtrack_type;
  nonstandards    = defaults.nonstandards;
  max_bp_span     = defaults.max_bp_span;
  oldAliEn        = defaults.oldAliEn;
  ribo            = defaults.ribo;
  cv_fact         = defaults.cv_fact;
  nc_fact         = defaults.nc_fact;
  logML           = defaults.logML;
#endif
}

/* below are the setter functions for global default settings */

PUBLIC void
vrna_md_defaults_temperature(double T){

  if(T >= -K0){
    defaults.temperature = T;
#ifdef VRNA_BACKWARD_COMPAT
    temperature = T;
#endif
  } else
    vrna_message_warning("vrna_md_defaults_temperature@model.c: Temperature out of range, T must be above absolute zero. Not changing anything!");
}

PUBLIC double
vrna_md_defaults_temperature_get(void){

  return defaults.temperature;
}

PUBLIC void
vrna_md_defaults_betaScale(double b){

  defaults.betaScale = b;
}

PUBLIC double
vrna_md_defaults_betaScale_get(void){

  return defaults.betaScale;
}

PUBLIC void
vrna_md_defaults_dangles(int d){
  if((d >= 0) && (d <= 3)){
    defaults.dangles = d;
#ifdef VRNA_BACKWARD_COMPAT
    dangles = d;
#endif
  } else
    vrna_message_warning("vrna_md_defaults_dangles@model.c: Dangles out of range, must be (0 <= d <= 3). Not changing anything!");
}

PUBLIC int
vrna_md_defaults_dangles_get(void){

  return defaults.dangles;
}

PUBLIC void
vrna_md_defaults_special_hp(int flag){

  defaults.special_hp = flag ? 1 : 0;
#ifdef VRNA_BACKWARD_COMPAT
  tetra_loop = defaults.special_hp;
#endif
}

PUBLIC int
vrna_md_defaults_special_hp_get(void){

  return defaults.special_hp;
}

PUBLIC void
vrna_md_defaults_noLP(int flag){

  defaults.noLP = flag ? 1 : 0;
#ifdef VRNA_BACKWARD_COMPAT
  noLonelyPairs = defaults.noLP;
#endif
}

PUBLIC int
vrna_md_defaults_noLP_get(void){

  return defaults.noLP;
}

PUBLIC void
vrna_md_defaults_noGU(int flag){

  defaults.noGU = flag ? 1 : 0;
#ifdef VRNA_BACKWARD_COMPAT
  noGU = defaults.noGU;
#endif
}

PUBLIC int
vrna_md_defaults_noGU_get(void){

  return defaults.noGU;
}

PUBLIC void
vrna_md_defaults_noGUclosure(int flag){

  defaults.noGUclosure = flag ? 1 : 0;
#ifdef VRNA_BACKWARD_COMPAT
  no_closingGU = defaults.noGUclosure;
#endif
}

PUBLIC int
vrna_md_defaults_noGUclosure_get(void){

  return defaults.noGUclosure;
}

PUBLIC void
vrna_md_defaults_logML(int flag){

  defaults.logML = flag ? 1 : 0;
#ifdef VRNA_BACKWARD_COMPAT
  logML = defaults.logML;
#endif
}

PUBLIC int
vrna_md_defaults_logML_get(void){

  return defaults.logML;
}

PUBLIC void
vrna_md_defaults_circ(int flag){

  defaults.circ = flag ? 1 : 0;
#ifdef VRNA_BACKWARD_COMPAT
  circ = defaults.circ;
#endif
}

PUBLIC int
vrna_md_defaults_circ_get(void){

  return defaults.circ;
}

PUBLIC void
vrna_md_defaults_gquad(int flag){

  defaults.gquad = flag ? 1 : 0;
#ifdef VRNA_BACKWARD_COMPAT
  gquad = defaults.gquad;
#endif
}

PUBLIC int
vrna_md_defaults_gquad_get(void){

  return defaults.gquad;
}

PUBLIC void
vrna_md_defaults_uniq_ML(int flag){

  defaults.uniq_ML = flag ? 1 : 0;
#ifdef VRNA_BACKWARD_COMPAT
  uniq_ML = defaults.uniq_ML;
#endif
}

PUBLIC int
vrna_md_defaults_uniq_ML_get(void){

  return defaults.uniq_ML;
}

PUBLIC void
vrna_md_defaults_energy_set(int e){

  if((e >= 0) && (e <= 3)){
    defaults.energy_set = e;
#ifdef VRNA_BACKWARD_COMPAT
    energy_set = e;
#endif
  } else
    vrna_message_warning("vrna_md_defaults_energy_set@model.c: Energy Set out of range, must be (0 <= e <= 3). Not changing anything!");
}

PUBLIC int
vrna_md_defaults_energy_set_get(void){

  return defaults.energy_set;
}

PUBLIC void
vrna_md_defaults_backtrack(int flag){

  defaults.backtrack = flag ? 1 : 0;
}

PUBLIC int
vrna_md_defaults_backtrack_get(void){

  return defaults.backtrack;
}

PUBLIC void
vrna_md_defaults_backtrack_type(char t){

  switch(t){
    case 'M': /* fall through */
    case 'C': /* fall through */
    case 'F': defaults.backtrack_type = t;
#ifdef VRNA_BACKWARD_COMPAT
              backtrack_type = t;
#endif
              break;
    default:  vrna_message_warning("vrna_md_defaults_backtrack_type@model.c: Backtrack type must be any of 'F', 'C', or 'M'. Not changing anything!");
  }
}

PUBLIC char
vrna_md_defaults_backtrack_type_get(void){

  return defaults.backtrack_type;
}

PUBLIC void
vrna_md_defaults_compute_bpp(int flag){

  if((flag >= 0) && (flag <= 2)){
    defaults.compute_bpp = flag;
#ifdef VRNA_BACKWARD_COMPAT
    do_backtrack = flag;
#endif
  } else
    defaults.compute_bpp = 1;
}

PUBLIC int
vrna_md_defaults_compute_bpp_get(void){

  return defaults.compute_bpp;
}

PUBLIC void
vrna_md_defaults_max_bp_span(int span){

  defaults.max_bp_span = (span <= 0) ? -1 : span;
#ifdef VRNA_BACKWARD_COMPAT
  max_bp_span = defaults.max_bp_span;
#endif
}

PUBLIC int
vrna_md_defaults_max_bp_span_get(void){

  return defaults.max_bp_span;
}

PUBLIC void
vrna_md_defaults_min_loop_size(int size){

  defaults.min_loop_size = (size < 0) ? 0 : size;
}

PUBLIC int
vrna_md_defaults_min_loop_size_get(void){

  return defaults.min_loop_size;
}

PUBLIC void
vrna_md_defaults_window_size(int size){

  defaults.window_size = (size <= 0) ? -1 : size;
}

PUBLIC int
vrna_md_defaults_window_size_get(void){

  return defaults.window_size;
}

PUBLIC void
vrna_md_defaults_oldAliEn(int flag){

  defaults.oldAliEn = flag ? 1 : 0;
#ifdef VRNA_BACKWARD_COMPAT
  oldAliEn = defaults.oldAliEn;
#endif
}

PUBLIC int
vrna_md_defaults_oldAliEn_get(void){

  return defaults.oldAliEn;
}

PUBLIC void
vrna_md_defaults_ribo(int flag){

  defaults.ribo = flag ? 1 : 0;
#ifdef VRNA_BACKWARD_COMPAT
  ribo = defaults.ribo;
#endif
}

PUBLIC int
vrna_md_defaults_ribo_get(void){

  return defaults.ribo;
}

PUBLIC void
vrna_md_defaults_cv_fact(double factor){

  defaults.cv_fact = factor;
#ifdef VRNA_BACKWARD_COMPAT
  cv_fact = factor;
#endif
}

PUBLIC double
vrna_md_defaults_cv_fact_get(void){

  return defaults.cv_fact;
}

PUBLIC void
vrna_md_defaults_nc_fact(double factor){

  defaults.nc_fact = factor;
#ifdef VRNA_BACKWARD_COMPAT
  nc_fact = factor;
#endif
}

PUBLIC double
vrna_md_defaults_nc_fact_get(void){

  return defaults.nc_fact;
}

PUBLIC void
vrna_md_defaults_sfact(double factor){

  defaults.sfact = factor;
}

PUBLIC double
vrna_md_defaults_sfact_get(void){

  return defaults.sfact;
}


PUBLIC void
vrna_md_update(vrna_md_t *md){

  if(md)
    fill_pair_matrices(md);
}

PRIVATE void
fill_pair_matrices(vrna_md_t *md){

  int i,j;

  /* nullify everything */
  for(i = 0;i <= MAXALPHA; i++)
    memset(md->pair[i], 0, (MAXALPHA + 1) * sizeof(int));

  memset(md->alias, 0, (MAXALPHA + 1) * sizeof(short));

  /* start setting actual base pair type encodings */
  switch(md->energy_set){
    case  0:    for(i = 0; i < 5; i++)
                  md->alias[i] = (short) i;

                md->alias[5] = 3; /* X <-> G */
                md->alias[6] = 2; /* K <-> C */
                md->alias[7] = 0; /* I <-> default base '@' */

                for(i = 0; i < NBASES; i++)
                    for(j = 0; j < NBASES; j++)
                      md->pair[i][j] = BP_pair[i][j];

                if(md->noGU)
                  md->pair[3][4] = md->pair[4][3] = 0;

                if(md->nonstandards[0] != '\0') {  /* allow nonstandard bp's (encoded by type=7) */
                   for(i = 0; i < (int)strlen(md->nonstandards); i += 2)
                      md->pair[vrna_nucleotide_encode(md->nonstandards[i], md)]
                        [vrna_nucleotide_encode(md->nonstandards[i+1], md)] = 7;
                }

                break;

    case 1:     for(i = 1; i < MAXALPHA;){
                  md->alias[i++] = 3;  /* A <-> G */
                  md->alias[i++] = 2;  /* B <-> C */
                }
                for(i = 1; i < MAXALPHA; i++){
                  md->pair[i][i+1] = 2;    /* AB <-> GC */
                  i++;
                  md->pair[i][i-1] = 1;    /* BA <-> CG */
                }

                break;

    case 2:     for(i = 1; i < MAXALPHA;){
                  md->alias[i++] = 1;  /* A <-> A*/
                  md->alias[i++] = 4;  /* B <-> U */
                }
                for(i = 1; i < MAXALPHA; i++){
                  md->pair[i][i+1] = 5;    /* AB <-> AU */
                  i++;
                  md->pair[i][i-1] = 6;    /* BA <-> UA */
                }

                break;

    case 3:     for(i = 1; i < MAXALPHA - 2; ){
                  md->alias[i++] = 3;  /* A <-> G */
                  md->alias[i++] = 2;  /* B <-> C */
                  md->alias[i++] = 1;  /* C <-> A */
                  md->alias[i++] = 4;  /* D <-> U */
                }
                for(i = 1; i < MAXALPHA - 2; i++){
                  md->pair[i][i+1] = 2;    /* AB <-> GC */
                  i++;
                  md->pair[i][i-1] = 1;    /* BA <-> CG */
                  i++;
                  md->pair[i][i+1] = 5;    /* CD <-> AU */
                  i++;
                  md->pair[i][i-1] = 6;    /* DC <-> UA */
                }

                break;

    default:    vrna_message_error("Which energy_set are YOU using??");
                break;
  }

  /* set the reverse base pair types */
  for(i = 0; i <= MAXALPHA; i++){
    for(j = 0; j <= MAXALPHA; j++){
      md->rtype[md->pair[i][j]] = md->pair[j][i];
    }
  }

  /* was used for energy_set == 0
  for(i = 0; i < NBASES; i++)
      for(j = 0; j < NBASES; j++)
       md->rtype[md->pair[i][j]] = md->pair[j][i];
  */
}

#ifdef  VRNA_BACKWARD_COMPAT

/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/

PUBLIC void
set_model_details(vrna_md_t *md){

  int i = 0;

  if(md){
    md->dangles           = dangles;
    md->special_hp        = tetra_loop;
    md->noLP              = noLonelyPairs;
    md->noGU              = noGU;
    md->noGUclosure       = no_closingGU;
    md->logML             = logML;
    md->gquad             = gquad;
    md->canonicalBPonly   = canonicalBPonly;
    md->circ              = circ;
    md->uniq_ML           = uniq_ML;
    md->compute_bpp       = do_backtrack;
    md->backtrack         = VRNA_MODEL_DEFAULT_BACKTRACK;
    md->backtrack_type    = backtrack_type;
    md->energy_set        = energy_set;
    md->max_bp_span       = max_bp_span;
    md->min_loop_size     = TURN;
    md->window_size       = VRNA_MODEL_DEFAULT_WINDOW_SIZE;
    md->oldAliEn          = oldAliEn;
    md->ribo              = ribo;
    md->cv_fact           = cv_fact;
    md->nc_fact           = nc_fact;
    md->temperature       = temperature;
    md->betaScale         = VRNA_MODEL_DEFAULT_BETA_SCALE;
    md->sfact             = 1.07;

    if(nonstandards){
      copy_nonstandards(md, nonstandards);
    } else {
      md->nonstandards[0] = (char)0;
    }
    /* set default values for the pair/rtype[pair] stuff */
    memcpy(md->rtype, &(rtype[0]), 8 * sizeof(int));
    memset(md->alias, 0, (MAXALPHA + 1) * sizeof(short));
    for(i = 0;i <= MAXALPHA; i++)
      memset(md->pair[i], 0, (MAXALPHA + 1) * sizeof(int));

    vrna_md_update(md);

  }
}

PUBLIC char *
option_string(void){

  vrna_md_t md;
  set_model_details(&md);

  return vrna_md_option_string(&md);
}


#endif


file_formats.c/ 0           0     0     644     30062     `
/*
    file_formats.c

    Various functions dealing with file formats for RNA sequences, structures, and alignments

    (c) 2014 Ronny Lorenz

    Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <ctype.h>

#include "fold_vars.h"
#include "utils.h"
#include "constraints.h"
#if WITH_JSON_SUPPORT
# include <json/json.h>
#endif
#include "file_formats.h"

#define DEBUG
/*
#################################
# PRIVATE VARIABLES             #
#################################
*/

PRIVATE char          *inbuf  = NULL;
PRIVATE char          *inbuf2 = NULL;
PRIVATE unsigned int  typebuf = 0;

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/

PRIVATE unsigned int
read_multiple_input_lines(char **string, FILE *file, unsigned int option);

PRIVATE void
elim_trailing_ws(char *string);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PRIVATE void
elim_trailing_ws(char *string){    /* eliminate whitespaces at the end of a character string */

  int i, l = strlen(string);

  for(i = l-1; i >= 0; i--){
    if      (string[i] == ' ')  continue;
    else if (string[i] == '\t') continue;
    else                        break;
  }
  string[(i >= 0) ? (i+1) : 0] = '\0';
}

PUBLIC void
vrna_file_helixlist(const char *seq,
                    const char *db,
                    float energy,
                    FILE *file){

  int         s;
  short       *pt;
  vrna_hx_t   *list;
  FILE *out;

  if(strlen(seq) != strlen(db))
    vrna_message_error("vrna_file_helixlist: sequence and structure have unequal length!");

  out   = (file) ? file : stdout;
  pt    = vrna_ptable(db);
  list  = vrna_hx_from_ptable(pt);

  fprintf(out, "%s\t%6.2f\n", seq, energy);
  for(s = 0; list[s].length > 0; s++){
    fprintf(out, "%d\t%d\t%d\n", list[s].start, list[s].end, list[s].length);
  }

  free(pt);
  free(list);
}

PUBLIC void
vrna_file_connect(const char *seq,
                  const char *db,
                  float energy,
                  const char *identifier,
                  FILE *file){

  int i, power_d;
  FILE *out = (file) ? file : stdout;

  if(strlen(seq) != strlen(db))
    vrna_message_error("vrna_file_connect: sequence and structure have unequal length!");

  short *pt = vrna_ptable(db);

  for(power_d=0;pow(10,power_d) <= (int)strlen(seq);power_d++);

  /*
    Connect table file format looks like this:

    300  ENERGY = 7.0  example
      1 G       0    2   22    1
      2 G       1    3   21    2

    where the headerline is followed by 6 columns with:
    1. Base number: index n
    2. Base (A, C, G, T, U, X)
    3. Index n-1  (0 if first nucleotide)
    4. Index n+1  (0 if last nucleotide)
    5. Number of the base to which n is paired. No pairing is indicated by 0 (zero).
    6. Natural numbering.
  */

  /* print header */
  fprintf(out, "%d  ENERGY = %6.2f", (int)strlen(seq), energy);
  if(identifier)
    fprintf(out, "  %s\n", identifier);

  /* print structure information except for last line */
  /* TODO: modify the structure information for cofold */
  for(i = 0; i < strlen(seq) - 1; i++){
    fprintf(out, "%*d %c %*d %*d %*d %*d\n",
                  power_d, i+1,           /* nucleotide index */
                  (char)toupper(seq[i]),  /* nucleotide char */
                  power_d, i,             /* nucleotide predecessor index */
                  power_d, i+2,           /* nucleotide successor index */
                  power_d, pt[i+1],       /* pairing partner index */
                  power_d, i+1);          /* nucleotide natural numbering */
  }
  /* print last line */
  fprintf(out, "%*d %c %*d %*d %*d %*d\n",
                power_d, i+1,
                (char)toupper(seq[i]),
                power_d, i,
                power_d, 0,
                power_d, pt[i+1],
                power_d, i+1);

  /* clean up */
  free(pt);
  fflush(out);
}

PUBLIC void
vrna_file_bpseq(const char *seq,
                const char *db,
                FILE *file){

  int i;
  FILE *out = (file) ? file : stdout;

  if(strlen(seq) != strlen(db))
    vrna_message_error("vrna_file_bpseq: sequence and structure have unequal length!");

  short *pt = vrna_ptable(db);

  for(i = 1; i <= pt[0]; i++){
    fprintf(out, "%d %c %d\n", i, (char)toupper(seq[i-1]), pt[i]);
  }

  /* clean up */
  free(pt);
  fflush(out);
}

#if WITH_JSON_SUPPORT

PUBLIC void
vrna_file_json( const char *seq,
                const char *db,
                double energy,
                const char *identifier,
                FILE *file){

  FILE *out = (file) ? file : stdout;

  JsonNode *data  = json_mkobject();
  JsonNode *value;

  if(identifier){
    value = json_mkstring(identifier);
    json_append_member(data, "id", value);
  }

  value = json_mkstring(seq);
  json_append_member(data, "sequence", value);

  value = json_mknumber(energy);
  json_append_member(data, "mfe", value);

  value = json_mkstring(db);
  json_append_member(data, "structure", value);

  
  fprintf(out, "%s\n", json_stringify(data, "\t"));

  fflush(out);
}

#endif

PRIVATE  unsigned int
read_multiple_input_lines(char **string,
                          FILE *file,
                          unsigned int option){

  char  *line;
  int   i, l;
  int   state = 0;
  int   str_length = 0;
  FILE  *in = (file) ? file : stdin;

  line = (inbuf2) ? inbuf2 : get_line(in);
  inbuf2 = NULL;
  do{

    /*
    * read lines until informative data appears or
    * report an error if anything goes wrong
    */
    if(!line) return VRNA_INPUT_ERROR;

    l = (int)strlen(line);

    /* eliminate whitespaces at the end of the line read */
    if(!(option & VRNA_INPUT_NO_TRUNCATION))
      elim_trailing_ws(line);

    l           = (int)strlen(line);
    str_length  = (*string) ? (int) strlen(*string) : 0;

    switch(*line){
      case  '@':    /* user abort */
                    if(state) inbuf2 = line;
                    else      free(line);
                    return (state==2) ? VRNA_INPUT_CONSTRAINT : (state==1) ? VRNA_INPUT_SEQUENCE : VRNA_INPUT_QUIT;

      case  '\0':   /* empty line */
                    if(option & VRNA_INPUT_NOSKIP_BLANK_LINES){
                      if(state) inbuf2 = line;
                      else      free(line);
                      return (state==2) ? VRNA_INPUT_CONSTRAINT : (state==1) ? VRNA_INPUT_SEQUENCE : VRNA_INPUT_BLANK_LINE;
                    }
                    break;

      case  '#': case  '%': case  ';': case  '/': case  '*': case ' ':
                    /* comments */
                    if(option & VRNA_INPUT_NOSKIP_COMMENTS){
                      if(state) inbuf2   = line;
                      else      *string = line;
                      return (state == 2) ? VRNA_INPUT_CONSTRAINT : (state==1) ? VRNA_INPUT_SEQUENCE : VRNA_INPUT_COMMENT;
                    }
                    break;

      case  '>':    /* fasta header */
                    if(state) inbuf2   = line;
                    else      *string = line;
                    return (state==2) ? VRNA_INPUT_CONSTRAINT : (state==1) ? VRNA_INPUT_SEQUENCE : VRNA_INPUT_FASTA_HEADER;

      case  'x': case 'e': case 'l': case '&':   /* seems to be a constraint or line starting with second sequence for dimer calculations */
                    i = 1;
                    /* lets see if this assumption holds for the complete line */
                    while((line[i] == 'x') || (line[i] == 'e') || (line[i] == 'l')) i++;
                    /* lines solely consisting of 'x's, 'e's or 'l's will be considered as structure constraint */
                    
                    if(
                            ((line[i]>64) && (line[i]<91))  /* A-Z */
                        ||  ((line[i]>96) && (line[i]<123)) /* a-z */
                      ){
                      if(option & VRNA_INPUT_FASTA_HEADER){
                        /* are we in structure mode? Then we remember this line for the next round */
                        if(state == 2){ inbuf2 = line; return VRNA_INPUT_CONSTRAINT;}
                        else{
                          *string = (char *)vrna_realloc(*string, sizeof(char) * (str_length + l + 1));
                          strcpy(*string + str_length, line);
                          state = 1;
                        }
                        break;
                      }
                      /* otherwise return line read */
                      else{ *string = line; return VRNA_INPUT_SEQUENCE;}
                    }
                    /* mmmh? it really seems to be a constraint */
                    /* fallthrough */
      case  '<': case  '.': case  '|': case  '(': case ')': case '[': case ']': case '{': case '}': case ',': case '+':
                    /* seems to be a structure or a constraint */
                    /* either we concatenate this line to one that we read previously */
                    if(option & VRNA_INPUT_FASTA_HEADER){
                      if(state == 1){
                        inbuf2 = line;
                        return VRNA_INPUT_SEQUENCE;
                      }
                      else{
                        *string = (char *)vrna_realloc(*string, sizeof(char) * (str_length + l + 1));
                        strcpy(*string + str_length, line);
                        state = 2;
                      }
                    }
                    /* or we return it as it is */
                    else{
                      *string = line;
                      return VRNA_INPUT_CONSTRAINT;
                    }
                    break;
      default:      if(option & VRNA_INPUT_FASTA_HEADER){
                      /* are we already in sequence mode? */
                      if(state == 2){
                        inbuf2 = line;
                        return VRNA_INPUT_CONSTRAINT;
                      }
                      else{
                        *string = (char *)vrna_realloc(*string, sizeof(char) * (str_length + l + 1));
                        strcpy(*string + str_length, line);
                        state = 1;
                      }
                    }
                    /* otherwise return line read */
                    else{
                      *string = line;
                      return VRNA_INPUT_SEQUENCE;
                    }
    }
    free(line);
    line = get_line(in);
  }while(line);

  return (state==2) ? VRNA_INPUT_CONSTRAINT : (state==1) ? VRNA_INPUT_SEQUENCE : VRNA_INPUT_ERROR;
}

PUBLIC  unsigned int
vrna_file_fasta_read_record( char **header,
                        char **sequence,
                        char ***rest,
                        FILE *file,
                        unsigned int options){

  unsigned int  input_type, return_type, tmp_type;
  int           rest_count;
  char          *input_string;

  rest_count    = 0;
  return_type   = tmp_type = 0;
  input_string  = *header = *sequence = NULL;
  *rest         = (char **)vrna_alloc(sizeof(char *));

  /* remove unnecessary option flags from options variable... */
  options &= ~VRNA_INPUT_FASTA_HEADER;

  /* read first input or last buffered input */
  if(typebuf){
    input_type    = typebuf;
    input_string  = inbuf;
    typebuf       = 0;
    inbuf         = NULL;
  }
  else input_type  = read_multiple_input_lines(&input_string, file, options);

  if(input_type & (VRNA_INPUT_QUIT | VRNA_INPUT_ERROR)) return input_type;

  /* skip everything until we read either a fasta header or a sequence */
  while(input_type & (VRNA_INPUT_MISC | VRNA_INPUT_CONSTRAINT | VRNA_INPUT_BLANK_LINE)){
    free(input_string); input_string = NULL;
    input_type    = read_multiple_input_lines(&input_string, file, options);
    if(input_type & (VRNA_INPUT_QUIT | VRNA_INPUT_ERROR)) return input_type;
  }

  if(input_type & VRNA_INPUT_FASTA_HEADER){
    return_type  |= VRNA_INPUT_FASTA_HEADER; /* remember that we've read a fasta header */
    *header       = input_string;
    input_string  = NULL;
    /* get next data-block with fasta support if not explicitely forbidden by VRNA_INPUT_NO_SPAN */
    input_type  = read_multiple_input_lines(
                    &input_string,
                    file,
                    ((options & VRNA_INPUT_NO_SPAN) ? 0 : VRNA_INPUT_FASTA_HEADER) | options
                  );
    if(input_type & (VRNA_INPUT_QUIT | VRNA_INPUT_ERROR)) return (return_type | input_type);
  }

  if(input_type & VRNA_INPUT_SEQUENCE){
    return_type  |= VRNA_INPUT_SEQUENCE; /* remember that we've read a sequence */
    *sequence     = input_string;
    input_string  = NULL;
  } else vrna_message_error("sequence input missing");

  /* read the rest until we find user abort, EOF, new sequence or new fasta header */
  if(!(options & VRNA_INPUT_NO_REST)){
    options |= VRNA_INPUT_NOSKIP_COMMENTS; /* allow commetns to appear in rest output */
    tmp_type = VRNA_INPUT_QUIT | VRNA_INPUT_ERROR | VRNA_INPUT_SEQUENCE | VRNA_INPUT_FASTA_HEADER;
    if(options & VRNA_INPUT_NOSKIP_BLANK_LINES) tmp_type |= VRNA_INPUT_BLANK_LINE;
    while(!((input_type = read_multiple_input_lines(&input_string, file, options)) & tmp_type)){
      *rest = vrna_realloc(*rest, sizeof(char **)*(++rest_count + 1));
      (*rest)[rest_count-1] = input_string;
      input_string = NULL;
    }
    /*
    if(input_type & (VRNA_INPUT_QUIT | VRNA_INPUT_ERROR)) return input_type;
    */

    /*  finished reading everything...
    *   we now put the last line into the buffer if necessary
    *   since it should belong to the next record
    */
    inbuf = input_string;
    typebuf = input_type;
  }
  (*rest)[rest_count] = NULL;
  return (return_type);
}

PUBLIC char *
vrna_extract_record_rest_structure( const char **lines,
                                    unsigned int length,
                                    unsigned int options){

  char *structure = NULL;
  int r, i, l, cl, stop;
  char *c;

  if(lines){
    for(r = i = stop = 0; lines[i]; i++){
      l   = (int)strlen(lines[i]);
      c   = (char *) vrna_alloc(sizeof(char) * (l+1));
      (void) sscanf(lines[i], "%s", c);
      cl  = (int)strlen(c);

      /* line commented out ? */
      if((*c == '#') || (*c == '%') || (*c == ';') || (*c == '/') || (*c == '*' || (*c == '\0'))){
        /* skip leading comments only, i.e. do not allow comments inside the constraint */
        if(!r)  continue;
        else    break;
      }

      /* append the structure part to the output */
      r += cl+1;
      structure = (char *)vrna_realloc(structure, r*sizeof(char));
      strcat(structure, c);
      free(c);
      /* stop if the assumed structure length has been reached */
      if((length > 0) && (r-1 == length)) break;
      /* stop if not allowed to read from multiple lines */
      if(!(options & VRNA_OPTION_MULTILINE)) break;
    }
  }
  return structure;
}

PUBLIC void
vrna_extract_record_rest_constraint(char **cstruc,
                                    const char **lines,
                                    unsigned int option){

  *cstruc = vrna_extract_record_rest_structure(lines, 0, option | (option & VRNA_CONSTRAINT_MULTILINE) ? VRNA_OPTION_MULTILINE : 0);
  
}

PUBLIC int
vrna_file_SHAPE_read( const char *file_name,
                      int length,
                      double default_value,
                      char *sequence,
                      double *values){

  FILE *fp;
  char *line;
  int i;
  int count = 0;

  if(!file_name)
    return 0;

  if(!(fp = fopen(file_name, "r"))){
    vrna_message_warning("SHAPE data file could not be opened");
    return 0;
  }

  for (i = 0; i < length; ++i)
  {
    sequence[i] = 'N';
    values[i + 1] = default_value;
  }

  sequence[length] = '\0';

  while((line=get_line(fp))){
    int position;
    unsigned char nucleotide = 'N';
    double reactivity = default_value;
    char *second_entry = 0;
    char *third_entry = 0;
    char *c;

    if(sscanf(line, "%d", &position) != 1)
    {
      free(line);
      continue;
    }

    if(position <= 0 || position > length)
    {
      vrna_message_warning("Provided SHAPE data outside of sequence scope");
      fclose(fp);
      free(line);
      return 0;
    }

    for(c = line + 1; *c; ++c){
      if(isspace(*(c-1)) && !isspace(*c)) {
        if(!second_entry){
          second_entry = c;
        }else{
          third_entry = c;
          break;
        }
      }
    }

    if(second_entry){
      if(third_entry){
        sscanf(second_entry, "%c", &nucleotide);
        sscanf(third_entry, "%lf", &reactivity);
      }else if(sscanf(second_entry, "%lf", &reactivity) != 1)
        sscanf(second_entry, "%c", &nucleotide);
    }

    sequence[position-1] = nucleotide;
    values[position] = reactivity;
    ++count;

    free(line);
  }

  fclose(fp);

  if(!count)
  {
      vrna_message_warning("SHAPE data file is empty");
      return 0;
  }

  return 1;
}

PRIVATE int
parse_constraints_line( const char *line,
                        char command,
                        int *i,
                        int *j,
                        int *k,
                        int *l,
                        char *loop,
                        char *orientation,
                        float *e){

  int v1, v2;
  int ret = 0;
  int range_mode = 0;
  int pos = 0;
  int max_entries = 5;
  int entries_seen = 0;
  int pp;
  float energy;
  char buf[256], buf2[10], *c, tmp_loop;

  switch(command){
    case 'A':   /* fall through */
    case 'F':   /* fall through */
    case 'P':   max_entries = 5;
                break;
    case 'C':   /* fall through */
    case 'E':   max_entries = 4;
                break;
    case '#': case ';': case '%': case '/': case ' ':
                ret = 2;  /* comment */
                break;
    default:    ret = 1;  /* error */
                break;
  }

  /* default to all loop types */
  *loop     = VRNA_CONSTRAINT_CONTEXT_ALL_LOOPS;
  tmp_loop  = (char)0;

  /* now lets scan the entire line for content */
  while(!ret && (entries_seen < max_entries) && (sscanf(line+pos,"%15s%n", &buf[0], &pp) == 1)){
    pos += pp;
    switch(entries_seen){
      case 0: /* must be i, or range */
              if(sscanf(buf, "%d-%d%n", &v1, &v2, &pp) == 2){
                if(pp == strlen(buf)){
                  *i = v1;
                  *j = v2;
                  range_mode = 1;
                  --max_entries; /* no orientation allowed now */
                  break;
                }
              } else if(sscanf(buf, "%d%n", &v1, &pp) == 1){
                if(pp == strlen(buf)){
                  *i = v1;
                  break;
                }
              }
              ret = 1;
              break;
      case 1: /* must be j, or range */
              if(sscanf(buf, "%d-%d%n", &v1, &v2, &pp) == 2){
                if(pp == strlen(buf)){
                  *k = v1;
                  *l = v2;
                  if(!range_mode)
                    --max_entries; /* no orientation allowed now */
                  range_mode = 1;
                  break;
                }
              } else if(range_mode){
                if(sscanf(buf, "%d%n", &v1, &pp) == 1){
                  if(pp == strlen(buf)){
                    *l = v1;
                    break;
                  }
                }
              } else if(sscanf(buf, "%d%n", &v1, &pp) == 1){
                if(pp == strlen(buf)){
                  *j = v1;
                  break;
                }
              }
              ret = 1;
              break;
      case 2: /* skip if in range_mode */
              if(!range_mode){
                /* must be k */
                if(sscanf(buf, "%d%n", &v1, &pp) == 1){
                  if(pp == strlen(buf)){
                    *k = v1;
                    break;
                  }
                }
                ret = 1;
                break;
              } else {
                --max_entries;
                /* fall through */
              }
      case 3: 
              if(command == 'E'){ /* must be pseudo energy */
                if(sscanf(buf, "%g%n", &energy, &pp) == 1){
                  if(pp == strlen(buf)){
                    *e = energy;
                    break;
                  }
                }
              } else { /*  must be loop type, or orientation */
                if(sscanf(buf, "%8s%n", &buf2[0], &pp) == 1){
                  buf2[8] = '\0';
                  if(pp == strlen(buf)){
                    for(c = &(buf2[0]); (*c != '\0') && (!ret); c++){
                      switch(*c){
                        case 'E': tmp_loop |= VRNA_CONSTRAINT_CONTEXT_EXT_LOOP;
                                  break;
                        case 'H': tmp_loop |= VRNA_CONSTRAINT_CONTEXT_HP_LOOP;
                                  break;
                        case 'I': tmp_loop |= VRNA_CONSTRAINT_CONTEXT_INT_LOOP;
                                  break;
                        case 'i': tmp_loop |= VRNA_CONSTRAINT_CONTEXT_INT_LOOP_ENC;
                                  break;
                        case 'M': tmp_loop |= VRNA_CONSTRAINT_CONTEXT_MB_LOOP;
                                  break;
                        case 'm': tmp_loop |= VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC;
                                  break;
                        case 'A': tmp_loop |= VRNA_CONSTRAINT_CONTEXT_ALL_LOOPS;
                                  break;
                        case 'U': case 'D':
                                  *orientation = *c;
                                  break;
                        default:  ret = 1;
                      }
                    }
                    if(tmp_loop)
                      *loop = tmp_loop;

                    break;
                  }
                }
              }
              ret = 1;
              break;
      case 4: /* must be orientation */
              if(!(sscanf(buf, "%c", orientation) == 1)){
                ret = 1;
              }
              break;
    }
    ++entries_seen;
  }

  return ret;
}

PUBLIC  vrna_plist_t *
vrna_file_constraints_read( const char *filename,
                            unsigned int length,
                            unsigned int options){

  FILE  *fp;
  int   line_number, constraint_number, constraint_number_guess;
  char  *line;
  vrna_plist_t *constraints;

  if(!(fp = fopen(filename, "r"))){
    vrna_message_warning("Hard Constraints File could not be opened!");
    return NULL;
  }

  line_number             = 0;
  constraint_number       = 0;
  constraint_number_guess = 10;
  constraints             = (vrna_plist_t *)vrna_alloc(sizeof(vrna_plist_t) * constraint_number_guess);

  while((line=get_line(fp))){

    int i, j, k, l, h, cnt1, cnt2, cnt3, error, type, valid;
    float e;
    char command, looptype, orientation;

    line_number++; /* increase line number */

    if(sscanf(line, "%c", &command) != 1){
      free(line);
      continue;
    }

    i = j = k = l = -1;
    orientation = '\0'; /* no orientation */
    e = 0.;

    error = parse_constraints_line(line + 1, command, &i, &j, &k, &l, &looptype, &orientation, &e);
    if(error == 1){
      fprintf(stderr, "WARNING: Unrecognized constraint command line in input file %s, line %d\n", filename, line_number);
    } else if(error == 0){
      /* do something with the constraint we've just read */
      type  = (int)looptype;
      h     = 1; /* helix length for pairs, or number of unpaired nucleotides */

      /* check indices */
      valid = 0;
      if(i > 0){
        if(j == -1){ /* i and range [k:l] */
          if((k > 0) && (l > 0)){
            if((k < l) && (i < k) && (orientation == '\0')){
              j     = i;
              valid = 1;
            }
          }
        } else if(k <= 0){ /* range [i:j] and l */
          if((i < j) && (j < l) && (orientation == '\0')){
            k     = l;
            valid = 1;
          }
        } else if(l <= 0){ /* helix of size k starting with pair (i,j), or segment [i:i+k-1] */
          if(i != j){
            if((j == 0) || (((j - i + 1) > 2*k) && (orientation == '\0'))){
              h     = k;
              k = l = j;
              j     = i;
              valid = 1;
            }
          }
        } else if((i < j) && (k < l) && (i <= k) && (j <= l) && (orientation == '\0')){  /* range [i:j] and [k:l] */
          if(command == 'P'){ /* we only allow this for 'prohibit pairing between two ranges' */
            h     = 0;
            valid = 1;
          }
        }
      }

      if(valid){  /* still valid constraint? */

        /* nucleotide constraint? */
        if((k == 0) && (l == 0) && (i == j) && (h > 0)){
          /* set correct loop type context */
          switch(command){
            case 'P': break;
            case 'A': /* this case allows particular nucleotides to form non-canonical pairs */
                      type |= 8192; /* do not remove possibility to stay unpaired */
                      /* fall through */
            case 'F': /* set i == j == k == l */
                      k = l = i;
                      if(orientation != '\0')
                        type |= (orientation == 'U') ? 1024 : 2048; /* add hidden flags for pairing orientation */
                      break;
            case 'E': type = (int)(VRNA_CONSTRAINT_CONTEXT_ALL_LOOPS);  /* soft constraints are always applied for all loops */
                      type |= 4096; /* add hidden flag indicating soft constraint */
                      break;
            case 'C': type |= (int)(VRNA_CONSTRAINT_CONTEXT_ENFORCE); /* enforce context dependency */
                      break;
            default:  break;
          }
        } else { /* base pair constraint */
          /* set correct loop type context */
          switch(command){
            case 'P': type = ~type; /* prohibit */
                      type &= (int)(VRNA_CONSTRAINT_CONTEXT_ALL_LOOPS);
                      type |= 8192;  /* since we prohibit pairs, we do not want to remove incompatible pairs */
                      break;
            case 'F': type |= (int)(VRNA_CONSTRAINT_CONTEXT_ENFORCE);  /* enforce */
                      break;
            case 'E': type = (int)(VRNA_CONSTRAINT_CONTEXT_ALL_LOOPS);  /* soft constraints are always applied for all loops */
                      type |= 4096; /* add hidden flag indicating soft constraint */
                      break;
            case 'C': break;        /* remove conflicting pairs only */
            case 'A': type |= 8192; /* since we allow pairs, we do not want to remove incompatible pairs */
                      break;
            default:  break;
          }
        }

        /* construct list of constraints */
        if(h == 0){ /* range mode */
          for(cnt1 = i; cnt1 <= j; cnt1++)
            for(cnt2 = MAX2(cnt1 + 1, k); cnt2 <= l; cnt2++){
              constraints[constraint_number].i    = cnt1;
              constraints[constraint_number].j    = cnt2;
              constraints[constraint_number].p    = e;
              constraints[constraint_number].type = type;
              constraint_number++;

              if(constraint_number == constraint_number_guess){
                constraint_number_guess *= 2;
                constraints = (vrna_plist_t *)vrna_realloc(constraints, sizeof(vrna_plist_t) * constraint_number_guess);
              }
            }
        } else {
          for(cnt1 = i; cnt1 <= j; cnt1++)
            for(cnt2 = k; cnt2 <= l; cnt2++)
              for(cnt3 = h; cnt3 != 0; cnt3--){
                constraints[constraint_number].i    = cnt1 + (cnt3 - 1);
                constraints[constraint_number].p    = e;
                constraints[constraint_number].type = type;
                if(cnt2 == 0){  /* enforce unpairedness of nucleotide */
                  constraints[constraint_number].j  = 0;
                } else if((i == j) && (j == k) && (k == l)){  /* enforce pairedness of nucleotide */
                  constraints[constraint_number].j  = cnt1 + (cnt3 - 1);
                } else {  /* enforce / prohibit base pair */
                  constraints[constraint_number].j  = cnt2 - (cnt3 - 1);
                }
                constraint_number++;

                if(constraint_number == constraint_number_guess){
                  constraint_number_guess *= 2;
                  constraints = (vrna_plist_t *)vrna_realloc(constraints, sizeof(vrna_plist_t) * constraint_number_guess);
                }
              }
        }
      } else {
        fprintf(stderr, "WARNING: Incorrect constraint command in input file %s, line %d\n", filename, line_number);
      }
    }

    free(line);
  }

  fclose(fp);

  /* resize plist to actual size */
  constraints = (vrna_plist_t *)vrna_realloc(constraints, sizeof(vrna_plist_t) * (constraint_number + 1));

  constraints[constraint_number].i    = 0;
  constraints[constraint_number].j    = 0;
  constraints[constraint_number].p    = 0.;
  constraints[constraint_number].type = 0;

  if(constraint_number == 0){
    vrna_message_warning("Constraints file does not contain any constraints");
  }

  return constraints;
}

#ifdef  VRNA_BACKWARD_COMPAT

/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/

PUBLIC unsigned int
get_multi_input_line( char **string,
                      unsigned int option){

  return read_multiple_input_lines(string, NULL, option);
}

PUBLIC unsigned int
read_record(char **header,
            char **sequence,
            char  ***rest,
            unsigned int options){

  return vrna_file_fasta_read_record(header, sequence, rest, NULL, options);
}

PUBLIC char *
extract_record_rest_structure(const char **lines,
                              unsigned int length,
                              unsigned int options){

  return vrna_extract_record_rest_structure(lines, length, options);
}


#endif
dp_matrices.c/  0           0     0     644     40440     `
/** \file dp_matricess.c **/

/*
                  Dynamic Programming matrix related functions

                  This file contains everything necessary to
                  obtain and destroy data structures representing
                  dynamic programming (DP) matrices used in the folding
                  recurrences throughout the VienneRNA paclage

                  c Ronny Lorenx

                  Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdlib.h>
#include <math.h>

#include "data_structures.h"
#include "model.h"
#include "utils.h"
#include "gquad.h"
#include "dp_matrices.h"

/*
#################################
# PRIVATE MACROS                #
#################################
*/

/* the definitions below indicate which arrays should be allocated upon retrieval of a matrices data structure */
#define ALLOC_NOTHING     0
#define ALLOC_F           1
#define ALLOC_F5          2
#define ALLOC_F3          4
#define ALLOC_FC          8
#define ALLOC_C           16
#define ALLOC_FML         32
#define ALLOC_PROBS       256
#define ALLOC_AUX         512

#define ALLOC_CIRC        1024
#define ALLOC_HYBRID      2048
#define ALLOC_UNIQ        4096


#define ALLOC_MFE_DEFAULT         (ALLOC_F5 | ALLOC_C | ALLOC_FML)
#define ALLOC_MFE_LOCAL           (ALLOC_F3 | ALLOC_C | ALLOC_FML)

#define ALLOC_PF_WO_PROBS         (ALLOC_F | ALLOC_C | ALLOC_FML)
#define ALLOC_PF_DEFAULT          (ALLOC_PF_WO_PROBS | ALLOC_PROBS | ALLOC_AUX)

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/
PRIVATE unsigned int    get_mx_alloc_vector(vrna_md_t *md_p, vrna_mx_type_e type, unsigned int options);
PRIVATE void            mfe_matrices_alloc_default(vrna_mx_mfe_t *vars, unsigned int m, unsigned int alloc_vector);
PRIVATE void            mfe_matrices_free_default(vrna_mx_mfe_t *self);
PRIVATE void            mfe_matrices_alloc_window(vrna_mx_mfe_t *vars, unsigned int m, unsigned int alloc_vector);
PRIVATE void            mfe_matrices_free_window(vrna_mx_mfe_t *self, unsigned int length, unsigned int window_size);
PRIVATE void            mfe_matrices_alloc_2Dfold(vrna_mx_mfe_t *vars, unsigned int m, unsigned int alloc_vector);
PRIVATE void            mfe_matrices_free_2Dfold( vrna_mx_mfe_t *self, unsigned int length, int *indx);
PRIVATE void            pf_matrices_alloc_default(vrna_mx_pf_t *vars, unsigned int m, unsigned int alloc_vector);
PRIVATE void            pf_matrices_free_default(vrna_mx_pf_t *self);
PRIVATE void            pf_matrices_alloc_2Dfold(vrna_mx_pf_t *vars, unsigned int m, unsigned int alloc_vector);
PRIVATE void            pf_matrices_free_2Dfold(vrna_mx_pf_t *self, unsigned int length, int *indx, int *jindx);
PRIVATE vrna_mx_mfe_t   *get_mfe_matrices_alloc(unsigned int n, unsigned int m, vrna_mx_type_e type, unsigned int alloc_vector);
PRIVATE vrna_mx_pf_t    *get_pf_matrices_alloc(unsigned int n, vrna_mx_type_e type, unsigned int alloc_vector);
PRIVATE void            add_pf_matrices( vrna_fold_compound_t *vc, vrna_mx_type_e type, unsigned int alloc_vector);
PRIVATE void            add_mfe_matrices(vrna_fold_compound_t *vc, vrna_mx_type_e type, unsigned int alloc_vector);


/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PUBLIC void
vrna_mx_mfe_free(vrna_fold_compound_t *vc){

  if(vc){
    vrna_mx_mfe_t *self = vc->matrices;
    if(self){
      switch(self->type){
        case VRNA_MX_DEFAULT:   mfe_matrices_free_default(self);
                                break;

        case VRNA_MX_WINDOW:    mfe_matrices_free_window(self, vc->length, vc->window_size);
                                break;

        case VRNA_MX_2DFOLD:    mfe_matrices_free_2Dfold(self, vc->length, vc->iindx);
                                break;

        default:                /* do nothing */
                                break;
      }
      free(self);
      vc->matrices = NULL;
    }
  }
}

PUBLIC void
vrna_mx_pf_free(vrna_fold_compound_t *vc){

  if(vc){
    vrna_mx_pf_t  *self = vc->exp_matrices;
    if(self){
      switch(self->type){
        case VRNA_MX_DEFAULT:   pf_matrices_free_default(self);
                                break;

        case VRNA_MX_2DFOLD:    pf_matrices_free_2Dfold(self, vc->length, vc->iindx, vc->jindx);
                                break;

        default:                /* do nothing */
                                break;
      }

      free(self->expMLbase);
      free(self->scale);

      free(self);
      vc->exp_matrices = NULL;
    }
  }
}

PUBLIC int
vrna_mx_add(vrna_fold_compound_t *vc,
            vrna_mx_type_e mx_type,
            unsigned int options){

  int ret;

  ret = 1;

  if(options & VRNA_OPTION_MFE){
    ret &= vrna_mx_mfe_add(vc, mx_type, options);
  }

  if(options & VRNA_OPTION_PF){
    ret &= vrna_mx_pf_add(vc, mx_type, options);
  }

  return ret;
}

PUBLIC int
vrna_mx_mfe_add(vrna_fold_compound_t *vc,
                vrna_mx_type_e mx_type,
                unsigned int options){

  unsigned int mx_alloc_vector;

  if(vc->params){
    options |= VRNA_OPTION_MFE;
    if(vc->cutpoint > 0)
      options |= VRNA_OPTION_HYBRID;

    mx_alloc_vector = get_mx_alloc_vector(&(vc->params->model_details), mx_type, options);
    vrna_mx_mfe_free(vc);
    add_mfe_matrices(vc, mx_type, mx_alloc_vector);
  } else {
    return 0;
  }

  return 1;
}

PUBLIC int
vrna_mx_pf_add( vrna_fold_compound_t *vc,
                vrna_mx_type_e mx_type,
                unsigned int options){

  unsigned int mx_alloc_vector;
  if(vc->exp_params){
    mx_alloc_vector = get_mx_alloc_vector(&(vc->exp_params->model_details), mx_type, options | VRNA_OPTION_PF);
    vrna_mx_pf_free(vc);
    add_pf_matrices(vc, mx_type, mx_alloc_vector);
  } else {
    return 0;
  }

  return 1;
}

/*
#####################################
# BEGIN OF STATIC HELPER FUNCTIONS  #
#####################################
*/

PRIVATE void
add_pf_matrices(vrna_fold_compound_t *vc,
                vrna_mx_type_e type,
                unsigned int alloc_vector){

  if(vc){
    vc->exp_matrices  = get_pf_matrices_alloc(vc->length, type, alloc_vector);
    if(vc->exp_params->model_details.gquad){
      switch(vc->type){
        case VRNA_VC_TYPE_SINGLE:   vc->exp_matrices->G = NULL;
                                    /* can't do that here, since scale[] is not filled yet :( 
                                      vc->exp_matrices->G = get_gquad_pf_matrix(vc->sequence_encoding2, vc->exp_matrices->scale, vc->exp_params);
                                    */
                                    break;
        default:                    /* do nothing */
                                    break;
      }
    }
    vrna_exp_params_rescale(vc, NULL);
  }
}

PRIVATE void
add_mfe_matrices( vrna_fold_compound_t *vc,
                  vrna_mx_type_e mx_type,
                  unsigned int alloc_vector){

  if(vc){
    switch(mx_type){
      case VRNA_MX_WINDOW:  vc->matrices = get_mfe_matrices_alloc(vc->length, vc->window_size, mx_type, alloc_vector);
                            break;
      default:              vc->matrices = get_mfe_matrices_alloc(vc->length, vc->length, mx_type, alloc_vector);
                            break;
    }

    if(vc->params->model_details.gquad){
      switch(vc->type){
        case VRNA_VC_TYPE_SINGLE:     switch(mx_type){
                                        case VRNA_MX_WINDOW:  /* do nothing, since we handle memory somewhere else */
                                                              break;
                                        default:              vc->matrices->ggg = get_gquad_matrix(vc->sequence_encoding2, vc->params);
                                                              break;
                                      }
                                      break;
        case VRNA_VC_TYPE_ALIGNMENT:  vc->matrices->ggg = get_gquad_ali_matrix(vc->S_cons, vc->S, vc->n_seq,  vc->params);
                                      break;
        default:                      /* do nothing */
                                      break;
      }
    }
  }
}

PRIVATE vrna_mx_mfe_t  *
get_mfe_matrices_alloc( unsigned int n,
                        unsigned int m,
                        vrna_mx_type_e type,
                        unsigned int alloc_vector){

  vrna_mx_mfe_t *vars;

  if((int)(n * m) >= (int)INT_MAX)
    vrna_message_error("get_mfe_matrices_alloc@data_structures.c: sequence length exceeds addressable range");

  vars          = (vrna_mx_mfe_t *)vrna_alloc(sizeof(vrna_mx_mfe_t));
  vars->length  = n;
  vars->type    = type;

  switch(type){
    case VRNA_MX_DEFAULT:   mfe_matrices_alloc_default(vars, m, alloc_vector);
                            break;

    case VRNA_MX_WINDOW:    mfe_matrices_alloc_window(vars, m, alloc_vector);
                            break;

    case VRNA_MX_2DFOLD:    mfe_matrices_alloc_2Dfold(vars, m, alloc_vector);
                            break;

    default:                /* do nothing */
                            break;
  }

  return vars;
}

PRIVATE vrna_mx_pf_t  *
get_pf_matrices_alloc(unsigned int n,
                      vrna_mx_type_e type,
                      unsigned int alloc_vector){

  unsigned int  lin_size;
  vrna_mx_pf_t  *vars;

  if(n >= (unsigned int)sqrt((double)INT_MAX))
    vrna_message_error("get_pf_matrices_alloc@data_structures.c: sequence length exceeds addressable range");

  lin_size      = n + 2;
  vars          = (vrna_mx_pf_t *)vrna_alloc(sizeof(vrna_mx_pf_t));
  vars->length  = n;
  vars->type    = type;


  switch(type){
    case VRNA_MX_DEFAULT:   pf_matrices_alloc_default(vars, n, alloc_vector);
                            break;

    case VRNA_MX_2DFOLD:    pf_matrices_alloc_2Dfold(vars, n, alloc_vector);
                            break;

    default:                /* do nothing */
                            break;
  }

  /*
      always alloc the helper arrays for unpaired nucleotides in multi-
      branch loops and scaling
  */
  vars->scale     = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL) * lin_size);
  vars->expMLbase = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL) * lin_size);

  return vars;
}

PRIVATE unsigned int
get_mx_alloc_vector(vrna_md_t *md_p,
                    vrna_mx_type_e mx_type,
                    unsigned int options){

  unsigned int  v;

  v = ALLOC_NOTHING;

  /* default MFE matrices ? */
  if(options & VRNA_OPTION_MFE)
    v |= (mx_type == VRNA_MX_WINDOW) ? ALLOC_MFE_LOCAL : ALLOC_MFE_DEFAULT;

  /* default PF matrices ? */
  if(options & VRNA_OPTION_PF)
    v |= (md_p->compute_bpp) ? ALLOC_PF_DEFAULT : ALLOC_PF_WO_PROBS;

  if(options & VRNA_OPTION_HYBRID)
    v |= ALLOC_HYBRID;

  /* matrices for circular folding ? */
  if(md_p->circ){
    md_p->uniq_ML = 1; /* we need unique ML arrays for circular folding */
    v |= ALLOC_CIRC;
  }

  /* unique ML decomposition ? */
  if(md_p->uniq_ML)
    v |= ALLOC_UNIQ;

  return v;
}


PRIVATE void
mfe_matrices_alloc_default( vrna_mx_mfe_t *vars,
                            unsigned int m,
                            unsigned int alloc_vector){

  unsigned int  n, size, lin_size;

  n             = vars->length;
  size          = ((n + 1) * (m + 2)) / 2;
  lin_size      = n + 2;

  //vars->evaluated = NULL;
  vars->f5  = NULL;
  vars->f3  = NULL;
  vars->fc  = NULL;
  vars->c   = NULL;
  vars->fML = NULL;
  vars->fM1 = NULL;
  vars->fM2 = NULL;
  vars->ggg = NULL;

  if(alloc_vector)
    vars->evaluated  = (int *) vrna_alloc(sizeof(int) * size);

  if(alloc_vector & ALLOC_F5)
    vars->f5  = (int *) vrna_alloc(sizeof(int) * lin_size);

  if(alloc_vector & ALLOC_F3)
    vars->f3  = (int *) vrna_alloc(sizeof(int) * lin_size);

  if(alloc_vector & ALLOC_HYBRID)
    vars->fc  = (int *) vrna_alloc(sizeof(int) * lin_size);

  if(alloc_vector & ALLOC_C)
    vars->c   = (int *) vrna_alloc(sizeof(int) * size);

  if(alloc_vector & ALLOC_FML)
    vars->fML = (int *) vrna_alloc(sizeof(int) * size);

  if(alloc_vector & ALLOC_UNIQ)
    vars->fM1 = (int *) vrna_alloc(sizeof(int) * size);

  if(alloc_vector & ALLOC_CIRC)
    vars->fM2 = (int *) vrna_alloc(sizeof(int) * lin_size);

  /* setting exterior loop energies for circular case to INF is always safe */
  vars->FcH = vars->FcI = vars->FcM = vars->Fc = INF;

}

PRIVATE void
mfe_matrices_free_default(vrna_mx_mfe_t *self){

  free(self->f5);
  free(self->f3);
  free(self->fc);
  free(self->c);
  free(self->fML);
  free(self->fM1);
  free(self->fM2);
  free(self->ggg);
}

PRIVATE void
mfe_matrices_alloc_window(vrna_mx_mfe_t *vars,
                          unsigned int m,
                          unsigned int alloc_vector){

  int i;
  unsigned int  n, lin_size;

  n             = vars->length;
  lin_size      = n + 2;

  vars->f3_local = NULL;
  vars->c_local = NULL;
  vars->fML_local = NULL;
  vars->ggg_local = NULL;

  if(alloc_vector & ALLOC_F3)
    vars->f3_local = (int *) vrna_alloc(sizeof(int) * lin_size);

  if(alloc_vector & ALLOC_C){
    vars->c_local = (int **) vrna_alloc(sizeof(int *) * lin_size);
    for (i = (int)n; ( i > ((int)n - (int)m - 5)) && (i>=0); i--){
      vars->c_local[i] = (int *) vrna_alloc(sizeof(int)*(m + 5));
    }
  }

  if(alloc_vector & ALLOC_FML){
    vars->fML_local = (int **) vrna_alloc(sizeof(int *) * lin_size);
    for (i = (int)n; ( i > ((int)n - (int)m - 5)) && (i>=0); i--){
      vars->fML_local[i] = (int *) vrna_alloc(sizeof(int)*(m + 5));
    }
  }
}

PRIVATE void
mfe_matrices_free_window( vrna_mx_mfe_t *self,
                          unsigned int length,
                          unsigned int window_size){

  unsigned int  i;

  if(self->c_local)
    for (i=0; (i < window_size + 5) && (i <= length); i++){
      free(self->c_local[i]);
    }
  free(self->c_local);

  if(self->fML_local)
    for (i=0; (i < window_size + 5) && (i <= length); i++){
      free(self->fML_local[i]);
    }
  free(self->fML_local);

  if(self->ggg_local)
    for (i=0; (i < window_size + 5) && (i <= length); i++){
      free(self->ggg_local[i]);
    }
  free(self->ggg_local);

  free(self->f3_local);
}

PRIVATE void
mfe_matrices_alloc_2Dfold(vrna_mx_mfe_t *vars,
                          unsigned int m,
                          unsigned int alloc_vector){

  unsigned int  n, i, size, lin_size;

  n               = vars->length;
  size            = ((n + 1) * (m + 2)) / 2;
  lin_size        = n + 2;

  vars->E_F5      = NULL;
  vars->l_min_F5  = NULL;
  vars->l_max_F5  = NULL;
  vars->k_min_F5  = NULL;
  vars->k_max_F5  = NULL;
  vars->E_F5_rem  = NULL;

  vars->E_F3      = NULL;
  vars->l_min_F3  = NULL;
  vars->l_max_F3  = NULL;
  vars->k_min_F3  = NULL;
  vars->k_max_F3  = NULL;
  vars->E_F3_rem  = NULL;

  vars->E_C       = NULL;
  vars->l_min_C   = NULL;
  vars->l_max_C   = NULL;
  vars->k_min_C   = NULL;
  vars->k_max_C   = NULL;
  vars->E_C_rem   = NULL;

  vars->E_M       = NULL;
  vars->l_min_M   = NULL;
  vars->l_max_M   = NULL;
  vars->k_min_M   = NULL;
  vars->k_max_M   = NULL;
  vars->E_M_rem   = NULL;

  vars->E_M1      = NULL;
  vars->l_min_M1  = NULL;
  vars->l_max_M1  = NULL;
  vars->k_min_M1  = NULL;
  vars->k_max_M1  = NULL;
  vars->E_M1_rem  = NULL;

  vars->E_M2      = NULL;
  vars->l_min_M2  = NULL;
  vars->l_max_M2  = NULL;
  vars->k_min_M2  = NULL;
  vars->k_max_M2  = NULL;
  vars->E_M2_rem  = NULL;

  /* setting exterior loop energies for circular case to INF is always safe */
  vars->E_Fc      = NULL;
  vars->E_FcH     = NULL;
  vars->E_FcI     = NULL;
  vars->E_FcM     = NULL;
  vars->E_Fc_rem  = INF;
  vars->E_FcH_rem = INF;
  vars->E_FcI_rem = INF;
  vars->E_FcM_rem = INF;

  if(alloc_vector & ALLOC_F5){
    vars->E_F5      = (int ***) vrna_alloc(sizeof(int **) * lin_size);
    vars->l_min_F5  = (int **)  vrna_alloc(sizeof(int *)  * lin_size);
    vars->l_max_F5  = (int **)  vrna_alloc(sizeof(int *)  * lin_size);
    vars->k_min_F5  = (int *)   vrna_alloc(sizeof(int)    * lin_size);
    vars->k_max_F5  = (int *)   vrna_alloc(sizeof(int)    * lin_size);
    vars->E_F5_rem  = (int *)   vrna_alloc(sizeof(int)    * lin_size);
    for(i = 0; i <= n; i++)
      vars->E_F5_rem[i] = INF;
  }

  if(alloc_vector & ALLOC_F3){
    vars->E_F3      = (int ***) vrna_alloc(sizeof(int **)  * lin_size);
    vars->l_min_F3  = (int **)  vrna_alloc(sizeof(int *)   * lin_size);
    vars->l_max_F3  = (int **)  vrna_alloc(sizeof(int *)   * lin_size);
    vars->k_min_F3  = (int *)   vrna_alloc(sizeof(int)     * lin_size);
    vars->k_max_F3  = (int *)   vrna_alloc(sizeof(int)     * lin_size);
    vars->E_F3_rem  = (int *)   vrna_alloc(sizeof(int)    * lin_size);
    for(i = 0; i <= n; i++)
      vars->E_F3_rem[i] = INF;
  }

  if(alloc_vector & ALLOC_C){
    vars->E_C     = (int ***) vrna_alloc(sizeof(int **) * size);
    vars->l_min_C = (int **)  vrna_alloc(sizeof(int *)  * size);
    vars->l_max_C = (int **)  vrna_alloc(sizeof(int *)  * size);
    vars->k_min_C = (int *)   vrna_alloc(sizeof(int)    * size);
    vars->k_max_C = (int *)   vrna_alloc(sizeof(int)    * size);
    vars->E_C_rem = (int *)   vrna_alloc(sizeof(int)    * size);
    for(i = 0; i < size; i++)
      vars->E_C_rem[i] = INF;
  }

  if(alloc_vector & ALLOC_FML){
    vars->E_M     = (int ***) vrna_alloc(sizeof(int **) * size);
    vars->l_min_M = (int **)  vrna_alloc(sizeof(int *)  * size);
    vars->l_max_M = (int **)  vrna_alloc(sizeof(int *)  * size);
    vars->k_min_M = (int *)   vrna_alloc(sizeof(int)    * size);
    vars->k_max_M = (int *)   vrna_alloc(sizeof(int)    * size);
    vars->E_M_rem = (int *)   vrna_alloc(sizeof(int)    * size);
    for(i = 0; i < size; i++)
      vars->E_M_rem[i] = INF;
  }

  if(alloc_vector & ALLOC_UNIQ){
    vars->E_M1      = (int ***) vrna_alloc(sizeof(int **) * size);
    vars->l_min_M1  = (int **)  vrna_alloc(sizeof(int *)  * size);
    vars->l_max_M1  = (int **)  vrna_alloc(sizeof(int *)  * size);
    vars->k_min_M1  = (int *)   vrna_alloc(sizeof(int)    * size);
    vars->k_max_M1  = (int *)   vrna_alloc(sizeof(int)    * size);
    vars->E_M1_rem  = (int *)   vrna_alloc(sizeof(int)    * size);
    for(i = 0; i < size; i++)
      vars->E_M1_rem[i] = INF;
  }

  if(alloc_vector & ALLOC_CIRC){
    vars->E_M2      = (int ***) vrna_alloc(sizeof(int **)  * lin_size);
    vars->l_min_M2  = (int **)  vrna_alloc(sizeof(int *)   * lin_size);
    vars->l_max_M2  = (int **)  vrna_alloc(sizeof(int *)   * lin_size);
    vars->k_min_M2  = (int *)   vrna_alloc(sizeof(int)     * lin_size);
    vars->k_max_M2  = (int *)   vrna_alloc(sizeof(int)     * lin_size);
    vars->E_M2_rem  = (int *)   vrna_alloc(sizeof(int)     * lin_size);
    for(i = 0; i <= n; i++)
      vars->E_M2_rem[i] = INF;
  }

#ifdef COUNT_STATES
  vars->N_C   = (unsigned long ***) vrna_alloc(sizeof(unsigned long **)  * size);
  vars->N_F5  = (unsigned long ***) vrna_alloc(sizeof(unsigned long **)  * lin_size);
  vars->N_M   = (unsigned long ***) vrna_alloc(sizeof(unsigned long **)  * size);
  vars->N_M1  = (unsigned long ***) vrna_alloc(sizeof(unsigned long **)  * size);
#endif
}

PRIVATE void
mfe_matrices_free_2Dfold( vrna_mx_mfe_t *self,
                          unsigned int length,
                          int *indx){

  unsigned int  i, j, ij;
  int           cnt1;

  /* This will be some fun... */
#ifdef COUNT_STATES
  if(self->N_F5 != NULL){
    for(i = 1; i <= length; i++){
      if(!self->N_F5[i]) continue;
      for(cnt1 = self->k_min_F5[i]; cnt1 <= vars->k_max_F5[i]; cnt1++)
        if(vars->l_min_F5[i][cnt1] < INF){
          vars->N_F5[i][cnt1] += vars->l_min_F5[i][cnt1]/2;
          free(vars->N_F5[i][cnt1]);
        }
      if(vars->k_min_F5[i] < INF){
        vars->N_F5[i] += vars->k_min_F5[i];
        free(vars->N_F5[i]);
      }
    }
    free(vars->N_F5);
  }
#endif

  if(self->E_F5 != NULL){
    for(i = 1; i <= length; i++){
      if(!self->E_F5[i]) continue;
      for(cnt1 = self->k_min_F5[i]; cnt1 <= self->k_max_F5[i]; cnt1++)
        if(self->l_min_F5[i][cnt1] < INF){
          self->E_F5[i][cnt1] += self->l_min_F5[i][cnt1]/2;
          free(self->E_F5[i][cnt1]);
        }
      if(self->k_min_F5[i] < INF){
        self->E_F5[i] += self->k_min_F5[i];
        free(self->E_F5[i]);
        self->l_min_F5[i] += self->k_min_F5[i];
        self->l_max_F5[i] += self->k_min_F5[i];
        free(self->l_min_F5[i]);
        free(self->l_max_F5[i]);
      }
    }
    free(self->E_F5);
    free(self->l_min_F5);
    free(self->l_max_F5);
    free(self->k_min_F5);
    free(self->k_max_F5);
  }

  if(self->E_F3 != NULL){
    for(i = 1; i <= length; i++){
      if(!self->E_F3[i]) continue;
      for(cnt1 = self->k_min_F3[i]; cnt1 <= self->k_max_F3[i]; cnt1++)
        if(self->l_min_F3[i][cnt1] < INF){
          self->E_F3[i][cnt1] += self->l_min_F3[i][cnt1]/2;
          free(self->E_F3[i][cnt1]);
        }
      if(self->k_min_F3[i] < INF){
        self->E_F3[i] += self->k_min_F3[i];
        free(self->E_F3[i]);
        self->l_min_F3[i] += self->k_min_F3[i];
        self->l_max_F3[i] += self->k_min_F3[i];
        free(self->l_min_F3[i]);
        free(self->l_max_F3[i]);
      }
    }
    free(self->E_F3);
    free(self->l_min_F3);
    free(self->l_max_F3);
    free(self->k_min_F3);
    free(self->k_max_F3);
  }

#ifdef COUNT_STATES
  if(self->N_C != NULL){
    for(i = 1; i < length; i++){
      for(j = i; j <= length; j++){
        ij = indx[i] - j;
        if(!self->N_C[ij]) continue;
        for(cnt1 = self->k_min_C[ij]; cnt1 <= self->k_max_C[ij]; cnt1++)
          if(self->l_min_C[ij][cnt1] < INF){
            self->N_C[ij][cnt1] += self->l_min_C[ij][cnt1]/2;
            free(self->N_C[ij][cnt1]);
          }
        if(self->k_min_C[ij] < INF){
          self->N_C[ij] += self->k_min_C[ij];
          free(self->N_C[ij]);
        }
      }
    }
    free(self->N_C);
  }
#endif

  if(self->E_C != NULL){
    for(i = 1; i < length; i++){
      for(j = i; j <= length; j++){
        ij = indx[i] - j;
        if(!self->E_C[ij]) continue;
        for(cnt1 = self->k_min_C[ij]; cnt1 <= self->k_max_C[ij]; cnt1++)
          if(self->l_min_C[ij][cnt1] < INF){
            self->E_C[ij][cnt1] += self->l_min_C[ij][cnt1]/2;
            free(self->E_C[ij][cnt1]);
          }
        if(self->k_min_C[ij] < INF){
          self->E_C[ij] += self->k_min_C[ij];
          free(self->E_C[ij]);
          self->l_min_C[ij] += self->k_min_C[ij];
          self->l_max_C[ij] += self->k_min_C[ij];
          free(self->l_min_C[ij]);
          free(self->l_max_C[ij]);
        }
      }
    }
    free(self->E_C);
    free(self->l_min_C);
    free(self->l_max_C);
    free(self->k_min_C);
    free(self->k_max_C);
  }

#ifdef COUNT_STATES
  if(self->N_M != NULL){
    for(i = 1; i < length; i++){
      for(j = i; j <= length; j++){
        ij = indx[i] - j;
        if(!self->N_M[ij]) continue;
        for(cnt1 = self->k_min_M[ij]; cnt1 <= self->k_max_M[ij]; cnt1++)
          if(self->l_min_M[ij][cnt1] < INF){
            self->N_M[ij][cnt1] += self->l_min_M[ij][cnt1]/2;
            free(self->N_M[ij][cnt1]);
          }
        if(self->k_min_M[ij] < INF){
          self->N_M[ij] += self->k_min_M[ij];
          free(self->N_M[ij]);
        }
      }
    }
    free(self->N_M);
  }
#endif

  if(self->E_M != NULL){
    for(i = 1; i < length; i++){
      for(j = i; j <= length; j++){
        ij = indx[i] - j;
        if(!self->E_M[ij]) continue;
        for(cnt1 = self->k_min_M[ij]; cnt1 <= self->k_max_M[ij]; cnt1++)
          if(self->l_min_M[ij][cnt1] < INF){
            self->E_M[ij][cnt1] += self->l_min_M[ij][cnt1]/2;
            free(self->E_M[ij][cnt1]);
          }
        if(self->k_min_M[ij] < INF){
          self->E_M[ij] += self->k_min_M[ij];
          free(self->E_M[ij]);
          self->l_min_M[ij] += self->k_min_M[ij];
          self->l_max_M[ij] += self->k_min_M[ij];
          free(self->l_min_M[ij]);
          free(self->l_max_M[ij]);
        }
      }
    }
    free(self->E_M);
    free(self->l_min_M);
    free(self->l_max_M);
    free(self->k_min_M);
    free(self->k_max_M);
  }

#ifdef COUNT_STATES
  if(self->N_M1 != NULL){
    for(i = 1; i < length; i++){
      for(j = i; j <= length; j++){
        ij = indx[i] - j;
        if(!self->N_M1[ij]) continue;
        for(cnt1 = self->k_min_M1[ij]; cnt1 <= self->k_max_M1[ij]; cnt1++)
          if(self->l_min_M1[ij][cnt1] < INF){
            self->N_M1[ij][cnt1] += self->l_min_M1[ij][cnt1]/2;
            free(self->N_M1[ij][cnt1]);
          }
        if(self->k_min_M1[ij] < INF){
          self->N_M1[ij] += self->k_min_M1[ij];
          free(self->N_M1[ij]);
        }
      }
    }
    free(self->N_M1);
  }
#endif

  if(self->E_M1 != NULL){
    for(i = 1; i < length; i++){
      for(j = i; j <= length; j++){
        ij = indx[i] - j;
        if(!self->E_M1[ij]) continue;
        for(cnt1 = self->k_min_M1[ij]; cnt1 <= self->k_max_M1[ij]; cnt1++)
          if(self->l_min_M1[ij][cnt1] < INF){
            self->E_M1[ij][cnt1] += self->l_min_M1[ij][cnt1]/2;
            free(self->E_M1[ij][cnt1]);
          }
        if(self->k_min_M1[ij] < INF){
          self->E_M1[ij] += self->k_min_M1[ij];
          free(self->E_M1[ij]);
          self->l_min_M1[ij] += self->k_min_M1[ij];
          self->l_max_M1[ij] += self->k_min_M1[ij];
          free(self->l_min_M1[ij]);
          free(self->l_max_M1[ij]);
        }
      }
    }
    free(self->E_M1);
    free(self->l_min_M1);
    free(self->l_max_M1);
    free(self->k_min_M1);
    free(self->k_max_M1);
  }

  if(self->E_M2 != NULL){
    for(i = 1; i < length-TURN-1; i++){
      if(!self->E_M2[i]) continue;
      for(cnt1 = self->k_min_M2[i]; cnt1 <= self->k_max_M2[i]; cnt1++)
        if(self->l_min_M2[i][cnt1] < INF){
          self->E_M2[i][cnt1] += self->l_min_M2[i][cnt1]/2;
          free(self->E_M2[i][cnt1]);
        }
      if(self->k_min_M2[i] < INF){
        self->E_M2[i] += self->k_min_M2[i];
        free(self->E_M2[i]);
        self->l_min_M2[i] += self->k_min_M2[i];
        self->l_max_M2[i] += self->k_min_M2[i];
        free(self->l_min_M2[i]);
        free(self->l_max_M2[i]);
      }
    }
    free(self->E_M2);
    free(self->l_min_M2);
    free(self->l_max_M2);
    free(self->k_min_M2);
    free(self->k_max_M2);
  }

  if(self->E_Fc != NULL){
    for(cnt1 = self->k_min_Fc; cnt1 <= self->k_max_Fc; cnt1++)
      if(self->l_min_Fc[cnt1] < INF){
        self->E_Fc[cnt1] += self->l_min_Fc[cnt1]/2;
        free(self->E_Fc[cnt1]);
      }
    if(self->k_min_Fc < INF){
      self->E_Fc += self->k_min_Fc;
      free(self->E_Fc);
      self->l_min_Fc += self->k_min_Fc;
      self->l_max_Fc += self->k_min_Fc;
      free(self->l_min_Fc);
      free(self->l_max_Fc);
    }
  }

  if(self->E_FcI != NULL){
    for(cnt1 = self->k_min_FcI; cnt1 <= self->k_max_FcI; cnt1++)
      if(self->l_min_FcI[cnt1] < INF){
        self->E_FcI[cnt1] += self->l_min_FcI[cnt1]/2;
        free(self->E_FcI[cnt1]);
      }
    if(self->k_min_FcI < INF){
      self->E_FcI += self->k_min_FcI;
      free(self->E_FcI);
      self->l_min_FcI += self->k_min_FcI;
      self->l_max_FcI += self->k_min_FcI;
      free(self->l_min_FcI);
      free(self->l_max_FcI);
    }
  }

  if(self->E_FcH != NULL){
    for(cnt1 = self->k_min_FcH; cnt1 <= self->k_max_FcH; cnt1++)
      if(self->l_min_FcH[cnt1] < INF){
        self->E_FcH[cnt1] += self->l_min_FcH[cnt1]/2;
        free(self->E_FcH[cnt1]);
      }
    if(self->k_min_FcH < INF){
      self->E_FcH += self->k_min_FcH;
      free(self->E_FcH);
      self->l_min_FcH += self->k_min_FcH;
      self->l_max_FcH += self->k_min_FcH;
      free(self->l_min_FcH);
      free(self->l_max_FcH);
    }
  }

  if(self->E_FcM != NULL){
    for(cnt1 = self->k_min_FcM; cnt1 <= self->k_max_FcM; cnt1++)
      if(self->l_min_FcM[cnt1] < INF){
        self->E_FcM[cnt1] += self->l_min_FcM[cnt1]/2;
        free(self->E_FcM[cnt1]);
      }
    if(self->k_min_FcM < INF){
      self->E_FcM += self->k_min_FcM;
      free(self->E_FcM);
      self->l_min_FcM += self->k_min_FcM;
      self->l_max_FcM += self->k_min_FcM;
      free(self->l_min_FcM);
      free(self->l_max_FcM);
    }
  }

  free(self->E_F5_rem);
  free(self->E_F3_rem);
  free(self->E_C_rem);
  free(self->E_M_rem);
  free(self->E_M1_rem);
  free(self->E_M2_rem);
}

PRIVATE void
pf_matrices_alloc_default(vrna_mx_pf_t *vars,
                          unsigned int m,
                          unsigned int alloc_vector){

  unsigned int  n, size, lin_size;

  n             = vars->length;
  size          = ((n + 1) * (n + 2)) / 2;
  lin_size      = n + 2;

  vars->q       = NULL;
  vars->qb      = NULL;
  vars->qm      = NULL;
  vars->qm1     = NULL;
  vars->qm2     = NULL;
  vars->probs   = NULL;
  vars->q1k     = NULL;
  vars->qln     = NULL;

  if(alloc_vector & ALLOC_F)
    vars->q     = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL) * size);

  if(alloc_vector & ALLOC_C)
    vars->qb    = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL) * size);

  if(alloc_vector & ALLOC_FML)
    vars->qm    = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL) * size);

  if(alloc_vector & ALLOC_UNIQ)
    vars->qm1   = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL) * size);

  if(alloc_vector & ALLOC_CIRC)
    vars->qm2   = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL) * lin_size);

  if(alloc_vector & ALLOC_PROBS)
    vars->probs = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL) * size);

  if(alloc_vector & ALLOC_AUX){
    vars->q1k   = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL) * lin_size);
    vars->qln   = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL) * lin_size);
  }
}

PRIVATE void
pf_matrices_free_default( vrna_mx_pf_t *self){

  free(self->q);
  free(self->qb);
  free(self->qm);
  free(self->qm1);
  free(self->qm2);
  free(self->probs);
  free(self->G);
  free(self->q1k);
  free(self->qln);
}

PRIVATE void
pf_matrices_alloc_2Dfold( vrna_mx_pf_t *vars,
                          unsigned int m,
                          unsigned int alloc_vector){

  unsigned int  n, size, lin_size;

  n             = vars->length;
  size          = ((n + 1) * (n + 2)) / 2;
  lin_size      = n + 2;

  vars->Q           = NULL;
  vars->l_min_Q     = NULL;
  vars->l_max_Q     = NULL;
  vars->k_min_Q     = NULL;
  vars->k_max_Q     = NULL;
  vars->Q_rem       = NULL;

  vars->Q_B         = NULL;
  vars->l_min_Q_B   = NULL;
  vars->l_max_Q_B   = NULL;
  vars->k_min_Q_B   = NULL;
  vars->k_max_Q_B   = NULL;
  vars->Q_B_rem     = NULL;

  vars->Q_M         = NULL;
  vars->l_min_Q_M   = NULL;
  vars->l_max_Q_M   = NULL;
  vars->k_min_Q_M   = NULL;
  vars->k_max_Q_M   = NULL;
  vars->Q_M_rem     = NULL;

  vars->Q_M1        = NULL;
  vars->l_min_Q_M1  = NULL;
  vars->l_max_Q_M1  = NULL;
  vars->k_min_Q_M1  = NULL;
  vars->k_max_Q_M1  = NULL;
  vars->Q_M1_rem    = NULL;

  vars->Q_M2        = NULL;
  vars->l_min_Q_M2  = NULL;
  vars->l_max_Q_M2  = NULL;
  vars->k_min_Q_M2  = NULL;
  vars->k_max_Q_M2  = NULL;
  vars->Q_M2_rem    = NULL;

  vars->Q_c         = NULL;
  vars->Q_cH        = NULL;
  vars->Q_cI        = NULL;
  vars->Q_cM        = NULL;
  vars->Q_c_rem     = 0.;
  vars->Q_cH_rem    = 0.;
  vars->Q_cI_rem    = 0.;
  vars->Q_cM_rem    = 0.;

  if(alloc_vector & ALLOC_F){
    vars->Q       = (FLT_OR_DBL ***)vrna_alloc(sizeof(FLT_OR_DBL **)  * size);
    vars->l_min_Q = (int **)        vrna_alloc(sizeof(int *)          * size);
    vars->l_max_Q = (int **)        vrna_alloc(sizeof(int *)          * size);
    vars->k_min_Q = (int *)         vrna_alloc(sizeof(int)            * size);
    vars->k_max_Q = (int *)         vrna_alloc(sizeof(int)            * size);
    vars->Q_rem   = (FLT_OR_DBL *)  vrna_alloc(sizeof(FLT_OR_DBL)     * size);
  }

  if(alloc_vector & ALLOC_C){
    vars->Q_B       = (FLT_OR_DBL ***)vrna_alloc(sizeof(FLT_OR_DBL **)  * size);
    vars->l_min_Q_B = (int **)        vrna_alloc(sizeof(int *)          * size);
    vars->l_max_Q_B = (int **)        vrna_alloc(sizeof(int *)          * size);
    vars->k_min_Q_B = (int *)         vrna_alloc(sizeof(int)            * size);
    vars->k_max_Q_B = (int *)         vrna_alloc(sizeof(int)            * size);
    vars->Q_B_rem   = (FLT_OR_DBL *)  vrna_alloc(sizeof(FLT_OR_DBL)     * size);
  }

  if(alloc_vector & ALLOC_FML){
    vars->Q_M       = (FLT_OR_DBL ***)vrna_alloc(sizeof(FLT_OR_DBL **)  * size);
    vars->l_min_Q_M = (int **)        vrna_alloc(sizeof(int *)          * size);
    vars->l_max_Q_M = (int **)        vrna_alloc(sizeof(int *)          * size);
    vars->k_min_Q_M = (int *)         vrna_alloc(sizeof(int)            * size);
    vars->k_max_Q_M = (int *)         vrna_alloc(sizeof(int)            * size);
    vars->Q_M_rem   = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)      * size);
  }

  if(alloc_vector & ALLOC_UNIQ){
    vars->Q_M1        = (FLT_OR_DBL ***)vrna_alloc(sizeof(FLT_OR_DBL **)  * size);
    vars->l_min_Q_M1  = (int **)        vrna_alloc(sizeof(int *)          * size);
    vars->l_max_Q_M1  = (int **)        vrna_alloc(sizeof(int *)          * size);
    vars->k_min_Q_M1  = (int *)         vrna_alloc(sizeof(int)            * size);
    vars->k_max_Q_M1  = (int *)         vrna_alloc(sizeof(int)            * size);
    vars->Q_M1_rem    = (FLT_OR_DBL *)  vrna_alloc(sizeof(FLT_OR_DBL)     * size);
  }

  if(alloc_vector & ALLOC_CIRC){
    vars->Q_M2        = (FLT_OR_DBL ***)vrna_alloc(sizeof(FLT_OR_DBL **)  * lin_size);
    vars->l_min_Q_M2  = (int **)        vrna_alloc(sizeof(int *)          * lin_size);
    vars->l_max_Q_M2  = (int **)        vrna_alloc(sizeof(int *)          * lin_size);
    vars->k_min_Q_M2  = (int *)         vrna_alloc(sizeof(int)            * lin_size);
    vars->k_max_Q_M2  = (int *)         vrna_alloc(sizeof(int)            * lin_size);
    vars->Q_M2_rem    = (FLT_OR_DBL *)  vrna_alloc(sizeof(FLT_OR_DBL)     * lin_size);
  }
}

PRIVATE void
pf_matrices_free_2Dfold(vrna_mx_pf_t *self,
                        unsigned int length,
                        int *indx,
                        int *jindx){

  unsigned int  i, j, ij;
  int           cnt1;

  /* This will be some fun... */
  if(self->Q != NULL){
    for(i = 1; i <= length; i++){
      for(j = i; j <= length; j++){
        ij = indx[i] - j;
        if(!self->Q[ij]) continue;
        for(cnt1 = self->k_min_Q[ij]; cnt1 <= self->k_max_Q[ij]; cnt1++)
          if(self->l_min_Q[ij][cnt1] < INF){
            self->Q[ij][cnt1] += self->l_min_Q[ij][cnt1]/2;
            free(self->Q[ij][cnt1]);
          }
        if(self->k_min_Q[ij] < INF){
          self->Q[ij] += self->k_min_Q[ij];
          free(self->Q[ij]);
          self->l_min_Q[ij] += self->k_min_Q[ij];
          self->l_max_Q[ij] += self->k_min_Q[ij];
          free(self->l_min_Q[ij]);
          free(self->l_max_Q[ij]);
        }
      }
    }
  }
  free(self->Q);
  free(self->l_min_Q);
  free(self->l_max_Q);
  free(self->k_min_Q);
  free(self->k_max_Q);

  if(self->Q_B != NULL){
    for(i = 1; i < length; i++){
      for(j = i; j <= length; j++){
        ij = indx[i] - j;
        if(!self->Q_B[ij]) continue;
        for(cnt1 = self->k_min_Q_B[ij]; cnt1 <= self->k_max_Q_B[ij]; cnt1++)
          if(self->l_min_Q_B[ij][cnt1] < INF){
            self->Q_B[ij][cnt1] += self->l_min_Q_B[ij][cnt1]/2;
            free(self->Q_B[ij][cnt1]);
          }
        if(self->k_min_Q_B[ij] < INF){
          self->Q_B[ij] += self->k_min_Q_B[ij];
          free(self->Q_B[ij]);
          self->l_min_Q_B[ij] += self->k_min_Q_B[ij];
          self->l_max_Q_B[ij] += self->k_min_Q_B[ij];
          free(self->l_min_Q_B[ij]);
          free(self->l_max_Q_B[ij]);
        }
      }
    }
  }
  free(self->Q_B);
  free(self->l_min_Q_B);
  free(self->l_max_Q_B);
  free(self->k_min_Q_B);
  free(self->k_max_Q_B);

  if(self->Q_M != NULL){
    for(i = 1; i < length; i++){
      for(j = i; j <= length; j++){
        ij = indx[i] - j;
        if(!self->Q_M[ij]) continue;
        for(cnt1 = self->k_min_Q_M[ij]; cnt1 <= self->k_max_Q_M[ij]; cnt1++)
          if(self->l_min_Q_M[ij][cnt1] < INF){
            self->Q_M[ij][cnt1] += self->l_min_Q_M[ij][cnt1]/2;
            free(self->Q_M[ij][cnt1]);
          }
        if(self->k_min_Q_M[ij] < INF){
          self->Q_M[ij] += self->k_min_Q_M[ij];
          free(self->Q_M[ij]);
          self->l_min_Q_M[ij] += self->k_min_Q_M[ij];
          self->l_max_Q_M[ij] += self->k_min_Q_M[ij];
          free(self->l_min_Q_M[ij]);
          free(self->l_max_Q_M[ij]);
        }
      }
    }
  }
  free(self->Q_M);
  free(self->l_min_Q_M);
  free(self->l_max_Q_M);
  free(self->k_min_Q_M);
  free(self->k_max_Q_M);

  if(self->Q_M1 != NULL){
    for(i = 1; i < length; i++){
      for(j = i; j <= length; j++){
        ij = jindx[j] + i;
        if(!self->Q_M1[ij]) continue;
        for(cnt1 = self->k_min_Q_M1[ij]; cnt1 <= self->k_max_Q_M1[ij]; cnt1++)
          if(self->l_min_Q_M1[ij][cnt1] < INF){
            self->Q_M1[ij][cnt1] += self->l_min_Q_M1[ij][cnt1]/2;
            free(self->Q_M1[ij][cnt1]);
          }
        if(self->k_min_Q_M1[ij] < INF){
          self->Q_M1[ij] += self->k_min_Q_M1[ij];
          free(self->Q_M1[ij]);
          self->l_min_Q_M1[ij] += self->k_min_Q_M1[ij];
          self->l_max_Q_M1[ij] += self->k_min_Q_M1[ij];
          free(self->l_min_Q_M1[ij]);
          free(self->l_max_Q_M1[ij]);
        }
      }
    }
  }
  free(self->Q_M1);
  free(self->l_min_Q_M1);
  free(self->l_max_Q_M1);
  free(self->k_min_Q_M1);
  free(self->k_max_Q_M1);

  if(self->Q_M2 != NULL){
    for(i = 1; i < length-TURN-1; i++){
      if(!self->Q_M2[i]) continue;
      for(cnt1 = self->k_min_Q_M2[i]; cnt1 <= self->k_max_Q_M2[i]; cnt1++)
        if(self->l_min_Q_M2[i][cnt1] < INF){
          self->Q_M2[i][cnt1] += self->l_min_Q_M2[i][cnt1]/2;
          free(self->Q_M2[i][cnt1]);
        }
      if(self->k_min_Q_M2[i] < INF){
        self->Q_M2[i] += self->k_min_Q_M2[i];
        free(self->Q_M2[i]);
        self->l_min_Q_M2[i] += self->k_min_Q_M2[i];
        self->l_max_Q_M2[i] += self->k_min_Q_M2[i];
        free(self->l_min_Q_M2[i]);
        free(self->l_max_Q_M2[i]);
      }
    }
  }
  free(self->Q_M2);
  free(self->l_min_Q_M2);
  free(self->l_max_Q_M2);
  free(self->k_min_Q_M2);
  free(self->k_max_Q_M2);

  if(self->Q_c != NULL){
    for(cnt1 = self->k_min_Q_c; cnt1 <= self->k_max_Q_c; cnt1++)
      if(self->l_min_Q_c[cnt1] < INF){
        self->Q_c[cnt1] += self->l_min_Q_c[cnt1]/2;
        free(self->Q_c[cnt1]);
      }
    if(self->k_min_Q_c < INF){
      self->Q_c += self->k_min_Q_c;
      free(self->Q_c);
      self->l_min_Q_c += self->k_min_Q_c;
      self->l_max_Q_c += self->k_min_Q_c;
      free(self->l_min_Q_c);
      free(self->l_max_Q_c);
    }
  }

  if(self->Q_cI != NULL){
    for(cnt1 = self->k_min_Q_cI; cnt1 <= self->k_max_Q_cI; cnt1++)
      if(self->l_min_Q_cI[cnt1] < INF){
        self->Q_cI[cnt1] += self->l_min_Q_cI[cnt1]/2;
        free(self->Q_cI[cnt1]);
      }
    if(self->k_min_Q_cI < INF){
      self->Q_cI += self->k_min_Q_cI;
      free(self->Q_cI);
      self->l_min_Q_cI += self->k_min_Q_cI;
      self->l_max_Q_cI += self->k_min_Q_cI;
      free(self->l_min_Q_cI);
      free(self->l_max_Q_cI);
    }
  }

  if(self->Q_cH != NULL){
    for(cnt1 = self->k_min_Q_cH; cnt1 <= self->k_max_Q_cH; cnt1++)
      if(self->l_min_Q_cH[cnt1] < INF){
        self->Q_cH[cnt1] += self->l_min_Q_cH[cnt1]/2;
        free(self->Q_cH[cnt1]);
      }
    if(self->k_min_Q_cH < INF){
      self->Q_cH += self->k_min_Q_cH;
      free(self->Q_cH);
      self->l_min_Q_cH += self->k_min_Q_cH;
      self->l_max_Q_cH += self->k_min_Q_cH;
      free(self->l_min_Q_cH);
      free(self->l_max_Q_cH);
    }
  }

  if(self->Q_cM != NULL){
    for(cnt1 = self->k_min_Q_cM; cnt1 <= self->k_max_Q_cM; cnt1++)
      if(self->l_min_Q_cM[cnt1] < INF){
        self->Q_cM[cnt1] += self->l_min_Q_cM[cnt1]/2;
        free(self->Q_cM[cnt1]);
      }
    if(self->k_min_Q_cM < INF){
      self->Q_cM += self->k_min_Q_cM;
      free(self->Q_cM);
      self->l_min_Q_cM += self->k_min_Q_cM;
      self->l_max_Q_cM += self->k_min_Q_cM;
      free(self->l_min_Q_cM);
      free(self->l_max_Q_cM);
    }
  }

  free(self->Q_rem);
  free(self->Q_B_rem);
  free(self->Q_M_rem);
  free(self->Q_M1_rem);
  free(self->Q_M2_rem);
}

/102            0           0     0     644     35265     `

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>

#include "fold_vars.h"
#include "energy_par.h"
#include "utils.h"
#include "constraints.h"
#include "gquad.h"
#include "exterior_loops.h"

#ifdef __GNUC__
# define INLINE inline
#else
# define INLINE
#endif

#ifdef ON_SAME_STRAND
#undef ON_SAME_STRAND
#endif

#define ON_SAME_STRAND(I,J,C)  (((I)>=(C))||((J)<(C)))

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PUBLIC int
E_ext_loop( int i,
            int j,
            vrna_fold_compound_t *vc){

  char          eval_loop, *ptype, *hard_constraints;
  short         *S;
  int           ij, en, e, type, cp, *idx;
  vrna_param_t  *P;
  vrna_md_t     *md;
  vrna_sc_t     *sc;
#ifdef WITH_GEN_HC
  vrna_callback_hc_evaluate *f;
#endif

  cp                = vc->cutpoint;
  S                 = vc->sequence_encoding;
  idx               = vc->jindx;
  ptype             = vc->ptype;
  P                 = vc->params;
  md                = &(P->model_details);
  hard_constraints  = vc->hc->matrix;
  sc                = vc->sc;

#ifdef WITH_GEN_HC
  f = vc->hc->f;
#endif

  e     = INF;
  ij    = idx[j] + i;
  type  = ptype[ij];

  if((cp < 0) || (((i)>=cp)||((j)<cp))){ /* regular exterior loop */
    eval_loop = hard_constraints[ij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP;
#ifdef WITH_GEN_HC
    if(f)
      eval_loop = (f(i, j, i, j, VRNA_DECOMP_EXT_STEM, vc->hc->data)) ? eval_loop : (char)0;
#endif
    if(eval_loop){

      if(type == 0)
        type = 7;

      switch(md->dangles){
        case 2:   e = E_ExtLoop(type, S[i-1], S[j+1], P);
                  break;
        case 0:   /* fall through */
        default:  e = E_ExtLoop(type, -1, -1, P);
                  break;
      }
      if(sc){
        if(sc->f)
          e += sc->f(i, j, i, j, VRNA_DECOMP_EXT_STEM, sc->data);
      }
    }

    if(md->dangles % 2){
      ij = idx[j - 1] + i;
      eval_loop = hard_constraints[ij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP;
#ifdef WITH_GEN_HC
      if(f)
        eval_loop = (f(i, j, i, j - 1, VRNA_DECOMP_EXT_STEM, vc->hc->data)) ? eval_loop : (char)0;
#endif
      if(eval_loop){
        type = vc->ptype[ij];

        if(type == 0)
          type = 7;

        en = E_ExtLoop(type, -1, S[j], P);
        if(sc){
          if(sc->f)
            en += sc->f(i, j, i, j - 1, VRNA_DECOMP_EXT_STEM, sc->data);
        }
        e = MIN2(e, en);
      }

      ij = idx[j] + i + 1;
      eval_loop = hard_constraints[ij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP;
#ifdef WITH_GEN_HC
      if(f)
        eval_loop = (f(i, j, i+1, j, VRNA_DECOMP_EXT_STEM, vc->hc->data)) ? eval_loop : (char)0;
#endif
      if(eval_loop){
        type = vc->ptype[ij];

        if(type == 0)
          type = 7;

        en = E_ExtLoop(type, S[i], -1, P);
        if(sc){
          if(sc->f)
            en += sc->f(i, j, i + 1, j, VRNA_DECOMP_EXT_STEM, sc->data);
        }
        e = MIN2(e, en);
      }
    }
  }

  return e;
}


PUBLIC void
E_ext_loop_5( vrna_fold_compound_t *vc){

  char          eval_loop, el, *ptype, *hc;
  short         *S;
  int           en, i, j, ij, type, length, *indx, *hc_up, *f5, *c, dangle_model,
                *ggg, with_gquad, turn;
  vrna_sc_t     *sc;
  vrna_param_t  *P;
#ifdef WITH_GEN_HC
  vrna_callback_hc_evaluate *f;
#endif

  length        = (int)vc->length;
  ptype         = vc->ptype;
  S             = vc->sequence_encoding;
  indx          = vc->jindx;
  hc            = vc->hc->matrix;
  hc_up         = vc->hc->up_ext;
  sc            = vc->sc;
  f5            = vc->matrices->f5;
  c             = vc->matrices->c;
  P             = vc->params;
  dangle_model  = P->model_details.dangles;
  ggg           = vc->matrices->ggg;
  with_gquad    = P->model_details.gquad;
  turn          = P->model_details.min_loop_size;

#ifdef WITH_GEN_HC
  f = vc->hc->f;
#endif

  f5[0] = 0;
  for(i = 1; i <= turn + 1; i++){
    if(f5[i-1] != INF){
      eval_loop = (hc_up[i] > 0) ? (char)1 : (char)0;
#ifdef WITH_GEN_HC
      if(f)
        eval_loop = (f(1, i, 1, i - 1, VRNA_DECOMP_EXT_EXT, vc->hc->data)) ? eval_loop : (char)0;
#endif
      if(eval_loop){
        f5[i] = f5[i-1];
        if(sc){
          if(sc->energy_up)
            f5[i] += sc->energy_up[i][1];
          if(sc->f)
            f5[i] += sc->f(1, i, 1, i - 1, VRNA_DECOMP_EXT_EXT, sc->data);
        }
      } else {
        f5[i] = INF;
      }
    } else {
      f5[i] = INF;
    }
  }

  /* duplicated code may be faster than conditions inside loop ;) */
  switch(dangle_model){
    /* dont use dangling end and mismatch contributions at all */
    case 0:   for(j=turn+2; j<=length; j++){
                /* initialize with INF */
                f5[j] = INF;

                /* check for 3' extension with one unpaired nucleotide */
                if(f5[j-1] != INF){
                  eval_loop = (hc_up[j] > 0) ? (char)1 : (char)0;
#ifdef WITH_GEN_HC
                  if(f)
                    eval_loop = (f(1, j, 1, j-1, VRNA_DECOMP_EXT_EXT, vc->hc->data)) ? eval_loop : (char)0;
#endif
                  if(eval_loop){
                    f5[j] = f5[j-1];
                    if(sc){
                      if(sc->energy_up)
                        f5[j] += sc->energy_up[j][1];
                      if(sc->f)
                        f5[j] += sc->f(1, j, i, j - 1, VRNA_DECOMP_EXT_EXT, sc->data);
                    }
                  }
                }

                /* check for possible stems branching off the exterior loop */
                if(sc && sc->f){
                  for (i=j-turn-1; i>1; i--){



                    if(f5[i-1] != INF){

                      ij = indx[j]+i;
                      //if (matrices->evaluated[ij]) continue;


                      if(with_gquad){
                        f5[j] = MIN2(f5[j], f5[i-1] + ggg[ij]);
                      }

                      if(c[ij] != INF){
                        eval_loop = hc[ij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP;
#ifdef WITH_GEN_HC
                        if(f)
                          eval_loop = (f(1, j, i-1, i, VRNA_DECOMP_EXT_EXT_STEM, vc->hc->data)) ? eval_loop : (char)0;
#endif
                        if(eval_loop){
                          type = ptype[ij];

                          if(type == 0)
                            type = 7;

                          en  = f5[i-1] + c[ij] + E_ExtLoop(type, -1, -1, P);
                          en += sc->f(1, j, i - 1, i, VRNA_DECOMP_EXT_EXT_STEM, sc->data);
                          f5[j] = MIN2(f5[j], en);
                        }
                      }
                    }
                  }
                } else {
                  for (i=j-turn-1; i>1; i--){
                    if(f5[i-1] != INF){

                      ij = indx[j]+i;
                      //if (matrices->evaluated[ij]) continue;

                      if(with_gquad){
                        f5[j] = MIN2(f5[j], f5[i-1] + ggg[ij]);
                      }

                      if(c[ij] != INF){
                        eval_loop = hc[ij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP;
#ifdef WITH_GEN_HC
                        if(f)
                          eval_loop = (f(1, j, i-1, i, VRNA_DECOMP_EXT_EXT_STEM, vc->hc->data)) ? eval_loop : (char)0;
#endif
                        if(eval_loop){
                          type = ptype[ij];

                          if(type == 0)
                            type = 7;

                          en    = f5[i-1] + c[ij] + E_ExtLoop(type, -1, -1, P);
                          f5[j] = MIN2(f5[j], en);
                        }
                      }
                    }
                  }
                }
                ij = indx[j] + 1;
                //if (matrices->evaluated[ij]) continue;
              	//matrices->evaluated[ij] = 1;

                if(with_gquad){
                  f5[j] = MIN2(f5[j], ggg[ij]);
                }

                if(c[ij] != INF){
                  eval_loop = hc[ij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP;
#ifdef WITH_GEN_HC
                  if(f)
                    eval_loop = (f(1, j, 1, j, VRNA_DECOMP_EXT_STEM, vc->hc->data)) ? eval_loop : (char)0;
#endif
                  if(eval_loop){
                    type = ptype[ij];

                    if(type == 0)
                      type = 7;

                    en    = c[ij] + E_ExtLoop(type, -1, -1, P);
                    if(sc){
                      if(sc->f)
                        en += sc->f(1, j, 1, j, VRNA_DECOMP_EXT_STEM, sc->data);
                    }
                    f5[j] = MIN2(f5[j], en);
                  }
                }
              }
              break;

    /* always use dangles on both sides */
    case 2:   for(j=turn+2; j<length; j++){
                f5[j] = INF;

                if(f5[j-1] != INF){
                  eval_loop = (hc_up[j] > 0) ? (char)1 : (char)0;
#ifdef WITH_GEN_HC
                  if(f)
                    eval_loop = (f(1, j, 1, j-1, VRNA_DECOMP_EXT_EXT, vc->hc->data)) ? eval_loop : (char)0;
#endif
                  if(eval_loop){
                    f5[j] = f5[j-1];
                    if(sc){
                      if(sc->energy_up)
                        f5[j] += sc->energy_up[j][1];
                      if(sc->f)
                        f5[j] += sc->f(1, j, 1, j - 1, VRNA_DECOMP_EXT_EXT, sc->data);
                    }
                  }
                }
                if(sc && sc->f){
                  for (i=j-turn-1; i>1; i--){
                    if(f5[i-1] != INF){
                      ij = indx[j] + i;

                      if(with_gquad){
                        f5[j] = MIN2(f5[j], f5[i-1] + ggg[ij]);
                      }

                      if(c[ij] != INF){
                        eval_loop = hc[ij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP;
#ifdef WITH_GEN_HC
                        if(f)
                          eval_loop = (f(1, j, i-1, i, VRNA_DECOMP_EXT_EXT_STEM, vc->hc->data)) ? eval_loop : (char)0;
#endif
                        if(eval_loop){
                          type = ptype[ij];

                          if(type == 0)
                            type = 7;

                          en    = f5[i-1] + c[ij] + E_ExtLoop(type, S[i-1], S[j+1], P);
                          en   += sc->f(1, j, i - 1, i, VRNA_DECOMP_EXT_EXT_STEM, sc->data);
                          f5[j] = MIN2(f5[j], en);
                        }
                      }
                    }
                  }
                } else {
                  for (i=j-turn-1; i>1; i--){
                    if(f5[i-1] != INF){
                      ij = indx[j] + i;

                      if(with_gquad){
                        f5[j] = MIN2(f5[j], f5[i-1] + ggg[ij]);
                      }

                      if(c[ij] != INF){
                        eval_loop = hc[ij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP;
#ifdef WITH_GEN_HC
                        if(f)
                          eval_loop = (f(1, j, i-1, i, VRNA_DECOMP_EXT_EXT_STEM, vc->hc->data)) ? eval_loop : (char)0;
#endif
                        if(eval_loop){
                          type = ptype[ij];

                          if(type == 0)
                            type = 7;

                          en    = f5[i-1] + c[ij] + E_ExtLoop(type, S[i-1], S[j+1], P);
                          f5[j] = MIN2(f5[j], en);
                        }
                      }
                    }
                  }
                }
                ij = indx[j] + 1;

                if(with_gquad){
                  f5[j] = MIN2(f5[j], ggg[ij]);
                }

                if(c[ij] != INF){
                  eval_loop = hc[ij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP;
#ifdef WITH_GEN_HC
                  if(f)
                    eval_loop = (f(1, j, 1, j, VRNA_DECOMP_EXT_STEM, vc->hc->data)) ? eval_loop : (char)0;
#endif
                  if(eval_loop){
                    type = ptype[ij];

                    if(type == 0)
                      type = 7;

                    en    = c[ij] + E_ExtLoop(type, -1, S[j+1], P);
                    if(sc){
                      if(sc->f)
                        en += sc->f(1, j, 1, j, VRNA_DECOMP_EXT_STEM, sc->data);
                    }
                    f5[j] = MIN2(f5[j], en);
                  }
                }
              }

              f5[length] = INF;
              if(f5[length-1] != INF){
                eval_loop = (hc_up[length] > 0) ? (char)1 : (char)0;
#ifdef WITH_GEN_HC
                if(f)
                  eval_loop = (f(1, length, 1, length-1, VRNA_DECOMP_EXT_EXT, vc->hc->data)) ? eval_loop : (char)0;
#endif
                if(eval_loop){
                  f5[length] = f5[length-1];
                  if(sc){
                    if(sc->energy_up)
                      f5[length] += sc->energy_up[length][1];
                    if(sc->f)
                      f5[length] += sc->f(1, length, 1, length - 1, VRNA_DECOMP_EXT_EXT, sc->data);
                  }
                }
              }
              if(sc && sc->f){

                for (i=length-turn-1; i>1; i--){
                  if(f5[i-1] != INF){
                    ij = indx[length] + i;

                    if(with_gquad){
                      f5[length] = MIN2(f5[length], f5[i-1] + ggg[ij]);
                    }

                    if(c[ij] != INF){
                      eval_loop = hc[ij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP;
#ifdef WITH_GEN_HC
                      if(f)
                        eval_loop = (f(1, length, i-1, i, VRNA_DECOMP_EXT_EXT_STEM, vc->hc->data)) ? eval_loop : (char)0;
#endif
                      if(eval_loop){
                        type = ptype[ij];

                        if(type == 0)
                          type = 7;

                        en          = f5[i-1] + c[ij] + E_ExtLoop(type, S[i-1], -1, P);
                        en         += sc->f(1, length, i - 1, i, VRNA_DECOMP_EXT_EXT_STEM, sc->data);
                        f5[length]  = MIN2(f5[length], en);
                      }
                    }
                  }
                }
              } else {
                for (i=length-turn-1; i>1; i--){
                  if(f5[i-1] != INF){
                    ij = indx[length] + i;

                    if(with_gquad){
                      f5[length] = MIN2(f5[length], f5[i-1] + ggg[ij]);
                    }

                    if(c[ij] != INF){
                      eval_loop = hc[ij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP;
#ifdef WITH_GEN_HC
                      if(f)
                        eval_loop = (f(1, length, i-1, i, VRNA_DECOMP_EXT_EXT_STEM, vc->hc->data)) ? eval_loop : (char)0;
#endif
                      if(eval_loop){
                        type = ptype[ij];

                        if(type == 0)
                          type = 7;

                        en          = f5[i-1] + c[ij] + E_ExtLoop(type, S[i-1], -1, P);
                        f5[length]  = MIN2(f5[length], en);
                      }
                    }
                  }
                }
              }
              ij = indx[length] + 1;

              if(with_gquad){
                f5[length] = MIN2(f5[length], ggg[ij]);
              }

              if(c[ij] != INF){
                eval_loop = hc[ij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP;
#ifdef WITH_GEN_HC
                if(f)
                  eval_loop = (f(1, length, 1, length, VRNA_DECOMP_EXT_STEM, vc->hc->data)) ? eval_loop : (char)0;
#endif
                if(eval_loop){
                  type = ptype[ij];

                  if(type == 0)
                    type = 7;

                  en          = c[ij] + E_ExtLoop(type, -1, -1, P);
                  if(sc){
                    if(sc->f)
                      en += sc->f(1, length, 1, length, VRNA_DECOMP_EXT_STEM, sc->data);
                  }
                  f5[length]  = MIN2(f5[length], en);
                }
              }
              break;

    /* normal dangles, aka dangle_model = 1 || 3 */
    default:  for(j=turn+2; j<=length; j++){
                f5[j] = INF;
                if(f5[j-1] != INF){
                  eval_loop = (hc_up[j] > 0) ? (char)1 : (char)0;
#ifdef WITH_GEN_HC
                  if(f)
                    eval_loop = (f(1, j, 1, j-1, VRNA_DECOMP_EXT_EXT, vc->hc->data)) ? eval_loop : (char)0;
#endif
                  if(eval_loop){
                    f5[j] = f5[j-1];
                    if(sc){
                      if(sc->energy_up)
                        f5[j] += sc->energy_up[j][1];
                      if(sc->f)
                        f5[j] += sc->f(1, j, 1, j - 1, VRNA_DECOMP_EXT_EXT, sc->data);
                    }
                  }
                }

                for (i=j-turn-1; i>1; i--){
                  ij = indx[j] + i;
                  if(f5[i-1] != INF){

                    if(with_gquad){
                      f5[j] = MIN2(f5[j], f5[i-1] + ggg[ij]);
                    }

                    if(c[ij] != INF){
                      eval_loop = hc[ij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP;
#ifdef WITH_GEN_HC
                      if(f)
                        eval_loop = (f(1, j, i - 1, i, VRNA_DECOMP_EXT_EXT_STEM, vc->hc->data)) ? eval_loop : (char)0;
#endif
                      if(eval_loop){
                        type = ptype[ij];

                        if(type == 0)
                          type = 7;

                        en    = f5[i-1] + c[ij] + E_ExtLoop(type, -1, -1, P);
                        if(sc){
                          if(sc->f)
                            en += sc->f(1, j, i - 1, i, VRNA_DECOMP_EXT_EXT_STEM, sc->data);
                        }
                        f5[j] = MIN2(f5[j], en);
                      }
                    }
                  }

                  if((f5[i-2] != INF) && c[ij] != INF){
                    eval_loop = hc[ij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP;
                    eval_loop = (hc_up[i-1] > 0) ? eval_loop : (char)0;
#ifdef WITH_GEN_HC
                    if(f)
                      eval_loop = (f(1, j, i-2, i, VRNA_DECOMP_EXT_EXT_STEM, vc->hc->data)) ? eval_loop : (char)0;
#endif
                    if(eval_loop){
                      type = ptype[ij];

                      if(type == 0)
                        type = 7;

                      en    = f5[i-2] + c[ij] + E_ExtLoop(type, S[i-1], -1, P);

                      if(sc){
                        if(sc->energy_up)
                          en += sc->energy_up[i-1][1];
                        if(sc->f)
                          en += sc->f(1, j, i - 2, i, VRNA_DECOMP_EXT_EXT_STEM, sc->data);
                      }
                      f5[j] = MIN2(f5[j], en);
                    }
                  }

                  ij = indx[j-1] + i;
                  if(c[ij] != INF){
                    if(f5[i - 1] != INF){
                      eval_loop = hc[ij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP;
                      eval_loop = (hc_up[j] > 0) ? eval_loop : (char)0;
#ifdef WITH_GEN_HC
                      if(f)
                        eval_loop = (f(1, j, i-1, i, VRNA_DECOMP_EXT_EXT_STEM1, vc->hc->data)) ? eval_loop : (char)0;
#endif
                      if(eval_loop){
                        type = ptype[ij];

                        if(type == 0)
                          type = 7;

                        en    = f5[i-1] + c[ij] + E_ExtLoop(type, -1, S[j], P);

                        if(sc){
                          if(sc->energy_up)
                            en += sc->energy_up[j][1];
                          if(sc->f)
                            en += sc->f(1, j, i - 1, i, VRNA_DECOMP_EXT_EXT_STEM1, sc->data);
                        }
                        f5[j] = MIN2(f5[j], en);
                      }
                    }

                    if(f5[i - 2] != INF){
                      el = hc[ij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP;
                      el = (hc_up[i-1] > 0) ? el : (char)0;
#ifdef WITH_GEN_HC
                      if(f)
                        el = (f(1, j, i-2, i, VRNA_DECOMP_EXT_EXT_STEM1, vc->hc->data)) ? el : (char)0;
#endif
                      if(el){
                        type = ptype[ij];

                        if(type == 0)
                          type = 7;

                        en    = f5[i-2] + c[ij] + E_ExtLoop(type, S[i-1], S[j], P);

                        if(sc){
                          if(sc->energy_up)
                            en += sc->energy_up[i-1][1] + sc->energy_up[j][1];
                          if(sc->f)
                            en += sc->f(1, j, i - 2, i, VRNA_DECOMP_EXT_EXT_STEM1, sc->data);
                        }
                        f5[j] = MIN2(f5[j], en);
                      }
                    }
                  }
                }

                ij = indx[j] + 1;

                if(with_gquad){
                  f5[j] = MIN2(f5[j], ggg[ij]);
                }

                if(c[ij] != INF){

                  eval_loop = hc[ij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP;
#ifdef WITH_GEN_HC
                  if(f)
                    eval_loop = (f(1, j, 1, j, VRNA_DECOMP_EXT_STEM, vc->hc->data)) ? eval_loop : (char)0;
#endif
                  if(eval_loop){
                    type = ptype[ij];

                    if(type == 0)
                      type = 7;

                    en    = c[ij] + E_ExtLoop(type, -1, -1, P);
                    if(sc){
                      if(sc->f)
                        en += sc->f(1, j, 1, j, VRNA_DECOMP_EXT_STEM, sc->data);
                    }
                    f5[j] = MIN2(f5[j], en);
                  }
                }
                ij = indx[j-1] + 1;
                if(c[ij] != INF){
                  eval_loop = hc[ij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP;
                  eval_loop = (hc_up[j] > 0) ? eval_loop : (char)0;
#ifdef WITH_GEN_HC
                  if(f)
                    eval_loop = (f(1, j, 1, j-1, VRNA_DECOMP_EXT_STEM, vc->hc->data)) ? eval_loop : (char)0;
#endif
                  if(eval_loop){
                    type = ptype[ij];

                    if(type == 0)
                      type = 7;

                    en    = c[ij] + E_ExtLoop(type, -1, S[j], P);

                    if(sc){
                      if(sc->energy_up)
                        en += sc->energy_up[j][1];
                      if(sc->f)
                        en += sc->f(1, j, 1, j - 1, VRNA_DECOMP_EXT_STEM, sc->data);
                    }
                    f5[j] = MIN2(f5[j], en);
                  }
                }
              }
  }
}

PUBLIC int
E_Stem( int type,
        int si1,
        int sj1,
        int extLoop,
        vrna_param_t *P){

  int energy = 0;
  int d5 = (si1 >= 0) ? P->dangle5[type][si1] : 0;
  int d3 = (sj1 >= 0) ? P->dangle3[type][sj1] : 0;

  if(type > 2)
    energy += P->TerminalAU;

  if(si1 >= 0 && sj1 >= 0)
    energy += (extLoop) ? P->mismatchExt[type][si1][sj1] : P->mismatchM[type][si1][sj1];
  else
    energy += d5 + d3;

  if(!extLoop) energy += P->MLintern[type];
  return energy;
}

PUBLIC int
E_ExtLoop(int type,
          int si1,
          int sj1,
          vrna_param_t *P){

  int energy = 0;

  if(si1 >= 0 && sj1 >= 0){
    energy += P->mismatchExt[type][si1][sj1];
  }
  else if (si1 >= 0){
    energy += P->dangle5[type][si1];
  }
  else if (sj1 >= 0){
    energy += P->dangle3[type][sj1];
  }

  if(type > 2)
    energy += P->TerminalAU;

  return energy;
}

PUBLIC FLT_OR_DBL
exp_E_Stem( int type,
            int si1,
            int sj1,
            int extLoop,
            vrna_exp_param_t *P){

  double energy = 1.0;
  double d5 = (si1 >= 0) ? P->expdangle5[type][si1] : 1.;
  double d3 = (sj1 >= 0) ? P->expdangle3[type][sj1] : 1.;

  if(si1 >= 0 && sj1 >= 0)
    energy = (extLoop) ? P->expmismatchExt[type][si1][sj1] : P->expmismatchM[type][si1][sj1];
  else
    energy = d5 * d3;

  if(type > 2)
    energy *= P->expTermAU;

  if(!extLoop) energy *= P->expMLintern[type];
  return (FLT_OR_DBL)energy;
}

PUBLIC FLT_OR_DBL
exp_E_ExtLoop(int type,
              int si1,
              int sj1,
              vrna_exp_param_t *P){

  double energy = 1.0;

  if(si1 >= 0 && sj1 >= 0){
    energy = P->expmismatchExt[type][si1][sj1];
  }
  else if(si1 >= 0){
    energy = P->expdangle5[type][si1];
  }
  else if(sj1 >= 0){
    energy = P->expdangle3[type][sj1];
  }

  if(type > 2)
    energy *= P->expTermAU;

  return (FLT_OR_DBL)energy;
}

PUBLIC int
vrna_BT_ext_loop_f5(vrna_fold_compound_t *vc,
                    int *k,
                    int *i,
                    int *j,
                    vrna_bp_stack_t *bp_stack,
                    int *stack_count){

  unsigned char type;
  char          *ptype;
  short         mm5, mm3, *S1;
  int           length, cp, fij, fi, jj, u, en, e, *my_f5, *my_c, *my_ggg, *idx,
                dangle_model, turn, with_gquad;
  vrna_param_t  *P;
  vrna_md_t     *md;
  vrna_hc_t     *hc;
  vrna_sc_t     *sc;

  length        = vc->length;
  cp            = vc->cutpoint;
  P             = vc->params;
  md            = &(P->model_details);
  hc            = vc->hc;
  sc            = vc->sc;
  my_f5         = vc->matrices->f5;
  my_c          = vc->matrices->c;
  my_ggg        = vc->matrices->ggg;
  idx           = vc->jindx;
  ptype         = vc->ptype;
  S1            = vc->sequence_encoding;
  dangle_model  = md->dangles;
  turn          = md->min_loop_size;
  with_gquad    = md->gquad;

  jj = *k;

  /* nibble off unpaired 3' bases */
  do{
    fij = my_f5[jj];
    fi  = (hc->up_ext[jj]) ? my_f5[jj-1] : INF;

    if(sc){
      if(sc->energy_up)
        fi += sc->energy_up[jj][1];
      if(sc->f)
        fi += sc->f(1, jj, 1, jj - 1, VRNA_DECOMP_EXT_EXT, sc->data);
    }

    if(--jj == 0)
      break;

  } while (fij == fi);
  jj++;

  if (jj < turn + 2){ /* no more pairs */
    *i = *j = -1;
    *k = 0;
    return 1;
  }

  /* must have found a decomposition */
  switch(dangle_model){
    case 0:   /* j is paired. Find pairing partner */
              for(u = jj - turn - 1; u >= 1; u--){

                if(with_gquad){
                  if(fij == my_f5[u - 1] + my_ggg[idx[jj] + u]){
                    *i = *j = -1;
                    *k = u - 1;
                    vrna_BT_gquad_mfe(vc, u, jj, bp_stack, stack_count);
                    return 1;
                  }
                }

                if(hc->matrix[idx[jj] + u] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
                  type = (unsigned char)ptype[idx[jj] + u];

                  if(type == 0)
                    type = 7;

                  en = my_c[idx[jj] + u];
                  if(sc){
                    if(sc->f)
                      en += sc->f(1, jj, u - 1, u, VRNA_DECOMP_EXT_EXT_STEM, sc->data);
                  }
                  if(!ON_SAME_STRAND(u, jj, cp))
                    en += P->DuplexInit;
                  if(fij == E_ExtLoop(type, -1, -1, P) + en + my_f5[u - 1]){
                    *i = u;
                    *j = jj;
                    *k = u - 1;
                    bp_stack[++(*stack_count)].i = u;
                    bp_stack[(*stack_count)].j   = jj;
                    return 1;
                  }
                }
              }
              break;

    case 2:   mm3 = ((jj<length) && ON_SAME_STRAND(jj, jj + 1, cp)) ? S1[jj+1] : -1;
              for(u = jj - turn - 1; u >= 1; u--){

                if(with_gquad){
                  if(fij == my_f5[u - 1] + my_ggg[idx[jj] + u]){
                    *i = *j = -1;
                    *k = u - 1;
                    vrna_BT_gquad_mfe(vc, u, jj, bp_stack, stack_count);
                    return 1;
                  }
                }

                if(hc->matrix[idx[jj] + u] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
                  mm5   = ((u > 1) && ON_SAME_STRAND(u - 1, u, cp)) ? S1[u - 1] : -1;
                  type  = (unsigned char)ptype[idx[jj] + u];

                  if(type == 0)
                    type = 7;

                  en    = my_c[idx[jj] + u];
                  if(sc){
                    if(sc->f)
                      en += sc->f(1, jj, u - 1, u, VRNA_DECOMP_EXT_EXT_STEM, sc->data);
                  }
                  if(!ON_SAME_STRAND(u, jj, cp))
                    en += P->DuplexInit;
                  if(fij == E_ExtLoop(type, mm5, mm3, P) + en + my_f5[u - 1]){
                    *i = u;
                    *j = jj;
                    *k = u - 1;
                    bp_stack[++(*stack_count)].i = u;
                    bp_stack[(*stack_count)].j   = jj;
                    return 1;
                  }
                }
              }
              break;

    default:  if(with_gquad){
                if(fij == my_ggg[idx[jj] + 1]){
                  *i = *j = -1;
                  *k = 0;
                  vrna_BT_gquad_mfe(vc, 1, jj, bp_stack, stack_count);
                  return 1;
                }
              }

              if(hc->matrix[idx[jj] + 1] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
                type  = (unsigned char)ptype[idx[jj] + 1];

                if(type == 0)
                  type = 7;

                en    = my_c[idx[jj] + 1];
                if(sc){
                  if(sc->f)
                    en += sc->f(1, jj, 1, jj, VRNA_DECOMP_EXT_STEM, sc->data);
                }
                if(!ON_SAME_STRAND(1, jj, cp))
                  en += P->DuplexInit;
                if(fij == en + E_ExtLoop(type, -1, -1, P)){
                  *i = 1;
                  *j = jj;
                  *k = 0;
                  bp_stack[++(*stack_count)].i = 1;
                  bp_stack[(*stack_count)].j   = jj;
                  return 1;
                }
              }

              if(hc->matrix[idx[jj - 1] + 1] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
                if(hc->up_ext[jj]){
                  if(ON_SAME_STRAND(jj - 1, jj, cp)){
                    mm3   = S1[jj];
                    type  = (unsigned char)ptype[idx[jj - 1] + 1];

                    if(type == 0)
                      type = 7;

                    en    = my_c[idx[jj - 1] + 1];
                    if(sc){
                      if(sc->energy_up)
                        en += sc->energy_up[jj][1];
                      if(sc->f)
                        en += sc->f(1, jj, 1, jj - 1, VRNA_DECOMP_EXT_STEM, sc->data);
                    }
                    if(!ON_SAME_STRAND(1, jj - 1, cp))
                      en += P->DuplexInit;

                    if(fij == en + E_ExtLoop(type, -1, mm3, P)){
                      *i = 1;
                      *j = jj - 1;
                      *k = 0;
                      bp_stack[++(*stack_count)].i = 1;
                      bp_stack[(*stack_count)].j   = jj - 1;
                      return 1;
                    }
                  }
                }
              }

              for(u = jj - turn - 1; u > 1; u--){

                if(with_gquad){
                  if(fij == my_f5[u - 1] + my_ggg[idx[jj] + u]){
                    *i = *j = -1;
                    *k = u - 1;
                    vrna_BT_gquad_mfe(vc, u, jj, bp_stack, stack_count);
                    return 1;
                  }
                }

                if(hc->matrix[idx[jj] + u] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
                  type  = (unsigned char)ptype[idx[jj] + u];

                  if(type == 0)
                    type = 7;

                  en    = my_c[idx[jj] + u];
                  
                  if(!ON_SAME_STRAND(u, jj, cp))
                    en += P->DuplexInit;

                  e = my_f5[u - 1] + en + E_ExtLoop(type, -1, -1, P);
                  if(sc){
                    if(sc->f)
                      e += sc->f(1, jj, u - 1, u, VRNA_DECOMP_EXT_EXT_STEM, sc->data);
                  }
                  if(fij == e){
                    *i = u;
                    *j = jj;
                    *k = u - 1;
                    bp_stack[++(*stack_count)].i = u;
                    bp_stack[(*stack_count)].j   = jj;
                    return 1;
                  }
                  if(hc->up_ext[u - 1]){
                    if(ON_SAME_STRAND(u - 1, u, cp)){
                      mm5 = S1[u - 1];
                      e = my_f5[u - 2] + en + E_ExtLoop(type, mm5, -1, P);
                      if(sc){
                        if(sc->energy_up)
                          e += sc->energy_up[u - 1][1];
                        if(sc->f)
                          e += sc->f(1, jj, u - 2, u, VRNA_DECOMP_EXT_EXT_STEM, sc->data);
                      }
                      if(fij == e){
                        *i = u;
                        *j = jj;
                        *k = u - 2;
                        bp_stack[++(*stack_count)].i = u;
                        bp_stack[(*stack_count)].j   = jj;
                        return 1;
                      }
                    }
                  }
                }
                if(hc->matrix[idx[jj-1] + u] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
                  if(hc->up_ext[jj])
                    if(ON_SAME_STRAND(jj - 1, jj, cp)){
                      mm3   = S1[jj];
                      type  = (unsigned char)ptype[idx[jj - 1] + u];

                      if(type == 0)
                        type = 7;

                      en    = my_c[idx[jj - 1] + u];
                      if(!ON_SAME_STRAND(u, jj - 1, cp))
                        en += P->DuplexInit;

                      e = my_f5[u - 1] + en + E_ExtLoop(type, -1, mm3, P);

                      if(sc){
                        if(sc->energy_up)
                          e += sc->energy_up[jj][1];
                        if(sc->f)
                          e += sc->f(1, jj, u - 1, u, VRNA_DECOMP_EXT_EXT_STEM1, sc->data);
                      }

                      if(fij == e){
                        *i = u;
                        *j = jj - 1;
                        *k = u - 1;
                        bp_stack[++(*stack_count)].i = u;
                        bp_stack[(*stack_count)].j   = jj - 1;
                        return 1;
                      }

                      if(hc->up_ext[u - 1]){
                        mm5 = ON_SAME_STRAND(u - 1, u, cp) ? S1[u - 1] : -1;
                        e = my_f5[u - 2] + en + E_ExtLoop(type, mm5, mm3, P);
                        if(sc){
                          if(sc->energy_up)
                            e +=    sc->energy_up[jj][1]
                                  + sc->energy_up[u - 1][1];
                          if(sc->f)
                            e += sc->f(1, jj, u - 2, u, VRNA_DECOMP_EXT_EXT_STEM1, sc->data);
                        }
                        if(fij == e){
                          *i = u;
                          *j = jj - 1;
                          *k = u - 2;
                          bp_stack[++(*stack_count)].i = u;
                          bp_stack[(*stack_count)].j   = jj - 1;
                          return 1;
                        }
                      }
                    }
                }
              }
              break;
  }

  return 0;
}

hairpin_loops.c/0           0     0     644     24242     `

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include "fold_vars.h"
#include "energy_par.h"
#include "data_structures.h"
#include "params.h"
#include "utils.h"
#include "constraints.h"
#include "exterior_loops.h"
#include "gquad.h"
#include "hairpin_loops.h"

#ifdef ON_SAME_STRAND
#undef ON_SAME_STRAND
#endif

#define ON_SAME_STRAND(I,J,C)  (((I)>=(C))||((J)<(C)))


PRIVATE FLT_OR_DBL exp_eval_hp_loop(vrna_fold_compound_t *vc, int i, int j);
PRIVATE FLT_OR_DBL exp_eval_ext_hp_loop(vrna_fold_compound_t *vc, int i, int j);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

/**
 *  @brief  Evaluate the free energy of a hairpin loop
 *          and consider possible hard constraints
 *
 *  @note This function is polymorphic! The provided #vrna_fold_compound_t may be of type
 *  #VRNA_VC_TYPE_SINGLE or #VRNA_VC_TYPE_ALIGNMENT
 *
 */
PUBLIC int
vrna_E_hp_loop( vrna_fold_compound_t *vc,
                int i,
                int j){

  char        eval_loop;
  int         p, q, u, *hc_up;
  vrna_hc_t   *hc;
  int         (*eval_f)(vrna_fold_compound_t *a, int b, int c);
#ifdef WITH_GEN_HC
  vrna_callback_hc_evaluate *f;
#endif

  hc    = vc->hc;
  hc_up = hc->up_hp;

#ifdef WITH_GEN_HC
  f = hc->f;
#endif

  if((i > 0) && (j > 0)){
    if(j > i){ /* linear case */
      p       = i;
      q       = j;
      u       = q - p - 1;
      eval_f  = vrna_eval_hp_loop;
    } else { /* circular case */
      p       = j;
      q       = i;
      u       = vc->length - q + p - 1;
      eval_f  = vrna_eval_ext_hp_loop;
    }

    eval_loop = hc->matrix[vc->jindx[q] + p] & VRNA_CONSTRAINT_CONTEXT_HP_LOOP;

#ifdef WITH_GEN_HC
    if(f)
      eval_loop = (f(i, j, i, j, VRNA_DECOMP_PAIR_HP, hc->data)) ? eval_loop : (char)0;
#endif

    /* is this base pair allowed to close a hairpin (like) loop ? */
    if(eval_loop){
      
      /* are all nucleotides in the loop allowed to be unpaired ? */
      if(hc_up[i+1] >= u){
        return eval_f(vc, p, q);
      }
    }
  }

  return INF;
}

/**
 *  @brief  Evaluate the free energy of an exterior hairpin loop
 *          and consider possible hard constraints
 */
PUBLIC int
vrna_E_ext_hp_loop( vrna_fold_compound_t *vc,
                    int i,
                    int j){

  return vrna_E_hp_loop(vc, j, i);
}

/**
 *  @brief Evaluate free energy of an exterior hairpin loop
 *
 *  @ingroup eval
 *
 */
PUBLIC int
vrna_eval_ext_hp_loop(vrna_fold_compound_t *vc,
                      int i,
                      int j){

  char            **Ss, loopseq[10];
  unsigned short  **a2s;
  short           *S, **SS, **S5, **S3;
  int             u, e, s, type, *types, n_seq, length;
  vrna_param_t    *P;
  vrna_sc_t       *sc, **scs;
  vrna_md_t       *md;

  length  = vc->length;
  P       = vc->params;
  md      = &(P->model_details);
  e       = INF;

  switch(vc->type){
    /* single sequences and cofolding hybrids */
    case  VRNA_VC_TYPE_SINGLE:    S     = vc->sequence_encoding;
                                  sc    = vc->sc;
                                  u     = vc->length - j + i - 1;
                                  type  = md->pair[S[j]][S[i]];

                                  if(type == 0)
                                    type = 7;

                                  if (u<7) {
                                    strcpy(loopseq , vc->sequence + j - 1);
                                    strncat(loopseq, vc->sequence, i);
                                  }

                                  e = E_Hairpin(u, type, S[j + 1], S[i - 1],  loopseq, P);

                                  if(sc){
                                    if(sc->energy_up)
                                      e +=  sc->energy_up[j + 1][vc->length - j]
                                            + sc->energy_up[1][i - 1];

                                    if(sc->f)
                                      e += sc->f(j, i, j, i, VRNA_DECOMP_PAIR_HP, sc->data);
                                  }
                                  break;

    /* sequence alignments */
    case  VRNA_VC_TYPE_ALIGNMENT: SS    = vc->S;                                                               
                                  S5    = vc->S5;     /*S5[s][i] holds next base 5' of i in sequence s*/
                                  S3    = vc->S3;     /*Sl[s][i] holds next base 3' of i in sequence s*/
                                  Ss    = vc->Ss;                                                       
                                  a2s   = vc->a2s;                                                      
                                  scs   = vc->scs;
                                  n_seq = vc->n_seq;
                                  e     = 0;
                                  types = (int *)vrna_alloc(sizeof(int) * n_seq);

                                  for (s=0; s<n_seq; s++) {
                                    types[s] = md->pair[SS[s][j]][SS[s][i]];
                                    if (types[s]==0) types[s]=7;
                                  }
                                  
                                  for (s=0; s<n_seq; s++) {
                                    char loopseq[10];
                                    u = a2s[s][length] - a2s[s][j] + a2s[s][i - 1];

                                    if (u<9) {
                                      strcpy(loopseq , Ss[s] + a2s[s][j] - 1);
                                      strncat(loopseq, Ss[s], a2s[s][i]);
                                    }
                                    if (u < 3) e += 600;
                                    else e += E_Hairpin(u, types[s], S3[s][j], S5[s][i],  loopseq, P);
                                  }
                                  if(scs)
                                    for(s=0;s < n_seq; s++){
                                      if(scs[s]){
                                        if(scs[s]->energy_up){
                                          e +=    ((i > 1) ? scs[s]->energy_up[1][a2s[s][i - 1]] : 0)
                                                    + ((j < length) ? scs[s]->energy_up[a2s[s][j + 1]][a2s[s][length] - a2s[s][j]] : 0);
                                        }
                                        if(scs[s]->f)
                                          e += scs[s]->f(a2s[s][j], a2s[s][i], a2s[s][j], a2s[s][i], VRNA_DECOMP_PAIR_HP, scs[s]->data);
                                      }
                                    }

                                  free(types);
                                  break;

    /* nothing */
    default:                      break;
  }

  return e;
}

/**
 *  @brief Evaluate free energy of a hairpin loop
 *
 *  @ingroup eval
 *
 *  @note This function is polymorphic! The provided #vrna_fold_compound_t may be of type
 *  #VRNA_VC_TYPE_SINGLE or #VRNA_VC_TYPE_ALIGNMENT
 *
 *  @param  vc  The #vrna_fold_compound_t for the particular energy evaluation
 *  @param  i   5'-position of the base pair
 *  @param  j   3'-position of the base pair
 *  @returns    Free energy of the hairpin loop closed by @f$ (i,j) @f$ in deka-kal/mol
 */
PUBLIC int
vrna_eval_hp_loop(vrna_fold_compound_t *vc,
                  int i,
                  int j){

  char            **Ss;
  unsigned short  **a2s;
  short           *S, **SS, **S5, **S3;
  int             u, e, s, ij, cp, type, *types, *idx, n_seq;
  vrna_param_t    *P;
  vrna_sc_t       *sc, **scs;
  vrna_md_t       *md;

  cp  = vc->cutpoint;
  idx = vc->jindx;
  P   = vc->params;
  md  = &(P->model_details);
  e   = INF;

  switch(vc->type){
    /* single sequences and cofolding hybrids */
    case  VRNA_VC_TYPE_SINGLE:    S     = vc->sequence_encoding;
                                  sc    = vc->sc;
                                  u     = j - i - 1;
                                  ij    = idx[j] + i;
                                  type  = md->pair[S[i]][S[j]];

                                  if(type == 0)
                                    type = 7;

                                  if((cp < 0) || ON_SAME_STRAND(i, j, cp)){ /* regular hairpin loop */
                                    e = E_Hairpin(u, type, S[i+1], S[j-1], vc->sequence+i-1, P);
                                  } else { /* hairpin-like exterior loop (for cofolding) */
                                    short si, sj;
                                    si  = ON_SAME_STRAND(i, i + 1, cp) ? S[i+1] : -1;
                                    sj  = ON_SAME_STRAND(j - 1, j, cp) ? S[j-1] : -1;
                                    if (md->dangles)
                                      e = E_ExtLoop(md->rtype[type], sj, si, P);
                                    else
                                      e = E_ExtLoop(md->rtype[type], -1, -1, P);
                                  }

                                  /* add soft constraints */
                                  if(sc){
                                    if(sc->energy_up)
                                      e += sc->energy_up[i+1][u];

                                    if(sc->energy_bp){
                                      e += sc->energy_bp[ij];
                                    }
                                    if(sc->f)
                                      e += sc->f(i, j, i, j, VRNA_DECOMP_PAIR_HP, sc->data);
                                  }
                                  break;
    /* sequence alignments */
    case  VRNA_VC_TYPE_ALIGNMENT: SS    = vc->S;                                                               
                                  S5    = vc->S5;     /*S5[s][i] holds next base 5' of i in sequence s*/
                                  S3    = vc->S3;     /*Sl[s][i] holds next base 3' of i in sequence s*/
                                  Ss    = vc->Ss;                                                       
                                  a2s   = vc->a2s;                                                      
                                  scs   = vc->scs;
                                  n_seq = vc->n_seq;
                                  ij    = idx[j] + i;
                                  types = (int *)vrna_alloc(sizeof(int) * n_seq);

                                  for (s=0; s<n_seq; s++) {
                                    types[s] = md->pair[SS[s][i]][SS[s][j]];
                                    if (types[s]==0) types[s]=7;
                                  }
                                  
                                  for(e = s = 0; s < n_seq; s++){
                                    u = a2s[s][j-1] - a2s[s][i];
                                    e += (u < 3) ? 600 : E_Hairpin(u, types[s], S3[s][i], S5[s][j], Ss[s]+(a2s[s][i-1]), P);  /* ??? really 600 ??? */

                                  }
                                  
                                  if(scs)
                                    for(s = 0; s < n_seq; s++){
                                      if(scs[s]){
                                        u = a2s[s][j-1]-a2s[s][i];

                                        if(scs[s]->energy_up)
                                          e += scs[s]->energy_up[a2s[s][i + 1]][u];

                                        if(scs[s]->energy_bp)
                                          e += scs[s]->energy_bp[ij];

                                        if(scs[s]->f)
                                          e += scs[s]->f(a2s[s][i], a2s[s][j], a2s[s][i], a2s[s][j], VRNA_DECOMP_PAIR_HP, scs[s]->data);
                                      }
                                    }

                                  free(types);

                                  break;
    /* nothing */
    default:                      break;
  }


  return e;
}

/*
*************************************
* Partition function variants below *
*************************************
*/


/**
 *  @brief High-Level function for hairpin loop energy evaluation (partition function variant)
 *
 *  @see E_hp_loop() for it's free energy counterpart
*/
PUBLIC FLT_OR_DBL
vrna_exp_E_hp_loop( vrna_fold_compound_t *vc,
                    int i,
                    int j){

  int         p, q, u, *hc_up;
  char        eval_loop;
  FLT_OR_DBL  z;
  vrna_hc_t   *hc;
  FLT_OR_DBL  (*eval_f)(vrna_fold_compound_t *a, int b, int c);
#ifdef WITH_GEN_HC
  vrna_callback_hc_evaluate *f = hc->f;
#endif

  z = 0.;

  hc        = vc->hc;
  hc_up     = hc->up_hp;

  if((i > 0) && (j > 0)){
    if(j >= i){ /* linear case */
      p       = i;
      q       = j;
      u       = q - p - 1;
      eval_f  = exp_eval_hp_loop;
    } else { /* circular case */
      p       = j;
      q       = i;
      u       = vc->length - q + p - 1;
      eval_f  = exp_eval_ext_hp_loop;
    }

    eval_loop = hc->matrix[vc->jindx[q] + p] & VRNA_CONSTRAINT_CONTEXT_HP_LOOP;

#ifdef WITH_GEN_HC
    if(f)
      eval_loop = (f(i, j, i, j, VRNA_DECOMP_PAIR_HP, hc->data)) ? eval_loop : (char)0;
#endif

    /* is this base pair allowed to close a hairpin (like) loop ? */
    if(eval_loop){
      /* are all nucleotides in the loop allowed to be unpaired ? */
      if(hc_up[i+1] >= u){
        z = eval_f(vc, p, q);
      }
    }
  }

  return z;
}

PRIVATE FLT_OR_DBL
exp_eval_hp_loop( vrna_fold_compound_t *vc,
                  int i,
                  int j){

  char              **Ss;
  unsigned short    **a2s;
  short             *S, **SS, **S5, **S3;
  int               u, ij, type, n_seq, s, *types, cp, *idx, *iidx;
  FLT_OR_DBL        q, qbt1, *scale;
  vrna_exp_param_t  *P;
  vrna_sc_t         *sc, **scs;
  vrna_md_t         *md;

  cp    = vc->cutpoint;
  idx   = vc->jindx;
  iidx  = vc->iindx;
  P     = vc->exp_params;
  md    = &(P->model_details);
  scale = vc->exp_matrices->scale;
  types = NULL;

  q     = 0.;
  ij    = idx[j] + i;

  switch(vc->type){
    case VRNA_VC_TYPE_SINGLE:     S     = vc->sequence_encoding;
                                  sc    = vc->sc;
                                  u     = j - i - 1;
                                  type  = vc->ptype[ij];

                                  if(type == 0)
                                    type = 7;

                                  if((cp < 0) || ON_SAME_STRAND(i, j, cp)){ /* regular hairpin loop */
                                    q = exp_E_Hairpin(u, type, S[i+1], S[j-1], vc->sequence+i-1, P);
                                  } else { /* hairpin-like exterior loop (for cofolding) */
                                    /* this is currently handle somewhere else */
                                  }

                                  /* add soft constraints */
                                  if(sc){
                                    if(sc->exp_energy_up)
                                      q *= sc->exp_energy_up[i+1][u];

                                    if(sc->exp_energy_bp)
                                      q *= sc->exp_energy_bp[iidx[i] - j];

                                    if(sc->exp_f)
                                      q *= sc->exp_f(i, j, i, j, VRNA_DECOMP_PAIR_HP, sc->data);
                                  }

                                  q *= scale[u+2];
                                  break;

    case VRNA_VC_TYPE_ALIGNMENT:  SS    = vc->S;                                                               
                                  S5    = vc->S5;     /*S5[s][i] holds next base 5' of i in sequence s*/
                                  S3    = vc->S3;     /*Sl[s][i] holds next base 3' of i in sequence s*/
                                  Ss    = vc->Ss;                                                       
                                  a2s   = vc->a2s;                                                      
                                  scs   = vc->scs;
                                  n_seq = vc->n_seq;
                                  qbt1  = 1.;
                                  types = (int *)vrna_alloc(sizeof(int) * n_seq);

                                  for (s=0; s<n_seq; s++) {
                                    types[s] = md->pair[SS[s][i]][SS[s][j]];
                                    if (types[s]==0) types[s]=7;
                                  }
                                  
                                  for (s=0; s<n_seq; s++) {
                                    u = a2s[s][j-1] - a2s[s][i];
                                    if (a2s[s][i]<1) continue;
                                    char loopseq[10];
                                    if (u<9){
                                      strncpy(loopseq, Ss[s]+a2s[s][i]-1, 10);
                                    }
                                    qbt1 *= exp_E_Hairpin(u, types[s], S3[s][i], S5[s][j], loopseq, P);
                                  }

                                  /* add soft constraints */
                                  if(scs)
                                    for(s = 0; s < n_seq; s++){
                                      if(scs[s]){
                                        u = a2s[s][j-1] - a2s[s][i];

                                        if(scs[s]->exp_energy_bp)
                                          qbt1 *= scs[s]->exp_energy_bp[iidx[i] - j];

                                        if(scs[s]->exp_energy_up)
                                          qbt1 *= scs[s]->exp_energy_up[a2s[s][i + 1]][u];

                                        if(scs[s]->exp_f)
                                          qbt1 *= scs[s]->exp_f(a2s[s][i], a2s[s][j], a2s[s][i], a2s[s][j], VRNA_DECOMP_PAIR_HP, scs[s]->data);
                                      }
                                    }

                                  q = qbt1 * scale[j-i+1];
                                  break;

    default:                      break;
  }

  free(types);
  return q;
}

PRIVATE FLT_OR_DBL
exp_eval_ext_hp_loop( vrna_fold_compound_t *vc,
                      int i,
                      int j){

  char              **Ss, *sequence;
  unsigned short    **a2s;
  short             *S, **SS, **S5, **S3;
  int               u, u1, ij, n, type, n_seq, s, *rtype, *types, *idx, noGUclosure;
  FLT_OR_DBL        q, qbt1, *scale;
  vrna_exp_param_t  *P;
  vrna_sc_t         *sc, **scs;
  vrna_md_t         *md;

  n           = vc->length;
  idx         = vc->jindx;
  P           = vc->exp_params;
  md          = &(P->model_details);
  noGUclosure = md->noGUclosure;
  scale       = vc->exp_matrices->scale;
  types       = NULL;
  rtype       = &(md->rtype[0]);

  q     = 0.;
  u     = n - j + i - 1;
  ij    = idx[j] + i;

  switch(vc->type){
    case VRNA_VC_TYPE_SINGLE:     sequence  = vc->sequence;
                                  S         = vc->sequence_encoding;
                                  sc        = vc->sc;
                                  type      = rtype[vc->ptype[ij]];

                                  if(type == 0)
                                    type = 7;

                                  if(((type==3)||(type==4))&&noGUclosure)
                                    return q;

                                  /* get the loop sequence */
                                  char loopseq[10];
                                  if (u<7){
                                    strcpy(loopseq , sequence+j-1);
                                    strncat(loopseq, sequence, i);
                                  }

                                  q = exp_E_Hairpin(u, type, S[j+1], S[i-1], loopseq, P);

                                  /* add soft constraints */
                                  if(sc){
                                    if(sc->exp_energy_up)
                                      q *=    ((i > 1) ? sc->exp_energy_up[1][i - 1] : 1.)
                                            * ((j < n) ? sc->exp_energy_up[j+1][n-j] : 1.);

                                    if(sc->exp_f)
                                      q *= sc->exp_f(j, i, j, i, VRNA_DECOMP_PAIR_HP, sc->data);
                                  }

                                  q *= scale[u];
                                  break;

    case VRNA_VC_TYPE_ALIGNMENT:  SS    = vc->S;                                                               
                                  S5    = vc->S5;     /*S5[s][i] holds next base 5' of i in sequence s*/
                                  S3    = vc->S3;     /*Sl[s][i] holds next base 3' of i in sequence s*/
                                  Ss    = vc->Ss;                                                       
                                  a2s   = vc->a2s;                                                      
                                  scs   = vc->scs;
                                  n_seq = vc->n_seq;
                                  qbt1  = 1.;
                                  types = (int *)vrna_alloc(sizeof(int) * n_seq);

                                  for (s=0; s<n_seq; s++) {
                                    types[s] = md->pair[SS[s][j]][SS[s][i]];
                                    if (types[s]==0) types[s]=7;
                                  }
                                  
                                  for (s=0; s<n_seq; s++) {
                                    u1 = a2s[s][i] - 1 + a2s[s][n] - a2s[s][j];
                                    char loopseq[10];
                                    if (u1<7){
                                      strcpy(loopseq , Ss[s] + a2s[s][j] - 1);
                                      strncat(loopseq, Ss[s], a2s[s][i]);
                                    }
                                    qbt1 *= exp_E_Hairpin(u1, types[s], S3[s][j], S5[s][i], loopseq, P);
                                  }

                                  /* add soft constraints */
                                  if(scs)
                                    for(s = 0; s < n_seq; s++){
                                      if(scs[s]){

                                        if(scs[s]->exp_energy_up)
                                          qbt1 *=   ((i > 1) ? scs[s]->exp_energy_up[a2s[s][1]][a2s[s][i] - a2s[s][1]] : 1.)
                                                  * ((j < n) ? scs[s]->exp_energy_up[a2s[s][j] + 1][a2s[s][n] - a2s[s][j]] : 1.);

                                        if(scs[s]->exp_f)
                                          qbt1 *= scs[s]->exp_f(a2s[s][j], a2s[s][i], a2s[s][j], a2s[s][i], VRNA_DECOMP_PAIR_HP, scs[s]->data);
                                      }
                                    }

                                  q = qbt1 * scale[u];

                                  free(types);
                                  break;

    default:                      break;
  }

  return q;
}

/**
 *  @brief Backtrack a hairpin loop closed by @f$ (i,j) @f$
 *
 *  @note This function is polymorphic! The provided #vrna_fold_compound_t may be of type
 *  #VRNA_VC_TYPE_SINGLE or #VRNA_VC_TYPE_ALIGNMENT
 *
 */
PUBLIC int
vrna_BT_hp_loop(vrna_fold_compound_t *vc,
                int i,
                int j,
                int en,
                vrna_bp_stack_t *bp_stack,
                int   *stack_count){

  int       e, u;
  vrna_sc_t *sc;

  sc  = NULL;

  u = j - i - 1;

  if(vc->hc->up_hp[i+1] < u)
    return 0;

  e   = vrna_E_hp_loop(vc, i, j);

  if(e == en){
    switch(vc->type){
      case  VRNA_VC_TYPE_SINGLE:    sc  = vc->sc;
                                    break;
      case  VRNA_VC_TYPE_ALIGNMENT: if(vc->scs)
                                      sc = vc->scs[0];
                                    break;
      default:                      break;
    }

    if(sc)
      if(sc->bt){
        vrna_basepair_t *ptr, *aux_bps;
        aux_bps = sc->bt(i, j, i, j, VRNA_DECOMP_PAIR_HP, sc->data);
        for(ptr = aux_bps; ptr && ptr->i != 0; ptr++){
          bp_stack[++(*stack_count)].i = ptr->i;
          bp_stack[(*stack_count)].j   = ptr->j;
        }
        free(aux_bps);
      }

    return 1;
  }

  return 0;
}

/120            0           0     0     644     38047     `

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include "fold_vars.h"
#include "utils.h"
#include "constraints.h"
#include "exterior_loops.h"
#include "gquad.h"
#include "interior_loops.h"


PRIVATE int
E_int_loop( vrna_fold_compound_t *vc,
            int i,
            int j);

PRIVATE int
E_int_loop_comparative( vrna_fold_compound_t *vc,
                        int i,
                        int j);

PRIVATE FLT_OR_DBL
exp_E_int_loop( vrna_fold_compound_t *vc,
                int i,
                int j);

PRIVATE FLT_OR_DBL
exp_E_int_loop_comparative(vrna_fold_compound_t *vc,
                          int i,
                          int j);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/


PUBLIC int
vrna_E_int_loop(vrna_fold_compound_t *vc,
                int i,
                int j){

  int e = INF;

  if(vc){
    switch(vc->type){
      case VRNA_VC_TYPE_SINGLE:
        e = E_int_loop(vc, i, j);
        break;

      case VRNA_VC_TYPE_ALIGNMENT:
        e = E_int_loop_comparative(vc, i, j);
        break;
    }
  }

  return e;
}


PUBLIC FLT_OR_DBL
vrna_exp_E_int_loop(vrna_fold_compound_t *vc,
                int i,
                int j){

  FLT_OR_DBL q = 0.;

  if(vc){
    switch(vc->type){
      case VRNA_VC_TYPE_SINGLE:
        q = exp_E_int_loop(vc, i, j);
        break;

      case VRNA_VC_TYPE_ALIGNMENT:
        q = exp_E_int_loop_comparative(vc, i, j);
        break;
    }
  }

  return q;
}


PRIVATE int
E_int_loop( vrna_fold_compound_t *vc,
            int i,
            int j){

  unsigned char     type, type_2;
  char              *ptype, *ptype_pq, *hc_pq, *hc, eval_loop;
  short             *S, S_i1, S_j1, *S_p1, *S_q1;
  int               q, p, j_q, p_i, pq, *c_pq, max_q, max_p, tmp,
                    *rtype, noGUclosure, no_close, energy, cp,
                    *indx, *hc_up, ij, hc_decompose, e, *c, *ggg,
                    with_gquad, turn;
  vrna_sc_t         *sc;
  vrna_param_t      *P;
  vrna_md_t         *md;
#ifdef WITH_GEN_HC
  vrna_callback_hc_evaluate *f;
#endif

  cp            = vc->cutpoint;
  indx          = vc->jindx;
  hc            = vc->hc->matrix;
  hc_up         = vc->hc->up_int;
  P             = vc->params;
  ij            = indx[j] + i;
  hc_decompose  = hc[ij];
  e             = INF;
  c             = vc->matrices->c;
  ggg           = vc->matrices->ggg;
  md            = &(P->model_details);
  with_gquad    = md->gquad;
  turn          = md->min_loop_size;

#ifdef WITH_GEN_HC
  f = vc->hc->f;
#endif

  /* CONSTRAINED INTERIOR LOOP start */
  if(hc_decompose & VRNA_CONSTRAINT_CONTEXT_INT_LOOP){

    /* prepare necessary variables */
    rtype       = &(md->rtype[0]);
    noGUclosure = md->noGUclosure;
    max_q       = i+turn+2;
    max_q       = MAX2(max_q, j - MAXLOOP - 1);

    ptype     = vc->ptype;
    type      = (unsigned char)ptype[ij];
    no_close  = (((type==3)||(type==4))&&noGUclosure);
    S         = vc->sequence_encoding;
    S_i1      = S[i+1];
    S_j1      = S[j-1];

    sc        = vc->sc;

    if(type == 0)
      type = 7;

    for(q = j - 1; q >= max_q; q--){
      j_q = j - q - 1;

      if(hc_up[q+1] < j_q) break;

      pq        = indx[q] + i + 1;
      p_i       = 0;
      max_p     = i + 1;
      tmp       = i + 1 + MAXLOOP - j_q;
      max_p     = MAX2(max_p, tmp);
      tmp       = q - turn;
      max_p     = MIN2(max_p, tmp);
      tmp       = i + 1 + hc_up[i + 1];
      max_p     = MIN2(max_p, tmp);
      hc_pq     = hc + pq;
      c_pq      = c + pq;

      ptype_pq  = ptype + pq;
      S_p1      = S + i;
      S_q1      = S + q + 1;

      for(p = i+1; p <= max_p; p++){
        eval_loop = *hc_pq & VRNA_CONSTRAINT_CONTEXT_INT_LOOP_ENC;
#ifdef WITH_GEN_HC
        if(f)
          eval_loop = (f(i, j, p, q, VRNA_DECOMP_PAIR_IL, vc->hc->data)) ? eval_loop : (char)0;
#endif
        /* discard this configuration if (p,q) is not allowed to be enclosed pair of an interior loop */
        if(eval_loop){
          energy = *c_pq;
          if(energy != INF){
            type_2 = rtype[(unsigned char)*ptype_pq];

            if(type_2 == 0)
              type_2 = 7;

            if (noGUclosure)
              if (no_close||(type_2==3)||(type_2==4))
                if ((p>i+1)||(q<j-1)) continue;  /* continue unless stack */

            energy += ubf_eval_int_loop(i, j, p, q,
                                        i + 1, j - 1, p - 1, q + 1,
                                        S_i1, S_j1, *S_p1, *S_q1,
                                        type, type_2, rtype,
                                        ij, cp,
                                        P, sc);
            e = MIN2(e, energy);
          }

        }
        hc_pq++;    /* get hc[pq + 1] */
        c_pq++;     /* get c[pq + 1] */
        p_i++;      /* increase unpaired region [i+1...p-1] */

        ptype_pq++; /* get ptype[pq + 1] */
        S_p1++;

        pq++;
      } /* end q-loop */
    } /* end p-loop */

    if(with_gquad){
      /* include all cases where a g-quadruplex may be enclosed by base pair (i,j) */
      if ((!no_close) && ((cp < 0) || ON_SAME_STRAND(i, j, cp))) {
        energy = E_GQuad_IntLoop(i, j, type, S, ggg, indx, P);
        e = MIN2(e, energy);
      }
    }

  }

  return e;
}

PRIVATE INLINE int
ubf_eval_int_loop_comparative(int col_i,
                              int col_j,
                              int col_p,
                              int col_q,
                              unsigned char type,
                              unsigned char type_2,
                              int *rtype,
                              int ij,
                              int cp,
                              vrna_param_t *P,
                              short *SS,
                              short *S5,
                              short *S3,
                              unsigned short *a2s,
                              vrna_sc_t *sc){

  short si, sj, sp, sq;
  int   energy, u1, u2;
  int   i, j, p, q, i1, j1, p1, q1;

  i   = a2s[col_i];
  j   = a2s[col_j];
  p   = a2s[col_p];
  q   = a2s[col_q];
  i1  = a2s[col_i + 1];
  j1  = a2s[col_j - 1];
  p1  = a2s[col_p - 1];
  q1  = a2s[col_q + 1];

  si  = S3[col_i];
  sj  = S5[col_j];
  sp  = S5[col_p];
  sq  = S3[col_q];

  u1  = p1 - i;
  u2  = j1 - q;

  if((cp < 0) || (ON_SAME_STRAND(i, p, cp) && ON_SAME_STRAND(q, j, cp))){ /* regular interior loop */
    energy = E_IntLoop(u1, u2, type, type_2, si, sj, sp, sq, P);
  } else { /* interior loop like cofold structure */
    short Si, Sj;
    Si  = ON_SAME_STRAND(i, i1, cp) ? si : -1;
    Sj  = ON_SAME_STRAND(j1, j, cp) ? sj : -1;
    energy = E_IntLoop_Co(rtype[type], rtype[type_2],
                            i, j, p, q,
                            cp,
                            Si, Sj,
                            sp, sq,
                            P->model_details.dangles,
                            P);
  }

  /* add soft constraints */
  if(sc){
    if(sc->energy_up)
      energy += sc->energy_up[i1][u1]
                + sc->energy_up[q1][u2];

    if(sc->energy_bp)
      energy += sc->energy_bp[ij];

    if(sc->energy_stack)
      if(u1 + u2 == 0){
        if(SS[col_i] && SS[col_j] && SS[col_p] && SS[col_q]){ /* no gap allowed */
          int a =   sc->energy_stack[i]
                    + sc->energy_stack[p]
                    + sc->energy_stack[q]
                    + sc->energy_stack[j];
          energy += a;
        }
      }
    if(sc->f)
      energy += sc->f(i, j, p, q, VRNA_DECOMP_PAIR_IL, sc->data);
  }

  return energy;

}

PRIVATE int
E_int_loop_comparative( vrna_fold_compound_t *vc,
                        int i,
                        int j){

  unsigned char     type, type_2;
  char              *hc_pq, *hc, eval_loop;
  unsigned short    **a2s;
  short             **SS, **S5, **S3, *S_cons;
  int               q, p, j_q, p_i, u, pq, *c_pq, min_q, max_q, max_p, tmp,
                    *rtype, *types, dangle_model, energy, c0, s, n_seq, cp,
                    *indx, *hc_up, ij, hc_decompose, e, *c, *ggg, with_gquad,
                    turn;
  vrna_sc_t         *sc, **scs;
  vrna_param_t      *P;
  vrna_md_t         *md;
#ifdef WITH_GEN_HC
  vrna_callback_hc_evaluate *f;
#endif

  cp            = vc->cutpoint;
  indx          = vc->jindx;
  hc            = vc->hc->matrix;
  hc_up         = vc->hc->up_int;
  P             = vc->params;
  ij            = indx[j] + i;
  hc_decompose  = hc[ij];
  e             = INF;
  c             = vc->matrices->c;
  ggg           = vc->matrices->ggg;
  md            = &(P->model_details);
  with_gquad    = md->gquad;
  turn          = md->min_loop_size;
  dangle_model  = md->dangles;
  types         = NULL;

#ifdef WITH_GEN_HC
  f = vc->hc->f;
#endif

  /* CONSTRAINED INTERIOR LOOP start */
  if(hc_decompose & VRNA_CONSTRAINT_CONTEXT_INT_LOOP){

    SS      = vc->S;                                                             
    S5      = vc->S5;     /*S5[s][i] holds next base 5' of i in sequence s*/
    S3      = vc->S3;     /*Sl[s][i] holds next base 3' of i in sequence s*/
    a2s     = vc->a2s;                                                      
    S_cons  = vc->S_cons;
    scs     = vc->scs;
    n_seq   = vc->n_seq;
    types   = (int *)vrna_alloc(sizeof(int) * n_seq);

    for (s=0; s<n_seq; s++) {
      types[s] = md->pair[SS[s][i]][SS[s][j]];
      if(types[s] == 0)
        types[s] = 7;
    }

    /* prepare necessary variables */
    rtype = &(md->rtype[0]);
    max_q = i+turn+2;
    max_q = MAX2(max_q, j - MAXLOOP - 1);

    for(q = j - 1; q >= max_q; q--){
      j_q = j - q - 1;

      if(hc_up[q+1] < j_q) break;

      pq    = indx[q] + i + 1;
      p_i   = 0;
      max_p = i + 1;
      tmp   = i + 1 + MAXLOOP - j_q;
      max_p = MAX2(max_p, tmp);
      tmp   = q - turn;
      max_p = MIN2(max_p, tmp);
      tmp   = i + 1 + hc_up[i + 1];
      max_p = MIN2(max_p, tmp);
      hc_pq = hc + pq;
      c_pq  = c + pq;

      for(p = i+1; p <= max_p; p++){
        eval_loop = *hc_pq & VRNA_CONSTRAINT_CONTEXT_INT_LOOP_ENC;
#ifdef WITH_GEN_HC
        if(f)
          eval_loop = (f(i, j, p, q, VRNA_DECOMP_PAIR_IL, vc->hc->data)) ? eval_loop : (char)0;
#endif
        /* discard this configuration if (p,q) is not allowed to be enclosed pair of an interior loop */
        if(eval_loop){
          energy = *c_pq;
          if(energy != INF){
            for (s=0; s<n_seq; s++) {
              type_2 = md->pair[SS[s][q]][SS[s][p]]; /* q,p not p,q! */
              if(type_2 == 0)
                type_2 = 7;

              sc = (scs && scs[s]) ? scs[s] : NULL;

              energy += ubf_eval_int_loop_comparative(i, j, p, q,
                                          types[s], type_2, rtype,
                                          ij, cp,
                                          P,
                                          SS[s],
                                          S5[s],
                                          S3[s],
                                          a2s[s],
                                          sc);
            }

            e = MIN2(e, energy);
          }

        }
        hc_pq++;    /* get hc[pq + 1] */
        c_pq++;     /* get c[pq + 1] */
        p_i++;      /* increase unpaired region [i+1...p-1] */

        pq++;
      } /* end q-loop */
    } /* end p-loop */

    if(with_gquad){
      /* include all cases where a g-quadruplex may be enclosed by base pair (i,j) */
      energy = 0;
      for(s=0;s<n_seq;s++){
        type = types[s];
        if(dangle_model == 2)
          energy += P->mismatchI[type][S3[s][i]][S5[s][j]];
        if(type > 2)
          energy += P->TerminalAU;
      }
      for(p = i + 2; p < j - VRNA_GQUAD_MIN_BOX_SIZE; p++){
        u    = p - i - 1;
        if(u>MAXLOOP) break;
        if(S_cons[p] != 3) continue;
        min_q  = j - i + p - MAXLOOP - 2;
        c0    = p + VRNA_GQUAD_MIN_BOX_SIZE - 1;
        min_q  = MAX2(c0, min_q);
        c0    = j - 1;
        max_q  = p + VRNA_GQUAD_MAX_BOX_SIZE + 1;
        max_q  = MIN2(c0, max_q);
        for(q = min_q; q < max_q; q++){
          if(S_cons[q] != 3) continue;
          c0    = energy + ggg[indx[q] + p] + n_seq * P->internal_loop[u + j - q - 1];
          e     = MIN2(e, c0);
        }
      }

      p = i + 1;
      if(S_cons[p] == 3){
        if(p < j - VRNA_GQUAD_MIN_BOX_SIZE){
          min_q  = j - i + p - MAXLOOP - 2;
          c0    = p + VRNA_GQUAD_MIN_BOX_SIZE - 1;
          min_q  = MAX2(c0, min_q);
          c0    = j - 3;
          max_q  = p + VRNA_GQUAD_MAX_BOX_SIZE + 1;
          max_q  = MIN2(c0, max_q);
          for(q = min_q; q < max_q; q++){
            if(S_cons[q] != 3) continue;
            c0  = energy + ggg[indx[q] + p] + n_seq * P->internal_loop[j - q - 1];
            e   = MIN2(e, c0);
          }
        }
      }
      q = j - 1;
      if(S_cons[q] == 3)
        for(p = i + 4; p < j - VRNA_GQUAD_MIN_BOX_SIZE; p++){
          u    = p - i - 1;
          if(u>MAXLOOP) break;
          if(S_cons[p] != 3) continue;
          c0  = energy + ggg[indx[q] + p] + n_seq * P->internal_loop[u];
          e   = MIN2(e, c0);
        }
    }

  }

  free(types);
  return e;
}


PRIVATE FLT_OR_DBL
exp_E_int_loop( vrna_fold_compound_t *vc,
                int i,
                int j){

  unsigned char     type, type_2;
  char              *ptype, *hc;
  short             *S1, S_i1, S_j1;
  int               k,l, u1, u2, kl, maxk, minl, *rtype, noGUclosure,
                    no_close, cp, *my_iindx, *jindx, *hc_up, ij,
                    with_gquad, turn;
  FLT_OR_DBL        qbt1, q_temp, *qb, *G, *scale;
  vrna_sc_t         *sc; 
  vrna_exp_param_t  *pf_params;
  vrna_md_t         *md;

  cp          = vc->cutpoint;
  ptype       = vc->ptype;
  S1          = vc->sequence_encoding;
  S_i1        = S1[i+1];
  S_j1        = S1[j-1];
  my_iindx    = vc->iindx;
  jindx       = vc->jindx;
  hc          = vc->hc->matrix;
  hc_up       = vc->hc->up_int;
  sc          = vc->sc; 
  pf_params   = vc->exp_params;
  ij          = jindx[j] + i;
  md          = &(pf_params->model_details);
  with_gquad  = md->gquad;
  turn        = md->min_loop_size;
  qb          = vc->exp_matrices->qb;
  G           = vc->exp_matrices->G;
  scale       = vc->exp_matrices->scale;
  qbt1        = 0.;

  /* CONSTRAINED INTERIOR LOOP start */
  if(hc[ij] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP){

    type        = (unsigned char)ptype[ij];
    rtype       = &(md->rtype[0]);
    noGUclosure = md->noGUclosure;
    no_close    = (((type==3)||(type==4))&&noGUclosure);
    maxk        = i + MAXLOOP + 1;
    maxk        = MIN2(maxk, j - turn - 2);
    maxk        = MIN2(maxk, i + 1 + hc_up[i+1]);

    if(type == 0)
      type = 7;

    for (k = i + 1; k <= maxk; k++) {
      if(!ON_SAME_STRAND(i, k, cp)) break;
      u1    = k-i-1;

      minl  = MAX2(k + turn + 1, j - 1 - MAXLOOP + u1);
      kl    = my_iindx[k] - j + 1;

      for (u2 = 0, l=j-1; l>=minl; l--, kl++, u2++){
        if(hc_up[l+1] < u2) break;
        if(hc[jindx[l] + k] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP_ENC){
          if(!ON_SAME_STRAND(l, j, cp)) break;
          type_2 = rtype[(unsigned char)ptype[jindx[l] + k]];

          if(type_2 == 0)
            type_2 = 7;

          q_temp = qb[kl]
                  * scale[u1+u2+2]
                  * exp_E_IntLoop(u1, u2, type, type_2, S_i1, S_j1, S1[k-1], S1[l+1], pf_params);

          if(sc){
            if(sc->exp_energy_up)
              q_temp *= sc->exp_energy_up[i+1][u1]
                        * sc->exp_energy_up[l+1][u2];

            if(sc->exp_f)
              q_temp *= sc->exp_f(i, j, k, l, VRNA_DECOMP_PAIR_IL, sc->data);

            if(sc->exp_energy_stack)
              if((i+1 == k) && (j-1 == l)){
                q_temp *=   sc->exp_energy_stack[i]
                          * sc->exp_energy_stack[k]
                          * sc->exp_energy_stack[l]
                          * sc->exp_energy_stack[j];
              }
          }

          qbt1 += q_temp;
        }
      }
    }

    if(with_gquad){
      /* include all cases where a g-quadruplex may be enclosed by base pair (i,j) */
      if ((!no_close) && ((cp < 0) || ON_SAME_STRAND(i, j, cp))) {
        qbt1 += exp_E_GQuad_IntLoop(i, j, type, S1, G, my_iindx, pf_params)
                * scale[2];
      }
    }

    if(sc && sc->exp_energy_bp){
      qbt1 *= sc->exp_energy_bp[my_iindx[i] - j];
    }


  }
  return qbt1;
}

PRIVATE FLT_OR_DBL
exp_E_int_loop_comparative( vrna_fold_compound_t *vc,
                            int i,
                            int j){

  unsigned char     type_2;
  char              *hc;
  unsigned short    **a2s;
  short             **S, **S5, **S3;
  int               n_seq, s, ij, jij, k,l, u1, u2, kl, maxk, minl, *types,
                    turn, with_gquad, *hc_up, *jindx, *my_iindx;
  FLT_OR_DBL        qbt1, *qb, *scale, qloop;
  vrna_sc_t         **scs;
  vrna_exp_param_t  *pf_params;
  vrna_md_t         *md;

  types       = NULL;
  my_iindx    = vc->iindx;
  jindx       = vc->jindx;
  hc          = vc->hc->matrix;
  hc_up       = vc->hc->up_int;
  pf_params   = vc->exp_params;
  md          = &(pf_params->model_details);
  with_gquad  = md->gquad;
  turn        = md->min_loop_size;
  qb          = vc->exp_matrices->qb;
  scale       = vc->exp_matrices->scale;
  qbt1        = 0.;
  jij         = jindx[j] + i;
  ij          = my_iindx[i] -j;

  /* CONSTRAINED INTERIOR LOOP start */
  if(hc[jij] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP){

    S     = vc->S;                                                             
    S5    = vc->S5;     /*S5[s][i] holds next base 5' of i in sequence s*/
    S3    = vc->S3;     /*Sl[s][i] holds next base 3' of i in sequence s*/
    a2s   = vc->a2s;                                                      
    scs   = vc->scs;
    n_seq = vc->n_seq;
    types = (int *)vrna_alloc(sizeof(int) * n_seq);

    for(s = 0; s < n_seq; s++){
      types[s] = md->pair[S[s][i]][S[s][j]];
      if(types[s] == 0)
        types[s] = 7;
    }

    /* prepare necessary variables */
    maxk  = i + MAXLOOP + 1;
    maxk  = MIN2(maxk, j - turn - 2);
    maxk  = MIN2(maxk, i + 1 + hc_up[i+1]);

    for (k = i + 1; k <= maxk; k++) {
      u1    = k-i-1;

      minl  = MAX2(k + turn + 1, j - 1 - MAXLOOP + u1);
      kl    = my_iindx[k] - j + 1;

      for(l=j-1; l>=minl; l--, kl++, u2++){
        if(hc_up[l+1] < j - l - 1)
          break;

        if(hc[jindx[l] + k] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP_ENC){
          qloop = 1.;

          for(s = 0; s < n_seq; s++){
            u1 = a2s[s][k-1] - a2s[s][i];
            u2 = a2s[s][j-1] - a2s[s][l];
            type_2 = md->pair[S[s][l]][S[s][k]];

            if(type_2 == 0)
              type_2 = 7;

            qloop *= exp_E_IntLoop(u1, u2,
                                types[s], type_2, S3[s][i],
                                S5[s][j], S5[s][k], S3[s][l],
                                pf_params
                              );
          }

          if(scs){
            for(s = 0; s < n_seq; s++){
              if(scs[s]){
                u1 = a2s[s][k-1] - a2s[s][i];
                u2 = a2s[s][j-1] - a2s[s][l];

                if(scs[s]->exp_energy_up)
                  qloop *=    scs[s]->exp_energy_up[a2s[s][i]+1][u1]
                            * scs[s]->exp_energy_up[a2s[s][l]+1][u2];

                if(scs[s]->exp_energy_stack)
                  if(u1 + u2 == 0){
                    if(S[s][i] && S[s][j] && S[s][k] && S[s][l]){ /* don't allow gaps in stack */
                      qloop *=    scs[s]->exp_energy_stack[i]
                                * scs[s]->exp_energy_stack[k]
                                * scs[s]->exp_energy_stack[l]
                                * scs[s]->exp_energy_stack[j];
                    }
                  }
              }
            }
          }

          qbt1 += qb[my_iindx[k] - l] * qloop * scale[k-i+j-l];
        }
      }
    }

    if(with_gquad){
      /* include all cases where a g-quadruplex may be enclosed by base pair (i,j) */
      /* not implemented yet! */
    }

    if(scs){
      for(s = 0; s < n_seq; s++){
        if(scs[s] && scs[s]->exp_energy_bp)
          qbt1 *= scs[s]->exp_energy_bp[ij];
      }
    }
  }

  /* cleanup */
  free(types);

  return qbt1;
}

PUBLIC int
vrna_E_ext_int_loop(vrna_fold_compound_t *vc,
                    int i,
                    int j,
                    int *ip,
                    int *iq){

  unsigned char             type, type_2;
  int                       ij, q, p, e, s, u1, u2, qmin, energy, *rtype, *types,
                            length, *indx, *hc_up, *c, turn, n_seq;
  char                      *ptype, *hc, eval_loop;
  unsigned short            **a2s;
  short                     *S, **SS, **S5, **S3;
  vrna_md_t                 *md;
  vrna_param_t              *P;
  vrna_sc_t                 *sc, **scs;
#ifdef WITH_GEN_HC
  vrna_callback_hc_evaluate *f;
#endif

  length  = vc->length;
  indx    = vc->jindx;
  ptype   = vc->ptype;
  c       = vc->matrices->c;
  hc      = vc->hc->matrix;
  hc_up   = vc->hc->up_int;
  P       = vc->params;
  md      = &(P->model_details);
  turn    = md->min_loop_size;
  types   = NULL;
  ij      = indx[j] + i;
  rtype   = &(md->rtype[0]);
  e       = INF;

#ifdef WITH_GEN_HC
  f = vc->hc->f;
#endif

  /* CONSTRAINED INTERIOR LOOP start */
  if(hc[ij] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP){

    /* prepare necessary variables */
    switch(vc->type){
      case VRNA_VC_TYPE_SINGLE:     type  = rtype[(unsigned char)ptype[ij]];

                                    if(type == 0)
                                      type = 7;

                                    S   = vc->sequence_encoding;
                                    sc  = vc->sc;

                                    break;

      case VRNA_VC_TYPE_ALIGNMENT:  SS    = vc->S;                                                               
                                    S5    = vc->S5;     /*S5[s][i] holds next base 5' of i in sequence s*/
                                    S3    = vc->S3;     /*Sl[s][i] holds next base 3' of i in sequence s*/
                                    a2s   = vc->a2s;                                                      
                                    scs   = vc->scs;
                                    n_seq = vc->n_seq;
                                    types = (int *)vrna_alloc(sizeof(int) * n_seq);

                                    for (s=0; s<n_seq; s++) {
                                      types[s] = md->pair[SS[s][j]][SS[s][i]];
                                      if(types[s] == 0)
                                        types[s] = 7;
                                    }

                                    break;

      default:                      return e;
                                    break;
    }

    for (p = j+1; p < length ; p++) {
      u1 = p-j-1;
      if (u1+i-1>MAXLOOP) break;
      if (hc_up[j+1] < u1) break;

      qmin = u1+i-1+length-MAXLOOP;
      if(qmin < p + turn + 1)
        qmin = p+turn+1;
      for (q = length; q >= qmin; q--) {
        u2 = i-1 + length-q;
        if(hc_up[q+1] < u2)
          break;

        if (u1+u2>MAXLOOP)
          continue;

        eval_loop = hc[indx[q] + p] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP;

#ifdef WITH_GEN_HC
        if(f)
          eval_loop = (f(i, j, p, q, VRNA_DECOMP_PAIR_IL, vc->hc->data)) ? eval_loop : (char)0;
#endif

        if(eval_loop){
          switch(vc->type){
            case VRNA_VC_TYPE_SINGLE:     type_2  = rtype[(unsigned char)ptype[indx[q]+p]];

                                          if(type_2 == 0)
                                            type_2 = 7;

                                          energy  = ubf_eval_ext_int_loop(i, j, p, q,
                                                                          i - 1, j + 1, p - 1, q + 1,
                                                                          S[j+1], S[i-1], S[p-1], S[q+1],
                                                                          type, type_2,
                                                                          length,
                                                                          P, sc);
                                          break;

            case VRNA_VC_TYPE_ALIGNMENT:  for (energy = s=0; s<n_seq; s++) {
                                            type_2 = md->pair[SS[s][q]][SS[s][p]]; /* q,p not p,q! */
                                            if(type_2 == 0)
                                              type_2 = 7;

                                            sc = (scs && scs[s]) ? scs[s] : NULL;

                                            energy += ubf_eval_ext_int_loop(a2s[s][i], a2s[s][j], a2s[s][p], a2s[s][q],
                                                                            a2s[s][i - 1], a2s[s][j + 1], a2s[s][p - 1], a2s[s][q + 1],
                                                                            S3[s][j], S5[s][i], S5[s][p], S3[s][q],
                                                                            types[s], type_2,
                                                                            a2s[s][length],
                                                                            P, sc);

                                          }
                                          break;
          }

          energy += c[indx[q]+p];

          if (energy < e){
            e = energy;
            if((ip != NULL) && (iq != NULL)){
              *ip = p;
              *iq = q;
            }
          }
        }
      }
    }
  }

  free(types);

  return e;
}


PUBLIC int
vrna_E_stack( vrna_fold_compound_t *vc,
              int i,
              int j){

  unsigned char     type, type_2;
  char              *ptype, *hard_constraints, eval_loop;
  unsigned short    **a2s;
  short             *S, **SS;
  int               e, ij, pq, p, q, s, n_seq, cp, *rtype, *indx;
  vrna_sc_t         *sc, **scs;
  vrna_param_t      *P;
  vrna_md_t         *md;
#ifdef WITH_GEN_HC
  vrna_callback_hc_evaluate *f;
#endif

  cp                = vc->cutpoint;
  P                = vc->params;
  md               = &(P->model_details);
  rtype            = &(md->rtype[0]);
  indx             = vc->jindx;
  hard_constraints = vc->hc->matrix;

#ifdef WITH_GEN_HC
  f = vc->hc->f;
#endif

  e         = INF;
  p         = i + 1;
  q         = j - 1;
  ij        = indx[j] + i;
  pq        = indx[q] + p;
  eval_loop = (hard_constraints[pq] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP_ENC) && (hard_constraints[ij] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP);

  if((j - i - 1) < 2){
    return e;
  }

#ifdef WITH_GEN_HC
  if(f)
    eval_loop = (f(i, j, i+1, j-1, VRNA_DECOMP_PAIR_IL, vc->hc->data)) ? eval_loop : (char)0;
#endif

  if(eval_loop){
    switch(vc->type){
      case VRNA_VC_TYPE_SINGLE:     S       = vc->sequence_encoding;
                                    ptype   = vc->ptype;
                                    type    = (unsigned char)ptype[ij];
                                    type_2  = rtype[(unsigned char)ptype[pq]];
                                    sc      = vc->sc;

                                    if(type == 0)
                                      type = 7;
                                    if(type_2 == 0)
                                      type_2 = 7;

                                    if ((cp < 0) || (ON_SAME_STRAND(i, p, cp) && ON_SAME_STRAND(q, j, cp))){ /* regular stack */
                                      e = P->stack[type][type_2];
                                    } else {  /* stack like cofold structure */
                                      short si, sj;
                                      si  = ON_SAME_STRAND(i, i + 1, cp) ? S[i+1] : -1;
                                      sj  = ON_SAME_STRAND(j - 1, j, cp) ? S[j-1] : -1;
                                      e   = E_IntLoop_Co(rtype[type], rtype[type_2],
                                                                    i, j, p, q,
                                                                    cp,
                                                                    si, sj,
                                                                    S[p-1], S[q+1],
                                                                    md->dangles,
                                                                    P);
                                    }

                                    /* add soft constraints */
                                    if(sc){
                                      if(sc->energy_bp)
                                        e += sc->energy_bp[ij];

                                      if(sc->energy_stack)
                                        e +=  sc->energy_stack[i]
                                              + sc->energy_stack[p]
                                              + sc->energy_stack[q]
                                              + sc->energy_stack[j];

                                      if(sc->f)
                                        e += sc->f(i, j, p, q, VRNA_DECOMP_PAIR_IL, sc->data);
                                    }
                                    break;

      case VRNA_VC_TYPE_ALIGNMENT:  n_seq = vc->n_seq;
                                    SS    = vc->S;
                                    a2s   = vc->a2s;
                                    scs   = vc->scs;
                                    e     = 0;
                                    for (s=0; s<n_seq; s++) {
                                      type   = md->pair[SS[s][i]][SS[s][j]];
                                      type_2 = md->pair[SS[s][q]][SS[s][p]]; /* q,p not p,q! */
                                      if(type == 0)
                                        type = 7;
                                      if(type_2 == 0)
                                        type_2 = 7;
                                      e += P->stack[type][type_2];
                                    }

                                    if(scs){
                                      for(s = 0; s < n_seq; s++){
                                        if(scs[s]){
                                          if(scs[s]->energy_bp)
                                            e +=  scs[s]->energy_bp[ij];

                                          if(scs[s]->energy_stack){
                                            if(SS[s][i] && SS[s][j] && SS[s][p] && SS[s][q]){ /* don't allow gaps in stack */
                                              e +=  scs[s]->energy_stack[a2s[s][i]]
                                                    + scs[s]->energy_stack[a2s[s][p]]
                                                    + scs[s]->energy_stack[a2s[s][q]]
                                                    + scs[s]->energy_stack[a2s[s][j]];
                                            }
                                          }
                                          if(scs[s]->f)
                                            e += scs[s]->f(a2s[s][i], a2s[s][j], a2s[s][p], a2s[s][q], VRNA_DECOMP_PAIR_IL, scs[s]->data);

                                        }
                                      }
                                    }
                                    break;

      default:                      break;
    }
  }

  return e;
}



PUBLIC int
vrna_BT_stack(vrna_fold_compound_t *vc,
              int *i,
              int *j,
              int *en,
              vrna_bp_stack_t *bp_stack,
              int *stack_count){

  unsigned char type, type_2;
  char          *ptype, eval_loop;
  int           ij, p, q, *idx, *my_c, *rtype, cp;
  vrna_param_t  *P;
  vrna_md_t     *md;
  vrna_hc_t     *hc;
  vrna_sc_t     *sc;
#ifdef WITH_GEN_HC
  vrna_callback_hc_evaluate *f;
#endif

  cp    = vc->cutpoint;
  idx   = vc->jindx;
  P     = vc->params;
  md    = &(P->model_details);
  hc    = vc->hc;
  sc    = vc->sc;
  my_c  = vc->matrices->c;
  ij    = idx[*j] + *i;
  ptype = vc->ptype;
  type  = (unsigned char)ptype[ij];
  rtype = &(md->rtype[0]);
  p     = *i + 1;
  q     = *j - 1;

#ifdef WITH_GEN_HC
  f     = vc->hc->f;
#endif

  if(my_c[ij] == *en){ /*  always true, if (i.j) closes canonical structure,
                          thus (i+1.j-1) must be a pair
                      */
    eval_loop =     (hc->matrix[ij] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP)
                &&  (hc->matrix[idx[q] + p] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP_ENC);

#ifdef WITH_GEN_HC
    if(f)
      eval_loop = (f(*i, *j, p, q, VRNA_DECOMP_PAIR_IL, hc->data)) ? eval_loop : (char)0;
#endif

    if(eval_loop){
      type_2 = ptype[idx[q] + p];
      type_2 = rtype[type_2];

      if(type == 0)
        type = 7;
      if(type_2 == 0)
        type_2 = 7;

      if ((cp < 0) || (ON_SAME_STRAND(*i, p, cp) && ON_SAME_STRAND(q, *j, cp))){ /* regular stack */
        *en    -= P->stack[type][type_2];
      } else { /* stack like cofold structure */
        short si, sj, *S;
        S     = vc->sequence_encoding;
        si    = ON_SAME_STRAND(*i, p, cp) ? S[p] : -1;
        sj    = ON_SAME_STRAND(q, *j, cp) ? S[q] : -1;
        *en  -= E_IntLoop_Co(rtype[type], rtype[type_2],
                                      *i, *j, p, q,
                                      cp,
                                      si, sj,
                                      S[p-1], S[q+1],
                                      md->dangles,
                                      P);
      
      }

      if(sc){
        if(sc->energy_bp)
          *en -= sc->energy_bp[ij];
        if(sc->energy_stack)
          *en -=    sc->energy_stack[*i]
                  + sc->energy_stack[p]
                  + sc->energy_stack[q]
                  + sc->energy_stack[*j];
        if(sc->f)
          *en -= sc->f(*i, *j, p, q, VRNA_DECOMP_PAIR_IL, sc->data);
      }
      bp_stack[++(*stack_count)].i = p;
      bp_stack[(*stack_count)].j   = q;
      (*i)++;
      (*j)--;
      return 1;
    }
  }

  return 0;
}

PUBLIC int
vrna_BT_int_loop( vrna_fold_compound_t *vc,
                  int *i,
                  int *j,
                  int en,
                  vrna_bp_stack_t *bp_stack,
                  int *stack_count){

  unsigned char type, type_2;
  char          *ptype, eval_loop;
  short         *S1;
  int           cp, ij, p, q, minq, turn, *idx, noGUclosure, no_close,
                energy, newX, *my_c, *rtype;
  vrna_param_t  *P;
  vrna_md_t     *md;
  vrna_hc_t     *hc;
  vrna_sc_t     *sc;
#ifdef WITH_GEN_HC
  vrna_callback_hc_evaluate *f;
#endif

  cp          = vc->cutpoint;
  idx         = vc->jindx;
  P           = vc->params;
  md          = &(P->model_details);
  hc          = vc->hc;
  sc          = vc->sc;
  my_c        = vc->matrices->c;
  turn        = md->min_loop_size;
  ij          = idx[*j] + *i;
  ptype       = vc->ptype;
  type        = (unsigned char)ptype[ij];
  rtype       = &(md->rtype[0]);
  S1          = vc->sequence_encoding;
  noGUclosure = md->noGUclosure;
  no_close    = (((type==3)||(type==4))&&noGUclosure);

#ifdef WITH_GEN_HC
  f           = vc->hc->f;
#endif

  if(hc->matrix[ij] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP){

    if(type == 0)
      type = 7;

    for (p = *i+1; p <= MIN2(*j-2-turn,*i+MAXLOOP+1); p++) {
      minq = *j-*i+p-MAXLOOP-2;
      if (minq<p+1+turn)
        minq = p+1+turn;

      if(hc->up_int[*i+1] < (p - *i - 1))
        break;

      for (q = *j-1; q >= minq; q--) {
        if(hc->up_int[q+1] < (*j - q - 1))
          break;

        type_2 = (unsigned char)ptype[idx[q]+p];
        eval_loop = hc->matrix[idx[q]+p] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP_ENC;

#ifdef WITH_GEN_HC
        if(f)
          eval_loop = (f(*i, *j, p, q, VRNA_DECOMP_PAIR_IL, hc->data)) ? eval_loop : (char)0;
#endif

        if(!eval_loop)
          continue;

        type_2 = rtype[type_2];

        if(type_2 == 0)
          type_2 = 7;

        if(noGUclosure)
          if(no_close||(type_2==3)||(type_2==4))
            if((p>*i+1)||(q<*j-1))
              continue;  /* continue unless stack */

        energy = ubf_eval_int_loop( *i, *j, p, q,
                                    (*i) + 1, (*j) - 1, p - 1, q + 1,
                                    S1[*i+1], S1[*j-1], S1[p-1], S1[q+1],
                                    type, type_2,
                                    rtype,
                                    ij,
                                    -1,
                                    P,
                                    sc);
        newX = energy + my_c[idx[q]+p];

        if(newX == en){
          bp_stack[++(*stack_count)].i = p;
          bp_stack[(*stack_count)].j   = q;
          if(sc)
            if(sc->bt){
              vrna_basepair_t *ptr, *aux_bps;
              aux_bps = sc->bt(*i, *j, p, q, VRNA_DECOMP_PAIR_IL, sc->data);
              for(ptr = aux_bps; ptr && ptr->i != 0; ptr++){
                bp_stack[++(*stack_count)].i = ptr->i;
                bp_stack[(*stack_count)].j   = ptr->j;
              }
              free(aux_bps);
            }
          *i = p, *j = q;
          return 1; /* success */
        }
      }
    }

  }
  /* is it a g-quadruplex? */
  if(md->gquad){
    /*
      The case that is handled here actually resembles something like
      an interior loop where the enclosing base pair is of regular
      kind and the enclosed pair is not a canonical one but a g-quadruplex
      that should then be decomposed further...
    */
    if(ON_SAME_STRAND(*i, *j, cp))
      if(vrna_BT_gquad_int(vc, *i, *j, en, bp_stack, stack_count)){
        *i = *j = -1; /* tell the calling block to continue backtracking with next block */
        return 1;
      }
  }
  
  return 0; /* unsuccessful */
}


/138            0           0     0     644     64822     `

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif


#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include "utils.h"
#include "fold_vars.h"
#include "energy_par.h"
#include "constraints.h"
#include "exterior_loops.h"
#include "gquad.h"
#include "multibranch_loops.h"

#ifdef ON_SAME_STRAND
#undef ON_SAME_STRAND
#endif

#define ON_SAME_STRAND(I,J,C)  (((I)>=(C))||((J)<(C)))


PRIVATE int
E_mb_loop_fast( vrna_fold_compound_t *vc,
                int i,
                int j,
                int *dmli1,
                int *dmli2);

PRIVATE int
E_mb_loop_fast_comparative( vrna_fold_compound_t *vc,
                            int i,
                            int j,
                            int *dmli1,
                            int *dmli2);

PRIVATE FLT_OR_DBL
exp_E_mb_loop_fast( vrna_fold_compound_t *vc,
                    int i,
                    int j,
                    FLT_OR_DBL *qqm1);

PRIVATE FLT_OR_DBL
exp_E_mb_loop_fast_comparative( vrna_fold_compound_t *vc,
                                int i,
                                int j,
                                FLT_OR_DBL *qqm1);

PRIVATE int
E_ml_stems_fast(vrna_fold_compound_t *vc,
                int i,
                int j,
                int *fmi,
                int *dmli);

PRIVATE int
E_ml_stems_fast_comparative(vrna_fold_compound_t *vc,
                            int i,
                            int j,
                            int *fmi,
                            int *dmli);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PUBLIC int
vrna_E_mb_loop_fast(vrna_fold_compound_t *vc,
                    int i,
                    int j,
                    int *dmli1,
                    int *dmli2){

  int e = INF;

  if(vc){
    switch(vc->type){
      case VRNA_VC_TYPE_SINGLE:
        e = E_mb_loop_fast(vc, i, j, dmli1, dmli2);
        break;

      case VRNA_VC_TYPE_ALIGNMENT:
        e = E_mb_loop_fast_comparative(vc, i, j, dmli1, dmli2);
        break;
    }
  }

  return e;
}


PUBLIC int
vrna_E_ml_stems_fast( vrna_fold_compound_t *vc,
                      int i,
                      int j,
                      int *fmi,
                      int *dmli){

  int e = INF;

  if(vc){
    switch(vc->type){
      case VRNA_VC_TYPE_SINGLE:
        e = E_ml_stems_fast(vc, i, j, fmi, dmli);
        break;

      case VRNA_VC_TYPE_ALIGNMENT:
        e = E_ml_stems_fast_comparative(vc, i, j, fmi, dmli);
        break;
    }
  }

  return e;
}


PUBLIC FLT_OR_DBL
vrna_exp_E_mb_loop_fast( vrna_fold_compound_t *vc,
                    int i,
                    int j,
                    FLT_OR_DBL *qqm1){

  FLT_OR_DBL q = 0.;

  if(vc){
    switch(vc->type){
      case VRNA_VC_TYPE_SINGLE:
        q = exp_E_mb_loop_fast(vc, i, j, qqm1);
        break;

      case VRNA_VC_TYPE_ALIGNMENT:
        q = exp_E_mb_loop_fast_comparative(vc, i, j, qqm1);
        break;
    }
  }

  return q;
}


PRIVATE int
E_mb_loop_fast_comparative( vrna_fold_compound_t *vc,
                            int i,
                            int j,
                            int *dmli1,
                            int *dmli2){

  char          *hard_constraints;
  short         **S, **S5, **S3;
  int           ij, *indx, e, decomp, s, n_seq, dangle_model, *type;
  vrna_param_t  *P;
  vrna_md_t     *md;
  vrna_sc_t     **scs;

  n_seq             = vc->n_seq;
  indx              = vc->jindx;
  hard_constraints  = vc->hc->matrix;
  P                 = vc->params;
  md                = &(P->model_details);
  scs               = vc->scs;
  dangle_model      = md->dangles;
  ij                = indx[j] + i;
  e                 = INF;

  /* multi-loop decomposition ------------------------*/
  if(hard_constraints[ij] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP){
    decomp = dmli1[j-1];

    type  = (int *)vrna_alloc(n_seq * sizeof(int));
    S     = vc->S;
    S5    = vc->S5;     /*S5[s][i] holds next base 5' of i in sequence s*/
    S3    = vc->S3;     /*Sl[s][i] holds next base 3' of i in sequence s*/

    for(s = 0; s < n_seq; s++){
      type[s] = md->pair[S[s][j]][S[s][i]];
      if(type[s] == 0)
        type[s] = 7;
    }

    if(dangle_model){
      for(s = 0; s < n_seq; s++){
        decomp += E_MLstem(type[s], S5[s][j], S3[s][i], P);
      }
    }
    else{
      for(s = 0; s < n_seq; s++){
        decomp += E_MLstem(type[s], -1, -1, P);
      }
    }
    if(scs)
      for(s = 0; s < n_seq; s++){
        if(scs[s]){
          if(scs[s]->energy_bp)
            decomp += scs[s]->energy_bp[indx[j] + i];
        }
      }

    free(type);

    e = decomp + n_seq * P->MLclosing;
  }

  return e;
}


PRIVATE int
E_mb_loop_fast( vrna_fold_compound_t *vc,
                int i,
                int j,
                int *dmli1,
                int *dmli2){

  unsigned char type, tt;
  char          *ptype, *hc, eval_loop, el;
  short         S_i1, S_j1, *S;
  int           decomp, en, e, cp, *indx, *hc_up, *fc, ij, hc_decompose,
                dangle_model, *rtype;
  vrna_sc_t     *sc;
  vrna_param_t  *P;
#ifdef WITH_GEN_HC
  vrna_callback_hc_evaluate *f;
#endif

  cp            = vc->cutpoint;
  ptype         = vc->ptype;
  S             = vc->sequence_encoding;
  indx          = vc->jindx;
  hc            = vc->hc->matrix;
  hc_up         = vc->hc->up_ml;
  sc            = vc->sc;
  fc            = vc->matrices->fc;
  P             = vc->params;
  ij            = indx[j] + i;
  hc_decompose  = hc[ij];
  dangle_model  = P->model_details.dangles;
  rtype         = &(P->model_details.rtype[0]);
  type          = (unsigned char)ptype[ij];
  /* init values */
  e             = INF;
  decomp        = INF;

#ifdef WITH_GEN_HC
  f  = vc->hc->f;
#endif

  if(cp < 0){
    S_i1    = S[i+1];
    S_j1    = S[j-1];
  } else {
    S_i1  = ON_SAME_STRAND(i, i + 1, cp) ? S[i+1] : -1;
    S_j1  = ON_SAME_STRAND(j - 1, j, cp) ? S[j-1] : -1;
  }

  if((S_i1 >= 0) && (S_j1 >= 0)){ /* regular multi branch loop */

    eval_loop = hc_decompose & VRNA_CONSTRAINT_CONTEXT_MB_LOOP;
    el        = eval_loop;

#ifdef WITH_GEN_HC
    if(f)
      el = (f(i, j, i+1, j-1, VRNA_DECOMP_PAIR_ML, vc->hc->data)) ? el : (char)0;
#endif

    if(el){
      decomp = dmli1[j-1];
      tt = rtype[type];

      if(tt == 0)
        tt = 7;

      if(decomp != INF){
        switch(dangle_model){
          /* no dangles */
          case 0:   decomp += E_MLstem(tt, -1, -1, P);
                    if(sc){
                      if(sc->energy_bp)
                        decomp += sc->energy_bp[ij];

                      if(sc->f)
                        decomp += sc->f(i, j, i+1, j-1, VRNA_DECOMP_PAIR_ML, sc->data);
                    }
                    break;

          /* double dangles */
          case 2:   decomp += E_MLstem(tt, S_j1, S_i1, P);
                    if(sc){
                      if(sc->energy_bp)
                        decomp += sc->energy_bp[ij];

                      if(sc->f)
                        decomp += sc->f(i, j, i+1, j-1, VRNA_DECOMP_PAIR_ML, sc->data);
                    }
                    break;

          /* normal dangles, aka dangles = 1 || 3 */
          default:  decomp += E_MLstem(tt, -1, -1, P);
                    if(sc){
                      if(sc->energy_bp)
                        decomp += sc->energy_bp[ij];

                      if(sc->f)
                        decomp += sc->f(i, j, i+1, j-1, VRNA_DECOMP_PAIR_ML, sc->data);
                    }
                    break;
        }
      }
    }

    if(dangle_model % 2){  /* dangles == 1 || dangles == 3 */

      el = eval_loop;
      el = (hc_up[i + 1] > 0) ? el : (char)0;

#ifdef WITH_GEN_HC
      if(f)
        el = (f(i, j, i+2, j-1, VRNA_DECOMP_PAIR_ML, vc->hc->data)) ? el : (char)0;
#endif

      if(el){
        if(dmli2[j-1] != INF){
          tt = rtype[type];

          if(tt == 0)
            tt = 7;

          en = dmli2[j-1] + E_MLstem(tt, -1, S_i1, P) + P->MLbase;
          if(sc){
            if(sc->energy_up)
              en += sc->energy_up[i+1][1];

            if(sc->energy_bp)
              en += sc->energy_bp[ij];

            if(sc->f)
              en += sc->f(i, j, i+2, j-1, VRNA_DECOMP_PAIR_ML, sc->data);
          }
          decomp = MIN2(decomp, en);
        }
      }

      el = eval_loop;
      el = ((hc_up[i + 1] > 0) && (hc_up[j-1] > 0)) ? el : (char)0;

#ifdef WITH_GEN_HC
      if(f)
        el = (f(i, j, i+2, j-2, VRNA_DECOMP_PAIR_ML, vc->hc->data)) ? el : (char)0;
#endif

      if(el){
        if(dmli2[j-2] != INF){
          tt = rtype[type];

          if(tt == 0)
            tt = 7;

          en = dmli2[j-2] + E_MLstem(tt, S_j1, S_i1, P) + 2*P->MLbase;
          if(sc){
            if(sc->energy_up)
              en += sc->energy_up[i+1][1]
                    + sc->energy_up[j-1][1];

            if(sc->energy_bp)
              en += sc->energy_bp[ij];

            if(sc->f)
              en += sc->f(i, j, i+2, j-2, VRNA_DECOMP_PAIR_ML, sc->data);
          }
          decomp = MIN2(decomp, en);
        }
      }

      el = eval_loop;
      el = (hc_up[j-1] > 0) ? el : (char)0;

#ifdef WITH_GEN_HC
      if(f)
        el = (f(i, j, i+1, j-2, VRNA_DECOMP_PAIR_ML, vc->hc->data)) ? el : (char)0;
#endif

      if(el){
        if(dmli1[j-2] != INF){
          tt = rtype[type];

          if(tt == 0)
            tt = 7;

          en = dmli1[j-2] + E_MLstem(tt, S_j1, -1, P) + P->MLbase;
          if(sc){
            if(sc->energy_up)
              en += sc->energy_up[j-1][1];

            if(sc->energy_bp)
              en += sc->energy_bp[ij];

            if(sc->f)
              en += sc->f(i, j, i+1, j-2, VRNA_DECOMP_PAIR_ML, sc->data);
          }
          decomp = MIN2(decomp, en);
        }
      }

    } /* end if dangles % 2 */

    if(decomp != INF)
      e = decomp + P->MLclosing;

  } /* end regular multibranch loop */

  if(!ON_SAME_STRAND(i, j, cp)){ /* multibrach like cofold structure with cut somewhere between i and j */

    eval_loop = hc_decompose & VRNA_CONSTRAINT_CONTEXT_MB_LOOP;
    el        = eval_loop;

#ifdef WITH_GEN_HC
    if(f)
      el = (f(i, j, i+1, j-1, VRNA_DECOMP_PAIR_ML, vc->hc->data)) ? el : (char)0;
#endif

    if(el){
      if((fc[i+1] != INF) && (fc[j-1] != INF)){
        decomp = fc[i+1] + fc[j-1];
        tt = rtype[type];

        if(tt == 0)
          tt = 7;

        switch(dangle_model){
          case 0:   decomp += E_ExtLoop(tt, -1, -1, P);
                    break;
          case 2:   decomp += E_ExtLoop(tt, S_j1, S_i1, P);
                    break;
          default:  decomp += E_ExtLoop(tt, -1, -1, P);
                    break;
        }
      }
    }

    if(dangle_model % 2){ /* dangles == 1 || dangles == 3 */
      el  = eval_loop;
      el  = (hc_up[i+1] > 0) ? el : (char)0;

#ifdef WITH_GEN_HC
      if(f)
        el = (f(i, j, i+2, j-1, VRNA_DECOMP_PAIR_ML, vc->hc->data)) ? el : (char)0;
#endif

      if(el){
        if((fc[i+2] != INF) && (fc[j-1] != INF)){
          tt = rtype[type];

          if(tt == 0)
            tt = 7;

          en     = fc[i+2] + fc[j-1] + E_ExtLoop(tt, -1, S_i1, P);
          decomp = MIN2(decomp, en);
        }
      }

      el  = eval_loop;
      el  = (hc_up[j-1] > 0) ? el : (char)0;

#ifdef WITH_GEN_HC
      if(f)
        el = (f(i, j, i+1, j-2, VRNA_DECOMP_PAIR_ML, vc->hc->data)) ? el : (char)0;
#endif

      if(el){
        if((fc[i+1] != INF) && (fc[j-2] != INF)){
          tt = rtype[type];

          if(tt == 0)
            tt = 7;

          en     = fc[i+1] + fc[j-2] + E_ExtLoop(tt, S_j1, -1, P);
          decomp = MIN2(decomp, en);
        }
      }

      el  = eval_loop;
      el  = ((hc_up[i+1] > 0) && (hc_up[j-1] > 0)) ? el : (char)0;

#ifdef WITH_GEN_HC
      if(f)
        el = (f(i, j, i+2, j-2, VRNA_DECOMP_PAIR_ML, vc->hc->data)) ? el : (char)0;
#endif

      if(el){
        if((fc[i+2] != INF) && (fc[j-2] != INF)){
          tt = rtype[type];

          if(tt == 0)
            tt = 7;

          en     = fc[i+2] + fc[j-2] + E_ExtLoop(tt, S_j1, S_i1, P);
          decomp = MIN2(decomp, en);
        }
      }
    }

    e = MIN2(e, decomp);
  }
  return e;
}

PUBLIC int
E_mb_loop_stack(int i,
                int j,
                vrna_fold_compound_t *vc){

  unsigned char type, type_2;
  char          eval_loop, el, *hc, *ptype;
  int           e, decomp, en, i1k, k1j1, ij, k, *indx, *c, *fML, turn, *rtype;
  vrna_param_t  *P;
  vrna_md_t     *md;
  vrna_sc_t     *sc;
#ifdef WITH_GEN_HC
  vrna_callback_hc_evaluate *f;
#endif

  indx  = vc->jindx;
  hc    = vc->hc->matrix;
  c     = vc->matrices->c;
  fML   = vc->matrices->fML;
  P     = vc->params;
  md    = &(P->model_details);
  turn  = md->min_loop_size;
  ptype = vc->ptype;
  rtype = &(md->rtype[0]);
  sc    = vc->sc;
  e     = INF;
  ij    = indx[j] + i;
  type  = ptype[ij];

#ifdef WITH_GEN_HC
  f = vc->hc->f;
#endif

  eval_loop = hc[ij] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP;

#ifdef WITH_GEN_HC
  if(f)
    eval_loop = (f(i, j, i+1, j-1, VRNA_DECOMP_PAIR_ML, vc->hc->data)) ? eval_loop : (char)0;
#endif

  if(eval_loop){
    if(type == 0)
      type = 7;

    decomp = INF;
    k1j1  = indx[j-1] + i + 2 + turn + 1;
    for (k = i+2+turn; k < j-2-turn; k++, k1j1++){
      i1k   = indx[k] + i + 1;

      /* honour generalized hard constraint */
      el    = hc[i1k] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC;

#ifdef WITH_GEN_HC
      if(f)
        el = (f(i, j, i+1, k, VRNA_DECOMP_ML_COAXIAL, vc->hc->data)) ? el : (char)0;
#endif

      if(el){
        type_2  = rtype[(unsigned char)ptype[i1k]];

        if(type_2 == 0)
          type_2 = 7;

        en      = c[i1k]+P->stack[type][type_2]+fML[k1j1];
        if(sc){
          if(sc->f)
            en += sc->f(i, j, i+1, k, VRNA_DECOMP_ML_COAXIAL, sc->data);
        }
        decomp  = MIN2(decomp, en);
      }

      el    = hc[k1j1] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC;

#ifdef WITH_GEN_HC
      if(f)
        el = (f(i, j, k+1, j-1, VRNA_DECOMP_ML_COAXIAL, vc->hc->data)) ? el : (char)0;
#endif

      if(el){
        type_2  = rtype[(unsigned char)ptype[k1j1]];

        if(type_2 == 0)
          type_2 = 7;

        en      = c[k1j1]+P->stack[type][type_2]+fML[i1k];
        if(sc){
          if(sc->f)
            en += sc->f(i, j, k+1, j-1, VRNA_DECOMP_ML_COAXIAL, sc->data);
        }
        decomp  = MIN2(decomp, en);
      }
    }
    /* no TermAU penalty if coax stack */
    decomp += 2*P->MLintern[1] + P->MLclosing;
    if(sc){
      if(sc->energy_bp)
        decomp += sc->energy_bp[ij];
      if(sc->f)
        decomp += sc->f(i, j, i+1, j-1, VRNA_DECOMP_PAIR_ML, sc->data);
    }
    e = decomp;

  }
  return e;
}

PUBLIC int
E_ml_rightmost_stem(int i,
                    int j,
                    vrna_fold_compound_t *vc){

  char              eval_loop, *hc;
  short             *S;
  int               en, length, *indx, *hc_up, *c, *fm, *ggg, ij, type, hc_decompose,
                    dangle_model, with_gquad, cp, e;
  vrna_param_t      *P;
  vrna_sc_t         *sc;
#ifdef WITH_GEN_HC
  vrna_callback_hc_evaluate *f;
#endif

  P             = vc->params;
  length        = vc->length;
  S             = vc->sequence_encoding;
  indx          = vc->jindx;
  hc            = vc->hc->matrix;
  hc_up         = vc->hc->up_ml;
  sc            = vc->sc;
  c             = vc->matrices->c;
  fm            = (P->model_details.uniq_ML) ? vc->matrices->fM1 : vc->matrices->fML;
  ggg           = vc->matrices->ggg;
  ij            = indx[j] + i;
  type          = vc->ptype[ij];
  hc_decompose  = hc[ij];
  dangle_model  = P->model_details.dangles;
  with_gquad    = P->model_details.gquad;
  cp            = vc->cutpoint;
  e             = INF;

#ifdef WITH_GEN_HC
  f = vc->hc->f;
#endif

  if(ON_SAME_STRAND(i - 1, i, cp)){
    if(ON_SAME_STRAND(j, j + 1, cp)){
      eval_loop = hc_decompose & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC;

#ifdef WITH_GEN_HC
      if(f)
        eval_loop = (f(i, j, i, j, VRNA_DECOMP_ML_STEM, vc->hc->data)) ? eval_loop : (char)0;
#endif

      if(eval_loop){

        if(type == 0)
          type = 7;

        e = c[ij];
        if(e != INF){
          switch(dangle_model){
            case 2:   e += E_MLstem(type, (i==1) ? S[length] : S[i-1], S[j+1], P);
                      break;
            default:  e += E_MLstem(type, -1, -1, P);
                      break;
          }
          if(sc){
            if(sc->f)
              e += sc->f(i, j, i, j, VRNA_DECOMP_ML_STEM, sc->data);
          }
        }
      }

      if(with_gquad)
        if(ON_SAME_STRAND(i, j, cp)){
          en  = ggg[ij] + E_MLstem(0, -1, -1, P);
          e   = MIN2(e, en);
        }

    }

    if(ON_SAME_STRAND(j - 1, j, cp)){
      eval_loop = (hc_up[j] > 0) ? (char)1 : (char)0;

#ifdef WITH_GEN_HC
      if(f)
        eval_loop = (f(i, j, i, j-1, VRNA_DECOMP_ML_ML, vc->hc->data)) ? eval_loop : (char)0;
#endif

      if(eval_loop){
        if(fm[indx[j - 1] + i] != INF){
          en = fm[indx[j - 1] + i] + P->MLbase;
          if(sc){
            if(sc->energy_up)
              en += sc->energy_up[j][1];
            if(sc->f)
              en += sc->f(i, j, i, j-1, VRNA_DECOMP_ML_ML, sc->data);
          }
          e = MIN2(e, en);
        }
      }
    }
  }
  return e;
}

PRIVATE int
E_ml_stems_fast(vrna_fold_compound_t *vc,
                int i,
                int j,
                int *fmi,
                int *dmli){

  char          *ptype, *hc, eval_loop;
  short         *S;
  int           k, en, decomp, mm5, mm3, type_2, k1j, stop, length, *indx, *hc_up,
                *c, *fm, ij, dangle_model, turn, type, *rtype, circular, cp, e;
  vrna_sc_t     *sc;
  vrna_param_t  *P;
#ifdef WITH_GEN_HC
  vrna_callback_hc_evaluate *f;
#endif

  length        = (int)vc->length;
  ptype         = vc->ptype;
  S             = vc->sequence_encoding;
  indx          = vc->jindx;
  hc            = vc->hc->matrix;
  hc_up         = vc->hc->up_ml;
  sc            = vc->sc;
  c             = vc->matrices->c;
  fm            = vc->matrices->fML;
  P             = vc->params;
  ij            = indx[j] + i;
  dangle_model  = P->model_details.dangles;
  turn          = P->model_details.min_loop_size;
  type          = ptype[ij];
  rtype         = &(P->model_details.rtype[0]);
  circular      = P->model_details.circ;
  cp            = vc->cutpoint;
  e             = INF;

#ifdef WITH_GEN_HC
  f = vc->hc->f;
#endif

  /*  extension with one unpaired nucleotide at the right (3' site)
      or full branch of (i,j)
  */
  e = E_ml_rightmost_stem(i,j,vc);

  /*  extension with one unpaired nucleotide at 5' site
      and all other variants which are needed for odd
      dangle models
  */
  if(ON_SAME_STRAND(i - 1, i, cp)){

    if(ON_SAME_STRAND(i, i + 1, cp)){
      eval_loop = (hc_up[i] > 0) ? (char)1 : (char)0;

#ifdef WITH_GEN_HC
      if(f)
        eval_loop = (f(i, j, i+1, j, VRNA_DECOMP_ML_ML, vc->hc->data)) ? eval_loop : (char)0;
#endif

      if(eval_loop){
        if(fm[ij + 1] != INF){
          en = fm[ij + 1] + P->MLbase;
          if(sc){
            if(sc->energy_up)
              en += sc->energy_up[i][1];
            if(sc->f)
              en += sc->f(i, j, i+1, j, VRNA_DECOMP_ML_ML, sc->data);
          }
          e = MIN2(e, en);
        }

      }
    }

    if(dangle_model % 2){ /* dangle_model = 1 || 3 */

      mm5 = ((i>1) || circular) ? S[i] : -1;
      mm3 = ((j<length) || circular) ? S[j] : -1;

      if(ON_SAME_STRAND(i, i + 1, cp)){
        eval_loop = hc[ij+1] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC;
        eval_loop = (hc_up[i] > 0) ? eval_loop : (char)0;

#ifdef WITH_GEN_HC
        if(f)
          eval_loop = (f(i, j, i+1, j, VRNA_DECOMP_ML_STEM, vc->hc->data)) ? eval_loop : (char)0;
#endif

        if(eval_loop){
          if(c[ij+1] != INF){
            type = ptype[ij+1];

            if(type == 0)
              type = 7;

            en = c[ij+1] + E_MLstem(type, mm5, -1, P) + P->MLbase;
            if(sc){
              if(sc->energy_up)
                en += sc->energy_up[i][1];
              if(sc->f)
                en += sc->f(i, j, i+1, j, VRNA_DECOMP_ML_STEM, sc->data);
            }
            e = MIN2(e, en);
          }
        }
      }

      if(ON_SAME_STRAND(j - 1, j, cp)){
        eval_loop = hc[indx[j-1]+i] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC;
        eval_loop = (hc_up[j] > 0) ? eval_loop : (char)0;

#ifdef WITH_GEN_HC
        if(f)
          eval_loop = (f(i, j, i, j-1, VRNA_DECOMP_ML_STEM, vc->hc->data)) ? eval_loop : (char)0;
#endif

        if(eval_loop){
          if(c[indx[j-1]+i] != INF){
            type = ptype[indx[j-1]+i];

            if(type == 0)
              type = 7;

            en = c[indx[j-1]+i] + E_MLstem(type, -1, mm3, P) + P->MLbase;
            if(sc){
              if(sc->energy_up)
                en += sc->energy_up[j][1];
              if(sc->f)
                en += sc->f(i, j, i, j-1, VRNA_DECOMP_ML_STEM, sc->data);
            }
            e = MIN2(e, en);
          }
        }
      }

      if(ON_SAME_STRAND(j - 1, j, cp) && ON_SAME_STRAND(i, i + 1, cp)){
        eval_loop = hc[indx[j-1]+i+1] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC;
        eval_loop = (hc_up[i] && hc_up[j]) ? eval_loop : (char)0;

#ifdef WITH_GEN_HC
        if(f)
          eval_loop = (f(i, j, i+1, j-1, VRNA_DECOMP_ML_STEM, vc->hc->data)) ? eval_loop : (char)0;
#endif

        if(eval_loop){
          if(c[indx[j-1]+i+1] != INF){
            type = ptype[indx[j-1]+i+1];

            if(type == 0)
              type = 7;

            en = c[indx[j-1]+i+1] + E_MLstem(type, mm5, mm3, P) + 2*P->MLbase;
            if(sc){
              if(sc->energy_up)
                en += sc->energy_up[j][1] + sc->energy_up[i][1];
              if(sc->f)
                en += sc->f(i, j, i+1, j-1, VRNA_DECOMP_ML_STEM, sc->data);
            }
            e = MIN2(e, en);
          }
        }
      }
    } /* end special cases for dangles == 1 || dangles == 3 */
  }

  /* modular decomposition -------------------------------*/
  k1j   = indx[j] + i + turn + 2;
  stop  = (cp > 0) ? (cp - 1) : (j - 2 - turn);

  /* duplicated code is faster than conditions in loop */
  if(sc && sc->f){
    for (decomp = INF, k = i + 1 + turn; k <= stop; k++, k1j++){
      if((fmi[k] != INF ) && (fm[k1j] != INF)){
        en = fmi[k] + fm[k1j];
        en += sc->f(i, j, k, k+1, VRNA_DECOMP_ML_ML_ML, sc->data);
        decomp = MIN2(decomp, en);
      }
    }
    k++; k1j++;
    for (;k <= j - 2 - turn; k++, k1j++){
      if((fmi[k] != INF) && (fm[k1j] != INF)){
        en = fmi[k] + fm[k1j];
        en += sc->f(i, j, k, k+1, VRNA_DECOMP_ML_ML_ML, sc->data);
        decomp = MIN2(decomp, en);
      }
    }
  } else {
    for (decomp = INF, k = i + 1 + turn; k <= stop; k++, k1j++){
      if((fmi[k] != INF ) && (fm[k1j] != INF)){
        en = fmi[k] + fm[k1j];
        decomp = MIN2(decomp, en);
      }
    }
    k++; k1j++;
    for (;k <= j - 2 - turn; k++, k1j++){
      if((fmi[k] != INF) && (fm[k1j] != INF)){
        en = fmi[k] + fm[k1j];
        decomp = MIN2(decomp, en);
      }
    }
  }


  dmli[j] = decomp;               /* store for use in fast ML decompositon */
  e = MIN2(e, decomp);

  /* coaxial stacking */
  if (dangle_model==3) {
    /* additional ML decomposition as two coaxially stacked helices */
    int ik;
    k1j = indx[j]+i+turn+2;
    for (decomp = INF, k = i + 1 + turn; k <= stop; k++, k1j++){
      ik = indx[k]+i;
      if((hc[ik] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC) && (hc[k1j] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC)){
        type    = rtype[(unsigned char)ptype[ik]];
        type_2  = rtype[(unsigned char)ptype[k1j]];

        if(type == 0)
          type = 7;
        if(type_2 == 0)
          type_2 = 7;

        en      = c[ik] + c[k1j] + P->stack[type][type_2];
        if(sc){
          if(sc->f)
            en += sc->f(i, k, k+1, j, VRNA_DECOMP_ML_COAXIAL, sc->data);
        }
        decomp  = MIN2(decomp, en);
      }
    }
    k++; k1j++;
    for (; k <= j-2-turn; k++, k1j++){
      ik = indx[k]+i;
      if((hc[ik] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC) && (hc[k1j] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC)){
        type    = rtype[(unsigned char)ptype[ik]];
        type_2  = rtype[(unsigned char)ptype[k1j]];

        if(type == 0)
          type = 7;
        if(type_2 == 0)
          type_2 = 7;

        en      = c[ik] + c[k1j] + P->stack[type][type_2];
        if(sc){
          if(sc->f)
            en += sc->f(i, k, k+1, j, VRNA_DECOMP_ML_COAXIAL, sc->data);
        }
        decomp  = MIN2(decomp, en);
      }
    }

    decomp += 2*P->MLintern[1];        /* no TermAU penalty if coax stack */
#if 0
        /* This is needed for Y shaped ML loops with coax stacking of
           interior pairts, but backtracking will fail if activated */
        DMLi[j] = MIN2(DMLi[j], decomp);
        DMLi[j] = MIN2(DMLi[j], DMLi[j-1]+P->MLbase);
        DMLi[j] = MIN2(DMLi[j], DMLi1[j]+P->MLbase);
        new_fML = MIN2(new_fML, DMLi[j]);
#endif
    e = MIN2(e, decomp);
  }

  fmi[j] = e;

  return e;
}


PRIVATE int
E_ml_stems_fast_comparative(vrna_fold_compound_t *vc,
                            int i,
                            int j,
                            int *fmi,
                            int *dmli){

  char            *hard_constraints;
  short           **S, **S5, **S3;
  unsigned short  **a2s;
  int             e, energy, *c, *fML, *ggg, ij, *indx, s, n_seq, k,
                  dangle_model, decomp, turn, *type;
  vrna_param_t    *P;
  vrna_md_t       *md;
  vrna_mx_mfe_t   *matrices;
  vrna_hc_t       *hc;
  vrna_sc_t       **scs;

  n_seq             = vc->n_seq;
  matrices          = vc->matrices;
  P                 = vc->params;
  md                = &(P->model_details);
  c                 = matrices->c;
  fML               = matrices->fML;
  ggg               = matrices->ggg;
  indx              = vc->jindx;
  hc                = vc->hc;
  scs               = vc->scs;
  hard_constraints  = hc->matrix;
  dangle_model      = md->dangles;
  turn              = md->min_loop_size;
  a2s               = vc->a2s;
  ij                = indx[j] + i;
  e                 = INF;

  if(hc->up_ml[i]){
    energy = fML[ij+1] + n_seq * P->MLbase;
    if(scs)
      for(s = 0; s < n_seq; s++){
        if(scs[s]){
          if(scs[s]->energy_up)
            energy += scs[s]->energy_up[a2s[s][i]][1];
        }
      }
    e = MIN2(e, energy);
  }

  if(hc->up_ml[j]){
    energy = fML[indx[j-1]+i] + n_seq * P->MLbase;
    if(scs)
      for(s = 0;s < n_seq; s++){
        if(scs[s]){
          if(scs[s]->energy_up)
            energy += scs[s]->energy_up[a2s[s][j]][1];
        }
      }
    e = MIN2(e, energy);
  }

  if(hard_constraints[ij] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC){
    energy = c[ij];

    type  = (int *)vrna_alloc(n_seq * sizeof(int));
    S     = vc->S;
    S5    = vc->S5;     /*S5[s][i] holds next base 5' of i in sequence s*/
    S3    = vc->S3;     /*Sl[s][i] holds next base 3' of i in sequence s*/

    for(s = 0; s < n_seq; s++){
      type[s] = md->pair[S[s][i]][S[s][j]];
      if(type[s] == 0)
        type[s] = 7;
    }

    if(dangle_model){
      for(s = 0; s < n_seq; s++){
        energy += E_MLstem(type[s], S5[s][i], S3[s][j], P);
      }
    }
    else{
      for(s = 0; s < n_seq; s++){
        energy += E_MLstem(type[s], -1, -1, P);
      }
    }
    e = MIN2(e, energy);

    if(md->gquad){
      decomp = ggg[indx[j] + i] + n_seq * E_MLstem(0, -1, -1, P);
      e = MIN2(e, decomp);
    }

    free(type);
  }


  /* modular decomposition -------------------------------*/
  for (decomp = INF, k = i+1+turn; k <= j-2-turn; k++)
    decomp = MIN2(decomp, fmi[k] + fML[indx[j] + k + 1]);

  dmli[j] = decomp; /* store for later use in ML decompositon */

  e = MIN2(e, decomp);

  fmi[j] = e; /* store for later use in ML decompositon */

  return e;
}

PRIVATE FLT_OR_DBL
exp_E_mb_loop_fast( vrna_fold_compound_t *vc,
                    int i,
                    int j,
                    FLT_OR_DBL *qqm1){

  unsigned char     type, tt;
  char              hc, *ptype;
  short             *S1;
  int               ij, k, kl, *my_iindx, *jindx, *rtype, cp;
  FLT_OR_DBL        qbt1, temp, qqqmmm, *qm, *scale, expMLclosing;
  vrna_sc_t         *sc;
  vrna_exp_param_t  *pf_params;
  vrna_md_t         *md;

  cp            = vc->cutpoint;
  my_iindx      = vc->iindx;
  jindx         = vc->jindx;
  sc            = vc->sc;
  ptype         = vc->ptype;
  S1            = vc->sequence_encoding;
  qm            = vc->exp_matrices->qm;
  scale         = vc->exp_matrices->scale;
  pf_params     = vc->exp_params;
  md            = &(pf_params->model_details);
  ij            = jindx[j] + i;
  hc            = vc->hc->matrix[ij];
  expMLclosing  = pf_params->expMLclosing;
  qbt1          = 0.;

  /*multiple stem loop contribution*/
  if((hc & VRNA_CONSTRAINT_CONTEXT_MB_LOOP) && ON_SAME_STRAND(i,i+1,cp) && ON_SAME_STRAND(j-1,j,cp)) {
    type    = (unsigned char)ptype[ij];
    rtype   = &(md->rtype[0]);
    tt      = rtype[type];

    if(tt == 0)
      tt = 7;

    qqqmmm  =   expMLclosing
              * exp_E_MLstem(tt, S1[j-1], S1[i+1], pf_params)
              * scale[2];

    temp = 0.0;
    kl = my_iindx[i+1]-(i+1);

    if(sc){
      if(sc->exp_energy_bp)
        qqqmmm *= sc->exp_energy_bp[my_iindx[i] - j];

      if(sc->exp_f){
        qqqmmm *= sc->exp_f(i, j, i, j, VRNA_DECOMP_PAIR_ML, sc->data);

        for (k=i+2; k<=j-1; k++,kl--){
          if (ON_SAME_STRAND(k-1,k,cp)){
            temp +=   qm[kl]
                    * qqm1[k]
                    * sc->exp_f(i+1, j-1, k-1, k, VRNA_DECOMP_ML_ML_ML, sc->data);
          }
        }
      } else {
        for (k=i+2; k<=j-1; k++,kl--){
          if (ON_SAME_STRAND(k-1,k,cp)){
            temp +=   qm[kl]
                    * qqm1[k];
          }
        }
      }
    } else {
      for (k=i+2; k<=j-1; k++,kl--){
        if (ON_SAME_STRAND(k-1,k,cp)){
          temp +=   qm[kl]
                  * qqm1[k];
        }
      }
    }

    qbt1 += temp * qqqmmm;
  }

  return qbt1;
}

PRIVATE FLT_OR_DBL
exp_E_mb_loop_fast_comparative( vrna_fold_compound_t *vc,
                                int i,
                                int j,
                                FLT_OR_DBL *qqm1){

  char              hc;
  short             **S, **S5, **S3;
  int               jij, k, kl, *my_iindx, *jindx, *types, n_seq, s;
  FLT_OR_DBL        qbt1, temp, qqqmmm, *qm, *scale, expMLclosing;
  vrna_sc_t         **scs;
  vrna_exp_param_t  *pf_params;
  vrna_md_t         *md;

  my_iindx      = vc->iindx;
  jindx         = vc->jindx;
  qm            = vc->exp_matrices->qm;
  scale         = vc->exp_matrices->scale;
  pf_params     = vc->exp_params;
  md            = &(pf_params->model_details);
  jij           = jindx[j] + i;
  hc            = vc->hc->matrix[jij];
  expMLclosing  = pf_params->expMLclosing;
  qbt1          = 0.;
  types         = NULL;

  /*multiple stem loop contribution*/
  if(hc & VRNA_CONSTRAINT_CONTEXT_MB_LOOP) {

    S       = vc->S;
    S5      = vc->S5;     /*S5[s][i] holds next base 5' of i in sequence s*/
    S3      = vc->S3;     /*Sl[s][i] holds next base 3' of i in sequence s*/
    scs     = vc->scs;
    n_seq   = vc->n_seq;
    types   = (int *)vrna_alloc(sizeof(int) * n_seq);

    qqqmmm  = 1.;

    for(s = 0; s < n_seq; s++){
      types[s] = md->pair[S[s][j]][S[s][i]];
      if(types[s] == 0)
        types[s] = 7;
    }

    for(s = 0; s < n_seq; s++){
      qqqmmm *=   exp_E_MLstem(types[s], S5[s][j], S3[s][i], pf_params)
                * expMLclosing;
    }

    if(scs){
      for(s = 0; s < n_seq; s++){
        if(scs[s]){
          if(scs[s]->exp_energy_bp)
            qqqmmm *= scs[s]->exp_energy_bp[my_iindx[i] - j];
        }
      }
    }

    /* multi-loop loop contribution */
    temp  = 0.;
    kl    = my_iindx[i+1]-(i+1);

    for(k = i + 2; k <= j - 1; k++, kl--){
      temp += qm[kl] * qqm1[k];
    }

    temp *= scale[2];

    qbt1 = temp * qqqmmm;
  }

  /* cleanup */
  free(types);

  return qbt1;
}

/*
#################################
# Backtracking functions below  #
#################################
*/

PUBLIC int
vrna_BT_mb_loop_fake( vrna_fold_compound_t *vc,
                      int *u,
                      int *i,
                      int *j,
                      vrna_bp_stack_t *bp_stack,
                      int *stack_count){

  unsigned char type;
  char          *ptype;
  short         mm5, mm3, *S1;
  int           length, ii, jj, k, en, cp, fij, fi, *my_c, *my_fc, *my_ggg,
                *idx, with_gquad, dangle_model, turn;
  vrna_param_t  *P;
  vrna_md_t     *md;
  vrna_hc_t     *hc;
  vrna_sc_t     *sc;

  cp            = vc->cutpoint;
  length        = vc->length;
  P             = vc->params;
  md            = &(P->model_details);
  hc            = vc->hc;
  sc            = vc->sc;
  S1            = vc->sequence_encoding;
  ptype         = vc->ptype;
  idx           = vc->jindx;
  my_c          = vc->matrices->c;
  my_fc         = vc->matrices->fc;
  my_ggg        = vc->matrices->ggg;
  turn          = md->min_loop_size;
  with_gquad    = md->gquad;
  dangle_model  = md->dangles;

  ii = *i;
  jj = *j;

  if(ii < cp){ /* 'lower' part (fc[i<cut,j=cut-1]) */

    /* nibble off unpaired 5' bases */
    do{
      fij = my_fc[ii];
      fi  = (hc->up_ext[ii]) ? my_fc[ii + 1] : INF;

      if(sc){
        if(sc->energy_up)
          fi += sc->energy_up[ii][1];
      }

      if(++ii == jj)
        break;

    } while (fij == fi);
    ii--;

    if (jj < ii + turn + 2){ /* no more pairs */
      *u = *i = *j = -1;
      return 1;
    }

    mm5 = (ii > 1 && ON_SAME_STRAND(ii - 1, ii, cp)) ? S1[ii - 1] : -1;

    /* i or i+1 is paired. Find pairing partner */
    switch(dangle_model){
      case 0:   for(k = ii + turn + 1; k <= jj; k++){
                  if(hc->matrix[idx[k] + ii] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
                    type = (unsigned char)ptype[idx[k] + ii];

                    if(type == 0)
                      type = 7;

                    if(fij == my_fc[k + 1] + my_c[idx[k] + ii] + E_ExtLoop(type, -1, -1, P)){
                      bp_stack[++(*stack_count)].i = ii;
                      bp_stack[(*stack_count)].j   = k;
                      *u = k + 1;
                      *i = ii;
                      *j = k;
                      return 1;
                    }
                  }

                  if (with_gquad){
                    if(fij == my_fc[k + 1] + my_ggg[idx[k] + ii]){
                      *u = k + 1;
                      *i = *j = -1;
                      vrna_BT_gquad_mfe(vc, ii, k, bp_stack, stack_count);
                      return 1;
                    }
                  }
                }
                break;

      case 2:   for(k = ii + turn + 1; k <= jj; k++){
                  if(hc->matrix[idx[k] + ii] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
                    mm3 = ON_SAME_STRAND(k, k + 1, cp) ? S1[k + 1] : -1;
                    type = (unsigned char)ptype[idx[k] + ii];

                    if(type == 0)
                      type = 7;

                    if(fij == my_fc[k + 1] + my_c[idx[k] + ii] + E_ExtLoop(type, mm5,  mm3, P)){
                      bp_stack[++(*stack_count)].i = ii;
                      bp_stack[(*stack_count)].j   = k;
                      *u = k + 1;
                      *i = ii;
                      *j = k;
                      return 1;
                    }
                  }

                  if (with_gquad){
                    if(fij == my_fc[k + 1] + my_ggg[idx[k] + ii]){
                      *u = k + 1;
                      *i = *j = -1;
                      vrna_BT_gquad_mfe(vc, ii, k, bp_stack, stack_count);
                      return 1;
                    }
                  }
                }
                break;

      default:  for(k = ii + turn + 1; k <= jj; k++){
                  if(hc->matrix[idx[k] + ii] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
                    type = (unsigned char)ptype[idx[k] + ii];

                    if(type == 0)
                      type = 7;

                    if(fij == my_fc[k + 1] + my_c[idx[k] + ii] + E_ExtLoop(type, -1, -1, P)){
                      bp_stack[++(*stack_count)].i = ii;
                      bp_stack[(*stack_count)].j   = k;
                      *u = k + 1;
                      *i = ii;
                      *j = k;
                      return 1;
                    }
                    if(hc->up_ext[k + 1]){
                      mm3 = ON_SAME_STRAND(k, k + 1, cp) ? S1[k + 1] : -1;
                      en = my_c[idx[k] + ii];
                      if(sc)
                        if(sc->energy_up)
                          en += sc->energy_up[k + 1][1];

                      if(fij == my_fc[k + 2] + en + E_ExtLoop(type, -1, mm3, P)){
                        bp_stack[++(*stack_count)].i = ii;
                        bp_stack[(*stack_count)].j   = k;
                        *u = k + 2;
                        *i = ii;
                        *j = k;
                        return 1;
                      }
                    }
                  }

                  if (with_gquad){
                    if(fij == my_fc[k + 1] + my_ggg[idx[k] + ii]){
                      *u = k + 1;
                      *i = *j = -1;
                      vrna_BT_gquad_mfe(vc, ii, k, bp_stack, stack_count);
                      return 1;
                    }
                  }

                  if(hc->matrix[idx[k] + ii + 1] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
                    if(hc->up_ext[ii]){
                      mm5   = ON_SAME_STRAND(ii, ii + 1,cp) ? S1[ii] : -1;
                      mm3   = ON_SAME_STRAND(k, k + 1,cp) ? S1[k + 1] : -1;
                      type  = ptype[idx[k] + ii + 1];

                      if(type == 0)
                        type = 7;

                      en    = my_c[idx[k] + ii + 1];
                      if(sc)
                        if(sc->energy_up)
                          en += sc->energy_up[ii][1];

                      if(fij == en + my_fc[k + 1] + E_ExtLoop(type, mm5, -1, P)){
                        bp_stack[++(*stack_count)].i = ii + 1;
                        bp_stack[(*stack_count)].j   = k;
                        *u = k + 1;
                        *i = ii + 1;
                        *j = k;
                        return 1;
                      }

                      if(k < jj){
                        if(hc->up_ext[k + 1]){
                          if(sc)
                            if(sc->energy_up)
                              en += sc->energy_up[k + 1][1];

                          if(fij == en + my_fc[k + 2] + E_ExtLoop(type, mm5, mm3, P)){
                            bp_stack[++(*stack_count)].i = ii + 1;
                            bp_stack[(*stack_count)].j   = k;
                            *u = k + 2;
                            *i = ii + 1;
                            *j = k;
                            return 1;
                          }
                        }
                      }
                    }
                  }
                }
                break;
    }
  } else { /* 'upper' part (fc[i=cut,j>cut]) */

    /* nibble off unpaired 3' bases */
    do{
      fij = my_fc[jj];
      fi  = (hc->up_ext[jj]) ? my_fc[jj - 1] : INF;

      if(sc){
        if(sc->energy_up)
          fi += sc->energy_up[jj][1];
      }

      if(--jj == ii)
        break;

    } while (fij == fi);
    jj++;

    if (jj < ii + turn + 2){ /* no more pairs */
      *u = *i = *j = -1;
      return 1;
    }

    /* j or j-1 is paired. Find pairing partner */
    mm3 = ((jj < length) && ON_SAME_STRAND(jj, jj + 1, cp)) ? S1[jj + 1] : -1;
    switch(dangle_model){
      case 0:   for (k = jj - turn - 1; k >= ii; k--){
                  if(with_gquad){
                    if(fij == my_fc[k - 1] + my_ggg[idx[jj] + k]){
                      *u = k - 1;
                      *i = *j = -1;
                      vrna_BT_gquad_mfe(vc, k, jj, bp_stack, stack_count);
                      return 1;
                    }
                  }

                  if(hc->matrix[idx[jj] + k] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
                    type  = (unsigned char)ptype[idx[jj] + k];

                    if(type == 0)
                      type = 7;

                    en    = my_c[idx[jj] + k];
                    if(!ON_SAME_STRAND(k, jj, cp))
                      en += P->DuplexInit;

                    if(fij == my_fc[k - 1] + en + E_ExtLoop(type, -1, -1, P)){
                      bp_stack[++(*stack_count)].i = k;
                      bp_stack[(*stack_count)].j   = jj;
                      *u = k - 1;
                      *i = k;
                      *j = jj;
                      return 1;
                    }
                  }
                }
                break;
      case 2:   for(k = jj - turn - 1; k >= ii; k--){
                  if(with_gquad){
                    if(fij == my_fc[k - 1] + my_ggg[idx[jj] + k]){
                      *u = k - 1;
                      *i = *j = -1;
                      vrna_BT_gquad_mfe(vc, k, jj, bp_stack, stack_count);
                      return 1;
                    }
                  }

                  if(hc->matrix[idx[jj] + k] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
                    mm5   = ((k > 1) && ON_SAME_STRAND(k - 1, k, cp)) ? S1[k - 1] : -1;
                    type  = (unsigned char)ptype[idx[jj] + k];

                    if(type == 0)
                      type = 7;

                    en    = my_c[idx[jj] + k];
                    if(!ON_SAME_STRAND(k, jj, cp))
                      en += P->DuplexInit;

                    if(fij == my_fc[k - 1] + en + E_ExtLoop(type, mm5, mm3, P)){
                      bp_stack[++(*stack_count)].i = k;
                      bp_stack[(*stack_count)].j   = jj;
                      *u = k - 1;
                      *i = k;
                      *j = jj;
                      return 1;
                    }
                  }
                }
                break;

      default:  for(k = jj - turn - 1; k >= ii; k--){

                  if(with_gquad){
                    if(fij == my_fc[k - 1] + my_ggg[idx[jj] + k]){
                      *u = k - 1;
                      *i = *j = -1;
                      vrna_BT_gquad_mfe(vc, k, jj, bp_stack, stack_count);
                      return 1;
                    }
                  }

                  if(hc->matrix[idx[jj] + k] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
                    type  = (unsigned char)ptype[idx[jj] + k];

                    if(type == 0)
                      type = 7;

                    en    = my_c[idx[jj] + k];
                    if(!ON_SAME_STRAND(k, jj, cp))
                      en += P->DuplexInit;

                    if(fij == my_fc[k - 1] + en + E_ExtLoop(type, -1, -1, P)){
                      bp_stack[++(*stack_count)].i = k;
                      bp_stack[(*stack_count)].j   = jj;
                      *u = k - 1;
                      *i = k;
                      *j = jj;
                      return 1;
                    }
                    if(hc->up_ext[k - 1]){
                      if((k > 1) && ON_SAME_STRAND(k - 1, k, cp)){
                        mm5 = S1[k - 1];
                        if(sc)
                          if(sc->energy_up)
                            en += sc->energy_up[k - 1][1];

                        if(fij == my_fc[k - 2] + en + E_ExtLoop(type, mm5, -1, P)){
                          bp_stack[++(*stack_count)].i = k;
                          bp_stack[(*stack_count)].j   = jj;
                          *u = k - 2;
                          *i = k;
                          *j = jj;
                          return 1;
                        }
                      }
                    }
                  }

                  if(hc->matrix[idx[jj - 1] + k] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
                    type = (unsigned char)ptype[idx[jj - 1] + k];

                    if(type == 0)
                      type = 7;

                    if(hc->up_ext[jj]){
                      if(ON_SAME_STRAND(jj - 1, jj, cp)){
                        mm3 = S1[jj];
                        en = my_c[idx[jj - 1] + k];
                        if (!ON_SAME_STRAND(k, jj - 1, cp))
                          en += P->DuplexInit; /*???*/
                        if(sc)
                          if(sc->energy_up)
                            en += sc->energy_up[jj][1];

                        if (fij == en + my_fc[k - 1] + E_ExtLoop(type, -1, mm3, P)){
                          bp_stack[++(*stack_count)].i = k;
                          bp_stack[(*stack_count)].j   = jj - 1;
                          *u = k - 1;
                          *i = k;
                          *j = jj - 1;
                          return 1;
                        }

                        if(k > ii){
                          if(hc->up_ext[k - 1]){
                            mm5 = ON_SAME_STRAND(k - 1, k, cp) ? S1[k - 1] : -1;
                            if(sc)
                              if(sc->energy_up)
                                en += sc->energy_up[k - 1][1];

                            if (fij == my_fc[k - 2] + en + E_ExtLoop(type, mm5, mm3, P)){
                              bp_stack[++(*stack_count)].i = k;
                              bp_stack[(*stack_count)].j   = jj - 1;
                              *u = k - 2;
                              *i = k;
                              *j = jj - 1;
                              return 1;
                            }
                          }
                        }
                      }
                    }
                  }
                }
                break;
    }
  }

  return 0;
}

PUBLIC int
vrna_BT_mb_loop_split(vrna_fold_compound_t *vc,
                      int *i,
                      int *j,
                      int *k,
                      int *l,
                      int *component1,
                      int *component2,
                      vrna_bp_stack_t *bp_stack,
                      int *stack_count){

  unsigned char type, type_2;
  char          *ptype;
  short         *S1;
  int           ij, ii, jj, fij, fi, u, en, *my_c, *my_fML, *my_ggg,
                turn, *idx, with_gquad, dangle_model, *rtype;
  vrna_param_t  *P;
  vrna_md_t     *md;
  vrna_hc_t     *hc;
  vrna_sc_t     *sc;


  P             = vc->params;
  md            = &(P->model_details);
  hc            = vc->hc;
  sc            = vc->sc;
  idx           = vc->jindx;
  ptype         = vc->ptype;
  rtype         = &(md->rtype[0]);
  S1            = vc->sequence_encoding;

  my_c          = vc->matrices->c;
  my_fML        = vc->matrices->fML;
  my_ggg        = vc->matrices->ggg;
  turn          = md->min_loop_size;
  with_gquad    = md->gquad;
  dangle_model  = md->dangles;

  ii = *i;
  jj = *j;

  /* nibble off unpaired 3' bases */
  do{
    fij = my_fML[idx[jj] + ii];
    fi  = (hc->up_ml[jj]) ? my_fML[idx[jj - 1] + ii] + P->MLbase : INF;

    if(sc){
      if(sc->energy_up)
        fi += sc->energy_up[jj][1];
      if(sc->f)
        fi += sc->f(ii, jj, ii, jj-1, VRNA_DECOMP_ML_ML, sc->data);
    }

    if(--jj == 0)
      break;

  } while (fij == fi);
  jj++;

  /* nibble off unpaired 5' bases */
  do{
    fij = my_fML[idx[jj] + ii];
    fi  = (hc->up_ml[ii]) ? my_fML[idx[jj] + ii + 1] + P->MLbase : INF;

    if(sc){
      if(sc->energy_up)
        fi += sc->energy_up[ii][1];
      if(sc->f)
        fi += sc->f(ii, jj, ii+1, jj, VRNA_DECOMP_ML_ML, sc->data);
    }

    if(++ii == jj)
      break;

  } while (fij == fi);
  ii--;

  if (jj < ii + turn + 1){ /* no more pairs */
    return 0;
  }

  ij = idx[jj] + ii;

  *component1 = *component2 = 1; /* split into two multi loop parts by default */

  /* 1. test for single component */

  if(with_gquad){
    if(fij == my_ggg[ij] + E_MLstem(0, -1, -1, P)){
      *i = *j = -1;
      *k = *l = -1;
      vrna_BT_gquad_mfe(vc, ii, jj, bp_stack, stack_count);
      return 1;
    }
  }

  type  = (unsigned char)ptype[ij];

  en    = my_c[ij];
  if(sc){
    if(sc->f)
      en += sc->f(ii, jj, ii+1, jj-1, VRNA_DECOMP_ML_STEM, sc->data);
  }
  switch(dangle_model){
    case 0:   if(hc->matrix[ij] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC){

                if(type == 0)
                  type = 7;

                if(fij == en + E_MLstem(type, -1, -1, P)){
                  *i = *j = -1;
                  *k = ii;
                  *l = jj;
                  *component2 = 2;  /* 2nd part is structure enclosed by base pair */
                  return 1;
                }
              }
              break;

    case 2:   if(hc->matrix[ij] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC){

                if(type == 0)
                  type = 7;

                if(fij == en + E_MLstem(type, S1[ii - 1], S1[jj + 1], P)){
                  *i = *j = -1;
                  *k = ii;
                  *l = jj;
                  *component2 = 2;
                  return 1;
                }
              }
              break;

    default:  if(hc->matrix[ij] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC){

                if(type == 0)
                  type = 7;

                if(fij == en + E_MLstem(type, -1, -1, P)){
                  *i = *j = -1;
                  *k = ii;
                  *l = jj;
                  *component2 = 2;
                  return 1;
                }
              }
              if(hc->matrix[ij + 1] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC){
                if(hc->up_ml[ii]){
                  int tmp_en = fij;
                  if(sc){
                    if(sc->energy_up)
                      tmp_en -= sc->energy_up[ii][1];
                    if(sc->f)
                      tmp_en -= sc->f(ii, jj, ii+1, jj, VRNA_DECOMP_ML_STEM, sc->data);
                  }
                  type = (unsigned char)ptype[ij + 1];

                  if(type == 0)
                    type = 7;

                  if(tmp_en == my_c[ij+1] + E_MLstem(type, S1[ii], -1, P) + P->MLbase){
                    *i = *j = -1;
                    *k = ii + 1;
                    *l = jj;
                    *component2 = 2;
                    return 1;
                  }
                }
              }
              if(hc->matrix[idx[jj - 1] + ii] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC){
                if(hc->up_ml[jj]){
                  int tmp_en = fij;
                  if(sc){
                    if(sc->energy_up)
                      tmp_en -= sc->energy_up[jj][1];
                    if(sc->f)
                      tmp_en -= sc->f(ii, jj, ii, jj-1, VRNA_DECOMP_ML_STEM, sc->data);
                  }
                  type = (unsigned char)ptype[idx[jj - 1] + ii];

                  if(type == 0)
                    type = 7;

                  if(tmp_en == my_c[idx[jj - 1] + ii] + E_MLstem(type, -1, S1[jj], P) + P->MLbase){
                    *i = *j = -1;
                    *k = ii;
                    *l = jj - 1;
                    *component2 = 2;
                    return 1;
                  }
                }
              }
              if(hc->matrix[idx[jj - 1] + ii + 1] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC){
                if(hc->up_ml[ii] && hc->up_ml[jj]){
                  int tmp_en = fij;
                  if(sc){
                    if(sc->energy_up)
                      tmp_en -= sc->energy_up[ii][1] + sc->energy_up[jj][1];
                    if(sc->f)
                      tmp_en -= sc->f(ii, jj, ii+1, jj-1, VRNA_DECOMP_ML_STEM, sc->data);
                  }
                  type = (unsigned char)ptype[idx[jj - 1] + ii + 1];

                  if(type == 0)
                    type = 7;

                  if(tmp_en == my_c[idx[jj - 1] + ii + 1] + E_MLstem(type, S1[ii], S1[jj], P) + 2 * P->MLbase){
                    *i = *j = -1;
                    *k = ii + 1;
                    *l = jj - 1;
                    *component2 = 2;
                    return 1;
                  }
                }
              }
              break;
  }

  /* 2. Test for possible split point */
  for(u = ii + 1 + turn; u <= jj - 2 - turn; u++){
    en = my_fML[idx[u] + ii] + my_fML[idx[jj] + u + 1];
    if(sc){
      if(sc->f)
        en += sc->f(ii, jj, u, u+1, VRNA_DECOMP_ML_ML_ML, sc->data);
    }
    if(fij == en){
      *i = ii;
      *j = u;
      *k = u + 1;
      *l = jj;
      return 1;
    }
  }

  /* 3. last chance! Maybe coax stack */
  if(dangle_model==3){
    int ik, k1j, tmp_en;
    for (k1j = idx[jj] + ii + turn + 2, u = ii + 1 + turn; u <= jj - 2 - turn; u++, k1j++) {
      ik = idx[u] + ii;
      if((hc->matrix[ik] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC) && (hc->matrix[k1j] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC)){
        type    = rtype[(unsigned char)ptype[ik]];
        type_2  = rtype[(unsigned char)ptype[k1j]];

        if(type == 0)
          type = 7;
        if(type_2 == 0)
          type_2 = 7;

        tmp_en  = my_c[ik] + my_c[k1j] + P->stack[type][type_2] + 2*P->MLintern[1];
        if(sc){
          if(sc->f)
            tmp_en += sc->f(ii, u, u+1, jj, VRNA_DECOMP_ML_COAXIAL, sc->data);
        }
        if (fij == tmp_en){
          *i = ii;
          *j = u;
          *k = u + 1;
          *l = jj;
          *component1 = *component2 = 2;
          return 1;
        }
      }
    }
  }

  return 0;
}


PUBLIC int
vrna_BT_mb_loop(vrna_fold_compound_t *vc,
                int *i,
                int *j,
                int *k,
                int en,
                int *component1,
                int *component2){

  unsigned char type, type_2, tt;
  char          *ptype;
  short         s5, s3, *S1;
  int           ij, p, q, r, e, tmp_en, cp, *idx, turn, dangle_model,
                *my_c, *my_fML, *my_fc, *rtype;
  vrna_param_t  *P;
  vrna_md_t     *md;
  vrna_hc_t     *hc;
  vrna_sc_t     *sc;

  cp            = vc->cutpoint;
  idx           = vc->jindx;
  ij            = idx[*j] + *i;
  S1            = vc->sequence_encoding;
  P             = vc->params;
  md            = &(P->model_details);
  hc            = vc->hc;
  sc            = vc->sc;
  my_c          = vc->matrices->c;
  my_fML        = vc->matrices->fML;
  my_fc         = vc->matrices->fc;
  turn          = md->min_loop_size;
  ptype         = vc->ptype;
  rtype         = &(md->rtype[0]);
  type          = (unsigned char)ptype[ij];
  tt            = type;
  type          = rtype[type];
  dangle_model  = md->dangles;

  p = *i + 1;
  q = *j - 1;

  r = q - turn - 1;

  if(hc->matrix[ij] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP){

    if(type == 0)
      type = 7;
    if(tt == 0)
      tt = 7;

    /* is it a fake multi-loop? */
    if(!ON_SAME_STRAND(*i, *j, cp)){
      int ii, jj;
      ii = jj = 0;
      e = my_fc[p] + my_fc[q];
      if(sc){
        if(sc->energy_bp)
          e += sc->energy_bp[ij];
      }
      s5 = ON_SAME_STRAND(q, *j, cp) ? S1[q] : -1;
      s3 = ON_SAME_STRAND(*i, p, cp) ? S1[p] : -1;

      switch(dangle_model){
        case 0:   if(en == e + E_ExtLoop(type, -1, -1, P)){
                    ii=p, jj=q;
                  }
                  break;
        case 2:   if(en == e + E_ExtLoop(type, s5, s3, P)){
                    ii=p, jj=q;
                  }
                  break;
        default:  {
                    if(en == e + E_ExtLoop(type, -1, -1, P)){
                      ii=p, jj=q;
                      break;
                    }
                    if(hc->up_ext[p]){
                      e = my_fc[p + 1] + my_fc[q];
                      if(sc){
                        if(sc->energy_up)
                          e += sc->energy_up[p][1];
                        if(sc->energy_bp)
                          e += sc->energy_bp[ij];
                      }
                      if(en == e + E_ExtLoop(type, -1, s3, P)){
                        ii = p + 1; jj = q;
                        break;
                      }
                    }
                    if(hc->up_ext[q]){
                      e = my_fc[p] + my_fc[q - 1];
                      if(sc){
                        if(sc->energy_up)
                          e += sc->energy_up[q][1];
                        if(sc->energy_bp)
                          e += sc->energy_bp[ij];
                      }
                      if(en == e + E_ExtLoop(type, s5, -1, P)){
                        ii = p; jj = q - 1;
                        break;
                      }
                    }
                    if((hc->up_ext[q]) && (hc->up_ext[p])){
                      e = my_fc[p + 1] + my_fc[q - 1];
                      if(sc){
                        if(sc->energy_up)
                          e += sc->energy_up[p][1] + sc->energy_up[q][1];
                        if(sc->energy_bp)
                          e += sc->energy_bp[ij];
                      }
                      if(en == e + E_ExtLoop(type, s5, s3, P)){
                        ii = p + 1; jj = q - 1;
                        break;
                      }
                    }
                  }
                  break;
      }

      if(ii){ /* found a decomposition */
        *component1 = 3;
        *i          = ii;
        *k          = cp - 1;
        *j          = jj;
        *component2 = 4;
        return 1;
      }
    }

    /* true multi loop? */
    *component1 = *component2 = 1;  /* both components are MB loop parts by default */

    s5 = ON_SAME_STRAND(q, *j, cp) ? S1[q] : -1;
    s3 = ON_SAME_STRAND(*i, p, cp) ? S1[p] : -1;

    switch(dangle_model){
      case 0:   e = en - E_MLstem(type, -1, -1, P) - P->MLclosing;
                if(sc){
                  if(sc->energy_bp)
                    e -= sc->energy_bp[ij];
                  if(sc->f)
                    e -= sc->f(*i, *j, p, q, VRNA_DECOMP_PAIR_ML, sc->data);
                }
                for(r = *i + 2 + turn; r < *j - 2 - turn; ++r){
                  tmp_en = my_fML[idx[r] + p] + my_fML[idx[q] + r + 1];
                  if(sc){
                    if(sc->f)
                      tmp_en += sc->f(p, q, r, r+1, VRNA_DECOMP_ML_ML_ML, sc->data);
                  }
                  if(e == tmp_en)
                    break;
                }
                break;

      case 2:   e = en - E_MLstem(type, s5, s3, P) - P->MLclosing;
                if(sc){
                  if(sc->energy_bp)
                    e -= sc->energy_bp[ij];
                  if(sc->f)
                    e -= sc->f(*i, *j, p, q, VRNA_DECOMP_PAIR_ML, sc->data);
                }
                for(r = p + turn + 1; r < q - turn - 1; ++r){
                  tmp_en = my_fML[idx[r] + p] + my_fML[idx[q] + r + 1];
                  if(sc){
                    if(sc->f)
                      tmp_en += sc->f(p, q, r, r+1, VRNA_DECOMP_ML_ML_ML, sc->data);
                  }
                  if(e == tmp_en)
                    break;
                }
                break;

      default:  e = en - P->MLclosing;
                if(sc){
                  if(sc->energy_bp)
                    e -= sc->energy_bp[ij];
                }
                for(r = p + turn + 1; r < q - turn - 1; ++r){
                  tmp_en = my_fML[idx[r] + p] + my_fML[idx[q] + r + 1] + E_MLstem(type, -1, -1, P);
                  if(sc){
                    if(sc->f){
                      tmp_en += sc->f(*i, *j, p, q, VRNA_DECOMP_PAIR_ML, sc->data);
                      tmp_en += sc->f(p, q, r, r+1, VRNA_DECOMP_ML_ML_ML, sc->data);
                    }
                  }
                  if(e == tmp_en){
                    break;
                  }
                  if(hc->up_ml[p]){
                    tmp_en = e;
                    if(sc){
                      if(sc->energy_up)
                        tmp_en -= sc->energy_up[p][1];
                      if(sc->f){
                        tmp_en -= sc->f(*i, *j, p+1, q, VRNA_DECOMP_PAIR_ML, sc->data);
                        tmp_en -= sc->f(p+1, q, r, r+1, VRNA_DECOMP_ML_ML_ML, sc->data);
                      }
                    }
                    if(tmp_en == my_fML[idx[r] + p + 1] + my_fML[idx[q] + r + 1] + E_MLstem(type, -1, s3, P) + P->MLbase){
                      p += 1;
                      break;
                    }
                  }
                  if(hc->up_ml[q]){
                    tmp_en = e;
                    if(sc){
                      if(sc->energy_up)
                        tmp_en -= sc->energy_up[q][1];
                      if(sc->f){
                        tmp_en -= sc->f(*i, *j, p, q-1, VRNA_DECOMP_PAIR_ML, sc->data);
                        tmp_en -= sc->f(p, q-1, r, r+1, VRNA_DECOMP_ML_ML_ML, sc->data);
                      }
                    }
                    if(tmp_en == my_fML[idx[r] + p] + my_fML[idx[q - 1] + r + 1] + E_MLstem(type, s5, -1, P) + P->MLbase){
                      q -= 1;
                      break;
                    }
                  }
                  if((hc->up_ml[p]) && (hc->up_ml[q])){
                    tmp_en = e;
                    if(sc){
                      if(sc->energy_up)
                        tmp_en -= sc->energy_up[p][1] + sc->energy_up[q][1];
                      if(sc->f){
                        tmp_en -= sc->f(*i, *j, p+1, q-1, VRNA_DECOMP_PAIR_ML, sc->data);
                        tmp_en -= sc->f(p+1, q-1, r, r+1, VRNA_DECOMP_ML_ML_ML, sc->data);
                      }
                    }
                    if(tmp_en == my_fML[idx[r] + p + 1] + my_fML[idx[q - 1] + r + 1] + E_MLstem(type, s5, s3, P) + 2 * P->MLbase){
                      p += 1;
                      q -= 1;
                      break;
                    }
                  }
                  /* coaxial stacking of (i.j) with (i+1.r) or (r.j-1) */
                  /* use MLintern[1] since coax stacked pairs don't get TerminalAU */
                  if(dangle_model == 3){
                    tmp_en = e;
                    if(hc->matrix[idx[r] + p] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC){
                      type_2 = rtype[(unsigned char)ptype[idx[r] + p]];

                      if(type_2 == 0)
                        type_2 = 7;

                      tmp_en = my_c[idx[r] + p] + P->stack[tt][type_2] + my_fML[idx[q] + r + 1];
                      if(sc){
                        if(sc->f){
                          tmp_en += sc->f(*i, *j, p, q, VRNA_DECOMP_PAIR_ML, sc->data);
                          tmp_en += sc->f(*i, *j, p, r, VRNA_DECOMP_ML_COAXIAL, sc->data);
                        }
                      }
                      if(e == tmp_en + 2 * P->MLintern[1]){
                        *component1 = 2;
                        break;
                      }
                    }

                    if(hc->matrix[idx[q] + r + 1] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC){
                      type_2 = rtype[(unsigned char)ptype[idx[q] + r + 1]];

                      if(type_2 == 0)
                        type_2 = 7;

                      tmp_en = my_c[idx[q] + r + 1] + P->stack[tt][type_2] + my_fML[idx[r] + p];
                      if(sc){
                        if(sc->f){
                          tmp_en += sc->f(*i, *j, p, q, VRNA_DECOMP_PAIR_ML, sc->data);
                          tmp_en += sc->f(*i, *j, r+1, q, VRNA_DECOMP_ML_COAXIAL, sc->data);
                        }
                      }
                      if (e == tmp_en + 2 * P->MLintern[1]){
                        *component2 = 2;
                        break;
                      }
                    }
                  }
                }
                break;
    }
  }

  if(r <= *j - turn - 3){
    *i = p;
    *k = r;
    *j = q;
    return 1;
  } else {
#if 0
    /* Y shaped ML loops fon't work yet */
    if (dangle_model==3) {
      d5 = P->dangle5[tt][S1[j-1]];
      d3 = P->dangle3[tt][S1[i+1]];
      /* (i,j) must close a Y shaped ML loop with coax stacking */
      if (cij ==  fML[indx[j-2]+i+2] + mm + d3 + d5 + P->MLbase + P->MLbase) {
        i1 = i+2;
        j1 = j-2;
      } else if (cij ==  fML[indx[j-2]+i+1] + mm + d5 + P->MLbase)
        j1 = j-2;
      else if (cij ==  fML[indx[j-1]+i+2] + mm + d3 + P->MLbase)
        i1 = i+2;
      else /* last chance */
        if (cij != fML[indx[j-1]+i+1] + mm + P->MLbase)
          fprintf(stderr,  "backtracking failed in repeat");
      /* if we arrive here we can express cij via fML[i1,j1]+dangles */
      bt_stack[++s].i = i1;
      bt_stack[s].j   = j1;
    }
#endif
  }

  return 0;
}

/159            0           0     0     644     32291     `
/*
                  partiton function for RNA secondary structures

                  Ivo L Hofacker + Ronny Lorenz
                  Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "utils.h"
#include "energy_par.h"
#include "fold_vars.h"
#include "loop_energies.h"
#include "gquad.h"
#include "constraints.h"
#include "boltzmann_sampling.h"

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/
PRIVATE void  backtrack(int i, int j, char *pstruc, vrna_fold_compound_t *vc);
PRIVATE void  backtrack_qm(int i, int j, char *pstruc, vrna_fold_compound_t *vc);
PRIVATE void  backtrack_qm1(int i,int j, char *pstruc, vrna_fold_compound_t *vc);
PRIVATE void  backtrack_qm2(int u, int n, char *pstruc, vrna_fold_compound_t *vc);
PRIVATE char  *wrap_pbacktrack_circ(vrna_fold_compound_t *vc);

PRIVATE void  backtrack_comparative(vrna_fold_compound_t *vc, char *pstruc, int i, int j, double *prob);
PRIVATE void  backtrack_qm1_comparative(vrna_fold_compound_t *vc, char *pstruc, int i,int j, double *prob);

/*
 *  @brief Sample a consensus secondary structure from the Boltzmann ensemble according its probability
 * 
 *  @ingroup consensus_stochbt
 *
 *  @see vrna_pf() for precomputing the partition function matrices, and
 *
 *  @param  vc    The #vrna_fold_compound_t of type #VRNA_VC_TYPE_ALIGNMENT with precomputed partition function matrices
 *  @param  prob  to be described (berni)
 *  @return       A sampled consensus secondary structure in dot-bracket notation
 */
PRIVATE char *pbacktrack_comparative(vrna_fold_compound_t *vc, double *prob);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

/*
  stochastic backtracking in pf_fold arrays
  returns random structure S with Boltzman probabilty
  p(S) = exp(-E(S)/kT)/Z
*/
PUBLIC char *
vrna_pbacktrack(vrna_fold_compound_t *vc){

  char    *structure  = NULL;
  double  prob        = 1.;

  if(vc && vc->exp_params){
      switch(vc->type){
        case VRNA_VC_TYPE_SINGLE:     if(vc->exp_params->model_details.circ){
                                        return wrap_pbacktrack_circ(vc);
                                      } else {
                                        return vrna_pbacktrack5(vc, vc->length);
                                      }
                                      break;

        case VRNA_VC_TYPE_ALIGNMENT:  return pbacktrack_comparative(vc, &prob);
                                      break;

        default:                      vrna_message_warning("unrecognized fold compound type");
                                      return structure;
                                      break;
      }
  }

  return structure;
}

PUBLIC char *
vrna_pbacktrack5( vrna_fold_compound_t *vc,
                  int length){

  FLT_OR_DBL        r, qt, q_temp, qkl;
  int               i,j,ij, n, k, u, start, type;
  char              *pstruc;
  int               *my_iindx, *jindx, hc_decompose, *hc_up_ext;
  FLT_OR_DBL        *q, *qb, *q1k, *qln, *scale;
  char              *ptype, *hard_constraints;
  short             *S1;
  vrna_mx_pf_t      *matrices;
  vrna_hc_t         *hc;
  vrna_sc_t         *sc;
  vrna_exp_param_t  *pf_params;

  n         = vc->length;

  pf_params = vc->exp_params;
  my_iindx  = vc->iindx;
  jindx     = vc->jindx;
  matrices  = vc->exp_matrices;

  hc        = vc->hc;
  sc        = vc->sc;
  ptype     = vc->ptype;
  S1        = vc->sequence_encoding;

  q         = matrices->q;
  qb        = matrices->qb;
  q1k       = matrices->q1k;
  qln       = matrices->qln;
  scale     = matrices->scale;

  hard_constraints  = hc->matrix;
  hc_up_ext         = hc->up_ext;

  if(length > n)
    vrna_message_error("part_func.c@pbacktrack5: 3'-end exceeds sequence length");
  else if(length < 1)
    vrna_message_error("part_func.c@pbacktrack5: 3'-end too small");

/*
  if (init_length<1)
    vrna_message_error("can't backtrack without pf arrays.\n"
            "Call pf_fold() before pbacktrack()");
*/

  pstruc = vrna_alloc((length+1)*sizeof(char));

  for (i=0; i<length; i++)
    pstruc[i] = '.';

  if(!(q1k && qln)){
    matrices->q1k = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+1));
    matrices->qln = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));
    q1k           = matrices->q1k;
    qln           = matrices->qln;
    for (k=1; k<=n; k++) {
      q1k[k] = q[my_iindx[1] - k];
      qln[k] = q[my_iindx[k] - n];
    }
    q1k[0] = 1.0;
    qln[n+1] = 1.0;
  }


#ifdef WITH_BOUSTROPHEDON
  j = length;
  while (j > 1) {
  /* find i position of first pair */
    for (; j>1; j--){
      if(hc_up_ext[j]){
        r = vrna_urn() * q[my_iindx[1] - j];
        q_temp = q[my_iindx[1] - j + 1] * scale[1];

        if(sc){
          if (sc->exp_energy_up)
            q_temp *= sc->exp_energy_up[j][1];

          if(sc->exp_f)
            q_temp *= sc->exp_f(1, j, 1, j-1, VRNA_DECOMP_EXT_EXT, sc->data);
        }

        if (r > q_temp)  break; /* i is paired */
      }
    }
    if (j<=1) break; /* no more pairs */

    /* now find the pairing partner i */
    r = vrna_urn() * (q[my_iindx[1] - j] - q_temp);
    u = j - 1;

    for (qt=0, k=1; k<j; k++) {
      /* apply alternating boustrophedon scheme to variable i */
      i             = (int)(1 + (u - 1)*((k - 1) % 2)) + (int)((1-(2*((k - 1) % 2)))*((k - 1)/2));
      ij            = my_iindx[i]-j;
      type          = ptype[jindx[j] + i];
      hc_decompose  = hard_constraints[jindx[j] + i];
      if (hc_decompose & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP) {

        if(type == 0)
          type = 7;

        qkl = qb[ij] * exp_E_ExtLoop(type, (i>1) ? S1[i-1] : -1, (j<n) ? S1[j+1] : -1, pf_params);

        if (i > 1){
          qkl *= q[my_iindx[1] - i + 1];
          if(sc){
            if(sc->exp_f)
              qkl *= sc->exp_f(1, j, i-1, i, VRNA_DECOMP_EXT_EXT_STEM, sc->data);
          }
        } else {
          if(sc){
            if(sc->exp_f)
              qkl *= sc->exp_f(i, j, i, j, VRNA_DECOMP_EXT_STEM, sc->data);
          }
        }

        qt += qkl;
        if (qt > r) break; /* j is paired */
      }
    }
    if (k==j) vrna_message_error("backtracking failed in ext loop");
    backtrack(i,j, pstruc, vc);
    j = i - 1;
  }
#else
  start = 1;
  while (start<length) {
  /* find i position of first pair */
    for (i=start; i<length; i++) {
      if(hc_up_ext[i]){
        r = vrna_urn() * qln[i];
        q_temp = qln[i+1]*scale[1];

        if(sc){
          if (sc->exp_energy_up)
            q_temp *= sc->exp_energy_up[i][1];

          if(sc->exp_f)
            q_temp *= sc->exp_f(i, length, i+1, length, VRNA_DECOMP_EXT_EXT, sc->data);
        }

        if (r > q_temp)  break; /* i is paired */
      }
    }
    if (i>=length) break; /* no more pairs */
    /* now find the pairing partner j */
    r = vrna_urn() * (qln[i] - q_temp);
    for (qt=0, j=i+1; j<=length; j++) {
      ij            = my_iindx[i]-j;
      type          = ptype[jindx[j] + i];
      hc_decompose  = hard_constraints[jindx[j] + i];
      if (hc_decompose & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP) {

        if(type == 0)
          type = 7;

        qkl = qb[ij] * exp_E_ExtLoop(type, (i>1) ? S1[i-1] : -1, (j<n) ? S1[j+1] : -1, pf_params);

        if (j<length){
          qkl *= qln[j+1];
          if(sc){
            if(sc->exp_f)
              qkl *= sc->exp_f(i, length, j, j+1, VRNA_DECOMP_EXT_STEM_EXT, sc->data);
          }
        } else {
          if(sc){
            if(sc->exp_f)
              qkl *= sc->exp_f(i, j, i, j, VRNA_DECOMP_EXT_STEM, sc->data);
          }
        }

        qt += qkl;
        if (qt > r) break; /* j is paired */
      }
    }
    if (j==length+1) vrna_message_error("backtracking failed in ext loop");
    start = j+1;
    backtrack(i,j, pstruc, vc);
  }
#endif
  return pstruc;
}

PRIVATE void
backtrack_qm( int i,
              int j,
              char *pstruc,
              vrna_fold_compound_t *vc){

  /* divide multiloop into qm and qm1  */
  FLT_OR_DBL        qmt, r, q_temp;
  int               k, n, u, cnt, span, turn;
  FLT_OR_DBL        *qm, *qm1, *expMLbase;
  int               *my_iindx, *jindx, *hc_up_ml;
  vrna_sc_t         *sc;
  vrna_hc_t         *hc;

  n = j;
  vrna_mx_pf_t  *matrices = vc->exp_matrices;

  my_iindx  = vc->iindx;
  jindx     = vc->jindx;

  hc        = vc->hc;
  sc        = vc->sc;
  hc_up_ml  = hc->up_ml;

  qm        = matrices->qm;
  qm1       = matrices->qm1;
  expMLbase = matrices->expMLbase;

  turn      = vc->exp_params->model_details.min_loop_size;

  while(j>i){
    /* now backtrack  [i ... j] in qm[] */
    r   = vrna_urn() * qm[my_iindx[i] - j];
    qmt = qm1[jindx[j]+i];
    k = cnt  = i;
    if(qmt<r)
      for(span = j - i,cnt=i+1; cnt<=j; cnt++){
#ifdef WITH_BOUSTROPHEDON
        k = (int)(i + 1 + span * ((cnt - i - 1) % 2)) + (int)((1 - (2 * ((cnt - i - 1) % 2))) * ((cnt - i) / 2));
#else
        k = cnt;
#endif
        q_temp = 0.;
        u = k - i;
        /* [i...k] is unpaired */
        if(hc_up_ml[i] >= u){
          q_temp += expMLbase[u] * qm1[jindx[j]+k];

          if(sc){
            if(sc->exp_energy_up)
              q_temp *= sc->exp_energy_up[i][u];

            if(sc->exp_f)
              q_temp *= sc->exp_f(i, j, k, j, VRNA_DECOMP_ML_ML, sc->data);
          }

          qmt += q_temp;
        }

        /* split between k-1, k */
        q_temp = qm[my_iindx[i]-(k-1)] * qm1[jindx[j]+k];

        if(sc){
          if(sc->exp_f)
            q_temp *= sc->exp_f(i, j, k-1, k, VRNA_DECOMP_ML_ML_ML, sc->data);
        }

        qmt += q_temp;

        if(qmt >= r){ break;}
      }
    if(cnt>j) vrna_message_error("backtrack failed in qm");

    backtrack_qm1(k, j, pstruc, vc);

    if(k<i+turn) break; /* no more pairs */

    u = k - i;
    /* check whether we make the decision to leave [i..k-1] unpaired */
    if(hc_up_ml[i] >= u){
      q_temp = expMLbase[u];

      if(sc){
        if(sc->exp_energy_up)
          q_temp *= sc->exp_energy_up[i][u];

        if(sc->exp_f)
          q_temp *= sc->exp_f(i, k-1, i, k-1, VRNA_DECOMP_ML_UP, sc->data);
      }

      r = vrna_urn() * (qm[my_iindx[i]-(k-1)] + q_temp);
      if(q_temp >= r) break;
    }
    j = k-1;
  }
}

PRIVATE void
backtrack_qm1(int i,
              int j,
              char *pstruc,
              vrna_fold_compound_t *vc){

  /* i is paired to l, i<l<j; backtrack in qm1 to find l */
  int           ii, l, il, type, n, turn;
  FLT_OR_DBL    qt, r, q_temp;
  FLT_OR_DBL    *qm1, *qb, *expMLbase;
  vrna_mx_pf_t  *matrices;
  int           u, *my_iindx, *jindx, *hc_up_ml;
  char          *ptype, *hard_constraints;
  short         *S1;
  vrna_sc_t     *sc;
  vrna_hc_t     *hc;
  vrna_exp_param_t  *pf_params;


  pf_params = vc->exp_params;
  my_iindx  = vc->iindx;
  jindx     = vc->jindx;

  ptype     = vc->ptype;

  sc        = vc->sc;
  hc        = vc->hc;
  hc_up_ml  = hc->up_ml;
  hard_constraints  = hc->matrix;

  matrices  = vc->exp_matrices;
  qb        = matrices->qb;
  qm1       = matrices->qm1;
  expMLbase = matrices->expMLbase;
  S1        = vc->sequence_encoding;

  turn      = pf_params->model_details.min_loop_size;

  n = j;
  r = vrna_urn() * qm1[jindx[j]+i];
  ii = my_iindx[i];
  for (qt=0., l=j; l > i + turn; l--) {
    il = jindx[l] + i;
    if(hard_constraints[il] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC){
      u = j - l;
      if(hc_up_ml[l+1] >= u){
        type = ptype[il];

        if(type == 0)
          type = 7;

        q_temp =  qb[ii-l]
                  * exp_E_MLstem(type, S1[i-1], S1[l+1], pf_params)
                  * expMLbase[j-l];

        if(sc){
          if(sc->exp_energy_up)
            q_temp *= sc->exp_energy_up[l+1][j-l];

          if(sc->exp_f)
            q_temp *= sc->exp_f(i, j, i, l, VRNA_DECOMP_ML_STEM, sc->data);
        }

        qt += q_temp;
        if (qt>=r) break;
      } else {
        l = i + turn;
        break;
      }
    }
  }
  if (l < i + turn + 1) vrna_message_error("backtrack failed in qm1");
  backtrack(i, l, pstruc, vc);
}

PRIVATE void
backtrack_qm2(int k,
              int n,
              char *pstruc,
              vrna_fold_compound_t *vc){

  FLT_OR_DBL  qom2t, r;
  int         u, turn;
  FLT_OR_DBL  *qm1, *qm2;
  int         *jindx;

  jindx     = vc->jindx;
  qm1       = vc->exp_matrices->qm1;
  qm2       = vc->exp_matrices->qm2;
  turn      = vc->exp_params->model_details.min_loop_size;

  r= vrna_urn()*qm2[k];
  /* we have to search for our barrier u between qm1 and qm1  */
  for (qom2t = 0.,u=k+turn+1; u<n-turn-1; u++){
    qom2t += qm1[jindx[u]+k]*qm1[jindx[n]+(u+1)];
    if(qom2t > r) break;
  }
  if(u==n-turn) vrna_message_error("backtrack failed in qm2");
  backtrack_qm1(k, u, pstruc, vc);
  backtrack_qm1(u+1, n, pstruc, vc);
}

PRIVATE void
backtrack(int i,
          int j,
          char *pstruc,
          vrna_fold_compound_t *vc){

  char              *ptype, *sequence, *hard_constraints, hc_decompose;
  vrna_exp_param_t  *pf_params;
  FLT_OR_DBL        *qb, *qm, *qm1, *scale, tmp;
  FLT_OR_DBL        r, qbt1, qt, q_temp;
  vrna_mx_pf_t      *matrices;
  int               *my_iindx, *jindx, *hc_up_int, *hc_up_hp;
  vrna_sc_t         *sc;
  vrna_hc_t         *hc;
  short             *S1;

  sequence    = vc->sequence;
  pf_params   = vc->exp_params;
  ptype       = vc->ptype;
  S1          = vc->sequence_encoding;
  my_iindx    = vc->iindx;
  jindx       = vc->jindx;

  sc          = vc->sc;
  hc          = vc->hc;
  hc_up_hp    = hc->up_hp;
  hc_up_int   = hc->up_int;
  hard_constraints  = hc->matrix;

  matrices    = vc->exp_matrices;
  qb          = matrices->qb;
  qm          = matrices->qm;
  qm1         = matrices->qm1;
  scale       = matrices->scale;

  int noGUclosure = pf_params->model_details.noGUclosure;
  int turn        = pf_params->model_details.min_loop_size;
  int   *rtype    = &(pf_params->model_details.rtype[0]);
  int n;
  n = j;
  do {
    int k, l, kl, u, u1, u2, max_k, min_l;
    unsigned char type;
    k = i;
    l = j;

    pstruc[i-1] = '('; pstruc[j-1] = ')';

    r = vrna_urn() * qb[my_iindx[i]-j];
    tmp = qb[my_iindx[i]-j];
    type = (unsigned char)ptype[jindx[j] + i];
    hc_decompose = hard_constraints[jindx[j] + i];
    if(hc_decompose & VRNA_CONSTRAINT_CONTEXT_HP_LOOP){ /* hairpin contribution */

      if(type == 0)
        type = 7;

      u = j-i-1;

      if (((type==3)||(type==4))&&noGUclosure) qbt1 = 0;
      else{
        q_temp = exp_E_Hairpin(u, type, S1[i+1], S1[j-1], sequence+i-1, pf_params) * scale[u+2];

        if(sc){
          if(sc->exp_energy_up)
            q_temp *= sc->exp_energy_up[i+1][u];

          if(sc->exp_f)
            q_temp *= sc->exp_f(i, j, i, j, VRNA_DECOMP_PAIR_HP, sc->data);
        }

        qbt1 = q_temp;

      }
      if (qbt1>=r) return; /* found the hairpin we're done */
    }

    if(hc_decompose & VRNA_CONSTRAINT_CONTEXT_INT_LOOP){ /* interior loop contributions */

      if(type == 0)
        type = 7;

      max_k = i + MAXLOOP + 1;
      max_k = MIN2(max_k, j - turn - 2);
      max_k = MIN2(max_k, i + 1 + hc_up_int[i+1]);
      for (k = i + 1; k<=max_k; k++) {
        u1    = k-i-1;
        min_l = MAX2(k+turn+1,j-1-MAXLOOP+u1);
        kl    = my_iindx[k] - j + 1;
        for (u2 = 0, l=j-1; l>=min_l; l--, kl++, u2++){
          if(hc_up_int[l+1] < u2) break;
          if(hard_constraints[jindx[l] + k] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP_ENC){
            unsigned char type_2 = (unsigned char)ptype[jindx[l] + k];
            type_2 = rtype[type_2];

            if(type_2 == 0)
              type_2 = 7;

            /* add *scale[u1+u2+2] */
            q_temp = qb[kl]
                     * scale[u1+u2+2]
                     * exp_E_IntLoop(u1, u2, type, type_2, S1[i+1], S1[j-1], S1[k-1], S1[l+1], pf_params);

            if(sc){
              if(sc->exp_energy_up)
                q_temp *=   sc->exp_energy_up[i+1][u1]
                          * sc->exp_energy_up[l+1][u2];

              if(sc->exp_energy_stack)
                if((i + 1 == k) && (j - 1 == l))
                  q_temp *=   sc->exp_energy_stack[i]
                            * sc->exp_energy_stack[k]
                            * sc->exp_energy_stack[l]
                            * sc->exp_energy_stack[j];

              if(sc->exp_f)
                q_temp *= sc->exp_f(i, j, k, l, VRNA_DECOMP_PAIR_IL, sc->data);
            }

            qbt1 += q_temp;
            if (qbt1 >= r) break;
          }
        }
        if (qbt1 >= r) break;
      }
      if (k <= max_k) {
        i=k; j=l;
      } else { /* interior loop contributions did not exceed threshold, so we break */
        break;
      }
    } else { /* must not be interior loop, so we break out */
      break;
    }
  } while (1);

  /* backtrack in multi-loop */
  {
    int k, ii, jj, tt;
    FLT_OR_DBL closingPair;
    tt = rtype[(unsigned char)ptype[jindx[j] + i]];
    closingPair =   pf_params->expMLclosing
                  * exp_E_MLstem(tt, S1[j-1], S1[i+1], pf_params)
                  * scale[2];
    if(sc){
      if(sc->exp_f)
        closingPair *= sc->exp_f(i, j, i, j, VRNA_DECOMP_PAIR_ML, sc->data);
    }

    i++; j--;
    /* find the first split index */
    ii = my_iindx[i]; /* ii-j=[i,j] */
    jj = jindx[j]; /* jj+i=[j,i] */
    for (qt=qbt1, k=i+1; k<j; k++) {

      q_temp = qm[ii-(k-1)] * qm1[jj+k] * closingPair;

      if(sc){
        if(sc->exp_f)
          q_temp *= sc->exp_f(i, j, k-1, k, VRNA_DECOMP_ML_ML_ML, sc->data);
      }

      qt += q_temp;
      qbt1 += q_temp;
      if (qt>=r) break;
    }
    if (k>=j){
      vrna_message_error("backtrack failed, can't find split index ");
    }

    backtrack_qm1(k, j, pstruc, vc);

    j = k-1;
    backtrack_qm(i, j, pstruc, vc);
  }
}

PRIVATE char *
wrap_pbacktrack_circ(vrna_fold_compound_t *vc){

  FLT_OR_DBL  r, qt;
  int         i, j, k, l, n;
  vrna_exp_param_t   *pf_params;
  FLT_OR_DBL  qo, qmo;
  FLT_OR_DBL  *scale, *qb, *qm, *qm2;
  char        *sequence, *ptype, *pstruc;
  int         *my_iindx, *jindx;
  short       *S1;

  vrna_mx_pf_t *matrices;

  pf_params     = vc->exp_params;
  matrices      = vc->exp_matrices;
  ptype         = vc->ptype;
  my_iindx      = vc->iindx;
  jindx         = vc->jindx;
  S1            = vc->sequence_encoding;

  qo            = matrices->qo;
  qmo           = matrices->qmo;
  qb            = matrices->qb;
  qm            = matrices->qm;
  qm2           = matrices->qm2;
  scale         = matrices->scale;

  FLT_OR_DBL  expMLclosing  = pf_params->expMLclosing;
  int         *rtype        = &(pf_params->model_details.rtype[0]);
  int         turn          = pf_params->model_details.min_loop_size;

  sequence  = vc->sequence;
  n         = vc->length;

/*
  if (init_length<1)
    vrna_message_error("can't backtrack without pf arrays.\n"
      "Call pf_circ_fold() before pbacktrack_circ()");
*/

  pstruc = vrna_alloc((n+1)*sizeof(char));

  /* initialize pstruct with single bases  */
  for (i=0; i<n; i++) pstruc[i] = '.';

  qt = 1.0*scale[n];
  r = vrna_urn() * qo;

  /* open chain? */
  if(qt > r) return pstruc;

  for(i=1; (i < n); i++){
    for(j=i+turn+1;(j<=n); j++){

      int type, u;
      /* 1. first check, wether we can do a hairpin loop  */
      u = n-j + i-1;
      if (u<turn) continue;

      type = ptype[jindx[j] + i];
      if (!type) continue;

      type=rtype[type];

      char loopseq[10];
      if (u<7){
        strcpy(loopseq , sequence+j-1);
        strncat(loopseq, sequence, i);
      }

      qt += qb[my_iindx[i]-j] * exp_E_Hairpin(u, type, S1[j+1], S1[i-1],  loopseq, pf_params) * scale[u];
      /* found a hairpin? so backtrack in the enclosed part and we're done  */
      if(qt>r){ backtrack(i,j, pstruc, vc); return pstruc;}

      /* 2. search for (k,l) with which we can close an interior loop  */
      for(k=j+1; (k < n); k++){
        int ln1, lstart;
        ln1 = k - j - 1;
        if(ln1+i-1>MAXLOOP) break;

        lstart = ln1+i-1+n-MAXLOOP;
        if(lstart<k+turn+1) lstart = k + turn + 1;
        for(l=lstart; (l <= n); l++){
            int ln2, type2;
            ln2 = (i - 1) + (n - l);
            if((ln1+ln2) > MAXLOOP) continue;

            type2 = ptype[jindx[l] + k];
            if(!type) continue;
            type2 = rtype[type2];
            qt += qb[my_iindx[i]-j] * qb[my_iindx[k]-l] * exp_E_IntLoop(ln2, ln1, type2, type, S1[l+1], S1[k-1], S1[i-1], S1[j+1], pf_params) * scale[ln1 + ln2];
            /* found an exterior interior loop? also this time, we can go straight  */
            /* forward and backtracking the both enclosed parts and we're done      */
            if(qt>r){ backtrack(i,j, pstruc, vc); backtrack(k,l, pstruc, vc); return pstruc;}
        }
      } /* end of kl double loop */
    }
  } /* end of ij double loop  */
  {
    /* as we reach this part, we have to search for our barrier between qm and qm2  */
    qt = 0.;
    r = vrna_urn()*qmo;
    for(k=turn+2; k<n-2*turn-3; k++){
      qt += qm[my_iindx[1]-k] * qm2[k+1] * expMLclosing;
      /* backtrack in qm and qm2 if we've found a valid barrier k  */
      if(qt>r){ backtrack_qm(1,k, pstruc, vc); backtrack_qm2(k+1,n, pstruc, vc); return pstruc;}
    }
  }
  /* if we reach the actual end of this function, an error has occured  */
  /* cause we HAVE TO find an exterior loop or an open chain!!!         */
  vrna_message_error("backtracking failed in exterior loop");
  return pstruc;
}


PRIVATE char *
pbacktrack_comparative( vrna_fold_compound_t *vc,
                        double *prob){

  FLT_OR_DBL  r, gr, qt;
  int         k,i,j, start,s;
  FLT_OR_DBL      probs=1;
  char        *pstruc = NULL;

  int               n_seq       = vc->n_seq;
  int               n           = vc->length;
  short             **S         = vc->S;
  short             **S5        = vc->S5;     /*S5[s][i] holds next base 5' of i in sequence s*/
  short             **S3        = vc->S3;     /*Sl[s][i] holds next base 3' of i in sequence s*/
  vrna_exp_param_t  *pf_params  = vc->exp_params;
  vrna_mx_pf_t      *matrices   = vc->exp_matrices;
  vrna_md_t         *md         = &(pf_params->model_details);
  int               *my_iindx   = vc->iindx;
  vrna_hc_t         *hc         = vc->hc;
  vrna_sc_t         **sc        = vc->scs;
  FLT_OR_DBL        *q          = matrices->q;
  FLT_OR_DBL        *qb         = matrices->qb;

  if((matrices->q1k == NULL) || (matrices->qln == NULL)){
    free(matrices->q1k);
    matrices->q1k = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+1));
    free(matrices->qln);
    matrices->qln = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));
  }

  FLT_OR_DBL *q1k   = matrices->q1k;
  FLT_OR_DBL *qln   = matrices->qln;
  FLT_OR_DBL *scale = matrices->scale;

  for (k=1; k<=n; k++) {
    q1k[k] = q[my_iindx[1] - k];
    qln[k] = q[my_iindx[k] - n];
  }
  q1k[0] = 1.0;
  qln[n+1] = 1.0;

  pstruc = vrna_alloc((n+1)*sizeof(char));

  for (i=0; i<n; i++)
    pstruc[i] = '.';


  start = 1;
  while (start<n) {
  /* find i position of first pair */
    probs=1.;
    for (i=start; i<n; i++) {
      gr = vrna_urn() * qln[i];
      if (gr > qln[i+1]*scale[1]) {
        *prob=*prob*probs*(1-qln[i+1]*scale[1]/qln[i]);
        break; /* i is paired */
      }
      probs*=qln[i+1]*scale[1]/qln[i];
    }
    if (i>=n) {
      *prob=*prob*probs;
      break; /* no more pairs */
    }
    /* now find the pairing partner j */
    r = vrna_urn() * (qln[i] - qln[i+1]*scale[1]);
    for (qt=0, j=i+1; j<=n; j++) {
      int xtype;
      /*  type = ptype[my_iindx[i]-j];
          if (type) {*/
      FLT_OR_DBL qkl;
      if (qb[my_iindx[i]-j]>0) {
        qkl = qb[my_iindx[i]-j]*qln[j+1];  /*if psc too small qb=0!*/
        for (s=0; s< n_seq; s++) {
          xtype=md->pair[S[s][i]][S[s][j]];
          if (xtype==0) xtype=7;
          qkl *= exp_E_ExtLoop(xtype, (i>1) ? S5[s][i] : -1, (j<n) ? S3[s][j] : -1, pf_params);
        }
        qt += qkl; /*?*exp(pscore[jindx[j]+i]/kTn)*/
        if (qt > r) {
          *prob=*prob*(qkl/(qln[i] - qln[i+1]*scale[1]));/*probs*=qkl;*/
          break; /* j is paired */
        }
      }
    }
    if (j==n+1) vrna_message_error("backtracking failed in ext loop");
    start = j+1;
    backtrack_comparative(vc, pstruc, i, j, prob); /*?*/
  }

  return pstruc;
}


PRIVATE void
backtrack_comparative(vrna_fold_compound_t *vc,
          char *pstruc,
          int i,
          int j,
          double *prob){

  int               n_seq       = vc->n_seq;
  short             **S         = vc->S;
  short             **S5        = vc->S5;     /*S5[s][i] holds next base 5' of i in sequence s*/
  short             **S3        = vc->S3;     /*Sl[s][i] holds next base 3' of i in sequence s*/
  char              **Ss        = vc->Ss;
  unsigned short    **a2s       = vc->a2s;
  vrna_exp_param_t  *pf_params  = vc->exp_params;
  vrna_mx_pf_t      *matrices   = vc->exp_matrices;
  vrna_md_t         *md         = &(pf_params->model_details);
  int               *my_iindx   = vc->iindx;
  int               *jindx      = vc->jindx;
  vrna_hc_t         *hc         = vc->hc;
  vrna_sc_t         **sc        = vc->scs;
  FLT_OR_DBL        *qb         = matrices->qb;
  FLT_OR_DBL        *qm         = matrices->qm;
  FLT_OR_DBL        *qm1        = matrices->qm1;
  int               *pscore     = vc->pscore;     /* precomputed array of pair types */

  FLT_OR_DBL        *scale        = matrices->scale;
  FLT_OR_DBL        *expMLbase    = matrices->expMLbase;

  /*backtrack given i,j basepair!*/
  FLT_OR_DBL kTn = pf_params->kT/10.;
  int *type = (int *)vrna_alloc(sizeof(int) * n_seq);

  do {
    FLT_OR_DBL  r, qbt1, max_k, min_l;
    int         k, l, u, u1, u2, s;
    pstruc[i-1] = '('; pstruc[j-1] = ')';
    for (s=0; s<n_seq; s++) {
      type[s] = md->pair[S[s][i]][S[s][j]];
      if (type[s]==0) type[s]=7;
    }
    r = vrna_urn() * (qb[my_iindx[i]-j]/exp(pscore[jindx[j]+i]/kTn)); /*?*exp(pscore[jindx[j]+i]/kTn)*/

    qbt1=1.;
    for (s=0; s<n_seq; s++){
      u = a2s[s][j-1]-a2s[s][i];
      if (a2s[s][i]<1) continue;
      char loopseq[10];
      if(u < 9){
        strncpy(loopseq, Ss[s]+a2s[s][i]-1, 10);
      }
      qbt1 *= exp_E_Hairpin(u, type[s], S3[s][i], S5[s][j], loopseq, pf_params);
    }
    qbt1 *= scale[j-i+1];

    if (qbt1>r) {
      *prob=*prob*qbt1/(qb[my_iindx[i]-j]/exp(pscore[jindx[j]+i]/kTn));/*probs*=qbt1;*/
      free(type);
      return; /* found the hairpin we're done */
    }


    max_k = MIN2(i+MAXLOOP+1,j-TURN-2);
    l = MAX2(i+TURN+2,j-MAXLOOP-1);
    for (k=i+1; k<=max_k; k++){
      min_l = MAX2(k+TURN+1,j-1-MAXLOOP+k-i-1);

      for (l=min_l; l<j; l++){
        FLT_OR_DBL qloop=1;
        int type_2;
        if (qb[my_iindx[k]-l]==0) {qloop=0; continue;}
        for (s=0; s<n_seq; s++) {
          u1      = a2s[s][k-1] - a2s[s][i]/*??*/;
          u2      = a2s[s][j-1] - a2s[s][l];
          type_2  = md->pair[S[s][l]][S[s][k]];
          if(type_2 == 0) type_2 = 7;

          qloop *= exp_E_IntLoop(u1, u2, type[s], type_2, S3[s][i], S5[s][j],S5[s][k], S3[s][l], pf_params);
        }

        if(sc)
          for (s=0; s<n_seq; s++) {
            if(sc[s]){
              int u1 = a2s[s][k-1] - a2s[s][i];
              int u2 = a2s[s][j-1] - a2s[s][l];
              if(u1 + u2 == 0)
                if(sc[s]->exp_energy_stack){
                  if(S[s][i] && S[s][j] && S[s][k] && S[s][l]){ /* don't allow gaps in stack */
                    qloop *=    sc[s]->exp_energy_stack[i]
                              * sc[s]->exp_energy_stack[k]
                              * sc[s]->exp_energy_stack[l]
                              * sc[s]->exp_energy_stack[j];
                  }
                }
            }
          }

        qbt1 += qb[my_iindx[k]-l] * qloop * scale[k-i+j-l];

        if (qbt1 > r) {
         *prob =  *prob
                  * qb[my_iindx[k]-l]
                  * qloop
                  * scale[k-i+j-l]
                  / (   qb[my_iindx[i]-j]
                      / exp(pscore[jindx[j]+i] / kTn));
         /*
          prob*=qb[my_iindx[k]-l] * qloop * scale[k-i+j-l];
         */
          break;
        }
      }
      if (qbt1 > r) break;
    }
    if (l<j) {
      i=k; j=l;
    }
    else {
      *prob=*prob*(1-qbt1/(qb[my_iindx[i]-j]/exp(pscore[jindx[j]+i]/kTn)));
      break;
    }
  } while (1);

  /* backtrack in multi-loop */
  {
    FLT_OR_DBL r, qt;
    int k, ii, jj;
    FLT_OR_DBL qttemp=0;;
    i++; j--;
    /* find the first split index */
    ii = my_iindx[i]; /* ii-j=[i,j] */
    jj = jindx[j]; /* jj+i=[j,i] */
    for (qt=0., k=i+1; k<j; k++) qttemp += qm[ii-(k-1)]*qm1[jj+k];
    r = vrna_urn() * qttemp;
    for (qt=0., k=i+1; k<j; k++) {
      qt += qm[ii-(k-1)]*qm1[jj+k];
      if (qt>=r){
        *prob = *prob
                * qm[ii-(k-1)]
                * qm1[jj+k]
                / qttemp;/*qttemp;*/
        /*        prob*=qm[ii-(k-1)]*qm1[jj+k];*/
        break;
      }
    }
    if (k>=j) vrna_message_error("backtrack failed, can't find split index ");

    backtrack_qm1_comparative(vc, pstruc, k, j, prob);

    j = k-1;
    while (j>i) {
      /* now backtrack  [i ... j] in qm[] */
      jj = jindx[j];/*habides??*/
      ii = my_iindx[i];
      r = vrna_urn() * qm[ii - j];
      qt = qm1[jj+i]; k=i;
      if (qt<r)
        for (k=i+1; k<=j; k++) {
          qt += (qm[ii-(k-1)]+expMLbase[k-i]/*n_seq??*/)*qm1[jj+k];
          if (qt >= r) {
            *prob = *prob
                    * (qm[ii-(k-1)] + expMLbase[k-i])
                    * qm1[jj+k]
                    / qm[ii - j];/*???*/
            /*            probs*=qt;*/
            break;
          }
        }
      else {
        *prob = *prob * qt / qm[ii - j];/*??*/
      }
      if (k>j) vrna_message_error("backtrack failed in qm");

      backtrack_qm1_comparative(vc, pstruc, k, j, prob);

      if (k<i+TURN) break; /* no more pairs */
      r = vrna_urn() * (qm[ii-(k-1)] + expMLbase[k-i]);
      if (expMLbase[k-i] >= r) {
        *prob = *prob * expMLbase[k-i] / (qm[ii-(k-1)] + expMLbase[k-i]);
        break; /* no more pairs */
      }
      j = k-1;
      /* whatishere?? */
    }
  }
  free(type);
}

PRIVATE void
backtrack_qm1_comparative(vrna_fold_compound_t *vc,
              char *pstruc,
              int i,
              int j,
              double *prob){

  int               n_seq       = vc->n_seq;
  short             **S         = vc->S;
  short             **S5        = vc->S5;     /*S5[s][i] holds next base 5' of i in sequence s*/
  short             **S3        = vc->S3;     /*Sl[s][i] holds next base 3' of i in sequence s*/
  vrna_exp_param_t  *pf_params  = vc->exp_params;
  vrna_mx_pf_t      *matrices   = vc->exp_matrices;
  vrna_md_t         *md         = &(pf_params->model_details);
  int               *my_iindx   = vc->iindx;
  int               *jindx      = vc->jindx;
  vrna_hc_t         *hc         = vc->hc;
  vrna_sc_t         **sc        = vc->scs;
  FLT_OR_DBL        *qb         = matrices->qb;
  FLT_OR_DBL        *qm1        = matrices->qm1;
  FLT_OR_DBL        *expMLbase    = matrices->expMLbase;

  /* i is paired to l, i<l<j; backtrack in qm1 to find l */
  int ii, l, xtype,s;
  FLT_OR_DBL qt, r, tempz;
  r = vrna_urn() * qm1[jindx[j]+i];
  ii = my_iindx[i];
  for (qt=0., l=i+TURN+1; l<=j; l++) {
    if (qb[ii-l]==0) continue;
    tempz=1.;
    for (s=0; s<n_seq; s++) {
      xtype = md->pair[S[s][i]][S[s][l]];
      if (xtype==0) xtype=7;
      tempz *= exp_E_MLstem(xtype, S5[s][i], S3[s][l], pf_params);
    }
    qt +=  qb[ii-l]*tempz*expMLbase[j-l];
    if (qt>=r) {
      *prob = *prob
              * qb[ii-l]
              * tempz
              * expMLbase[j-l]
              / qm1[jindx[j]+i];
      /* probs*=qb[ii-l]*tempz*expMLbase[j-l];*/
      break;
    }
  }
  if (l>j) vrna_message_error("backtrack failed in qm1");

  backtrack_comparative(vc, pstruc, i, l, prob);
}


/181            0           0     0     644     13372     `
/* SHAPE reactivity data handling */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>

#include "energy_par.h"
#include "energy_const.h" /* defines MINPSCORE */
#include "fold_vars.h"
#include "utils.h"
#include "aln_util.h"
#include "file_formats.h"
#include "params.h"
#include "constraints.h"
#include "constraints_SHAPE.h"

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/
PRIVATE void
sc_parse_parameters(const char *string,
                    char c1,
                    char c2,
                    float *v1,
                    float *v2);

PRIVATE void
sc_add_stack_en_mfe(vrna_fold_compound_t *vc,
                    const FLT_OR_DBL *constraints,
                    unsigned int options);

PRIVATE void
prepare_Boltzmann_weights_stack(vrna_fold_compound_t *vc);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/
PUBLIC int
vrna_sc_SHAPE_to_pr(const char *shape_conversion,
                    double *values,
                    int length,
                    double default_value){

  int *indices;
  int i, j;
  int index;
  int ret = 1;

  if(!shape_conversion || !(*shape_conversion) || length <= 0)
    return 0;

  if(*shape_conversion == 'S')
    return 1;

  indices = vrna_alloc(sizeof(int) * (length + 1));
  for (i = 1, j = 0; i <= length; ++i){
    if(values[i] < 0)
      values[i] = default_value;
    else
      indices[j++] = i;
  }

  if(*shape_conversion == 'M'){
    double max;
    double map_info[4][2] = {{0.25, 0.35},
                           {0.30, 0.55},
                           {0.70, 0.85},
                           {0, 1}};

    max = values[1];
    for(i = 2; i <= length; ++i)
      max = MAX2(max, values[i]);
    map_info[3][0] = max;

    for(i = 0; indices[i]; ++i){
      double lower_source = 0;
      double lower_target = 0;

      index = indices[i];

      if(values[index] == 0)
        continue;

      for(j = 0; j < 4; ++j){
        if(values[index] > lower_source && values[index] <= map_info[j][0]){
          double diff_source = map_info[j][0] - lower_source;
          double diff_target = map_info[j][1] - lower_target;
          values[index] = (values[index] - lower_source) / diff_source * diff_target + lower_target;
          break;
        }

        lower_source = map_info[j][0];
        lower_target = map_info[j][1];
      }
    }
  }
  else if (*shape_conversion == 'C'){
    float cutoff = 0.25;
    int i;

    sscanf(shape_conversion + 1, "%f", &cutoff);

    for(i = 0; indices[i]; ++i){
      index = indices[i];
      values[index] = values[index] < cutoff ? 0 : 1;
    }
  }
  else if (*shape_conversion == 'L' || *shape_conversion == 'O'){
    int i;
    float slope = (*shape_conversion == 'L') ? 0.68 : 1.6;
    float intercept = (*shape_conversion == 'L') ? 0.2 : -2.29;

    sc_parse_parameters(shape_conversion + 1, 's', 'i', &slope, &intercept);

    for(i = 0; indices[i]; ++i){
      double v;
      index = indices[i];

      v = (*shape_conversion == 'L') ? values[index] : log(values[index]);
      values[index] = MAX2(MIN2((v - intercept) / slope, 1),0);
    }
  }
  else
    ret = 0;

  free(indices);

  return ret;
}

PUBLIC  int
vrna_sc_add_SHAPE_zarringhalam( vrna_fold_compound_t *vc,
                                const double *reactivities,
                                double b,
                                double default_value,
                                const char *shape_conversion,
                                unsigned int options){

  int       i, j, n, ret;
  double        *pr;
  FLT_OR_DBL    *up, **bp;
  vrna_md_t *md;

  ret = 0; /* error */

  if(vc && reactivities && (vc->type == VRNA_VC_TYPE_SINGLE)){
    n   = vc->length;
    md  = &(vc->params->model_details);

    /* first we copy over the reactivities to convert them into probabilities later on */
    pr = (double *)vrna_alloc(sizeof(double) * (n + 1));
    for(i=0; i<=n; i++)
      pr[i] = reactivities[i];

    if(vrna_sc_SHAPE_to_pr(shape_conversion, pr, n, default_value)){

      /*  now, convert them into pseudo free energies for unpaired, and
          paired nucleotides
      */
      up = (FLT_OR_DBL *)vrna_alloc(sizeof(FLT_OR_DBL) * (n + 1));
      bp = (FLT_OR_DBL **)vrna_alloc(sizeof(FLT_OR_DBL *) * (n + 1));
      for(i = 1; i <= n; ++i){
        up[i] = b * fabs(pr[i] - 1);
        bp[i] = (FLT_OR_DBL *)vrna_alloc(sizeof(FLT_OR_DBL) * (n + 1));
        for(j = i + md->min_loop_size + 1; j <= n; ++j)
          bp[i][j] = b * (pr[i] + pr[j]);
      }

      /* add the pseudo energies as soft constraints */
      vrna_sc_add_up(vc, (const FLT_OR_DBL *)up, options);
      vrna_sc_add_bp(vc, (const FLT_OR_DBL **)bp, options);

      /* clean up memory */
      for(i = 1; i <= n; ++i)
        free(bp[i]);
      free(bp);
      free(up);

      ret = 1; /* success */
    }

    free(pr);

  }

  return ret;
}


PUBLIC int
vrna_sc_add_SHAPE_deigan( vrna_fold_compound_t *vc,
                          const double *reactivities,
                          double m,
                          double b,
                          unsigned int options){

  int     i;
  FLT_OR_DBL  *values;

  if(vc && (vc->type == VRNA_VC_TYPE_SINGLE)){
    if(reactivities){

      values = (FLT_OR_DBL *)vrna_alloc(sizeof(FLT_OR_DBL) * (vc->length + 1));

      /* first convert the values according to provided slope and intercept values */
      for (i = 1; i <= vc->length; ++i){
        values[i] = reactivities[i] < 0 ? 0. : (FLT_OR_DBL)(m * log(reactivities[i] + 1) + b);
      }

      /* always store soft constraints in plain format */
      sc_add_stack_en_mfe(vc, (const FLT_OR_DBL *)values, options);
      free(values);
    }

    if(options & VRNA_OPTION_PF)
      prepare_Boltzmann_weights_stack(vc);

    return 1; /* success */
  }
  return 0; /* error */
}

PUBLIC int
vrna_sc_add_SHAPE_deigan_ali( vrna_fold_compound_t *vc,
                              const char **shape_files,
                              const int *shape_file_association,
                              double m,
                              double b,
                              unsigned int options){

  float           reactivity, *reactivities, e1;
  char            *line, nucleotide, *sequence;
  int             s, i, p, r, position, *pseudo_energies, n_seq;
  unsigned short  **a2s;

  if(vc && (vc->type == VRNA_VC_TYPE_ALIGNMENT)){
    n_seq = vc->n_seq;
    a2s   = vc->a2s;

    vrna_sc_init(vc);

    for(s = 0; shape_file_association[s] != -1; s++){
      int ss = shape_file_association[s]; /* actual sequence number in alignment */

      if(ss >= n_seq){
        vrna_message_warning("SHAPE file association exceeds sequence number in alignment");
        continue;
      }

      /* read the shape file */
      FILE *fp;
      if(!(fp = fopen(shape_files[s], "r"))){
        fprintf(stderr, "WARNING: SHAPE data file %d could not be opened. No shape data will be used.\n", s);
      } else {

        reactivities  = (float *)vrna_alloc(sizeof(float) * (vc->length + 1));
        sequence      = (char *)vrna_alloc(sizeof(char) * (vc->length + 1));

        /* initialize reactivities with missing data for entire alignment length */
        for(i = 1; i <= vc->length; i++)
          reactivities[i] = -1.;

        while((line=get_line(fp))){
          r = sscanf(line, "%d %c %f", &position, &nucleotide, &reactivity);
          if(r){
            if((position <= 0) || (position > vc->length))
              vrna_message_error("provided shape data outside of sequence scope");

            switch(r){
              case 1:   nucleotide = 'N';
                        /* fall through */
              case 2:   reactivity = -1.;
                        /* fall through */
              default:  sequence[position-1]    = nucleotide;
                        reactivities[position]  = reactivity;
                        break;
            }
          }
          free(line);
        }
        fclose(fp);

        sequence[vc->length] = '\0';

        /* double check information by comparing the sequence read from */
        char *tmp_seq = get_ungapped_sequence(vc->sequences[shape_file_association[s]]);
        if(strcmp(tmp_seq, sequence)){
          fprintf(stderr, "WARNING: Input sequence %d differs from sequence provided via SHAPE file!\n", shape_file_association[s]);
        }
        free(tmp_seq);

        /* convert reactivities to pseudo energies */
        for(i = 1; i <= vc->length; i++){
          if(reactivities[i] < 0)
            reactivities[i] = 0.;
          else
            reactivities[i] = m * log(reactivities[i] + 1.) + b; /* this should be a value in kcal/mol */
        }

        /*  begin actual storage of the pseudo energies */
        /*  beware of the fact that energy_stack will be accessed through a2s[s] array,
            hence pseudo_energy might be gap-free (default)
        */
        /* ALWAYS store soft constraints in plain format */
        int energy, cnt, gaps, is_gap;
        pseudo_energies = (int *)vrna_alloc(sizeof(int) * (vc->length + 1));
        for(gaps = cnt = 0, i = 1; i<=vc->length; i++){
          is_gap  = (vc->sequences[ss][i-1] == '-') ? 1 : 0;
          energy  = ((i - gaps > 0) && !(is_gap)) ? (int)roundf(reactivities[i - gaps] * 100.) : 0;

          if(vc->params->model_details.oldAliEn){
            pseudo_energies[i] = energy;
            cnt++;
          } else if(!is_gap){ /* store gap-free */
            pseudo_energies[a2s[ss][i]] = energy;
            cnt++;
          }

          gaps += is_gap;
        }

        /* resize to actual number of entries */
        pseudo_energies = vrna_realloc(pseudo_energies, sizeof(int) * (cnt + 2));
        vc->scs[ss]->energy_stack = pseudo_energies;

        if(options & VRNA_OPTION_PF){
          FLT_OR_DBL *exp_pe = (FLT_OR_DBL *)vrna_alloc(sizeof(FLT_OR_DBL) * (vc->length + 1));
          for(i=0;i<=vc->length;i++)
            exp_pe[i] = 1.;

          for(p = 0, i = 1; i<=vc->length; i++){
            e1 = (i - p > 0) ? reactivities[i - p] : 0.;
            if(vc->sequences[ss][i-1] == '-'){
              p++; e1 = 0.;
            }
            exp_pe[i] = (FLT_OR_DBL)exp(-(e1 * 1000.) / vc->exp_params->kT );
          }
          vc->scs[ss]->exp_energy_stack = exp_pe;
        }
        
        free(reactivities);
      }
    }

    return 1; /* success */
  } else {
    return 0; /* error */
  }
}

PUBLIC  int
vrna_sc_SHAPE_parse_method( const char *method_string,
                            char *method,
                            float *param_1,
                            float *param_2){

  const char *params = method_string + 1;

  *param_1 = 0;
  *param_2 = 0;

  if (!method_string || !method_string[0])
    return 0;

  *method = method_string[0];

  switch(method_string[0]){
    case 'Z':   *param_1 = 0.89;
                sc_parse_parameters(params, 'b', '\0', param_1, NULL);
                break;

    case 'D':   *param_1 = 1.8;
                *param_2 = -0.6;
                sc_parse_parameters(params, 'm', 'b', param_1, param_2);
                break;

    case 'W':   break;

    default:    *method = 0;
                return 0;
  }

  return 1;
}

PRIVATE void
sc_parse_parameters( const char *string,
                        char c1,
                        char c2,
                        float *v1,
                        float *v2){

  char fmt[8];
  const char warning[] = "SHAPE method parameters not recognized! Using default parameters!";
  int r;

  assert(c1);
  assert(v1);

  if(!string || !(*string))
    return;

  if(c2 == 0 || v2 == NULL){
    sprintf(fmt, "%c%%f", c1);
    r = sscanf(string, fmt, v1);

    if(!r)
      vrna_message_warning(warning);

    return;
  }

  sprintf(fmt, "%c%%f%c%%f", c1, c2);
  r = sscanf(string, fmt, v1, v2);

  if(r!=2){
    sprintf(fmt, "%c%%f", c1);
    r = sscanf(string, fmt, v1);

    if(!r){
      sprintf(fmt, "%c%%f", c2);
      r = sscanf(string, fmt, v2);

      if(!r)
        vrna_message_warning(warning);
    }
  }
}

PRIVATE void
sc_add_stack_en_mfe(vrna_fold_compound_t *vc,
                    const FLT_OR_DBL *constraints,
                    unsigned int options){
  int i;

  if(!vc->sc)
    vrna_sc_init(vc);

  if(!vc->sc->energy_stack)
    vc->sc->energy_stack = (int *)vrna_alloc(sizeof(int) * (vc->length + 1));

  for(i = 1; i <= vc->length; ++i)
    vc->sc->energy_stack[i] = (int)roundf(constraints[i] * 100.);
}

PRIVATE void
prepare_Boltzmann_weights_stack(vrna_fold_compound_t *vc){
  int i;
  vrna_sc_t *sc = vc->sc;

  if(sc->energy_stack){
    if(!sc->exp_energy_stack){
      sc->exp_energy_stack = (FLT_OR_DBL *)vrna_alloc(sizeof(FLT_OR_DBL) * (vc->length + 1));
      for(i = 0; i <= vc->length; ++i)
        sc->exp_energy_stack[i] = 1.;
    }

    for(i = 1; i <= vc->length; ++i)
      sc->exp_energy_stack[i] = (FLT_OR_DBL)exp(-(sc->energy_stack[i] * 10.)/ vc->exp_params->kT);
  }
}

/202            0           0     0     644     32756     `
/* constraints handling */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>

#include "energy_par.h"
#include "energy_const.h" /* defines MINPSCORE */
#include "fold_vars.h"
#include "utils.h"
#include "aln_util.h"
#include "file_formats.h"
#include "params.h"
#include "constraints.h"
#include "constraints_hard.h"


#ifdef __GNUC__
# define INLINE inline
#else
# define INLINE
#endif

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/
PRIVATE void
hc_add_up(vrna_fold_compound_t *vc,
          int i,
          char option);

PRIVATE INLINE  void
hc_cant_pair( unsigned int i,
              char c_option,
              char *hc,
              unsigned int length,
              unsigned int min_loop_size,
              int *index);

PRIVATE INLINE  void
hc_must_pair( unsigned int i,
              char c_option,
              char *hc,
              int *index);

PRIVATE INLINE  void
hc_pairs_upstream(unsigned int i,
                  char c_option,
                  char *hc,
                  unsigned int length,
                  int *index);

PRIVATE INLINE  void
hc_pairs_downstream(unsigned int i,
                    char c_option,
                    char *hc,
                    unsigned int length,
                    int *index);

PRIVATE INLINE  void
hc_allow_pair(unsigned int i,
              unsigned int j,
              char c_option,
              char *hc,
              int *index);

PRIVATE INLINE  void
hc_weak_enforce_pair( unsigned int i,
                      unsigned int j,
                      char c_option,
                      char *hc,
                      unsigned int length,
                      unsigned int min_loop_size,
                      int *index);

PRIVATE INLINE  void
hc_enforce_pair(unsigned int i,
                unsigned int j,
                char c_option,
                char *hc,
                unsigned int length,
                unsigned int min_loop_size,
                int *index);

PRIVATE INLINE  void
hc_intramolecular_only( unsigned int i,
                        char c_option,
                        char *hc,
                        unsigned int length,
                        unsigned int min_loop_size,
                        int cut,
                        int *index);

PRIVATE INLINE  void
hc_intermolecular_only( unsigned int i,
                        char c_option,
                        char *hc,
                        unsigned int length,
                        unsigned int min_loop_size,
                        int cut,
                        int *index);

PRIVATE void
apply_DB_constraint(const char *constraint,
                    char *ptype,
                    unsigned int length,
                    unsigned int min_loop_size,
                    int cut,
                    unsigned int options);

PRIVATE void
hc_reset_to_default(vrna_fold_compound_t *vc);

PRIVATE void
hc_update_up(vrna_fold_compound_t *vc);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/
PUBLIC  void
vrna_message_constraint_options_all(void){

  vrna_message_constraint_options(  VRNA_CONSTRAINT_DB_PIPE
                                  | VRNA_CONSTRAINT_DB_DOT
                                  | VRNA_CONSTRAINT_DB_X
                                  | VRNA_CONSTRAINT_DB_ANG_BRACK
                                  | VRNA_CONSTRAINT_DB_RND_BRACK);
}

PUBLIC  void
vrna_message_constraint_options(unsigned int option){

  printf("Input structure constraints using the following notation:\n");
  if(option & VRNA_CONSTRAINT_DB_PIPE)       printf("| : paired with another base\n");
  if(option & VRNA_CONSTRAINT_DB_DOT)        printf(". : no constraint at all\n");
  if(option & VRNA_CONSTRAINT_DB_X)          printf("x : base must not pair\n");
  if(option & VRNA_CONSTRAINT_DB_ANG_BRACK)  printf("< : base i is paired with a base j<i\n> : base i is paired with a base j>i\n");
  if(option & VRNA_CONSTRAINT_DB_RND_BRACK)  printf("matching brackets ( ): base i pairs base j\n");
}

PUBLIC  void
vrna_hc_init(vrna_fold_compound_t *vc){

  unsigned int  n;
  vrna_hc_t     *hc;

  n           = vc->length;

  /* free previous hard constraints */
  vrna_hc_free(vc->hc);

  /* allocate memory new hard constraints data structure */
  hc          = (vrna_hc_t *)vrna_alloc(sizeof(vrna_hc_t));
  hc->matrix  = (char *)vrna_alloc(sizeof(char)*((n*(n+1))/2+2));
  hc->up_ext  = (int *)vrna_alloc(sizeof(int)*(n+2));
  hc->up_hp   = (int *)vrna_alloc(sizeof(int)*(n+2));
  hc->up_int  = (int *)vrna_alloc(sizeof(int)*(n+2));
  hc->up_ml   = (int *)vrna_alloc(sizeof(int)*(n+2));

  /* set new hard constraints */
  vc->hc = hc;

  /* prefill default values  */
  hc_reset_to_default(vc);

  /* add null pointers for the generalized hard constraint feature */
  hc->f           = NULL;
  hc->data        = NULL;
  hc->free_data   = NULL;

  /* update */
  hc_update_up(vc);
}

PUBLIC void
vrna_hc_add_up( vrna_fold_compound_t *vc,
                int i,
                char option){

  int j;

  if(vc)
    if(vc->hc){
      if((i <= 0) || (i > vc->length)){
        vrna_message_warning("vrna_hc_add_up: position out of range, not doing anything");
        return;
      }

      hc_add_up(vc, i, option);

      hc_update_up(vc);
    }
}

PUBLIC int
vrna_hc_add_up_batch( vrna_fold_compound_t *vc,
                      vrna_hc_up_t *constraints){

  int i, ret;

  ret = 0; /* failure */

  if(vc)
    if(vc->hc && constraints){
      for(i = 0; constraints[i].position != 0; i++){
        int pos       = constraints[i].position;
        char options  = constraints[i].options;
        if((pos <= 0) || (pos > vc->length)){
          vrna_message_warning("vrna_hc_add_up_batch: position out of range, application of hard constraints stops here!");
          return ret;
        }
        hc_add_up(vc, pos, options);
      }

      hc_update_up(vc);
      ret = 1; /* success */
    }

  return ret;
}

PRIVATE void
hc_add_up(vrna_fold_compound_t *vc,
          int i,
          char option){

  int   j;
  char  type = (char)0;

  if(option & VRNA_CONSTRAINT_CONTEXT_ENFORCE){ /* force nucleotide to appear unpaired within a certain type of loop */
    /* do not allow i to be paired with any other nucleotide */
    if(!(option & VRNA_CONSTRAINT_CONTEXT_NO_REMOVE)){
      for(j = 1; j < i; j++)
        vc->hc->matrix[vc->jindx[i] + j] = (char)0;
      for(j = i+1; j <= vc->length; j++)
        vc->hc->matrix[vc->jindx[j] + i] = (char)0;
    }

    type = option & (char)( VRNA_CONSTRAINT_CONTEXT_EXT_LOOP
                            | VRNA_CONSTRAINT_CONTEXT_HP_LOOP
                            | VRNA_CONSTRAINT_CONTEXT_INT_LOOP
                            | VRNA_CONSTRAINT_CONTEXT_MB_LOOP);

    vc->hc->matrix[vc->jindx[i] + i] = type;
  } else {
    type = option & VRNA_CONSTRAINT_CONTEXT_ALL_LOOPS;

    /* do not allow i to be paired with any other nucleotide (in context type) */
    if(!(option & VRNA_CONSTRAINT_CONTEXT_NO_REMOVE)){
      for(j = 1; j < i; j++)
        vc->hc->matrix[vc->jindx[i] + j] &= ~type;
      for(j = i+1; j <= vc->length; j++)
        vc->hc->matrix[vc->jindx[j] + i] &= ~type;
    }

    vc->hc->matrix[vc->jindx[i] + i] = (char)(  VRNA_CONSTRAINT_CONTEXT_EXT_LOOP
                                              | VRNA_CONSTRAINT_CONTEXT_HP_LOOP
                                              | VRNA_CONSTRAINT_CONTEXT_INT_LOOP
                                              | VRNA_CONSTRAINT_CONTEXT_MB_LOOP);
  }
}

PUBLIC void
vrna_hc_add_bp_nonspecific( vrna_fold_compound_t *vc,
                            int i,
                            int d,
                            char option){
  int   p;
  char  type, t1, t2;

  if(vc)
    if(vc->hc){
      if((i <= 0) || (i > vc->length)){
        vrna_message_warning("vrna_hc_add_bp_nonspecific: position out of range, not doing anything");
        return;
      }

      /* position i may pair in provided contexts */
      type  = option & VRNA_CONSTRAINT_CONTEXT_ALL_LOOPS;
      /* acknowledge pairing direction */
      t1    = (d <= 0) ? type : (char)0;
      t2    = (d >= 0) ? type : (char)0;

      if(option & VRNA_CONSTRAINT_CONTEXT_NO_REMOVE){
        /* only allow for possibly non-canonical pairs, do not enforce them */
        for(p = 1; p < i; p++)
          vc->hc->matrix[vc->jindx[i] + p] |= t1;
        for(p = i+1; p <= vc->length; p++)
          vc->hc->matrix[vc->jindx[p] + i] |= t2;
      } else {
        /* force pairing direction */
        for(p = 1; p < i; p++)
          vc->hc->matrix[vc->jindx[i] + p] &= t1;
        for(p = i+1; p <= vc->length; p++)
          vc->hc->matrix[vc->jindx[p] + i] &= t2;
        /* nucleotide mustn't be unpaired */
        vc->hc->matrix[vc->jindx[i] + i] = (char)0;
      }

      hc_update_up(vc);
    }

}

PUBLIC void
vrna_hc_add_bp( vrna_fold_compound_t *vc,
                int i,
                int j,
                char option){

  int   k, l;
  char  type;

  if(vc)
    if(vc->hc){
      if((i <= 0) || (j <= i) || (j > vc->length)){
        vrna_message_warning("vrna_hc_add_bp: position out of range, not doing anything");
        return;
      }

      /* reset ptype in case (i,j) is a non-canonical pair */
      if(option & VRNA_CONSTRAINT_CONTEXT_ALL_LOOPS){
        if(vc->hc->matrix[vc->jindx[j] + i])
          if(vc->ptype[vc->jindx[j] + i] == 0)
            vc->ptype[vc->jindx[j] + i] = 7;
      }

      vc->hc->matrix[vc->jindx[j] + i] = option & VRNA_CONSTRAINT_CONTEXT_ALL_LOOPS;

      if(!(option & VRNA_CONSTRAINT_CONTEXT_NO_REMOVE)){
        /*
          remove all conflicting base pairs, i.e. do not allow i,j to pair
          with any other nucleotide k
        */
        for(k = 1; k < i; k++){
          vc->hc->matrix[vc->jindx[i] + k] = (char)0;
          vc->hc->matrix[vc->jindx[j] + k] = (char)0;
          for(l = i+1; l < j; l++)
            vc->hc->matrix[vc->jindx[l] + k] = (char)0;
        }
        for(k = i+1; k < j; k++){
          vc->hc->matrix[vc->jindx[k] + i] = (char)0;
          vc->hc->matrix[vc->jindx[j] + k] = (char)0;
          for(l = j + 1; l <= vc->length; l++)
            vc->hc->matrix[vc->jindx[l] + k] = (char)0;
        }
        for(k = j+1; k <= vc->length; k++){
          vc->hc->matrix[vc->jindx[k] + i] = (char)0;
          vc->hc->matrix[vc->jindx[k] + j] = (char)0;
        }
      }

      if(option & VRNA_CONSTRAINT_CONTEXT_ENFORCE){

        /* do not allow i,j to be unpaired */
        vc->hc->matrix[vc->jindx[i] + i] = (char)0;
        vc->hc->matrix[vc->jindx[j] + j] = (char)0;

        hc_update_up(vc);
      }
    }
}

PUBLIC void
vrna_hc_free(vrna_hc_t *hc){

  if(hc){
    free(hc->matrix);
    free(hc->up_ext);
    free(hc->up_hp);
    free(hc->up_int);
    free(hc->up_ml);

    if(hc->free_data)
      hc->free_data(hc->data);

    free(hc);
  }
}

#ifdef WITH_GEN_HC

PUBLIC void
vrna_hc_add_f(vrna_fold_compound_t *vc,
              vrna_callback_hc_evaluate *f){

  if(vc && f){
    if(vc->type == VRNA_VC_TYPE_SINGLE){
      if(!vc->hc)
        vrna_hc_init(vc);

      vc->hc->f = f;
    }
  }
}

PUBLIC void
vrna_hc_add_data( vrna_fold_compound_t *vc,
                  void *data,
                  vrna_callback_free_auxdata *f){

  if(vc && data){
    if(vc->type == VRNA_VC_TYPE_SINGLE){
      if(!vc->hc)
        vrna_hc_init(vc);

      vc->hc->data        = data;
      vc->hc->free_data   = f;
    }
  }
}

#endif

PUBLIC  int
vrna_hc_add_from_db(vrna_fold_compound_t *vc,
                    const char *constraint,
                    unsigned int options){

  int         i, d, ret;
  vrna_md_t   *md;

  ret = 0; /* Failure */

  if(vc){
    if(vc->params)
      md = &(vc->params->model_details);
    else if(vc->exp_params)
      md = &(vc->exp_params->model_details);
    else
      return ret;

    if(!vc->hc)
      vrna_hc_init(vc);

    /* apply hard constraints from dot-bracket notation */
    apply_DB_constraint(constraint,
                        vc->hc->matrix,
                        vc->length,
                        md->min_loop_size,
                        -1,
                        options);
    hc_update_up(vc);
    ret = 1; /* Success */
  }

  return ret;
}





PRIVATE void
apply_DB_constraint(const char *constraint,
                    char *hc,
                    unsigned int length,
                    unsigned int min_loop_size,
                    int cut,
                    unsigned int options){

  int n,i,j;
  int hx, *stack;
  int *index;
  char c_option;

  if(constraint == NULL) return;

  n         = (int)strlen(constraint);
  stack     = (int *) vrna_alloc(sizeof(int)*(n+1));
  index     = vrna_idx_col_wise(length);
  c_option  =   VRNA_CONSTRAINT_CONTEXT_EXT_LOOP
              | VRNA_CONSTRAINT_CONTEXT_HP_LOOP
              | VRNA_CONSTRAINT_CONTEXT_INT_LOOP
              | VRNA_CONSTRAINT_CONTEXT_INT_LOOP_ENC
              | VRNA_CONSTRAINT_CONTEXT_MB_LOOP
              | VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC;

  for(hx=0, j=1; j<=n; j++) {
    switch (constraint[j-1]) {
       /* can't pair */
       case 'x':  if(options & VRNA_CONSTRAINT_DB_X){
                    hc_cant_pair(j, c_option, hc, length, min_loop_size, index);
                  }
                  break;

      /* must pair, i.e. may not be unpaired */
      case '|':   if(options & VRNA_CONSTRAINT_DB_PIPE){
                    if(options & VRNA_CONSTRAINT_DB_ENFORCE_BP)
                      hc_must_pair(j, c_option, hc, index);
                  }
                  break;

      /* weak enforced pair 'open' */
      case '(':   if(options & VRNA_CONSTRAINT_DB_RND_BRACK){
                    stack[hx++]=j;
                  }
                  break;

      /* weak enforced pair 'close' */
      case ')':   if(options & VRNA_CONSTRAINT_DB_RND_BRACK){
                    if (hx<=0) {
                      fprintf(stderr, "%s\n", constraint);
                      vrna_message_error("unbalanced brackets in constraints");
                    }
                    i = stack[--hx];
                    if(options & VRNA_CONSTRAINT_DB_ENFORCE_BP)
                      hc_enforce_pair(i, j, c_option, hc, length, min_loop_size, index);
                    else
                      hc_weak_enforce_pair(i, j, c_option, hc, length, min_loop_size, index);
                  }
                  break;

      /* pairs upstream */
      case '<':   if(options & VRNA_CONSTRAINT_DB_ANG_BRACK){
                    hc_pairs_downstream(j, c_option, hc, length, index);
                    if(options & VRNA_CONSTRAINT_DB_ENFORCE_BP)
                      hc_must_pair(j, c_option, hc, index);
                  }
                  break;

      /* pairs downstream */
      case '>':   if(options & VRNA_CONSTRAINT_DB_ANG_BRACK){
                    hc_pairs_upstream(j, c_option, hc, length, index);
                    if(options & VRNA_CONSTRAINT_DB_ENFORCE_BP)
                      hc_must_pair(j, c_option, hc, index);
                  }
                  break;

      /* only intramolecular basepairing */
      case 'l':   if(options & VRNA_CONSTRAINT_DB_INTRAMOL){
                    hc_intramolecular_only(j, c_option, hc, length, min_loop_size, cut, index);
                  }
                  break;

      /* only intermolecular bp */
      case 'e':   if(options & VRNA_CONSTRAINT_DB_INTERMOL){
                    hc_intermolecular_only(j, c_option, hc, length, min_loop_size, cut, index);
                  }
                  break;

      case '.':   break;

      default:    {
                    int r;
                    char *msg = NULL;
                    r = asprintf( &msg,
                                  "Unrecognized character '%c' in pseudo dot-bracket notation constraint string",
                                  constraint[j-1]);
                    if(r != -1)
                      vrna_message_warning(msg);
                    free(msg);
                  }
                  break;
    }
  }

  if (hx!=0) {
    fprintf(stderr, "%s\n", constraint);
    vrna_message_error("unbalanced brackets in constraint string");
  }
  /* clean up */
  free(index);
  free(stack);
}

PRIVATE INLINE  void
hc_intramolecular_only( unsigned int i,
                        char c_option,
                        char *hc,
                        unsigned int length,
                        unsigned int min_loop_size,
                        int cut,
                        int *index){

  unsigned int l;

  if(cut > 1){
    if(i < cut)
      for(l = MAX2(i+min_loop_size, cut); l <= length; l++)
        hc[index[l] + i] &= ~c_option;
    else
      for(l = 1; l < MIN2(cut, i-min_loop_size); l++)
        hc[index[i] + l] &= ~c_option;
  }
}

PRIVATE INLINE  void
hc_intermolecular_only( unsigned int i,
                        char c_option,
                        char *hc,
                        unsigned int length,
                        unsigned int min_loop_size,
                        int cut,
                        int *index){

  unsigned int l;

  if(cut > 1){
    if(i < cut){
      for(l = 1; l < i; l++)
        hc[index[i] + l] &= ~c_option;
      for(l = i + 1; l < cut; l++)
        hc[index[l] + i] &= ~c_option;
    } else {
      for(l = cut; l < i; l++)
        hc[index[i] + l] &= ~c_option;
      for(l = i + 1; l <= length; l++)
        hc[index[l] + i] &= ~c_option;
    }
  }
}

PRIVATE INLINE  void
hc_cant_pair( unsigned int i,
              char c_option,
              char *hc,
              unsigned int length,
              unsigned int min_loop_size,
              int *index){

  hc_pairs_upstream(i, c_option, hc, length, index);
  hc_pairs_downstream(i, c_option, hc, length, index);
}

PRIVATE INLINE  void
hc_must_pair( unsigned int i,
              char c_option,
              char *hc,
              int *index){

  hc[index[i]+i] &= ~c_option;
}

PRIVATE INLINE  void
hc_pairs_upstream(unsigned int i,
                  char c_option,
                  char *hc,
                  unsigned int length,
                  int *index){

  unsigned int l;

  /* prohibit downstream pairs */
  for(l = length; l > i; l--)
    hc[index[l] + i] = (char)0;
  /* allow upstream pairs of given type */
  for(l = i - 1; l >= 1; l--)
    hc[index[i] + l] &= c_option;
}

PRIVATE INLINE  void
hc_pairs_downstream(unsigned int i,
                    char c_option,
                    char *hc,
                    unsigned int length,
                    int *index){

  unsigned int l;
  /* allow downstream pairs of given type */
  for(l = length; l > i; l--)
    hc[index[l] + i] &= c_option;
  /* forbid upstream pairs */
  for(l = i - 1; l >= 1; l--)
    hc[index[i] + l] = (char)0;
}

PRIVATE INLINE  void
hc_allow_pair(unsigned int i,
              unsigned int j,
              char c_option,
              char *hc,
              int *index){

  hc[index[j] + i] |= c_option;
}

PRIVATE INLINE  void
hc_weak_enforce_pair( unsigned int i,
                      unsigned int j,
                      char c_option,
                      char *hc,
                      unsigned int length,
                      unsigned int min_loop_size,
                      int *index){

  unsigned int k, l;

  /* don't allow pairs (k,i) 1 <= k < i */
  /* don't allow pairs (i,k) i < k <= n */ 
  hc_pairs_upstream(i, (char)0, hc, length, index);
  /* don't allow pairs (k,j) 1 <= k < j */
  /* don't allow pairs (j,k) j < k <= n */ 
  hc_pairs_upstream(j, (char)0, hc, length, index);

  /* don't allow pairs i < k < j < l */
  for(k = i+1; k < j; k++)
    for(l = j+1; l <= length; l++){
      hc[index[l] + k] = 0;
    }
  /* don't allow pairs k<i<l<j */
  for(k = 1; k < i; k++)
    for(l = i+1; l < j; l++){
      hc[index[l] + k] = 0;
    }
  /* allow base pair (i,j) */
  hc[index[j] + i] |= c_option;
}

PRIVATE INLINE  void
hc_enforce_pair(unsigned int i,
                unsigned int j,
                char c_option,
                char *hc,
                unsigned int length,
                unsigned int min_loop_size,
                int *index){

  hc_weak_enforce_pair( i,
                        j,
                        c_option,
                        hc,
                        length,
                        min_loop_size,
                        index);

  /* forbid i and j to be unpaired */
  hc[index[i] + i] = 0;
  hc[index[j] + j] = 0;
}

PRIVATE void
hc_reset_to_default(vrna_fold_compound_t *vc){

  unsigned int      i, j, ij, min_loop_size, n;
  int               max_span, *idx;
  vrna_md_t         *md;
  vrna_hc_t         *hc;
  short             *S;

  md  = NULL;
  n   = vc->length;
  hc  = vc->hc;
  idx = vc->jindx;
  S   = vc->sequence_encoding;

  if(vc->params)
    md  = &(vc->params->model_details);
  else if(vc->exp_params)
    md  = &(vc->exp_params->model_details);
  else
    vrna_message_error("missing model_details in fold_compound");

  min_loop_size = md->min_loop_size;
  max_span      = md->max_bp_span;

  if((max_span < 5) || (max_span > n))
    max_span  = n;

  /* ######################### */
  /* fill with default values  */
  /* ######################### */

  /* 1. unpaired nucleotides are allowed in all contexts */
  for(i = 1; i <= n; i++)
    hc->matrix[idx[i] + i]  =   VRNA_CONSTRAINT_CONTEXT_EXT_LOOP
                              | VRNA_CONSTRAINT_CONTEXT_HP_LOOP
                              | VRNA_CONSTRAINT_CONTEXT_INT_LOOP
                              | VRNA_CONSTRAINT_CONTEXT_MB_LOOP;

  /* 2. all base pairs with pscore above threshold are allowed in all contexts */
  switch(vc->type){
    case VRNA_VC_TYPE_ALIGNMENT:  for(j = n; j > min_loop_size + 1; j--){
                                    ij = idx[j]+1;
                                    for(i=1; i < j - min_loop_size; i++, ij++){
                                      char opt = (char)0;
                                      if((j-i+1) <= max_span){
                                        if(vc->pscore[idx[j]+i] >= md->cv_fact*MINPSCORE)
                                          opt = VRNA_CONSTRAINT_CONTEXT_ALL_LOOPS;
                                      }
                                      hc->matrix[ij] = opt;
                                    }
                                  }
                                  break;

    case VRNA_VC_TYPE_SINGLE:     for(j = n; j > min_loop_size + 1; j--){
                                    ij = idx[j]+1;
                                    for(i=1; i < j - min_loop_size; i++, ij++){
                                      char opt = (char)0;
                                      if((j-i+1) <= max_span){
                                        int t = md->pair[S[i]][S[j]];
                                        switch(t){
                                          case 0:   break;
                                          case 3:   /* fallthrough */
                                          case 4:   if(md->noGU){
                                                      break;
                                                    } else if(md->noGUclosure){
                                                      opt = VRNA_CONSTRAINT_CONTEXT_ALL_LOOPS;
                                                      opt &= ~(VRNA_CONSTRAINT_CONTEXT_HP_LOOP | VRNA_CONSTRAINT_CONTEXT_MB_LOOP);
                                                      break;
                                                    } /* else fallthrough */
                                          default:  opt = VRNA_CONSTRAINT_CONTEXT_ALL_LOOPS;
                                                    break;
                                        }
                                      }
                                      hc->matrix[ij] = opt;
                                    }
                                  }

                                  /* correct for no lonely pairs (assuming that ptypes already incorporate noLP status) */
                                  /* this should be fixed such that ij loses its hard constraint type if it does not
                                     allow for enclosing an interior loop, etc.
                                  */
                                  /*  ???????
                                      Is this necessary? We could leave the noLP option somewhere else, i.e. do not enforce it
                                      on the level of ptype/constraints, but an the level of recursions...
                                      ???????
                                  */
                                  if(md->noLP){
                                    if(!vc->ptype)
                                      vc->ptype = vrna_ptypes(vc->sequence_encoding2, md);
                                    for(i = 1; i < n; i++)
                                      for(j = i + min_loop_size + 1; j <= n; j++){
                                        if(hc->matrix[idx[j] +i]){
                                          if(!vc->ptype[idx[j] + i]){
                                            hc->matrix[idx[j] + i] = (char)0;
                                          }
                                        }
                                      }
                                  }
                                  break;

    default:                      break;
  }

  /* should we reset the generalized hard constraint feature here? */
  if(hc->f || hc->data){
    if(hc->free_data)
      hc->free_data(hc->data);

    hc->f           = NULL;
    hc->data        = NULL;
    hc->free_data   = NULL;
  }

}

PRIVATE void
hc_update_up(vrna_fold_compound_t *vc){

  unsigned int      i, n;
  int               *idx;
  vrna_hc_t         *hc;

  n   = vc->length;
  idx = vc->jindx;
  hc  = vc->hc;

  for(hc->up_ext[n+1] = 0, i = n; i > 0; i--) /* unpaired stretch in exterior loop */
    hc->up_ext[i] = (hc->matrix[idx[i]+i] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP) ? 1 + hc->up_ext[i+1] : 0;

  for(hc->up_hp[n+1] = 0, i = n; i > 0; i--)  /* unpaired stretch in hairpin loop */
    hc->up_hp[i] = (hc->matrix[idx[i]+i] & VRNA_CONSTRAINT_CONTEXT_HP_LOOP) ? 1 + hc->up_hp[i+1] : 0;

  for(hc->up_int[n+1] = 0, i = n; i > 0; i--) /* unpaired stretch in interior loop */
    hc->up_int[i] = (hc->matrix[idx[i]+i] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP) ? 1 + hc->up_int[i+1] : 0;

  for(hc->up_ml[n+1] = 0, i = n; i > 0; i--)  /* unpaired stretch in multibranch loop */
    hc->up_ml[i] = (hc->matrix[idx[i]+i] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP) ? 1 + hc->up_ml[i+1] : 0;

  /*
   *  loop arround once more until we find a nucleotide that mustn't
   *  be unpaired (needed for circular folding)
   */

  if(hc->matrix[idx[1]+1] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
    hc->up_ext[n+1] = hc->up_ext[1];
    for(i = n; i > 0; i--){
      if(hc->matrix[idx[i]+i] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP){
        hc->up_ext[i] = MIN2(n, 1 + hc->up_ext[i+1]);
      } else
        break;
    }
  }

  if(hc->matrix[idx[1]+1] & VRNA_CONSTRAINT_CONTEXT_HP_LOOP){
    hc->up_hp[n+1] = hc->up_hp[1];
    for(i = n; i > 0; i--){
      if(hc->matrix[idx[i]+i] & VRNA_CONSTRAINT_CONTEXT_HP_LOOP){
        hc->up_hp[i] = MIN2(n, 1 + hc->up_hp[i+1]);
      } else
        break;
    }
  }

  if(hc->matrix[idx[1]+1] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP){
    hc->up_int[n+1] = hc->up_int[1];
    for(i = n; i > 0; i--){
      if(hc->matrix[idx[i]+i] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP){
        hc->up_int[i] = MIN2(n, 1 + hc->up_int[i+1]);
      } else
        break;
    }
  }

  if(hc->matrix[idx[1]+1] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP){
    hc->up_ml[n+1] = hc->up_ml[1];
    for(i = n; i > 0; i--){
      if(hc->matrix[idx[i]+i] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP){
        hc->up_ml[i] = MIN2(n, 1 + hc->up_ml[i+1]);
      } else
        break;
    }
  }

}

#ifdef  VRNA_BACKWARD_COMPAT

/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/

PUBLIC  void
print_tty_constraint_full(void){

  vrna_message_constraint_options_all();
}

PUBLIC  void
print_tty_constraint(unsigned int option){

  vrna_message_constraint_options(option);
}

PUBLIC void
constrain_ptypes( const char *constraint,
                  unsigned int length,
                  char *ptype,
                  int *BP,
                  int min_loop_size,
                  unsigned int idx_type){

  int n,i,j,k,l;
  int hx, *stack;
  char type;
  int *index;

  if(constraint == NULL) return;

  n = (int)strlen(constraint);

  stack = vrna_alloc(sizeof(int)*(n+1));

  if(!idx_type){ /* index allows access in energy matrices at pos (i,j) via index[j]+i */
    index = vrna_idx_col_wise(length);

    for(hx=0, j=1; j<=n; j++){
      switch(constraint[j-1]){
        case '|':   if(BP) BP[j] = -1;
                    break;
        case 'x':   /* can't pair */
                    for (l=1; l<j-min_loop_size; l++)
                      ptype[index[j]+l] = 0;
                    for (l=j+min_loop_size+1; l<=(int)length; l++)
                      ptype[index[l]+j] = 0;
                    break;
        case '(':   stack[hx++]=j;
                    /* fallthrough */
        case '<':   /* pairs upstream */
                    for (l=1; l<j-min_loop_size; l++)
                      ptype[index[j]+l] = 0;
                    break;
        case ')':   if (hx<=0) {
                      fprintf(stderr, "%s\n", constraint);
                      vrna_message_error("unbalanced brackets in constraint");
                    }
                    i = stack[--hx];
                    type = ptype[index[j]+i];
                    for (k=i+1; k<=(int)length; k++)
                      ptype[index[k]+i] = 0;
                    /* don't allow pairs i<k<j<l */
                    for (l=j; l<=(int)length; l++)
                      for (k=i+1; k<=j; k++)
                        ptype[index[l]+k] = 0;
                    /* don't allow pairs k<i<l<j */
                    for (l=i; l<=j; l++)
                      for (k=1; k<=i; k++)
                        ptype[index[l]+k] = 0;
                    for (k=1; k<j; k++)
                      ptype[index[j]+k] = 0;
                    ptype[index[j]+i] = (type==0) ? 7 : type;
                    /* fallthrough */
        case '>':   /* pairs downstream */
                    for (l=j+min_loop_size+1; l<=(int)length; l++)
                      ptype[index[l]+j] = 0;
                    break;
      }
    }
  }
  else{ /* index allows access in energy matrices at pos (i,j) via index[i]-j */
    index = vrna_idx_row_wise(length);

    for(hx=0, j=1; j<=n; j++) {
      switch (constraint[j-1]) {
        case 'x':   /* can't pair */
                    for (l=1; l<j-min_loop_size; l++)
                      ptype[index[l]-j] = 0;
                    for (l=j+min_loop_size+1; l<=(int)length; l++)
                      ptype[index[j]-l] = 0;
                    break;
        case '(':   stack[hx++]=j;
                    /* fallthrough */
        case '<':   /* pairs upstream */
                    for (l=1; l<j-min_loop_size; l++)
                      ptype[index[l]-j] = 0;
                    break;
        case ')':   if (hx<=0) {
                      fprintf(stderr, "%s\n", constraint);
                      vrna_message_error("unbalanced brackets in constraints");
                    }
                    i = stack[--hx];
                    type = ptype[index[i]-j];
                    /* don't allow pairs i<k<j<l */
                    for (k=i; k<=j; k++)
                      for (l=j; l<=(int)length; l++)
                        ptype[index[k]-l] = 0;
                    /* don't allow pairs k<i<l<j */
                    for (k=1; k<=i; k++)
                      for (l=i; l<=j; l++)
                        ptype[index[k]-l] = 0;
                    ptype[index[i]-j] = (type==0) ? 7 : type;
                    /* fallthrough */
        case '>':   /* pairs downstream */
                    for (l=j+min_loop_size+1; l<=(int)length; l++)
                      ptype[index[j]-l] = 0;
                    break;
      }
    }
  }
  if (hx!=0) {
    fprintf(stderr, "%s\n", constraint);
    vrna_message_error("unbalanced brackets in constraint string");
  }
  free(index);
  free(stack);
}

#endif
/222            0           0     0     644     10759     `
/* constraints handling */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <assert.h>
//#include "../config.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include <limits.h>

#include "energy_par.h"
#include "energy_const.h" /* defines MINPSCORE */
#include "fold_vars.h"
#include "utils.h"
#include "aln_util.h"
#include "file_formats.h"
#include "params.h"
#include "constraints_soft.h"


/*
#################################
# GLOBAL VARIABLES              #
#################################
*/

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/
PRIVATE void
sc_add_up(vrna_fold_compound_t *vc,
          const FLT_OR_DBL *constraints);

PRIVATE void
sc_add_bp(vrna_fold_compound_t *vc,
          const FLT_OR_DBL **constraints);

PRIVATE void
prepare_Boltzmann_weights_up( vrna_fold_compound_t *vc);

PRIVATE void
prepare_Boltzmann_weights_bp(vrna_fold_compound_t *vc);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PUBLIC void
vrna_sc_init(vrna_fold_compound_t *vc){

  unsigned int s;
  vrna_sc_t    *sc;

  if(vc){
    vrna_sc_remove(vc);

    switch(vc->type){
      case VRNA_VC_TYPE_SINGLE:     sc                    = (vrna_sc_t *)vrna_alloc(sizeof(vrna_sc_t));
                                    sc->energy_up         = NULL;
                                    sc->energy_bp         = NULL;
                                    sc->energy_stack      = NULL;
                                    sc->exp_energy_stack  = NULL;
                                    sc->exp_energy_up     = NULL;
                                    sc->exp_energy_bp     = NULL;
                                    sc->f                 = NULL;
                                    sc->exp_f             = NULL;
                                    sc->data              = NULL;
                                    sc->free_data         = NULL;

                                    vc->sc  = sc;
                                    break;

      case VRNA_VC_TYPE_ALIGNMENT:  vc->scs = (vrna_sc_t **)vrna_alloc(sizeof(vrna_sc_t*) * (vc->n_seq + 1));
                                    for(s = 0; s < vc->n_seq; s++){
                                      sc                    = (vrna_sc_t *)vrna_alloc(sizeof(vrna_sc_t));
                                      sc->energy_up         = NULL;
                                      sc->energy_bp         = NULL;
                                      sc->energy_stack      = NULL;
                                      sc->exp_energy_stack  = NULL;
                                      sc->exp_energy_up     = NULL;
                                      sc->exp_energy_bp     = NULL;
                                      sc->f                 = NULL;
                                      sc->exp_f             = NULL;
                                      sc->data              = NULL;
                                      sc->free_data         = NULL;

                                      vc->scs[s]  = sc;
                                    }
                                    break;
      default:                      /* do nothing */
                                    break;
    }
  }
}

PUBLIC void
vrna_sc_remove(vrna_fold_compound_t *vc){

  int s;

  if(vc){
    switch(vc->type){
      case  VRNA_VC_TYPE_SINGLE:    vrna_sc_free(vc->sc);
                                    vc->sc = NULL;
                                    break;
      case  VRNA_VC_TYPE_ALIGNMENT: if(vc->scs){
                                      for(s = 0; s < vc->n_seq; s++)
                                        vrna_sc_free(vc->scs[s]);
                                      free(vc->scs);
                                    }
                                    vc->scs = NULL;
                                    break;
      default:                      /* do nothing */
                                    break;
    }
  }
}

PUBLIC void
vrna_sc_free(vrna_sc_t *sc){

  int i;
  if(sc){
    if(sc->energy_up){
      for(i = 0; sc->energy_up[i]; free(sc->energy_up[i++]));
      free(sc->energy_up);
    }
    if(sc->exp_energy_up){
      for(i = 0; sc->exp_energy_up[i]; free(sc->exp_energy_up[i++]));
      free(sc->exp_energy_up);
    }
    
    free(sc->energy_bp);
    free(sc->exp_energy_bp);
    free(sc->energy_stack);
    free(sc->exp_energy_stack);

    if(sc->free_data)
      sc->free_data(sc->data);

    free(sc);
  }
}

PUBLIC void
vrna_sc_add_bp( vrna_fold_compound_t *vc,
                const FLT_OR_DBL **constraints,
                unsigned int options){

  if(vc && (vc->type == VRNA_VC_TYPE_SINGLE)){
    if(constraints){
      /* always add (pure) soft constraints */
      sc_add_bp(vc, constraints);
    }

    if(options & VRNA_OPTION_PF) /* prepare Boltzmann factors for the BP soft constraints */
      prepare_Boltzmann_weights_bp(vc);
  }
}

PUBLIC void
vrna_sc_add_up( vrna_fold_compound_t *vc,
                const FLT_OR_DBL *constraints,
                unsigned int options){

  if(vc && (vc->type == VRNA_VC_TYPE_SINGLE)){
    if(constraints){
      /* always add (pure) soft constraints */
      sc_add_up(vc, constraints);
    }

    if(options & VRNA_OPTION_PF)
      prepare_Boltzmann_weights_up(vc);
  }
}

PUBLIC void
vrna_sc_add_data( vrna_fold_compound_t *vc,
                  void *data,
                  vrna_callback_free_auxdata *free_data){

  if(vc){
    if(vc->type == VRNA_VC_TYPE_SINGLE){
      if(!vc->sc)
        vrna_sc_init(vc);

      vc->sc->data        = data;
      vc->sc->free_data   = free_data;
    }
  }
}

PUBLIC void
vrna_sc_add_f(vrna_fold_compound_t *vc,
              vrna_callback_sc_energy *f){

  if(vc && f){
    if(vc->type == VRNA_VC_TYPE_SINGLE){
      if(!vc->sc)
        vrna_sc_init(vc);

      vc->sc->f       = f;
    }
  }
}

PUBLIC void
vrna_sc_add_bt( vrna_fold_compound_t *vc,
                vrna_callback_sc_backtrack *f){

  if(vc && f){
    if(vc->type == VRNA_VC_TYPE_SINGLE){
      if(!vc->sc)
        vrna_sc_init(vc);

      vc->sc->bt      = f;
    }
  }
}

PUBLIC void
vrna_sc_add_exp_f(vrna_fold_compound_t *vc,
                  vrna_callback_sc_exp_energy *exp_f){

  if(vc && exp_f){
    if(vc->type == VRNA_VC_TYPE_SINGLE){
      if(!vc->sc)
        vrna_sc_init(vc);

      vc->sc->exp_f   = exp_f;
    }
  }
}

PRIVATE void
sc_add_bp(vrna_fold_compound_t *vc,
          const FLT_OR_DBL **constraints){

  unsigned int  i, j, n;
  vrna_sc_t     *sc;
  int           *idx;

  n   = vc->length;

  if(!vc->sc)
    vrna_sc_init(vc);

  sc              = vc->sc;

  if(sc->energy_bp)
    free(sc->energy_bp);

  sc->energy_bp = (int *)vrna_alloc(sizeof(int) * (((n + 1) * (n + 2)) / 2));

  idx = vc->jindx;
  for(i = 1; i < n; i++)
    for(j=i+1; j<=n; j++)
      sc->energy_bp[idx[j]+i] = (int)roundf(constraints[i][j] * 100.);

}

PRIVATE void
sc_add_up(vrna_fold_compound_t *vc,
          const FLT_OR_DBL *constraints){

  unsigned int  i, j, n;
  vrna_sc_t     *sc;

  if(vc && constraints){
    n   = vc->length;

    if(!vc->sc)
      vrna_sc_init(vc);

    sc  = vc->sc;
    /*  allocate memory such that we can access the soft constraint
        energies of a subsequence of length j starting at position i
        via sc->energy_up[i][j]
    */
    if(sc->energy_up){
      for(i = 0; i <= n; i++)
        if(sc->energy_up[i])
          free(sc->energy_up[i]);
      free(sc->energy_up);
    }

    sc->energy_up = (int **)vrna_alloc(sizeof(int *) * (n + 2));
    for(i = 0; i <= n; i++)
      sc->energy_up[i] = (int *)vrna_alloc(sizeof(int) * (n - i + 2));

    sc->energy_up[n+1] = NULL;

    for(i = 1; i <= n; i++){
      for(j = 1; j <= (n - i + 1); j++){
        sc->energy_up[i][j] =   sc->energy_up[i][j-1]
                                  + (int)roundf(constraints[i+j-1] * 100.); /* convert to 10kal/mol */
      }
    }
  }
}

/* compute Boltzmann factors for BP soft constraints from stored free energies */
PRIVATE void
prepare_Boltzmann_weights_bp(vrna_fold_compound_t *vc){

  unsigned int  i, j, n;
  vrna_sc_t     *sc;
  int           *idx, *jidx;

  if(vc->sc && vc->sc->energy_bp){
    n   = vc->length;
    sc  = vc->sc;

    vrna_exp_param_t  *exp_params = vc->exp_params;
    double            GT          = 0.;
    double            temperature = exp_params->temperature;
    double            kT          = exp_params->kT;
    double            TT          = (temperature+K0)/(Tmeasure);

    if(sc->exp_energy_bp)
      free(sc->exp_energy_bp);
    sc->exp_energy_bp     = (FLT_OR_DBL *)vrna_alloc(sizeof(FLT_OR_DBL) * (((n + 1) * (n + 2)) / 2));

    idx   = vc->iindx;
    jidx  = vc->jindx;

    for(i = 1; i < n; i++)
      for(j = i + 1; j <= n; j++){
        GT = sc->energy_bp[jidx[j] + i] * 10.;
        sc->exp_energy_bp[idx[i]-j] = (FLT_OR_DBL)exp( -GT / kT);
      }
  }
}

PRIVATE void
prepare_Boltzmann_weights_up(vrna_fold_compound_t *vc){

  unsigned int  i, j, n;
  vrna_sc_t     *sc;

  n   = vc->length;

  sc  = vc->sc;

  vrna_exp_param_t   *exp_params = vc->exp_params;
  double             GT          = 0.;
  double             temperature = exp_params->temperature;
  double             kT          = exp_params->kT;
  double             TT          = (temperature+K0)/(Tmeasure);

  /* #################################### */
  /* # single nucleotide contributions  # */
  /* #################################### */

  if(sc && sc->energy_up){
    /*  allocate memory such that we can access the soft constraint
        energies of a subsequence of length j starting at position i
        via sc->exp_energy_up[i][j]
    */

    /* free previous unpaired nucleotide constraints */
    if(sc->exp_energy_up){
      for(i = 0; i <= n; i++)
        if(sc->exp_energy_up[i])
          free(sc->exp_energy_up[i]);
      free(sc->exp_energy_up);
    }

    /* allocate memory and create Boltzmann factors from stored contributions */
    sc->exp_energy_up = (FLT_OR_DBL **)vrna_alloc(sizeof(FLT_OR_DBL *) * (n + 2));
    sc->exp_energy_up[0] = (FLT_OR_DBL *)vrna_alloc(sizeof(FLT_OR_DBL) * (n + 2));
    for(j = 0; j <= (n + 1); j++)
        sc->exp_energy_up[0][j] = 1.;

    for(i = 1; i <= n; i++){
      sc->exp_energy_up[i] = (FLT_OR_DBL *)vrna_alloc(sizeof(FLT_OR_DBL) * (n - i + 2));

      sc->exp_energy_up[i][0] = 1.;

      for(j = 1; j <= (n - i + 1); j++){
        GT  = (double)sc->energy_up[i][j] * 10.; /* convert to cal/mol */
        sc->exp_energy_up[i][j] = (FLT_OR_DBL)exp( -GT / kT);
      }
    }

    sc->exp_energy_up[n+1] = NULL;
  }
}

alphabet.c/     0           0     0     644     8585      `
/*
    alphabet.c
    
    Code for handling nucleotide and base pair alphabet
    
    Part of the ViennaRNA Package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

#include "utils.h"
#include "alphabet.h"

/*
  For now, we neglect all non-standard nucleotides in an input sequence, i.e. only
  ACGTUN is allowed.

  However, the standard nucleotide ambiguity code table would allow for many more:

  A = Adenylic acid
  C = Cytidylic acid
  G = Guanylic acid
  T = Thymidylic acid
  U = Uridylic acid
  I = Inosylic acid
  R = A or G = puRine
  Y = C or T = pYrimidine
  K = G or T = Keto
  M = A or C = aMino
  S = G or C = Strong base pair
  W = A or T = Weak base pair
  B = not A (G or C or T)
  D = not C (A or G or T)
  H = not G (A or C or T)
  V = not T/U (A or C or G)
  N = aNy base  (by convention, X is used for unknown amino acids, N for unknown nucleotides)

  For the future, we aim to accept all of the above codes.
*/

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/
PRIVATE const char Law_and_Order[] = "_ACGUTXKI";

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/
PRIVATE char  *wrap_get_ptypes(const short *S, vrna_md_t *md);  /* provides backward compatibility for old ptypes array in pf computations */

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/
PUBLIC int
vrna_nucleotide_IUPAC_identity( char nt,
                                char mask){

  char n1,n2,*p;

  p   = NULL;
  n1  = toupper(nt);
  n2  = toupper(mask);

  switch(n1){
    case 'A': p = strchr("ARMWDHVN", n2);
              break;
    case 'C': p = strchr("CYMSBHVN", n2);
              break;
    case 'G': p = strchr("GRKSBDVN", n2);
              break;
    case 'T': p = strchr("TYKWBDHN", n2);
              break;
    case 'U': p = strchr("UYKWBDHN", n2);
              break;
    case 'I': p = strchr("IN", n2);
              break;
    case 'R': p = strchr("AGR", n2);
              break;
    case 'Y': p = strchr("CTUY", n2);
              break;
    case 'K': p = strchr("GTUK", n2);
              break;
    case 'M': p = strchr("ACM", n2);
              break;
    case 'S': p = strchr("GCS", n2);
              break;
    case 'W': p = strchr("ATUW", n2);
              break;
    case 'B': p = strchr("GCTBU", n2);
              break;
    case 'D': p = strchr("AGTUD", n2);
              break;
    case 'H': p = strchr("ACTUH", n2);
              break;
    case 'V': p = strchr("ACGV", n2);
              break;
    case 'N': p = strchr("ACGTUN", n2);
              break;
  }

  return (p) ? 1 : 0;
}


PUBLIC char *
vrna_ptypes(const short *S,
                vrna_md_t *md){

  char *ptype;
  int n,i,j,k,l,*idx;
  int min_loop_size = md->min_loop_size;

  n     = S[0];
  ptype = (char *)vrna_alloc(sizeof(char)*((n*(n+1))/2+2));
  idx   = vrna_idx_col_wise(n);

  for (k=1; k<n-min_loop_size; k++)
    for (l=1; l<=2; l++) {
      int type,ntype=0,otype=0;
      i=k; j = i+min_loop_size+l; if (j>n) continue;
      type = md->pair[S[i]][S[j]];
      while ((i>=1)&&(j<=n)) {
        if ((i>1)&&(j<n)) ntype = md->pair[S[i-1]][S[j+1]];
        if (md->noLP && (!otype) && (!ntype))
          type = 0; /* i.j can only form isolated pairs */
        ptype[idx[j]+i] = (char) type;
        otype =  type;
        type  = ntype;
        i--; j++;
      }
    }
  free(idx);
  return ptype;
}

PUBLIC short *
vrna_seq_encode(const char *sequence,
                vrna_md_t *md){

  unsigned int  i, l;
  short         *S = NULL;
  
  if(sequence && md){
    S = vrna_seq_encode_simple(sequence, md);

    l = (unsigned int)strlen(sequence);

    for(i=1; i<=l; i++)
      S[i] = md->alias[S[i]];

    S[l+1] = S[1];
    S[0] = S[l];
  }

  return S;
}

PUBLIC short *
vrna_seq_encode_simple( const char *sequence,
                        vrna_md_t *md){

  unsigned int  i, l;
  short         *S = NULL;

  if(sequence && md){
    l = (unsigned int)strlen(sequence);
    S = (short *) vrna_alloc(sizeof(short)*(l+2));

    for(i=1; i<=l; i++) /* make numerical encoding of sequence */
      S[i]= (short) vrna_nucleotide_encode(toupper(sequence[i-1]), md);

    S[l+1] = S[1];
    S[0] = (short) l;
  }

  return S;
}

PUBLIC  int
vrna_nucleotide_encode( char c,
                        vrna_md_t *md){

  /* return numerical representation of nucleotide used e.g. in vrna_md_t.pair[][] */
  int code = -1;

  if(md){
    if (md->energy_set>0) code = (int) (c-'A')+1;
    else {
      const char *pos;
      pos = strchr(Law_and_Order, c);
      if (pos==NULL) code=0;
      else code = (int) (pos-Law_and_Order);
      if (code>5) code = 0;
      if (code>4) code--; /* make T and U equivalent */
    }
  }

  return code;
}

PUBLIC  char
vrna_nucleotide_decode( int enc,
                        vrna_md_t *md){

  if(md){
    if(md->energy_set > 0)
      return (char)enc + 'A' - 1;
    else
      return (char)Law_and_Order[enc];
  } else {
    return (char)0;
  }
}

PUBLIC void
vrna_aln_encode(const char *sequence,
                    short **S_p,
                    short **s5_p,
                    short **s3_p,
                    char **ss_p,
                    unsigned short **as_p,
                    vrna_md_t *md){

  unsigned  int   i,l;
  unsigned  short p;

  l     = strlen(sequence);

  (*s5_p)   = (short *)         vrna_alloc((l + 2) * sizeof(short));
  (*s3_p)   = (short *)         vrna_alloc((l + 2) * sizeof(short));
  (*as_p)  = (unsigned short *)vrna_alloc((l + 2) * sizeof(unsigned short));
  (*ss_p)   = (char *)          vrna_alloc((l + 2) * sizeof(char));

  /* make numerical encoding of sequence */
  (*S_p)    = vrna_seq_encode_simple(sequence, md);

  (*s5_p)[0] = (*s5_p)[1] = 0;

  if(md->oldAliEn){
    /* use alignment sequences in all energy evaluations */
    (*ss_p)[0]=sequence[0];
    for(i=1; i<l; i++){
      (*s5_p)[i] = (*S_p)[i-1];
      (*s3_p)[i] = (*S_p)[i+1];
      (*ss_p)[i] = sequence[i];
      (*as_p)[i] = i;
    }
    (*ss_p)[l]   = sequence[l];
    (*as_p)[l]   = l;
    (*s5_p)[l]   = (*S_p)[l-1];
    (*s3_p)[l]   = 0;
    (*S_p)[l+1]  = (*S_p)[1];
    (*s5_p)[1]   = 0;
    if(md->circ){
      (*s5_p)[1]   = (*S_p)[l];
      (*s3_p)[l]   = (*S_p)[1];
      (*ss_p)[l+1] = (*S_p)[1];
    }
  }
  else{
    if(md->circ){
      for(i=l; i>0; i--){
        char c5;
        c5 = sequence[i-1];
        if ((c5=='-')||(c5=='_')||(c5=='~')||(c5=='.')) continue;
        (*s5_p)[1] = (*S_p)[i];
        break;
      }
      for (i=1; i<=l; i++) {
        char c3;
        c3 = sequence[i-1];
        if ((c3=='-')||(c3=='_')||(c3=='~')||(c3=='.')) continue;
        (*s3_p)[l] = (*S_p)[i];
        break;
      }
    }
    else  (*s5_p)[1]=(*s3_p)[l]=0;

    for(i=1,p=0; i<=l; i++){
      char c5;
      c5 = sequence[i-1];
      if ((c5=='-')||(c5=='_')||(c5=='~')||(c5=='.'))
        (*s5_p)[i+1]=(*s5_p)[i];
      else { /* no gap */
        (*ss_p)[p++]=sequence[i-1]; /*start at 0!!*/
        (*s5_p)[i+1]=(*S_p)[i];
      }
      (*as_p)[i]=p;
    }
    for (i=l; i>=1; i--) {
      char c3;
      c3 = sequence[i-1];
      if ((c3=='-')||(c3=='_')||(c3=='~')||(c3=='.'))
        (*s3_p)[i-1]=(*s3_p)[i];
      else
        (*s3_p)[i-1]=(*S_p)[i];
    }
  }
}

PRIVATE char *
wrap_get_ptypes(const short *S,
                vrna_md_t *md){

  char *ptype;
  int n,i,j,k,l,*idx;

  n     = S[0];
  ptype = (char *)vrna_alloc(sizeof(char)*((n*(n+1))/2+2));
  idx   = vrna_idx_row_wise(n);
  int min_loop_size = md->min_loop_size;

  for (k=1; k<n-min_loop_size; k++)
    for (l=1; l<=2; l++) {
      int type,ntype=0,otype=0;
      i=k; j = i+min_loop_size+l; if (j>n) continue;
      type = md->pair[S[i]][S[j]];
      while ((i>=1)&&(j<=n)) {
        if ((i>1)&&(j<n)) ntype = md->pair[S[i-1]][S[j+1]];
        if (md->noLP && (!otype) && (!ntype))
          type = 0; /* i.j can only form isolated pairs */
        ptype[idx[i]-j] = (char) type;
        otype =  type;
        type  = ntype;
        i--; j++;
      }
    }
  free(idx);
  return ptype;
}

#ifdef  VRNA_BACKWARD_COMPAT

/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/

PUBLIC char *
get_ptypes( const short *S,
            vrna_md_t *md,
            unsigned int idx_type){

  if(idx_type)
    return wrap_get_ptypes(S, md);
  else
    return vrna_ptypes(S, md);
}

#endif


/242            0           0     0     644     46547     `
/*
                  partiton function for RNA secondary structures

                  Ivo L Hofacker + Ronny Lorenz
                  Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <float.h>    /* #defines FLT_MAX ... */
#include <limits.h>

#include "utils.h"
#include "energy_par.h"
#include "fold_vars.h"
#include "loop_energies.h"
#include "gquad.h"
#include "constraints.h"
#include "mfe.h"
#include "part_func.h"

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/
PRIVATE void  pf_create_bppm(vrna_fold_compound_t *vc, char *structure);
PRIVATE void  alipf_create_bppm(vrna_fold_compound_t *vc, char *structure);
PRIVATE INLINE void bppm_circ(vrna_fold_compound_t *vc);

PRIVATE FLT_OR_DBL  numerator_single(vrna_fold_compound_t *vc, int i, int j);
PRIVATE FLT_OR_DBL  numerator_comparative(vrna_fold_compound_t *vc, int i, int j);


PRIVATE double
wrap_mean_bp_distance(FLT_OR_DBL *p,
                      int length,
                      int *index,
                      int turn);

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

void
vrna_pairing_probs( vrna_fold_compound_t *vc,
                    char *structure){

  if(vc){
    switch(vc->type){
      case VRNA_VC_TYPE_SINGLE:     pf_create_bppm(vc, structure);
                                    break;

      case VRNA_VC_TYPE_ALIGNMENT:  alipf_create_bppm(vc, structure);
                                    break;

      default:                      vrna_message_warning("vrna_pf@part_func.c: Unrecognized fold compound type");
                                    break;
    }
  }
}

/* calculate base pairing probs */
PRIVATE void
pf_create_bppm( vrna_fold_compound_t *vc,
                char *structure){

  int n, i,j,k,l, ij, kl, ii, u1, u2, ov=0;
  unsigned char type, type_2, tt;
  FLT_OR_DBL  temp, Qmax=0, prm_MLb;
  FLT_OR_DBL  prmt, prmt1;
  FLT_OR_DBL  *tmp;
  FLT_OR_DBL  tmp2;
  FLT_OR_DBL  expMLclosing;
  FLT_OR_DBL  *qb, *qm, *G, *probs, *scale, *expMLbase;
  FLT_OR_DBL  *q1k, *qln;

  char              *ptype;

  double            max_real;
  int               *rtype, with_gquad;
  short             *S, *S1;
  vrna_hc_t         *hc;
  vrna_sc_t         *sc;
  int               *my_iindx, *jindx;
  int               circular, turn;
  vrna_exp_param_t  *pf_params;
  vrna_mx_pf_t      *matrices;
  vrna_md_t         *md;

  pf_params         = vc->exp_params;
  md                = &(pf_params->model_details);
  S                 = vc->sequence_encoding2;
  S1                = vc->sequence_encoding;
  my_iindx          = vc->iindx;
  jindx             = vc->jindx;
  ptype             = vc->ptype;

  circular          = md->circ;
  with_gquad        = md->gquad;
  turn              = md->min_loop_size;

  hc                = vc->hc;
  sc                = vc->sc;

  matrices          = vc->exp_matrices;

  qb                = matrices->qb;
  qm                = matrices->qm;
  G                 = matrices->G;
  probs             = matrices->probs;
  q1k               = matrices->q1k;
  qln               = matrices->qln;
  scale             = matrices->scale;
  expMLbase         = matrices->expMLbase;

  FLT_OR_DBL  expMLstem         = (with_gquad) ? exp_E_MLstem(0, -1, -1, pf_params) : 0;
  char        *hard_constraints = hc->matrix;
  int         *hc_up_int        = hc->up_int;

  int           corr_size       = 5;
  int           corr_cnt        = 0;
  vrna_plist_t  *bp_correction  = vrna_alloc(sizeof(vrna_plist_t) * corr_size);

  max_real      = (sizeof(FLT_OR_DBL) == sizeof(float)) ? FLT_MAX : DBL_MAX;


  if((S != NULL) && (S1 != NULL)){

    expMLclosing  = pf_params->expMLclosing;
    with_gquad    = pf_params->model_details.gquad;
    rtype         = &(pf_params->model_details.rtype[0]);
    n             = S[0];

    /*
      The hc_local array provides row-wise access to hc->matrix, i.e.
      my_iindx. Using this in the cubic order loop for multiloops below
      results in way faster computation due to fewer cache misses. Also,
      it introduces only little memory overhead, e.g. ~450MB for
      sequences of length 30,000
    */
    char *hc_local = (char *)vrna_alloc(sizeof(char) * (((n + 1) * (n + 2)) /2 + 2));
    for(i = 1; i <= n; i++)
      for(j = i; j <= n; j++)
        hc_local[my_iindx[i] - j] = hard_constraints[jindx[j] + i];

    FLT_OR_DBL *prm_l  = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));
    FLT_OR_DBL *prm_l1 = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));
    FLT_OR_DBL *prml   = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));

    Qmax=0;

    /* 1. exterior pair i,j and initialization of pr array */
    if(circular){
      bppm_circ(vc);
    } else {
      for (i=1; i<=n; i++) {
        for (j=i; j<=MIN2(i+turn,n); j++)
          probs[my_iindx[i]-j] = 0.;

        for (j=i+turn+1; j<=n; j++) {
          ij = my_iindx[i]-j;
          if((hc_local[ij] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP) && (qb[ij] > 0.)){
            type      = (unsigned char)ptype[jindx[j] + i];

            if(type == 0)
              type = 7;

            probs[ij] = q1k[i-1]*qln[j+1]/q1k[n];
            probs[ij] *= exp_E_ExtLoop(type, (i>1) ? S1[i-1] : -1, (j<n) ? S1[j+1] : -1, pf_params);
            if(sc){
              if(sc->exp_f){
                probs[ij] *= sc->exp_f(1, n, i, j, VRNA_DECOMP_EXT_STEM_OUTSIDE, sc->data);
              }
            }
          } else
            probs[ij] = 0.;
        }
      }
    } /* end if(!circular)  */

    for (l = n; l > turn + 1; l--) {

      /* 2. bonding k,l as substem of 2:loop enclosed by i,j */
      for(k = 1; k < l - turn; k++){
        kl      = my_iindx[k]-l;
        type_2  = (unsigned char)ptype[jindx[l] + k];
        type_2  = rtype[type_2];

        if(type_2 == 0)
          type_2 = 7;

        if (qb[kl]==0.) continue;

        if(hc_local[kl] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP_ENC){
          for(i = MAX2(1, k - MAXLOOP - 1); i <= k - 1; i++){
            u1 = k - i - 1;
            if(hc_up_int[i+1] < u1) continue;

            for(j = l + 1; j <= MIN2(l + MAXLOOP - k + i + 2, n); j++){
              u2 = j-l-1;
              if(hc_up_int[l+1] < u2) break;

              ij = my_iindx[i] - j;
              if(hc_local[ij] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP){
                type = (unsigned char)ptype[jindx[j] + i];

                if(type == 0)
                  type = 7;

                if(probs[ij] > 0){
                  tmp2 =  probs[ij]
                          * scale[u1 + u2 + 2]
                          * exp_E_IntLoop(u1, u2, type, type_2, S1[i+1], S1[j-1], S1[k-1], S1[l+1], pf_params);

                  if(sc){
                    if(sc->exp_energy_up)
                      tmp2 *=   sc->exp_energy_up[i+1][u1]
                              * sc->exp_energy_up[l+1][u2];

                    if(sc->exp_energy_bp)
                      tmp2 *=   sc->exp_energy_bp[ij];

                    if(sc->exp_energy_stack){
                      if((i+1 == k) && (j-1 == l)){
                        tmp2 *=   sc->exp_energy_stack[i]
                                * sc->exp_energy_stack[k]
                                * sc->exp_energy_stack[l]
                                * sc->exp_energy_stack[j];
                      }
                    }

                    if(sc->exp_f){
                      tmp2 *= sc->exp_f(i, j, k, l, VRNA_DECOMP_PAIR_IL, sc->data);
                      if(sc->bt){ /* store probability correction for auxiliary pairs in interior loop motif */
                        vrna_basepair_t *ptr, *aux_bps;
                        aux_bps = sc->bt(i, j, k, l, VRNA_DECOMP_PAIR_IL, sc->data);
                        for(ptr = aux_bps; ptr && ptr->i != 0; ptr++){
                          bp_correction[corr_cnt].i = ptr->i;
                          bp_correction[corr_cnt].j = ptr->j;
                          bp_correction[corr_cnt++].p = tmp2 * qb[kl];
                          if(corr_cnt == corr_size){
                            corr_size += 5;
                            bp_correction = vrna_realloc(bp_correction, sizeof(vrna_plist_t) * corr_size);
                          }
                        }
                        free(aux_bps);
                      }
                    
                    }
                  }

                  probs[kl] += tmp2;
                }
              }
            }
          }
        }
      }

      if(with_gquad){
        /* 2.5. bonding k,l as gquad enclosed by i,j */
        double *expintern = &(pf_params->expinternal[0]);
        FLT_OR_DBL qe;

        if(l < n - 3){
          for(k = 2; k <= l - VRNA_GQUAD_MIN_BOX_SIZE; k++){
            kl = my_iindx[k]-l;
            if (G[kl]==0.) continue;
            tmp2 = 0.;
            i = k - 1;
            for(j = MIN2(l + MAXLOOP + 1, n); j > l + 3; j--){
              ij = my_iindx[i] - j;
              type = (unsigned char)ptype[jindx[j] + i];
              if(!type) continue;
              qe = (type > 2) ? pf_params->expTermAU : 1.;
              tmp2 +=   probs[ij]
                      * qe
                      * (FLT_OR_DBL)expintern[j-l-1]
                      * pf_params->expmismatchI[type][S1[i+1]][S1[j-1]]
                      * scale[2];
            }
            probs[kl] += tmp2 * G[kl];
          }
        }

        if (l < n - 1){
          for (k=3; k<=l-VRNA_GQUAD_MIN_BOX_SIZE; k++) {
            kl = my_iindx[k]-l;
            if (G[kl]==0.) continue;
            tmp2 = 0.;
            for (i=MAX2(1,k-MAXLOOP-1); i<=k-2; i++){
              u1 = k - i - 1;
              for (j=l+2; j<=MIN2(l + MAXLOOP - u1 + 1,n); j++) {
                ij = my_iindx[i] - j;
                type = (unsigned char)ptype[jindx[j] + i];
                if(!type) continue;
                qe = (type > 2) ? pf_params->expTermAU : 1.;
                tmp2 +=   probs[ij]
                        * qe
                        * (FLT_OR_DBL)expintern[u1+j-l-1]
                        * pf_params->expmismatchI[type][S1[i+1]][S1[j-1]]
                        * scale[2];
              }
            }
            probs[kl] += tmp2 * G[kl];
          }
        }

        if(l < n){
          for(k = 4; k <= l - VRNA_GQUAD_MIN_BOX_SIZE; k++){
            kl = my_iindx[k]-l;
            if (G[kl]==0.) continue;
            tmp2 = 0.;
            j = l + 1;
            for (i=MAX2(1,k-MAXLOOP-1); i < k - 3; i++){
              ij = my_iindx[i] - j;
              type = (unsigned char)ptype[jindx[j] + i];
              if(!type) continue;
              qe = (type > 2) ? pf_params->expTermAU : 1.;
              tmp2 +=   probs[ij]
                      * qe
                      * (FLT_OR_DBL)expintern[k - i - 1]
                      * pf_params->expmismatchI[type][S1[i+1]][S1[j-1]]
                      * scale[2];
            }
            probs[kl] += tmp2 * G[kl];
          }
        }
      }

      /* 3. bonding k,l as substem of multi-loop enclosed by i,j */
      prm_MLb = 0.;
      if (l<n)
        for (k = 2; k < l - turn; k++) {
          kl    = my_iindx[k] - l;
          i     = k - 1;
          prmt  = prmt1 = 0.0;

          ii = my_iindx[i];     /* ii-j=[i,j]     */
          tt = (unsigned char)ptype[jindx[l+1] + i];
          tt = rtype[tt];

          if(tt == 0)
            tt = 7;

          if(hc_local[ii - (l + 1)] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP){
            prmt1 = probs[ii-(l+1)]
                    * expMLclosing
                    * exp_E_MLstem(tt, S1[l], S1[i+1], pf_params);

            if(sc){
              /* which decompositions are covered here? => (k-1, l+1) -> enclosing pair */
              if(sc->exp_energy_bp)
                prmt1 *= sc->exp_energy_bp[ii - (l+1)];

/*
              if(sc->exp_f)
                prmt1 *= sc->exp_f(i, l+1, k, l, , sc->data);
*/
            }
          }
          int lj;
          short s3;
          FLT_OR_DBL ppp;
          ij = my_iindx[i] - (l+2);
          lj = my_iindx[l+1]-(l+1);
          s3 = S1[i+1];
          for (j = l + 2; j<=n; j++, ij--, lj--){
            if(hc_local[ij] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP){
              tt = (unsigned char)md->pair[S1[j]][S1[i]];
              /* which decomposition is covered here? =>
                i + 1 = k < l < j:
                (i,j)       -> enclosing pair
                (k, l)      -> enclosed pair
                (l+1, j-1)  -> multiloop part with at least one stem
                a.k.a. (k,l) is left-most stem in multiloop closed by (k-1, j)
              */
              ppp = probs[ij]
                    * exp_E_MLstem(tt, S1[j-1], s3, pf_params)
                    * qm[lj];

              if(sc){
                if(sc->exp_energy_bp)
                  ppp *= sc->exp_energy_bp[ij];
/*
                if(sc->exp_f)
                  ppp *= sc->exp_f(i, j, l+1, j-1, , sc->data);
*/
              }
              prmt += ppp;
            }
          }
          prmt *= expMLclosing;

          tt        =   ptype[jindx[l] + k];

          prml[ i]  =   prmt;

          /* l+1 is unpaired */
          if(hc->up_ml[l+1]){
            ppp = prm_l1[i] * expMLbase[1];
            if(sc){
              if(sc->exp_energy_up)
                ppp *= sc->exp_energy_up[l+1][1];

/*
              if(sc_exp_f)
                ppp *= sc->exp_f(, sc->data);
*/
            }
            prm_l[i] = ppp + prmt1;
          } else { /* skip configuration where l+1 is unpaired */
            prm_l[i] = prmt1;
          }

          /* i is unpaired */
          if(hc->up_ml[i]){
            ppp = prm_MLb*expMLbase[1];
            if(sc){
              if(sc->exp_energy_up)
                ppp *= sc->exp_energy_up[i][1];

/*
              if(sc->exp_f)
                ppp *= sc->exp_f(, sc->data);
*/
            }

            prm_MLb = ppp + prml[i];
            /* same as:    prm_MLb = 0;
               for (i=1; i<=k-1; i++) prm_MLb += prml[i]*expMLbase[k-i-1]; */

          } else { /* skip all configurations where i is unpaired */
            prm_MLb = prml[i];
          }

          prml[i] = prml[i] + prm_l[i];

          if(with_gquad){
            if ((!tt) && (G[kl] == 0.)) continue;
          } else {
            if (qb[kl] == 0.) continue;
          }

          if(hc_local[kl] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC){

            temp = prm_MLb;

            for (i=1;i<=k-2; i++)
              temp += prml[i]*qm[my_iindx[i+1] - (k-1)];

            if(with_gquad){
              if(tt)
                temp    *= exp_E_MLstem(tt, (k>1) ? S1[k-1] : -1, (l<n) ? S1[l+1] : -1, pf_params) * scale[2];
              else
                temp    *= G[kl] * expMLstem * scale[2];
            } else {

              if(tt == 0)
                tt = 7;

              temp    *= exp_E_MLstem(tt, (k>1) ? S1[k-1] : -1, (l<n) ? S1[l+1] : -1, pf_params) * scale[2];
            }

            probs[kl]  += temp;

            if (probs[kl]>Qmax) {
              Qmax = probs[kl];
              if (Qmax>max_real/10.)
                fprintf(stderr, "P close to overflow: %d %d %g %g\n",
                  i, j, probs[kl], qb[kl]);
            }
            if (probs[kl]>=max_real) {
              ov++;
              probs[kl]=FLT_MAX;
            }
          }
        } /* end for (k=..) */
      tmp = prm_l1; prm_l1=prm_l; prm_l=tmp;

    }  /* end for (l=..)   */

    if(sc && sc->f && sc->bt){
      for (i=1; i<=n; i++)
        for (j=i+turn+1; j<=n; j++) {
          ij = my_iindx[i]-j;
          /*  search for possible auxiliary base pairs in hairpin loop motifs to store
              the corresponding probability corrections
          */ 
          if(hc_local[ij] & VRNA_CONSTRAINT_CONTEXT_HP_LOOP){
            vrna_basepair_t *ptr, *aux_bps;
            aux_bps = sc->bt(i, j, i, j, VRNA_DECOMP_PAIR_HP, sc->data);
            if(aux_bps){
              FLT_OR_DBL qhp = vrna_exp_E_hp_loop(vc, i, j);
              for(ptr = aux_bps; ptr && ptr->i != 0; ptr++){
                bp_correction[corr_cnt].i = ptr->i;
                bp_correction[corr_cnt].j = ptr->j;
                bp_correction[corr_cnt++].p = probs[ij] * qhp;
                if(corr_cnt == corr_size){
                  corr_size += 5;
                  bp_correction = vrna_realloc(bp_correction, sizeof(vrna_plist_t) * corr_size);
                }
              }
            }
            free(aux_bps);
          }
        }

      /*  correct pairing probabilities for auxiliary base pairs from hairpin-, or interior loop motifs
          as augmented by the generalized soft constraints feature
      */
      for(i = 0; i < corr_cnt; i++){
        ij = my_iindx[bp_correction[i].i] - bp_correction[i].j;
        /* printf("correcting pair %d, %d by %f\n", bp_correction[i].i, bp_correction[i].j, bp_correction[i].p); */
        probs[ij] += bp_correction[i].p / qb[ij];
      }
    }
    free(bp_correction);

    for (i=1; i<=n; i++)
      for (j=i+turn+1; j<=n; j++) {
        ij = my_iindx[i]-j;

        if(with_gquad){
          if (qb[ij] > 0.)
            probs[ij] *= qb[ij];

          if (G[ij] > 0.){
            probs[ij] += q1k[i-1] * G[ij] * qln[j+1]/q1k[n];
          }
        } else {
          if (qb[ij] > 0.)
            probs[ij] *= qb[ij];
        }
      }

    if (structure!=NULL){
      char *s = vrna_db_from_probs(probs, (unsigned int)n);
      memcpy(structure, s, n);
      structure[n] = '\0';
      free(s);
    }
    if (ov>0) fprintf(stderr, "%d overflows occurred while backtracking;\n"
        "you might try a smaller pf_scale than %g\n",
        ov, pf_params->pf_scale);

    /* clean up */
    free(prm_l);
    free(prm_l1);
    free(prml);

    free(hc_local);
  } /* end if((S != NULL) && (S1 != NULL))  */
  else
    vrna_message_error("bppm calculations have to be done after calling forward recursion\n");

  return;
}

PRIVATE FLT_OR_DBL
numerator_single( vrna_fold_compound_t *vc,
                  int i,
                  int j){

  return 1.;
}

PRIVATE FLT_OR_DBL
numerator_comparative(vrna_fold_compound_t *vc,
                      int i,
                      int j){

  int     *pscore = vc->pscore;             /* precomputed array of pair types */                      
  double  kTn     = vc->exp_params->kT/10.; /* kT in cal/mol  */
  int     *jindx  = vc->jindx;

  return exp(pscore[jindx[j]+i]/kTn);
}

/* calculate base pairing probs */
PRIVATE INLINE void
bppm_circ(vrna_fold_compound_t *vc){

  unsigned char     type;
  char              *ptype, *sequence;
  char              *hard_constraints;
  short             *S, *S1;
  int               n, i,j,k,l, ij, *rtype, *my_iindx, *jindx, turn;
  FLT_OR_DBL        tmp2, expMLclosing, *qb, *qm, *qm1, *probs, *scale, *expMLbase, qo;
  vrna_hc_t         *hc;
  vrna_exp_param_t  *pf_params;
  vrna_mx_pf_t      *matrices;
  vrna_md_t         *md;
  FLT_OR_DBL (*numerator_f)(vrna_fold_compound_t *vc, int i, int j);

  pf_params         = vc->exp_params;
  md                = &(pf_params->model_details);
  S                 = vc->sequence_encoding2;
  S1                = vc->sequence_encoding;
  my_iindx          = vc->iindx;
  jindx             = vc->jindx;
  ptype             = vc->ptype;
  turn              = md->min_loop_size;
  hc                = vc->hc;
  matrices          = vc->exp_matrices;
  qb                = matrices->qb;
  qm                = matrices->qm;
  qm1               = matrices->qm1;
  probs             = matrices->probs;
  scale             = matrices->scale;
  expMLbase         = matrices->expMLbase;
  qo                = matrices->qo;
  hard_constraints  = hc->matrix;
  sequence          = vc->sequence;


  expMLclosing  = pf_params->expMLclosing;
  rtype         = &(pf_params->model_details.rtype[0]);
  n             = S[0];

  switch(vc->type){
    case  VRNA_VC_TYPE_SINGLE:    numerator_f = numerator_single;
                                  break;
    case  VRNA_VC_TYPE_ALIGNMENT: numerator_f = numerator_comparative;
                                  break;
    default:                      numerator_f = NULL;
                                  break;
  }

  /*
    The hc_local array provides row-wise access to hc->matrix, i.e.
    my_iindx. Using this in the cubic order loop for multiloops below
    results in way faster computation due to fewer cache misses. Also,
    it introduces only little memory overhead, e.g. ~450MB for
    sequences of length 30,000
  */
  char *hc_local = (char *)vrna_alloc(sizeof(char) * (((n + 1) * (n + 2)) /2 + 2));
  for(i = 1; i <= n; i++)
    for(j = i; j <= n; j++)
      hc_local[my_iindx[i] - j] = hard_constraints[jindx[j] + i];

  /* 1. exterior pair i,j */
  for (i=1; i<=n; i++) {
    for (j=i; j<=MIN2(i+turn,n); j++)
      probs[my_iindx[i]-j] = 0;
    for (j=i+turn+1; j<=n; j++) {
      ij = my_iindx[i]-j;
      if(qb[ij] > 0.){
        probs[ij] = numerator_f(vc, i, j)/qo;

        type = (unsigned char)ptype[jindx[j] + i];

        unsigned char rt = rtype[type];

        /* 1.1. Exterior Hairpin Contribution */
        tmp2 = vrna_exp_E_hp_loop(vc, j, i);

        /* 1.2. Exterior Interior Loop Contribution                     */
        /* 1.2.1. i,j  delimtis the "left" part of the interior loop    */
        /* (j,i) is "outer pair"                                        */
        for(k=1; k < i-turn-1; k++){
          int ln1, lstart;
          ln1 = k + n - j - 1;
          if(ln1>MAXLOOP) break;
          lstart = ln1+i-1-MAXLOOP;
          if(lstart<k+turn+1) lstart = k + turn + 1;
          for(l=lstart; l < i; l++){
            int ln2, type_2;
            type_2 = (unsigned char)ptype[jindx[l] + k];
            if (type_2==0) continue;
            ln2 = i - l - 1;
            if(ln1+ln2>MAXLOOP) continue;
            tmp2 += qb[my_iindx[k] - l]
                    * exp_E_IntLoop(ln1,
                                    ln2,
                                    rt,
                                    rtype[type_2],
                                    S1[j+1],
                                    S1[i-1],
                                    S1[k-1],
                                    S1[l+1],
                                    pf_params)
                    * scale[ln1 + ln2];
          }
        }
        /* 1.2.2. i,j  delimtis the "right" part of the interior loop  */
        for(k=j+1; k < n-turn; k++){
          int ln1, lstart;
          ln1 = k - j - 1;
          if((ln1 + i - 1)>MAXLOOP) break;
          lstart = ln1+i-1+n-MAXLOOP;
          if(lstart<k+turn+1) lstart = k + turn + 1;
          for(l=lstart; l <= n; l++){
            int ln2, type_2;
            type_2 = (unsigned char)ptype[jindx[l] + k];
            if (type_2==0) continue;
            ln2 = i - 1 + n - l;
            if(ln1+ln2>MAXLOOP) continue;
            tmp2 += qb[my_iindx[k] - l]
                    * exp_E_IntLoop(ln2,
                                    ln1,
                                    rtype[type_2],
                                    rt,
                                    S1[l+1],
                                    S1[k-1],
                                    S1[i-1],
                                    S1[j+1],
                                    pf_params)
                    * scale[ln1 + ln2];
          }
        }
        /* 1.3 Exterior multiloop decomposition */
        /* 1.3.1 Middle part                    */
        if((i>turn+2) && (j<n-turn-1))
          tmp2 += qm[my_iindx[1]-i+1]
                  * qm[my_iindx[j+1]-n]
                  * expMLclosing
                  * exp_E_MLstem(type, S1[i-1], S1[j+1], pf_params);

        /* 1.3.2 Left part  */
        for(k=turn+2; k < i-turn-2; k++)
          tmp2 += qm[my_iindx[1]-k]
                  * qm1[jindx[i-1]+k+1]
                  * expMLbase[n-j]
                  * expMLclosing
                  * exp_E_MLstem(type, S1[i-1], S1[j+1], pf_params);

        /* 1.3.3 Right part */
        for(k=j+turn+2; k < n-turn-1;k++)
          tmp2 += qm[my_iindx[j+1]-k]
                  * qm1[jindx[n]+k+1]
                  * expMLbase[i-1]
                  * expMLclosing
                  * exp_E_MLstem(type, S1[i-1], S1[j+1], pf_params);

        /* all exterior loop decompositions for pair i,j done  */
        probs[ij] *= tmp2;

      }
      else probs[ij] = 0;
    }
  }
}



PRIVATE double
wrap_mean_bp_distance(FLT_OR_DBL *p,
                      int length,
                      int *index,
                      int turn){

  int         i,j;
  double      d = 0.;

  /* compute the mean base pair distance in the thermodynamic ensemble */
  /* <d> = \sum_{a,b} p_a p_b d(S_a,S_b)
     this can be computed from the pair probs p_ij as
     <d> = \sum_{ij} p_{ij}(1-p_{ij}) */

  for (i=1; i<=length; i++)
    for (j=i+turn+1; j<=length; j++)
      d += p[index[i]-j] * (1-p[index[i]-j]);

  return 2*d;
}


PUBLIC double
vrna_mean_bp_distance_pr( int length,
                          FLT_OR_DBL *p){

  int *index = vrna_idx_row_wise((unsigned int) length);
  double d;

  if (p==NULL)
    vrna_message_error("vrna_mean_bp_distance_pr: p==NULL. You need to supply a valid probability matrix");

  d = wrap_mean_bp_distance(p, length, index, TURN);

  free(index);
  return d;
}

PUBLIC double
vrna_mean_bp_distance(vrna_fold_compound_t *vc){

  if(!vc){
    vrna_message_error("vrna_mean_bp_distance: run vrna_pf_fold first!");
  } else if(!vc->exp_matrices){
    vrna_message_error("vrna_mean_bp_distance: exp_matrices==NULL!");
  } else if( !vc->exp_matrices->probs){
    vrna_message_error("vrna_mean_bp_distance: probs==NULL!");
  }

  return wrap_mean_bp_distance( vc->exp_matrices->probs,
                                vc->length,
                                vc->iindx,
                                vc->exp_params->model_details.min_loop_size);
}

PUBLIC vrna_plist_t *
vrna_stack_prob(vrna_fold_compound_t *vc, double cutoff){

  vrna_plist_t             *pl;
  int               i, j, plsize, turn, length, *index, *jindx, *rtype, num;
  char              *ptype;
  FLT_OR_DBL        *qb, *probs, *scale, p;
  vrna_exp_param_t  *pf_params;
  vrna_mx_pf_t      *matrices;

  plsize  = 256;
  pl      = NULL;
  num     = 0;

  if(vc){
    pf_params = vc->exp_params;
    length    = vc->length;
    index     = vc->iindx;
    jindx     = vc->jindx;
    rtype     = &(pf_params->model_details.rtype[0]);
    ptype     = vc->ptype;
    matrices  = vc->exp_matrices;
    qb        = matrices->qb;
    probs     = matrices->probs;
    scale     = matrices->scale;
    turn      = pf_params->model_details.min_loop_size;

    pl        = (vrna_plist_t *) vrna_alloc(plsize*sizeof(vrna_plist_t));

    for (i=1; i<length; i++)
      for (j=i+turn+3; j<=length; j++) {
        if((p=probs[index[i]-j]) < cutoff) continue;
        if (qb[index[i+1]-(j-1)]<FLT_MIN) continue;
        p *= qb[index[i+1]-(j-1)]/qb[index[i]-j];
        p *= exp_E_IntLoop(0,0,(unsigned char)ptype[jindx[j]+i],rtype[(unsigned char)ptype[jindx[j-1] + i+1]],
                           0,0,0,0, pf_params)*scale[2];/* add *scale[u1+u2+2] */
        if (p>cutoff) {
          pl[num].i     = i;
          pl[num].j     = j;
          pl[num].type  = 0;
          pl[num++].p   = p;
          if (num>=plsize) {
            plsize *= 2;
            pl = vrna_realloc(pl, plsize*sizeof(vrna_plist_t));
          }
        }
      }
    pl[num].i=0;
  }

  return pl;
}


PRIVATE void
alipf_create_bppm(vrna_fold_compound_t *vc,
                  char *structure){

  int s;
  int i,j,k,l, ij, kl, ii, ll, tt, *type, ov=0;
  FLT_OR_DBL temp, prm_MLb;
#ifdef USE_FLOAT_PF
  FLT_OR_DBL Qmax=0.;
#endif
  FLT_OR_DBL prmt,prmt1;
  FLT_OR_DBL qbt1, *tmp, tmp2, tmp3;

  int             n_seq         = vc->n_seq;
  int             n             = vc->length;


  short             **S           = vc->S;                                                                   
  short             **S5          = vc->S5;     /*S5[s][i] holds next base 5' of i in sequence s*/            
  short             **S3          = vc->S3;     /*Sl[s][i] holds next base 3' of i in sequence s*/            
  char              **Ss          = vc->Ss;
  unsigned short    **a2s         = vc->a2s;                                                                   
  vrna_exp_param_t  *pf_params    = vc->exp_params;
  vrna_mx_pf_t      *matrices     = vc->exp_matrices;
  vrna_md_t         *md           = &(pf_params->model_details);
  vrna_hc_t         *hc           = vc->hc;
  vrna_sc_t         **sc          = vc->scs;
  int               *my_iindx     = vc->iindx;
  int               *jindx        = vc->jindx;
  FLT_OR_DBL        *q            = matrices->q;
  FLT_OR_DBL        *qb           = matrices->qb;
  FLT_OR_DBL        *qm           = matrices->qm;
  FLT_OR_DBL        *qm1          = matrices->qm1;
  FLT_OR_DBL        qo            = matrices->qo;
  int               *pscore       = vc->pscore;     /* precomputed array of pair types */                      
  int               *rtype        = &(md->rtype[0]);
  int               circular      = md->circ;
  FLT_OR_DBL        *scale        = matrices->scale;
  FLT_OR_DBL        *expMLbase    = matrices->expMLbase;
  FLT_OR_DBL        expMLclosing  = pf_params->expMLclosing;
  FLT_OR_DBL        *probs        = matrices->probs;
  char              *hard_constraints = hc->matrix;

  double kTn;
  FLT_OR_DBL pp;

  FLT_OR_DBL *prm_l   = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));
  FLT_OR_DBL *prm_l1  = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));
  FLT_OR_DBL *prml    = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));
  type                = (int *)vrna_alloc(sizeof(int) * n_seq);

  if((matrices->q1k == NULL) || (matrices->qln == NULL)){
    free(matrices->q1k);
    matrices->q1k = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+1));
    free(matrices->qln);
    matrices->qln = (FLT_OR_DBL *) vrna_alloc(sizeof(FLT_OR_DBL)*(n+2));
  }

  FLT_OR_DBL *q1k    = matrices->q1k;
  FLT_OR_DBL *qln    = matrices->qln;

  for (k=1; k<=n; k++) {
    q1k[k] = q[my_iindx[1] - k];
    qln[k] = q[my_iindx[k] - n];
  }
  q1k[0] = 1.0;
  qln[n+1] = 1.0;


  kTn = pf_params->kT/10.;   /* kT in cal/mol  */

  for (i=0; i<=n; i++)
    prm_l[i]=prm_l1[i]=prml[i]=0;

  /* 1. exterior pair i,j and initialization of pr array */
  if(circular){
    for (i=1; i<=n; i++) {
      for (j=i; j<=MIN2(i+TURN,n); j++) probs[my_iindx[i]-j] = 0;
      for (j=i+TURN+1; j<=n; j++) {
        ij = my_iindx[i]-j;
        if (qb[ij]>0.) {
          probs[ij] =  exp(pscore[jindx[j]+i]/kTn)/qo;

          /* get pair types  */
          for (s=0; s<n_seq; s++) {
            type[s] = md->pair[S[s][j]][S[s][i]];
            if (type[s]==0) type[s]=7;
          }

          tmp2 = 0.;

          /* 1.1. Exterior Hairpin Contribution */
          tmp2 += vrna_exp_E_hp_loop(vc, j, i);

          /* 1.2. Exterior Interior Loop Contribution */
          /* recycling of k and l... */
          if(hard_constraints[jindx[j] + i] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP){

            /* 1.2.1. first we calc exterior loop energy with constraint, that i,j  */
            /* delimtis the "right" part of the interior loop                       */
            /* (l,k) is "outer pair"                                                */
            for(k=1; k < i-TURN-1; k++){
              /* so first, lets calc the length of loop between j and k */
              int ln1, lstart;
              ln1 = k + n - j - 1;
              if(ln1>MAXLOOP)
                break;
              if(hc->up_int[j+1] < ln1)
                break;

              lstart = ln1+i-1-MAXLOOP;
              if(lstart<k+TURN+1) lstart = k + TURN + 1;
              for(l=lstart; l < i; l++){
                int ln2,ln2a,ln1a, type_2;
                ln2 = i - l - 1;
                if(ln1+ln2>MAXLOOP)
                  continue;
                if(hc->up_int[l+1] < ln2)
                  continue;
                if(!(hard_constraints[jindx[l] + k] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP))
                  continue;
                
                FLT_OR_DBL qloop=1.;
                if(qb[my_iindx[k]-l]==0.){
                  qloop=0.;
                  continue;
                }

                for (s=0; s<n_seq; s++){
                  ln2a= a2s[s][i-1];
                  ln2a-=a2s[s][l];
                  ln1a= a2s[s][n]-a2s[s][j];
                  ln1a+=a2s[s][k-1];
                  type_2 = md->pair[S[s][l]][S[s][k]];
                  if (type_2 == 0) type_2 = 7;
                  qloop *= exp_E_IntLoop(ln1a, ln2a, type[s], type_2,
                              S[s][j+1],
                              S[s][i-1],
                              S[s][(k>1) ? k-1 : n],
                              S[s][l+1], pf_params);
                }
                if(sc)
                  for(s = 0; s < n_seq; s++){
                    if(sc[s]){
                      ln2a= a2s[s][i-1];
                      ln2a-=a2s[s][l];
                      ln1a= a2s[s][n]-a2s[s][j];
                      ln1a+=a2s[s][k-1];

                      if(sc[s]->exp_energy_up)
                        qloop *=    sc[s]->exp_energy_up[a2s[s][l]+1][ln2a]
                                  * ((j < n) ? sc[s]->exp_energy_up[a2s[s][j]+1][a2s[s][n] - a2s[s][j]] : 1.)
                                  * ((k > 1) ? sc[s]->exp_energy_up[1][a2s[s][k]-1] : 1.);

                      if((ln1a + ln2a == 0) && sc[s]->exp_energy_stack){
                        if(S[s][i] && S[s][j] && S[s][k] && S[s][l]){ /* don't allow gaps in stack */
                          qloop *=    sc[s]->exp_energy_stack[a2s[s][k]]
                                    * sc[s]->exp_energy_stack[a2s[s][l]]
                                    * sc[s]->exp_energy_stack[a2s[s][i]]
                                    * sc[s]->exp_energy_stack[a2s[s][j]];
                        }
                      }
                    }
                  }
                tmp2 += qb[my_iindx[k] - l] * qloop * scale[ln1+ln2];
              }
            }

            /* 1.2.2. second we calc exterior loop energy with constraint, that i,j */
            /* delimtis the "left" part of the interior loop                        */
            /* (j,i) is "outer pair"                                                */
            for(k=j+1; k < n-TURN; k++){
              /* so first, lets calc the length of loop between l and i */
              int ln1, lstart;
              ln1 = k - j - 1;
              if((ln1 + i - 1)>MAXLOOP)
                break;
              if(hc->up_int[j+1] < ln1)
                break;

              lstart = ln1+i-1+n-MAXLOOP;
              if(lstart<k+TURN+1) lstart = k + TURN + 1;
              for(l=lstart; l <= n; l++){
                int ln2, type_2;
                ln2 = i - 1 + n - l;
                if(ln1+ln2>MAXLOOP)
                  continue;
                if(hc->up_int[l+1] < ln2)
                  continue;
                if(!(hard_constraints[jindx[l] + k] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP))
                  continue;

                FLT_OR_DBL qloop=1.;
                if(qb[my_iindx[k]-l]==0.){
                  qloop=0.;
                  continue;
                }

                for (s=0; s<n_seq; s++){
                  ln1 = a2s[s][k] - a2s[s][j+1];
                  ln2 = a2s[s][i-1] + a2s[s][n] - a2s[s][l];
                  type_2 = md->pair[S[s][l]][S[s][k]];
                  if (type_2 == 0) type_2 = 7;
                  qloop *= exp_E_IntLoop(ln2, ln1, type_2, type[s],
                          S3[s][l],
                          S5[s][k],
                          S5[s][i],
                          S3[s][j], pf_params);
                }
                if(sc)
                  for(s = 0; s < n_seq; s++){
                    if(sc[s]){
                      ln1 = a2s[s][k] - a2s[s][j+1];
                      ln2 = a2s[s][i-1] + a2s[s][n] - a2s[s][l];

                      if(sc[s]->exp_energy_up)
                        qloop *=    sc[s]->exp_energy_up[a2s[s][j]+1][ln1]
                                  * ((l < n) ? sc[s]->exp_energy_up[a2s[s][l]+1][a2s[s][n] - a2s[s][l]] : 1.)
                                  * ((i > 1) ? sc[s]->exp_energy_up[1][a2s[s][i]-1] : 1.);

                      if((ln1 + ln2 == 0) && sc[s]->exp_energy_stack){
                        if(S[s][i] && S[s][j] && S[s][k] && S[s][l]){ /* don't allow gaps in stack */
                          qloop *=    sc[s]->exp_energy_stack[a2s[s][k]]
                                    * sc[s]->exp_energy_stack[a2s[s][l]]
                                    * sc[s]->exp_energy_stack[a2s[s][i]]
                                    * sc[s]->exp_energy_stack[a2s[s][j]];
                        }
                      }
                    }
                  }
                tmp2 += qb[my_iindx[k] - l] * qloop * scale[ln1+ln2];
              }
            }
          }
          /* 1.3 Exterior multiloop decomposition */
          if(hard_constraints[jindx[j] + i] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP){
            /* 1.3.1 Middle part                    */
            if((i>TURN+2) && (j<n-TURN-1)){

              for (tmp3=1, s=0; s<n_seq; s++){
                tmp3 *= exp_E_MLstem(rtype[type[s]], S5[s][i], S3[s][j], pf_params);
              }
              tmp2 += qm[my_iindx[1]-i+1] * qm[my_iindx[j+1]-n] * tmp3 * pow(expMLclosing,n_seq);
            }
            /* 1.3.2 Left part    */
            for(k=TURN+2; k < i-TURN-2; k++){
              if(hc->up_ml[j+1] < n-j)
                break;

              for (tmp3=1, s=0; s<n_seq; s++){
                tmp3 *= exp_E_MLstem(rtype[type[s]], S5[s][i], S3[s][j], pf_params);
              }

              if(sc)
                for(s = 0; s < n_seq; s++){
                  if(sc[s]){
                    if(sc[s]->exp_energy_bp)
                      tmp3 *= sc[s]->exp_energy_bp[jindx[j] + i];

                    if(sc[s]->exp_energy_up)
                      tmp3 *= sc[s]->exp_energy_up[a2s[s][j]+1][a2s[s][n]-a2s[s][j]];
                  }
                }

              tmp2 += qm[my_iindx[1]-k] * qm1[jindx[i-1]+k+1] * tmp3 * expMLbase[n-j] * pow(expMLclosing,n_seq);
            }
            /* 1.3.3 Right part    */
            for(k=j+TURN+2; k < n-TURN-1;k++){
              if(hc->up_ml[1] < i-1)
                break;

              for (tmp3=1, s=0; s<n_seq; s++){
                tmp3 *= exp_E_MLstem(rtype[type[s]], S5[s][i], S3[s][j], pf_params);
              }

              if(sc)
                for(s = 0; s < n_seq; s++){
                  if(sc[s]){
                    if(sc[s]->exp_energy_bp)
                      tmp3 *= sc[s]->exp_energy_bp[jindx[j] + i];

                    if(sc[s]->exp_energy_up)
                      tmp3 *= sc[s]->exp_energy_up[a2s[s][1]][a2s[s][i]-a2s[s][1]];
                  }
                }

              tmp2 += qm[my_iindx[j+1]-k] * qm1[jindx[n]+k+1] * tmp3 * expMLbase[i-1] * pow(expMLclosing,n_seq);
            }
          }
          probs[ij] *= tmp2;
        }
        else probs[ij] = 0;
      }  /* end for j=..*/
    }  /* end or i=...  */
  } /* end if(circular)  */
  else{
    for (i=1; i<=n; i++) {
      for (j=i; j<=MIN2(i+TURN,n); j++)
        probs[my_iindx[i]-j] = 0;

      for (j=i+TURN+1; j<=n; j++) {
        ij = my_iindx[i]-j;
        if ((qb[ij] > 0.) && (hard_constraints[jindx[j] + i] & VRNA_CONSTRAINT_CONTEXT_EXT_LOOP)){
          probs[ij] = q1k[i-1] * qln[j+1]/q1k[n] * exp(pscore[jindx[j]+i]/kTn);
          for (s=0; s<n_seq; s++) {
            int typ;
            typ = md->pair[S[s][i]][S[s][j]]; if (typ==0) typ=7;
            probs[ij] *= exp_E_ExtLoop(typ, (i>1) ? S5[s][i] : -1, (j<n) ? S3[s][j] : -1, pf_params);
          }
        } else
          probs[ij] = 0;
      }
    }
  } /* end if(!circular)  */
  for (l=n; l>TURN+1; l--) {

    /* 2. bonding k,l as substem of 2:loop enclosed by i,j */
    for (k=1; k<l-TURN; k++) {
      pp = 0.;
      kl = my_iindx[k]-l;
      if (qb[kl] == 0.) continue;
      if(!(hard_constraints[jindx[l] + k] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP_ENC)) continue;

      for (s=0; s<n_seq; s++) {
        type[s] = md->pair[S[s][l]][S[s][k]];
        if (type[s]==0) type[s]=7;
      }

      for (i=MAX2(1,k-MAXLOOP-1); i<=k-1; i++){
        if(hc->up_int[i+1] < k - i - 1)
          continue;

        for (j=l+1; j<=MIN2(l+ MAXLOOP -k+i+2,n); j++) {
          FLT_OR_DBL qloop=1;
          ij = my_iindx[i] - j;

          if(probs[ij] == 0.) continue;
          if(!(hard_constraints[jindx[j] + i] & VRNA_CONSTRAINT_CONTEXT_INT_LOOP)) continue;
          if(hc->up_int[l+1] < j - l - 1) break;

          for (s=0; s<n_seq; s++) {
            int typ, u1, u2;
            u1 = a2s[s][k-1] - a2s[s][i];
            u2 = a2s[s][j-1] - a2s[s][l];
            typ = md->pair[S[s][i]][S[s][j]]; if (typ==0) typ=7;
            qloop *=  exp_E_IntLoop(u1, u2, typ, type[s], S3[s][i], S5[s][j], S5[s][k], S3[s][l], pf_params);
          }

          if(sc){
            for(s = 0; s < n_seq; s++){
              if(sc[s]){
                int u1, u2;
                u1 = a2s[s][k-1] - a2s[s][i];
                u2 = a2s[s][j-1] - a2s[s][l];
/*
                u1 = k - i - 1;
                u2 = j - l - 1;
*/
                if(sc[s]->exp_energy_bp)
                  qloop *= sc[s]->exp_energy_bp[jindx[j] + i];

                if(sc[s]->exp_energy_up)
                  qloop *=    sc[s]->exp_energy_up[a2s[s][i]+1][u1]
                              * sc[s]->exp_energy_up[a2s[s][l]+1][u2];

                if(sc[s]->exp_energy_stack)
                  if(u1 + u2 == 0){
                    if(S[s][i] && S[s][j] && S[s][k] && S[s][l]){ /* don't allow gaps in stack */
                      qloop *=    sc[s]->exp_energy_stack[i]
                                * sc[s]->exp_energy_stack[k]
                                * sc[s]->exp_energy_stack[l]
                                * sc[s]->exp_energy_stack[j];
                    }
                  }
              }
            }
          }
          pp += probs[ij]*qloop*scale[k-i + j-l];
        }
      }
      probs[kl] += pp * exp(pscore[jindx[l]+k]/kTn);
    }
    /* 3. bonding k,l as substem of multi-loop enclosed by i,j */
    prm_MLb = 0.;
    if (l<n)
      for (k=2; k<l-TURN; k++) {
      i = k-1;
      prmt = prmt1 = 0.;

      if(1 /* hard_constraints[jindx[l] + k] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP_ENC */){
        ii = my_iindx[i];     /* ii-j=[i,j]     */
        ll = my_iindx[l+1];   /* ll-j=[l+1,j-1] */
        if(hard_constraints[jindx[l+1] + i] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP){
          prmt1 = probs[ii-(l+1)];
          for (s=0; s<n_seq; s++) {
            tt = md->pair[S[s][l+1]][S[s][i]]; if (tt==0) tt=7;
            prmt1 *= exp_E_MLstem(tt, S5[s][l+1], S3[s][i], pf_params) * expMLclosing;
          }

          if(sc)
            for(s = 0; s < n_seq; s++){
              if(sc[s]){
                if(sc[s]->exp_energy_bp)
                  prmt1 *= sc[s]->exp_energy_bp[jindx[l+1] + i];
              }
            }
        }

        for (j=l+2; j<=n; j++){
          pp = 1.;
          if(probs[ii-j]==0) continue;
          if(!(hard_constraints[jindx[j] + i] & VRNA_CONSTRAINT_CONTEXT_MB_LOOP)) continue;

          for (s=0; s<n_seq; s++) {
            tt = md->pair[S[s][j]][S[s][i]]; if (tt==0) tt=7;
            pp *=  exp_E_MLstem(tt, S5[s][j], S3[s][i], pf_params) * expMLclosing;
          }

          if(sc)
            for(s = 0; s < n_seq; s++){
              if(sc[s]){
                if(sc[s]->exp_energy_bp)
                  pp *= sc[s]->exp_energy_bp[jindx[j] + i];
              }
            }

          prmt +=  probs[ii-j] * pp * qm[ll-(j-1)];
        }
        kl = my_iindx[k]-l;

        prml[ i] = prmt;

        pp = 0.;
        if(hc->up_ml[l+1]){
          pp = prm_l1[i] * expMLbase[1];
          if(sc)
            for(s = 0; s < n_seq; s++){
              if(sc[s]){
                if(sc[s]->exp_energy_up)
                  pp *= sc[s]->exp_energy_up[a2s[s][l+1]][1];
              }
            }
        }
        prm_l[i] = pp + prmt1; /* expMLbase[1]^n_seq */

        pp = 0.;
        if(hc->up_ml[i]){
          pp = prm_MLb * expMLbase[1];
          if(sc)
            for(s = 0; s < n_seq; s++){
              if(sc[s]){
                if(sc[s]->exp_energy_up)
                  pp *= sc[s]->exp_energy_up[a2s[s][i]][1];
              }
            }
        }
        prm_MLb = pp + prml[i];

        /* same as:    prm_MLb = 0;
           for (i=1; i<=k-1; i++) prm_MLb += prml[i]*expMLbase[k-i-1]; */

        prml[i] = prml[ i] + prm_l[i];

        if (qb[kl] == 0.) continue;

        temp = prm_MLb;

        for (i=1;i<=k-2; i++)
          temp += prml[i]*qm[my_iindx[i+1] - (k-1)];

        for (s=0; s<n_seq; s++) {
          tt=md->pair[S[s][k]][S[s][l]]; if (tt==0) tt=7;
          temp *= exp_E_MLstem(tt, S5[s][k], S3[s][l], pf_params);
        }
        probs[kl] += temp * scale[2] * exp(pscore[jindx[l]+k]/kTn);
      } else { /* (k,l) not allowed to be substem of multiloop closed by (i,j) */
        prml[i] = prm_l[i] = prm_l1[i] = 0.;
      }

#ifdef USE_FLOAT_PF
      if (probs[kl]>Qmax) {
        Qmax = probs[kl];
        if (Qmax>FLT_MAX/10.)
          fprintf(stderr, "%d %d %g %g\n", i,j,probs[kl],qb[kl]);
      }
      if (probs[kl]>FLT_MAX) {
        ov++;
        probs[kl]=FLT_MAX;
      }
#endif
    } /* end for (k=2..) */
    tmp = prm_l1; prm_l1=prm_l; prm_l=tmp;

  }  /* end for (l=..)   */

  for (i=1; i<=n; i++)
    for (j=i+TURN+1; j<=n; j++) {
      ij = my_iindx[i]-j;
      probs[ij] *= qb[ij] *exp(-pscore[jindx[j]+i]/kTn);
    }

  if (structure!=NULL){
    char *s = vrna_db_from_probs(probs, (unsigned int)n);
    memcpy(structure, s, n);
    structure[n] = '\0';
    free(s);
  }

  if (ov>0) fprintf(stderr, "%d overflows occurred while backtracking;\n"
        "you might try a smaller pf_scale than %g\n",
        ov, pf_params->pf_scale);

  free(type);
  free(prm_l);
  free(prm_l1);
  free(prml);
}


/263            0           0     0     644     22528     `
/*
    file_formats_msa.c

    Various functions dealing with file formats for Multiple Sequence Alignments (MSA)

    (c) 2016 Ronny Lorenz

    ViennaRNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <ctype.h>

#include "fold_vars.h"
#include "utils.h"
#include "aln_util.h"
#include "file_formats.h"
#include "file_formats_msa.h"

/*
#################################
# STATIC DECLARATIONS           #
#################################
*/

typedef int (aln_parser_function)(FILE *fp, char ***names, char ***aln, char **id, char **structure, int verbosity);

typedef struct {
  unsigned int        code;
  aln_parser_function *parser;
  const char          *name;
} parsable;

PRIVATE aln_parser_function parse_aln_stockholm;

PRIVATE aln_parser_function parse_aln_clustal;

PRIVATE aln_parser_function parse_aln_fasta;

PRIVATE aln_parser_function parse_aln_maf;

PRIVATE int
parse_fasta_alignment(FILE *fp,
                      char ***names,
                      char ***aln,
                      int verbosity);

PRIVATE int
parse_clustal_alignment(FILE *clust,
                        char ***names,
                        char ***aln,
                        int verbosity);

PRIVATE int
parse_stockholm_alignment(FILE *fp,
                          char ***aln,
                          char ***names,
                          char  **id,
                          char  **structure,
                          int   verbosity);

PRIVATE int
parse_maf_alignment(FILE *fp,
                    char ***aln,
                    char ***names,
                    int   verbosity);

PRIVATE int
check_alignment(const char **names,
                const char **aln,
                int seq_num);

PRIVATE void
free_msa_record(char ***names,
                char ***aln,
                char **id,
                char **structure);

PRIVATE void
add_sequence( const char  *id,
              const char  *seq,
              char        ***names,
              char        ***aln,
              int         seq_num);

PRIVATE void
endmarker_msa_record( char ***names,
                      char ***aln,
                      int   seq_num);

/*
#################################
# STATIC VARIABLES              #
#################################
*/

/* number of known alignment parsers */
#define NUM_PARSERS 4

static parsable known_parsers[NUM_PARSERS] = {
  /* option, parser, name */
  { VRNA_FILE_FORMAT_MSA_STOCKHOLM, parse_aln_stockholm,  "Stockholm 1.0 format" },
  { VRNA_FILE_FORMAT_MSA_CLUSTAL,   parse_aln_clustal,    "ClustalW format" },
  { VRNA_FILE_FORMAT_MSA_FASTA,     parse_aln_fasta,      "FASTA format" },
  { VRNA_FILE_FORMAT_MSA_MAF,       parse_aln_maf,        "MAF format" }
};

/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/
PUBLIC unsigned int
vrna_file_msa_detect_format(const char *filename,
                            unsigned int options){

  FILE          *fp;
  char          **names, **aln;
  unsigned int  format;
  int           i, r;
  long int      fp_position;

  names     = NULL;
  aln       = NULL;
  format    = VRNA_FILE_FORMAT_MSA_UNKNOWN;

  /* if no alignment file format(s) were specified we probe for all of them */
  if(options == 0)
    options = VRNA_FILE_FORMAT_MSA_DEFAULT;

  if(!(fp = fopen(filename, "r"))){
    vrna_message_warning("Alignment file could not be opened!");
    return format;
  }

  r           = -1;
  fp_position = ftell(fp);

  for(i = 0; i < NUM_PARSERS; i++){
    if((options & known_parsers[i].code) && (known_parsers[i].parser)){
      /* go back to beginning of file */
      if(!fseek(fp, fp_position, SEEK_SET)){
        r = known_parsers[i].parser(fp, &names, &aln, NULL, NULL, -1);
        free_msa_record(&names, &aln, NULL, NULL);
        if(r > 0){
          format = known_parsers[i].code;
          break;
        }
      } else {
        fprintf(stderr, "ERROR: Something unexpected happened while parsing the alignment file");
      }
    }
  }

  fclose(fp);

  return format;
}


PUBLIC int
vrna_file_msa_read( const char *filename,
                    char ***names,
                    char ***aln,
                    char  **id,
                    char  **structure,
                    unsigned int options){

  FILE  *fp;
  char  *line = NULL;
  int   i, n, seq_num;
  seq_num   = 0;

  if(!(fp = fopen(filename, "r"))){
    vrna_message_warning("Alignment file could not be opened!");
    return seq_num;
  }

  if(names && aln){
    *names  = NULL;
    *aln    = NULL;
  } else {
    return seq_num;
  }

  if(id)
    *id = NULL;

  if(structure)
    *structure = NULL;

  /* if no alignment file format was specified, lets try to guess it */
  if(options == 0)
    options = VRNA_FILE_FORMAT_MSA_DEFAULT;

  int r = -1;
  long int fp_position = ftell(fp);

  for(i = 0; i < NUM_PARSERS; i++){
    if((options & known_parsers[i].code) && (known_parsers[i].parser)){
      /* go back to beginning of file */
      if(!fseek(fp, fp_position, SEEK_SET)){
        r = known_parsers[i].parser(fp, names, aln, id, structure, 0);
        if(r > 0)
          break;
      } else {
        fprintf(stderr, "ERROR: Something unexpected happened while parsing the alignment file");
      }
    }
  }

  fclose(fp);

  if(r == -1){
    vrna_message_warning("Alignment file parser is unknown (or not specified?)");
  } else {
    seq_num = r;

    if((seq_num > 0) && (!(options & VRNA_FILE_FORMAT_MSA_NOCHECK))){
      if(!check_alignment((const char **)(*names), (const char **)(*aln), seq_num)){
        vrna_message_warning("Alignment did not pass sanity checks!");

        /* discard the data we've read! */
        free_msa_record(names, aln, id, structure);

        seq_num = 0;
      }
    }
  }

  return seq_num;
}


PUBLIC int
vrna_file_msa_read_record(FILE *fp,
                          char ***names,
                          char ***aln,
                          char  **id,
                          char  **structure,
                          unsigned int options){

  const char          *parser_name;
  int                 i, r, rr, n, seq_num;
  aln_parser_function *parser;

  seq_num     = 0;
  parser_name = NULL;
  parser      = NULL;

  if(!fp){
    vrna_message_warning("Can't read alignment from file pointer!");
    return seq_num;
  }

  if(names && aln){
    *names  = NULL;
    *aln    = NULL;
  } else {
    return seq_num;
  }

  if(id)
    *id = NULL;

  if(structure)
    *structure = NULL;

  for(r = i = 0; i < NUM_PARSERS; i++){
    if((options & known_parsers[i].code) && (known_parsers[i].parser)){
      if(!parser){
        parser      = known_parsers[i].parser;
        parser_name = known_parsers[i].name;
      }
      r++;
    }
  }

  if(r == 0){
    vrna_message_warning("Did not find parser for specified MSA format!");
  } else {
    if(r > 1) { 
      vrna_message_warning("More than one MSA format parser specified!");
      char *msg = NULL;
      rr = asprintf(&msg, "Using parser for %s", parser_name);
      if(rr != -1)
        vrna_message_info(stderr, msg);
      free(msg);
    }

    seq_num = parser(fp, names, aln, id, structure, 0);

    if((seq_num > 0) && (!(options & VRNA_FILE_FORMAT_MSA_NOCHECK))){
      if(!check_alignment((const char **)(*names), (const char **)(*aln), seq_num)){
        vrna_message_warning("Alignment did not pass sanity checks!");

        /* discard the data we've read! */
        free_msa_record(names, aln, id, structure);

        seq_num = -1;
      }
    }
  }

  return seq_num;
}


PRIVATE int
parse_stockholm_alignment(FILE  *fp,
                          char  ***names,
                          char  ***aln,
                          char  **id,
                          char  **structure,
                          int   verbosity){

  char  *line = NULL;
  int   i, n, seq_num, seq_length, has_record;

  seq_num     = 0;
  seq_length  = 0;

  if(!fp){
    if(verbosity >= 0)
      vrna_message_warning("Can't read from filepointer while parsing Stockholm formatted sequence alignment!");
    return -1;
  }

  if(names && aln){
    *names  = NULL;
    *aln    = NULL;
  } else {
    return -1;
  }

  if(id)
    *id = NULL;

  if(structure)
    *structure = NULL;

  int inrecord = 0;
  while((line = get_line(fp))){
    if(strstr(line, "STOCKHOLM 1.0")){
      inrecord    = 1;
      has_record  = 1;
      free(line);
      break;
    }
    free(line);
  }

  if(inrecord){
    while((line=get_line(fp))){

      if(strncmp(line, "//", 2) == 0){
        /* end of alignment */
        free(line);
        line = NULL;
        break;
      }

      n = (int)strlen(line);

      switch(*line){
        /* we skip lines that start with whitespace */
        case ' ': case '\0':
          goto stockholm_next_line;

        /* Stockholm markup, or comment */
        case '#':
          if(strstr(line, "STOCKHOLM 1.0")){
            if(verbosity >= 0)
              vrna_message_warning("Malformatted Stockholm record, missing // ?");

            /* drop everything we've read so far and start new, blank record */
            free_msa_record(names, aln, id, structure);

            seq_num = 0;
          } else if(strncmp(line, "#=GF", 4) == 0){
            /* found feature markup */
            if((id != NULL) && (strncmp(line, "#=GF ID", 7) == 0)){
              *id = (char *)vrna_alloc(sizeof(char) * n);
              if(sscanf(line, "#=GF ID %s", *id) == 1){
                *id = (char *)vrna_realloc(*id, sizeof(char) * (strlen(*id) + 1));
              } else {
                free(*id);
                *id = NULL;
              }
            }
          } else if(strncmp(line, "#=GC", 4) == 0){
            /* found per-column annotation */
            if((structure != NULL) && (strncmp(line, "#=GC SS_cons", 12) == 0)){
              char *ss = (char *)vrna_alloc(sizeof(char) * n);
              if(sscanf(line, "#=GC SS_cons %s", ss) == 1){
                *structure = (char *)vrna_realloc(*structure, sizeof(char) * (strlen(ss) + 1));
                strcpy(*structure, ss);
              }
              free(ss);
            }
          } else if(strncmp(line, "#=GS", 4) == 0){
            /* found generic per-sequence annotation */
          } else if(strncmp(line, "#=GR", 4) == 0){
            /* found generic per-Residue annotation */
          } else {
            /* may be comment? */
          }
          break;

        /* should be sequence */
        default:
          {
            int tmp_l;
            char *tmp_name  = (char *)vrna_alloc(sizeof(char) * (n + 1));
            char *tmp_seq   = (char *)vrna_alloc(sizeof(char) * (n + 1));
            if(sscanf(line, "%s %s", tmp_name, tmp_seq) == 2){
              seq_num++;
              tmp_l = (int)strlen(tmp_seq);

              if(seq_num == 1){
                seq_length = tmp_l;
              } else {  /* check sequence length against first */
                if(seq_length != tmp_l){
                  if(verbosity >= 0)
                    vrna_message_warning("Discarding Stockholm record! Sequence lengths do not match.");

                  /* drop everything we've read so far and abort parsing */
                  free_msa_record(names, aln, id, structure);

                  seq_num = 0;

                  free(tmp_name);
                  free(tmp_seq);
                  free(line);
                  line = NULL;

                  goto stockholm_exit;
                }
              }

              add_sequence( tmp_name, tmp_seq,
                            names, aln,
                            seq_num);
            }
            free(tmp_name);
            free(tmp_seq);
          }
          break;
      }

stockholm_next_line:

      free(line);
    }
  } else {
    if(verbosity > 0)
      vrna_message_warning("Did not find any Stockholm 1.0 formatted record!");
    return -1;
  }

stockholm_exit:

  free(line);

  endmarker_msa_record(names, aln, seq_num);

  if((seq_num > 0) && (verbosity >= 0)){
    int r;
    char *msg = NULL;
    r = asprintf(&msg, "%d sequences; length of alignment %d.", seq_num, (int)strlen((*aln)[0]));
    if(r != -1)
      vrna_message_info(stderr, msg);
    free(msg);
  }

  return seq_num;
}


PRIVATE int
parse_fasta_alignment(FILE *fp,
                      char ***names,
                      char ***aln,
                      int verbosity){

  unsigned int  read_opt, rec_type;
  int           seq_num;
  char          *rec_id, *rec_sequence, **rec_rest;

  rec_id        = NULL;
  rec_sequence  = NULL;
  rec_rest      = NULL;
  seq_num       = 0;
  read_opt      = VRNA_INPUT_NO_REST; /* read sequence and header information only */

  /* read until EOF or user abort */
  while(
    !((rec_type = vrna_file_fasta_read_record(&rec_id, &rec_sequence, &rec_rest, fp, read_opt))
        & (VRNA_INPUT_ERROR | VRNA_INPUT_QUIT))){

    if(rec_id){ /* valid FASTA entry */
      seq_num++;

      char *id = (char *)vrna_alloc(sizeof(char) * strlen(rec_id));
      (void) sscanf(rec_id, ">%s", id);
      vrna_seq_toupper(rec_sequence);

      add_sequence( id, rec_sequence,
                    names, aln,
                    seq_num);

      free(id);
    }

    free(rec_id);
    free(rec_sequence);
    free(rec_rest);
  }

  free(rec_id);
  free(rec_sequence);
  free(rec_rest);

  endmarker_msa_record(names, aln, seq_num);

  if((seq_num > 0) && (verbosity >= 0)){
    int r;
    char *msg = NULL;
    r = asprintf(&msg, "%d sequences; length of alignment %d.", seq_num, (int)strlen((*aln)[0]));
    if(r != -1)
      vrna_message_info(stderr, msg);
    free(msg);
  } else {
    if(verbosity > 0)
      vrna_message_warning("Did not find any FASTA formatted record!");
    return -1;
  }

  return seq_num;
}


PRIVATE int
parse_clustal_alignment(FILE *clust,
                        char ***names,
                        char ***aln,
                        int verbosity){

  char *line, *name, *seq;
  int  n, r, nn=0, seq_num = 0, i;

  if((line=get_line(clust)) == NULL){
    return -1;
  }

  if(strncmp(line,"CLUSTAL", 7) != 0){
    if(verbosity > 0)
      vrna_message_warning("This doesn't look like a CLUSTALW file, sorry");

    free(line);
    return -1;
  }

  free(line);
  line = get_line(clust);

  while (line!=NULL) {
    n = strlen(line);

    if((n < 4) || isspace((int)line[0])) {
      /* skip non-sequence line */
      free(line);
      line  = get_line(clust);
      nn    = 0;  /* reset sequence number */
      continue;
    }

    /* skip comments */
    if(line[0] == '#'){
      free(line);
      line = get_line(clust);
      continue;
    }

    seq   = (char *)vrna_alloc(sizeof(char) * (n + 1));
    name  = (char *)vrna_alloc(sizeof(char) * (n + 1));
    if(sscanf(line, "%s %s", name, seq) == 2){
      /* realloc to actual sizes */
      seq   = (char *)vrna_realloc(seq, sizeof(char) * (strlen(seq) + 1));
      name  = (char *)vrna_realloc(name, sizeof(char) * (strlen(name) + 1));
      for(i = 0; i < strlen(seq); i++){
        if(seq[i] == '.')
          seq[i] = '-'; /* replace '.' gaps with '-' */
      }

      /* convert sequence to uppercase letters */
      vrna_seq_toupper(seq);

      if(nn == seq_num){ /* first time */
            add_sequence( name, seq,
                          names, aln,
                          nn + 1);
      } else {
        if (strcmp(name, (*names)[nn]) != 0) {
          /* name doesn't match */
           vrna_message_warning("Sorry, your file is messed up (inconsitent seq-names)");
           free(line); free(seq);
           return 0;
        }
        (*aln)[nn] = (char *)vrna_realloc((*aln)[nn], strlen(seq) + strlen((*aln)[nn])+1);
        strcat((*aln)[nn], seq);
      }
      nn++;
      if(nn > seq_num)
        seq_num = nn;

      free(seq);
      free(name);
    }
    free(line);

    line = get_line(clust);
  }

  endmarker_msa_record(names, aln, seq_num);

  if((seq_num > 0) && (verbosity >= 0)){
    int r;
    char *msg = NULL;
    r = asprintf(&msg, "%d sequences; length of alignment %d.", seq_num, (int)strlen((*aln)[0]));
    if(r != -1)
      vrna_message_info(stderr, msg);
    free(msg);
  }

  return seq_num;
}


PRIVATE int
parse_maf_alignment(FILE  *fp,
                    char  ***names,
                    char  ***aln,
                    int   verbosity){

  char  *line = NULL, *tmp_name, *tmp_sequence, strand;
  int   i, n, seq_num, seq_length, start, length, src_length;

  seq_num     = 0;
  seq_length  = 0;

  if(!fp){
    if(verbosity >= 0)
      vrna_message_warning("Can't read from filepointer while parsing MAF formatted sequence alignment!");
    return -1;
  }

  if(names && aln){
    *names  = NULL;
    *aln    = NULL;
  } else {
    return -1;
  }

  int inrecord = 0;
  while((line = get_line(fp))){
    if(*line == 'a'){
      if((line[1] == '\0') || isspace(line[1])){
        inrecord = 1;
        free(line);
        break;
      }
    }
    free(line);
  }

  if(inrecord){
    while((line=get_line(fp))){
      n = (int)strlen(line);

      switch(*line){
        case '#': /* comment */
          break;

        case 's': /* a sequence within the alignment block */
          tmp_name      = (char *)vrna_alloc(sizeof(char) * n);
          tmp_sequence  = (char *)vrna_alloc(sizeof(char) * n);
          if(sscanf(line, "s %s %d %d %c %d %s",
                tmp_name,
                &start,
                &length,
                &strand,
                &src_length,
                tmp_sequence) == 6){

            seq_num++;
            tmp_name      = (char *)vrna_realloc(tmp_name, sizeof(char) * (strlen(tmp_name) + 1));
            tmp_sequence  = (char *)vrna_realloc(tmp_sequence, sizeof(char) * (strlen(tmp_sequence) + 1));

            vrna_seq_toupper(tmp_sequence);

            add_sequence( tmp_name, tmp_sequence,
                          names, aln,
                          seq_num);

            free(tmp_name);
            free(tmp_sequence);
            break;
          }
          free(tmp_name);
          free(tmp_sequence);
          /* all through */

        default: /* something else that ends the block */
          free(line);
          goto maf_exit;
      }

      free(line);
    }
  } else {
    if(verbosity > 0)
      vrna_message_warning("Did not find any MAF formatted record!");
    return -1;
  }

maf_exit:

  endmarker_msa_record(names, aln, seq_num);

  if((seq_num > 0) && (verbosity >= 0)){
    int r;
    char *msg = NULL;
    r = asprintf(&msg, "%d sequences; length of alignment %d.", seq_num, (int)strlen((*aln)[0]));
    if(r != -1)
      vrna_message_info(stderr, msg);
    free(msg);
  }

  return seq_num;
}


PRIVATE void
free_msa_record(char ***names,
                char ***aln,
                char **id,
                char **structure){

  int s, i;

  s = 0;
  if(aln && (*aln))
    for(; (*aln)[s]; s++);

  if(id != NULL){
    free(*id);
    *id = NULL;
  }

  if(structure != NULL){
    free(*structure);
    *structure = NULL;
  }

  for(i = 0; i < s; i++){
    free((*names)[i]);
    free((*aln)[i]);
  }

  if(names && (*names)){
    free(*names);
    *names = NULL;
  }

  if(aln && (*aln)){
    free(*aln);
    *aln = NULL;
  }
}


PRIVATE int
parse_aln_stockholm(FILE *fp,
                    char ***names,
                    char ***aln,
                    char **id,
                    char **structure,
                    int  verbosity){

  return parse_stockholm_alignment(fp, names, aln, id, structure, verbosity);
}


PRIVATE int
parse_aln_clustal(FILE *fp,
                  char ***names,
                  char ***aln,
                  char **id,
                  char **structure,
                  int  verbosity){

  /* clustal format doesn't contain id's or structure information */
  if(id)
    *id = NULL;
  if(structure)
    *structure = NULL;

  return parse_clustal_alignment(fp, names, aln, verbosity);
}


PRIVATE int
parse_aln_fasta(FILE *fp,
                char ***names,
                char ***aln,
                char **id,
                char **structure,
                int  verbosity){

  /* fasta alignments do not contain an id, or structure information */
  if(id)
    *id = NULL;
  if(structure)
    *structure = NULL;

  return parse_fasta_alignment(fp, names, aln, verbosity);
}


PRIVATE int
parse_aln_maf(FILE *fp,
              char ***names,
              char ***aln,
              char **id,
              char **structure,
              int  verbosity){

  /* MAF alignments do not contain an id, or structure information */
  if(id)
    *id = NULL;
  if(structure)
    *structure = NULL;

  return parse_maf_alignment(fp, names, aln, verbosity);
}


PRIVATE void
add_sequence( const char  *id,
              const char  *seq,
              char        ***names,
              char        ***aln,
              int         seq_num){

  (*names)              = (char **)vrna_realloc(*names, sizeof(char *) * (seq_num));
  (*names)[seq_num - 1] = strdup(id);
  (*aln)                = (char **)vrna_realloc(*aln, sizeof(char *) * (seq_num));
  (*aln)[seq_num - 1]   = strdup(seq);
}


PRIVATE void
append_sequence(char *seq,
                char  **aln,
                int   seq_num){


}


PRIVATE void
endmarker_msa_record( char ***names,
                      char ***aln,
                      int   seq_num){

  /*
    append additional entry in 'aln' and 'names' pointing to NULL (this may be
    used as an indication for the end of the sequence list)
  */
  if(seq_num > 0){
    (*aln)            = (char **)vrna_realloc(*aln, sizeof(char *) * (seq_num + 1));
    (*names)          = (char **)vrna_realloc(*names, sizeof(char *) * (seq_num + 1));
    (*aln)[seq_num]   = NULL;
    (*names)[seq_num] = NULL;
  }
}


PRIVATE int
check_alignment(const char **names,
                const char **aln,
                int seq_num){

  int i, j, l, pass = 1;

  /* check for unique names */
  for(i = 0; i < seq_num; i++){
    for(j = i + 1; j < seq_num; j++){
      if(!strcmp(names[i], names[j])){
        vrna_message_warning("Sequence IDs in input alignment are not unique!");
        pass = 0;
      }
    }
  }

  /* check for equal lengths of sequences */
  l = (int)strlen(aln[0]);
  for(i = 1; i < seq_num; i++)
    if((int)strlen(aln[i]) != l){
      vrna_message_warning("Sequence lengths in input alignment do not match!");
      pass = 0;
    }

  return pass;
}
/283            0           0     0     644     40195     `
/*
        PostScript and other output formats for RNA secondary structure plots

                 c  Ivo Hofacker, Peter F Stadler, Ronny Lorenz
                          Vienna RNA package
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

//#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <ctype.h>
#include "model.h"
#include "utils.h"
#include "fold_vars.h"
#include "aln_util.h"
#include "gquad.h"
#include "plot_layouts.h"
#include "plot_structure.h"

/*
#################################
# PRIVATE MACROS                #
#################################
*/

#ifndef PI
#define  PI       3.141592654
#endif
#define  PIHALF       PI/2.
#define SIZE 452.

/*
#################################
# GLOBAL VARIABLES              #
#################################
*/

/*
#################################
# PRIVATE VARIABLES             #
#################################
*/
static const char *RNAss_head =
"%%BeginProlog\n"
"/RNAplot 100 dict def\n"
"RNAplot begin\n"
"/fsize  14 def\n"
"/outlinecolor {0.2 setgray} bind def\n"
"/paircolor    {0.2 setgray} bind def\n"
"/seqcolor     {0   setgray} bind def\n"
"/cshow  { dup stringwidth pop -2 div fsize -3 div rmoveto show} bind def\n"
"/min { 2 copy gt { exch } if pop } bind def\n"
"/max { 2 copy lt { exch } if pop } bind def\n"
"/arccoords { % i j arccoords\n"
"  % puts optimal x1 y1 x2 y2 coordinates used in bezier curves from i to j\n"
"  % onto the stack\n"
"  dup 3 -1 roll dup 4 -1 roll lt dup dup 5 2 roll {exch} if\n"
"  dup 3 -1 roll dup 3 -1 roll exch sub 1 sub dup\n"
"  4 -2 roll 5 -1 roll {exch} if 4 2 roll\n"
"  sequence length dup 2 div exch 3 1 roll lt \n"
"  {exch 5 -1 roll pop 4 -2 roll exch 4 2 roll}\n"
"  { 4 2 roll 5 -1 roll dup 6 1 roll {exch} if\n"
"    4 -2 roll exch pop dup 3 -1 roll dup 4 1 roll\n"
"    exch add 4 -1 roll dup 5 1 roll sub 1 sub\n"
"    5 -1 roll not {4 -2 roll exch 4 2 roll} if\n"
"  }ifelse\n"
"   % compute the scalingfactor and prepare (1-sf) and sf*r\n"
"  2 mul exch cpr 3 1 roll div dup\n"
"  3 -1 roll mul exch 1 exch sub exch\n"
"   % compute the coordinates\n"
"  3 -1 roll 1 sub coor exch get aload pop % get coord for i\n"
"  4 -1 roll dup 5 1 roll mul 3 -1 roll dup 4 1 roll add exch % calculate y1\n"
"  4 -1 roll dup 5 1 roll mul 3 -1 roll dup 4 1 roll add exch % calculate x1\n"
"  5 -1 roll 1 sub coor exch get aload pop % get coord for j\n"
"  % duplicate j coord\n"
"  dup 3 -1 roll dup 4 1 roll exch 8 2 roll\n"
"  6 -1 roll dup 7 1 roll mul 5 -1 roll dup 6 1 roll add exch % calculate y2\n"
"  6 -1 roll mul 5 -1 roll add exch % calculate x2\n"
"  6 -2 roll % reorder\n"
"} bind def\n"
"/drawoutline {\n"
"  gsave outlinecolor newpath\n"
"  coor 0 get aload pop 0.8 0 360 arc % draw 5' circle of 1st sequence\n"
"  currentdict /cutpoint known        % check if cutpoint is defined\n"
"  {coor 0 cutpoint getinterval\n"
"   {aload pop lineto} forall         % draw outline of 1st sequence\n"
"   coor cutpoint 1 add get aload pop\n"
"   2 copy moveto 0.8 0 360 arc       % draw 5' circle of 2nd sequence\n"
"   coor cutpoint 1 add coor length cutpoint 1 add sub getinterval\n"
"   {aload pop lineto} forall}        % draw outline of 2nd sequence\n"
"  {coor {aload pop lineto} forall}   % draw outline as a whole\n"
"  ifelse\n"
"  stroke grestore\n"
"} bind def\n"
"/drawpairs {\n"
"  paircolor\n"
"  0.7 setlinewidth\n"
"  [9 3.01] 9 setdash\n"
"  newpath\n"
"  pairs {aload pop\n"
"      currentdict (cpr) known\n"
"      { exch dup\n"
"        coor  exch 1 sub get aload pop moveto\n"
"        exch arccoords curveto\n"
"      }\n"
"      { coor exch 1 sub get aload pop moveto\n"
"        coor exch 1 sub get aload pop lineto\n"
"      }ifelse\n"
"  } forall\n"
"  stroke\n"
"} bind def\n"
"% draw bases\n"
"/drawbases {\n"
"  [] 0 setdash\n"
"  seqcolor\n"
"  0\n"
"  coor {\n"
"    aload pop moveto\n"
"    dup sequence exch 1 getinterval cshow\n"
"    1 add\n"
"  } forall\n"
"  pop\n"
"} bind def\n\n"
"/init {\n"
"  /Helvetica findfont fsize scalefont setfont\n"
"  1 setlinejoin\n"
"  1 setlinecap\n"
"  0.8 setlinewidth\n"
"  72 216 translate\n"
"  % find the coordinate range\n"
"  /xmax -1000 def /xmin 10000 def\n"
"  /ymax -1000 def /ymin 10000 def\n"
"  coor {\n"
"      aload pop\n"
"      dup ymin lt {dup /ymin exch def} if\n"
"      dup ymax gt {/ymax exch def} {pop} ifelse\n"
"      dup xmin lt {dup /xmin exch def} if\n"
"      dup xmax gt {/xmax exch def} {pop} ifelse\n"
"  } forall\n"
"  /size {xmax xmin sub ymax ymin sub max} bind def\n"
"  72 6 mul size div dup scale\n"
"  size xmin sub xmax sub 2 div size ymin sub ymax sub 2 div\n"
"  translate\n"
"} bind def\n"
"end\n";

static const char *anote_macros =
"RNAplot begin\n"
"% extra definitions for standard anotations\n"
"/min { 2 copy gt { exch } if pop } bind def\n"
"/BLACK { 0 0 0 } def\n"
"/RED   { 1 0 0 } def\n"
"/GREEN { 0 1 0 } def\n"
"/BLUE  { 0 0 1 } def\n"
"/WHITE { 1 1 1 } def\n"
"/LabelFont { % font size LabelFont\n"
"  exch findfont exch fsize mul scalefont setfont\n"
"} bind def\n"
"/Label { % i dx dy (text) Label\n"
"  % write text at base i plus offset dx, dy\n"
"  4 3 roll 1 sub coor exch get aload pop moveto\n"
"  3 1 roll fsize mul exch fsize mul exch rmoveto\n"
"  show\n"
"} bind def\n"
"/cmark { % i cmark   draw circle around base i\n"
"  newpath 1 sub coor exch get aload pop\n"
"  fsize 2 div 0 360 arc stroke\n"
"} bind def\n"
"/gmark { % i j c gmark\n"
"  % draw basepair i,j with c counter examples in gray\n"
"  gsave\n"
"  3 min [0 0.33 0.66 0.9] exch get setgray\n"
"  1 sub dup coor exch get aload pop moveto\n"
"  sequence exch 1 getinterval cshow\n"
"  1 sub dup coor exch get aload pop moveto\n"
"  sequence exch 1 getinterval cshow\n"
"  grestore\n"
"} bind def\n"
"/segmark { % f i j lw r g b segmark\n"
"  % mark segment [i,j] with outline width lw and color rgb\n"
"  % use omark and Fomark instead\n"
"  gsave\n"
"  setrgbcolor setlinewidth\n"
"  newpath\n"
"  1 sub exch 1 sub dup\n"
"  coor exch get aload pop moveto\n"
"  currentdict (cpr) known\n"
"  {\n"
"    3 -1 roll dup 4 1 roll dup\n"
"    {\n"
"      3 1 roll dup 3 -1 roll dup\n"
"      4 1 roll exch 5 2 roll exch\n"
"    }\n"
"    {\n"
"      3 1 roll exch\n"
"    } ifelse\n"
"    1 exch { coor exch get aload pop lineto } for\n"
"    {\n"
"      dup 3 1 roll 1 add exch 1 add arccoords pop pop\n"
"      4 2 roll 5 -1 roll coor exch get aload pop curveto\n"
"    } if\n"
"  }\n"
"  {\n"
"    exch 1 exch {\n"
"      coor exch get aload pop lineto\n"
"    } for\n"
"  } ifelse\n"
"  { closepath fill } if  stroke\n"
"  grestore\n"
"} bind def\n"
"/omark { % i j lw r g b omark\n"
"  % stroke segment [i..j] with linewidth lw, color rgb\n"
"  false 7 1 roll segmark\n"
"} bind def\n"
"/Fomark { % i j r g b Fomark\n"
"  % fill segment [i..j] with color rgb\n"
"  % should precede drawbases\n"
"  1 4 1 roll true 7 1 roll segmark\n"
"} bind def\n"
"/BFmark{ % i j k l r g b BFmark\n"
"  % fill block between pairs (i,j) and (k,l) with color rgb\n"
"  % should precede drawbases\n"
"  gsave\n"
"  setrgbcolor\n"
"  newpath\n"
"  currentdict (cpr) known\n"
"  {\n"
"    dup 1 sub coor exch get aload pop moveto % move to l\n"
"    dup 1 sub 4 -1 roll dup 5 1 roll 1 sub 1 exch\n"
"    { coor exch get aload pop lineto } for % lines from l to j\n"
"    3 -1 roll 4 -1 roll dup 5 1 roll arccoords curveto % curve from j to i\n"
"    exch dup 4 -1 roll 1 sub exch 1 sub 1 exch\n"
"    { coor exch get aload pop lineto } for % lines from i to k\n"
"    exch arccoords curveto% curve from k to l\n"
"  }\n"
"  {  exch 4 3 roll exch 1 sub exch 1 sub dup\n"
"     coor exch get aload pop moveto\n"
"     exch 1 exch { coor exch get aload pop lineto } for\n"
"     exch 1 sub exch 1 sub dup\n"
"     coor exch get aload pop lineto\n"
"     exch 1 exch { coor exch get aload pop lineto } for\n"
"  } ifelse\n"
"    closepath fill stroke\n"
"   grestore\n"
"} bind def\n"
"/hsb {\n"
"  dup 0.3 mul 1 exch sub sethsbcolor\n"
"} bind def\n"
"/colorpair { % i j hue sat colorpair\n"
"  % draw basepair i,j in color\n"
"  % 1 index 0.00 ne {\n"
"  gsave\n"
"  newpath\n"
"  hsb\n"
"  fsize setlinewidth\n"
"  currentdict (cpr) known\n"
"  {\n"
"    exch dup\n"
"    coor  exch 1 sub get aload pop moveto\n"
"    exch arccoords curveto\n"
"  }\n"
"  { 1 sub coor exch get aload pop moveto\n"
"    1 sub coor exch get aload pop lineto\n"
"  } ifelse\n"
"   stroke\n"
"   grestore\n"
"   % } if\n"
"} bind def\n"
 "end\n\n";

/*
#################################
# PRIVATE FUNCTION DECLARATIONS #
#################################
*/

PRIVATE char **annote(const char *structure, const char *AS[]);


/*
#################################
# BEGIN OF FUNCTION DEFINITIONS #
#################################
*/

PUBLIC int
vrna_file_PS_rnaplot( const char *string,
                      const char *structure,
                      const char *ssfile,
                      vrna_md_t  *md_p){

  return vrna_file_PS_rnaplot_a(string, structure, ssfile, NULL, NULL, md_p);
}

PUBLIC int
vrna_file_PS_rnaplot_a( const char *seq,
                        const char *structure,
                        const char *ssfile,
                        const char *pre,
                        const char *post,
                        vrna_md_t  *md_p){

  float  xmin, xmax, ymin, ymax;
  int    i, length;
  int    ee, gb, ge, Lg, l[3];
  float *X, *Y;
  FILE  *xyplot;
  short *pair_table, *pair_table_g;
  char  *c, *string;
  vrna_md_t   md;

  if(!md_p){
    set_model_details(&md);
    md_p  = &md;
  }
    
  string = strdup(seq);
  length = strlen(string);

  xyplot = fopen(ssfile, "w");
  if (xyplot == NULL) {
    fprintf(stderr, "can't open file %s - not doing xy_plot\n", ssfile);
    return 0;
  }

  pair_table = vrna_ptable(structure);
  pair_table_g = vrna_ptable(structure);

  ge=0;
  while ( (ee=parse_gquad(structure+ge, &Lg, l)) >0 ) {
    ge += ee;
    gb=ge-Lg*4-l[0]-l[1]-l[2]+1;
    /* add pseudo-base pair encloding gquad */
    for (i=0; i<Lg; i++) {
      pair_table_g[ge-i]=gb+i;
      pair_table_g[gb+i]=ge-i;
    }
  } 
      
  X = (float *) vrna_alloc((length+1)*sizeof(float));
  Y = (float *) vrna_alloc((length+1)*sizeof(float));
  switch(rna_plot_type){
    case VRNA_PLOT_TYPE_SIMPLE:   i = simple_xy_coordinates(pair_table_g, X, Y);
                                  break;
    case VRNA_PLOT_TYPE_CIRCULAR: {
                                    int radius = 3*length;
                                    i = simple_circplot_coordinates(pair_table_g, X, Y);
                                    for (i = 0; i < length; i++) {
                                      X[i] *= radius;
                                      X[i] += radius;
                                      Y[i] *= radius;
                                      Y[i] += radius;
                                    }
                                  }
                                  break;
    default:                      i = naview_xy_coordinates(pair_table_g, X, Y);
                                  break;
  }
  if(i!=length) fprintf(stderr,"strange things happening in PS_rna_plot...\n");

  xmin = xmax = X[0];
  ymin = ymax = Y[0];
  for (i = 1; i < length; i++) {
     xmin = X[i] < xmin ? X[i] : xmin;
     xmax = X[i] > xmax ? X[i] : xmax;
     ymin = Y[i] < ymin ? Y[i] : ymin;
     ymax = Y[i] > ymax ? Y[i] : ymax;
  }

  fprintf(xyplot,
          "%%!PS-Adobe-3.0 EPSF-3.0\n"
          "%%%%Creator: ViennaRNA-%s\n"
          "%%%%CreationDate: %s"
          "%%%%Title: RNA Secondary Structure Plot\n"
          "%%%%BoundingBox: 66 210 518 662\n"
          "%%%%DocumentFonts: Helvetica\n"
          "%%%%Pages: 1\n"
          "%%%%EndComments\n\n"
          "%%Options: %s\n", "2.2.10", vrna_time_stamp(), vrna_md_option_string(md_p));
  fprintf(xyplot, "%% to switch off outline pairs of sequence comment or\n"
          "%% delete the appropriate line near the end of the file\n\n");
  fprintf(xyplot, "%s", RNAss_head);

  if (pre || post) {
    fprintf(xyplot, "%s", anote_macros);
  }
  fprintf(xyplot, "%%%%EndProlog\n");

  fprintf(xyplot, "RNAplot begin\n"
          "%% data start here\n");

  /* cut_point */
  if ((c = strchr(structure, '&'))) {
    int cutpoint;
    cutpoint = c - structure;
    string[cutpoint] = ' '; /* replace & with space */
    fprintf(xyplot, "/cutpoint %d def\n", cutpoint);
  }

  /* sequence */
  fprintf(xyplot,"/sequence (\\\n");
  i=0;
  while (i<length) {
    fprintf(xyplot, "%.255s\\\n", string+i);  /* no lines longer than 255 */
    i+=255;
  }
  fprintf(xyplot,") def\n");
  /* coordinates */
  fprintf(xyplot, "/coor [\n");
  for (i = 0; i < length; i++)
    fprintf(xyplot, "[%3.8f %3.8f]\n", X[i], Y[i]);
  fprintf(xyplot, "] def\n");
  /* correction coordinates for quadratic beziers in case we produce a circplot */
  if(rna_plot_type == VRNA_PLOT_TYPE_CIRCULAR)
    fprintf(xyplot, "/cpr %6.2f def\n", (float)3*length);
  /* base pairs */
  fprintf(xyplot, "/pairs [\n");
  for (i = 1; i <= length; i++)
    if (pair_table[i]>i)
      fprintf(xyplot, "[%d %d]\n", i, pair_table[i]);
  /* add gquad pairs */
  ge=0;
  while ( (ee=parse_gquad(structure+ge, &Lg, l)) >0 ) {
    int k;
    fprintf(xyplot, "%% gquad\n");
    ge += ee;
    gb=ge-Lg*4-l[0]-l[1]-l[2]+1; /* add pseudo-base pair encloding gquad */
    for (k=0; k<Lg; k++) {
      int ii, jj, il;
      for (il=0, ii=gb+k; il<3; il++) {
        jj = ii+l[il]+Lg;
        fprintf(xyplot, "[%d %d]\n", ii, jj);
        ii = jj;
      }
      jj = gb+k;
      fprintf(xyplot, "[%d %d]\n", jj, ii);
    }
  }

  fprintf(xyplot, "] def\n\n");

  fprintf(xyplot, "init\n\n");
  /* draw the data */
  if (pre) {
    fprintf(xyplot, "%% Start Annotations\n");
    fprintf(xyplot, "%s\n", pre);
    fprintf(xyplot, "%% End Annotations\n");
  }
  fprintf(xyplot,
          "%% switch off outline pairs or bases by removing these lines\n"
          "drawoutline\n"
          "drawpairs\n"
          "drawbases\n");

  if (post) {
    fprintf(xyplot, "%% Start Annotations\n");
    fprintf(xyplot, "%s\n", post);
    fprintf(xyplot, "%% End Annotations\n");
  }
  fprintf(xyplot, "%% show it\nshowpage\n");
  fprintf(xyplot, "end\n");
  fprintf(xyplot, "%%%%EOF\n");

  fclose(xyplot);

  free(string);
  free(pair_table);
  free(pair_table_g);
  free(X); free(Y);
  return 1; /* success */
}

/* options for gml output:
   uppercase letters: print sequence labels
   lowercase letters: no sequence lables
   graphics information:
   x X  simple xy plot
   (nothing else implemented at present)
   default:           no graphics data at all
*/

PUBLIC int gmlRNA(char *string, char *structure, char *ssfile, char option)
{
  FILE *gmlfile;
  int i;
  int length;
  short *pair_table;
  float *X, *Y;

  gmlfile = fopen(ssfile, "w");
  if (gmlfile == NULL) {
     fprintf(stderr, "can't open file %s - not doing xy_plot\n", ssfile);
     return 0;
  }

  length = strlen(string);

  pair_table = vrna_ptable(structure);

  switch(option){
  case 'X' :
  case 'x' :
    /* Simple XY Plot */
    X = (float *) vrna_alloc((length+1)*sizeof(float));
    Y = (float *) vrna_alloc((length+1)*sizeof(float));
    if (rna_plot_type == 0)
      i = simple_xy_coordinates(pair_table, X, Y);
    else
      i = naview_xy_coordinates(pair_table, X, Y);

    if(i!=length) fprintf(stderr,"strange things happening in gmlRNA ...\n");
    break;
  default:
    /* No Graphics Information */
    X = NULL;
    Y = NULL;
  }

  fprintf(gmlfile,
          "# Vienna RNA Package %s\n"
          "# GML Output\n"
          "# CreationDate: %s\n"
          "# Name: %s\n"
          "# Options: %s\n", "2.2.10", vrna_time_stamp(), ssfile, option_string());
  fprintf(gmlfile,
          "graph [\n"
          " directed 0\n");
  for (i=1; i<=length; i++){
     fprintf(gmlfile,
          " node [ id %d ", i);
     if (option) fprintf(gmlfile,
          "label \"%c\"",string[i-1]);
     if ((option == 'X')||(option=='x'))
       fprintf(gmlfile,
               "\n  graphics [ x %9.4f y %9.4f ]\n", X[i-1], Y[i-1]);
     fprintf(gmlfile," ]\n");
  }
  for (i=1; i<length; i++)
    fprintf(gmlfile,
            "edge [ source %d target %d ]\n", i, i+1);
  for (i=1; i<=length; i++) {
     if (pair_table[i]>i)
        fprintf(gmlfile,
                "edge [ source %d target %d ]\n", i, pair_table[i]);
  }
  fprintf(gmlfile, "]\n");
  fclose(gmlfile);

  free(pair_table);
  free(X); free(Y);
  return 1; /* success */
}



int PS_rna_plot_snoop_a(char *string, char *structure, char *ssfile, int *relative_access, const char *seqs[])
{
  int    i, length;
  float *X, *Y;
  FILE  *xyplot;
  short *pair_table;
  short *pair_table_snoop;

  length = strlen(string);

  xyplot = fopen(ssfile, "w");
  if (xyplot == NULL) {
    fprintf(stderr, "can't open file %s - not doing xy_plot\n", ssfile);
    return 0;
  }

  pair_table = vrna_ptable(structure);
  pair_table_snoop = vrna_pt_snoop_get(structure);

  X = (float *) vrna_alloc((length+1)*sizeof(float));
  Y = (float *) vrna_alloc((length+1)*sizeof(float));
  if (rna_plot_type == 0)
    i = simple_xy_coordinates(pair_table, X, Y);
  else
    i = naview_xy_coordinates(pair_table, X, Y);
  if(i!=length) fprintf(stderr,"strange things happening in PS_rna_plot...\n");
/*   printf("cut_point %d\n", cut_point); */

/*   for (i = 1; i < length; i++) { */
/*     printf("%d X %f Y %f \n", i, X[i], Y[i]); */
/*     xmin = X[i] < xmin ? X[i] : xmin; */
/*     xmax = X[i] > xmax ? X[i] : xmax; */
/*     ymin = Y[i] < ymin ? Y[i] : ymin; */
/*     ymax = Y[i] > ymax ? Y[i] : ymax; */
/*   } */
  /* localize centre of the interaction bucket. Geometry */
  
  for (i = 1; i < cut_point; i++) {  /* interior loop of size 0 */
    if(pair_table_snoop[i] != 0){ 
      X[i-1]=X[pair_table_snoop[i]-1]; 
      Y[i-1]=Y[pair_table_snoop[i]-1]; 
    }
    else if(pair_table_snoop[i-1] && pair_table_snoop[i+1]){ /* interior loop of size 1 */
      X[i-1]=X[pair_table_snoop[i-1] -1-1];
      Y[i-1]=Y[pair_table_snoop[i-1] -1-1];
    } 
    else if(pair_table_snoop[i-1] && pair_table_snoop[i+2]){ /* interior loop of size 2 */
      if(pair_table_snoop[i-1] - pair_table_snoop[i+2] ==2){
        X[i-1]=X[pair_table_snoop[i-1]-2];
        Y[i-1]=Y[pair_table_snoop[i-1]-2];
        X[i]=X[pair_table_snoop[i+2]];
        Y[i]=Y[pair_table_snoop[i+2]];
        i++;
      }
      else if(pair_table[pair_table_snoop[i-1]-1]){
        X[i-1]=X[pair_table_snoop[i-1]-2];
        Y[i-1]=Y[pair_table_snoop[i-1]-2];
        X[i]=X[pair_table[pair_table_snoop[i-1]-1]-1];
        Y[i]=Y[pair_table[pair_table_snoop[i-1]-1]-1];
        i++;
      }
      else if(pair_table[pair_table_snoop[i-1]-2]){
        X[i-1]=X[pair_table_snoop[i-1]-3];
        Y[i-1]=Y[pair_table_snoop[i-1]-3];
        X[i]=X[pair_table[pair_table_snoop[i-1]-2]-1];
        Y[i]=Y[pair_table[pair_table_snoop[i-1]-2]-1];
        i++;
      }
      else if(pair_table[pair_table_snoop[i-1]-3]){
        X[i-1]=X[pair_table_snoop[i-1]-4];
        Y[i-1]=Y[pair_table_snoop[i-1]-4];
        X[i]=X[pair_table[pair_table_snoop[i-1]-3]-1];
        Y[i]=Y[pair_table[pair_table_snoop[i-1]-3]-1];
        i++;
      }
      else{
        X[i-1]=X[pair_table_snoop[i-1]-2];
        Y[i-1]=Y[pair_table_snoop[i-1]-2];
        X[i]=X[pair_table_snoop[i+2]];
        Y[i]=Y[pair_table_snoop[i+2]];
        i++;
      }
    }
    else if(pair_table_snoop[i-1] && pair_table_snoop[i+3]){ /* interior loop of size 2 */
      if(pair_table[pair_table_snoop[i-1]-1]){
        X[i-1]=0.5*(X[pair_table_snoop[i-1]-1]+X[pair_table_snoop[i-1]-2]);
        Y[i-1]=0.5*(Y[pair_table_snoop[i-1]-1]+Y[pair_table_snoop[i-1]-2]);
        X[i]=  0.5*(X[pair_table[pair_table_snoop[i-1]-1]-1]+X[pair_table_snoop[i-1]-2]);
        Y[i]=  0.5*(Y[pair_table[pair_table_snoop[i-1]-1]-1]+Y[pair_table_snoop[i-1]-2]);
        X[i+1]=0.5*(X[pair_table[pair_table_snoop[i-1]-1]-2]+X[pair_table[pair_table_snoop[i-1]-1]-1]);
        Y[i+1]=0.5*(Y[pair_table[pair_table_snoop[i-1]-1]-2]+Y[pair_table[pair_table_snoop[i-1]-1]-1]);
        i++;i++;

      }
      else if(pair_table[pair_table_snoop[i-1]-2]){
        X[i-1]=0.5*(X[pair_table_snoop[i-1]-2]+X[pair_table_snoop[i-1]-3]);
        Y[i-1]=0.5*(Y[pair_table_snoop[i-1]-2]+Y[pair_table_snoop[i-1]-3]);
        X[i]=  0.5*(X[pair_table[pair_table_snoop[i-1]-2]-1]+X[pair_table_snoop[i-1]-3]);
        Y[i]=  0.5*(Y[pair_table[pair_table_snoop[i-1]-2]-1]+Y[pair_table_snoop[i-1]-3]);
        X[i+1]=0.5*(X[pair_table[pair_table_snoop[i-1]-2]-2]+X[pair_table[pair_table_snoop[i-1]-2]-1]);
        Y[i+1]=0.5*(Y[pair_table[pair_table_snoop[i-1]-2]-2]+Y[pair_table[pair_table_snoop[i-1]-2]-1]);
        i++;i++;
      }
      else if(pair_table[pair_table_snoop[i-1]-3]){
        X[i-1]=0.5*(X[pair_table_snoop[i-1]-3]+X[pair_table_snoop[i-1]-4]);
        Y[i-1]=0.5*(Y[pair_table_snoop[i-1]-3]+Y[pair_table_snoop[i-1]-4]);
        X[i]=  0.5*(X[pair_table[pair_table_snoop[i-1]-3]-1]+X[pair_table_snoop[i-1]-4]);
        Y[i]=  0.5*(Y[pair_table[pair_table_snoop[i-1]-3]-1]+Y[pair_table_snoop[i-1]-4]);
        X[i+1]=0.5*(X[pair_table[pair_table_snoop[i-1]-3]-2]+X[pair_table[pair_table_snoop[i-1]-3]-1]);
        Y[i+1]=0.5*(Y[pair_table[pair_table_snoop[i-1]-3]-2]+Y[pair_table[pair_table_snoop[i-1]-3]-1]);
        i++;i++;
      }
      else{
        X[i-1]=X[pair_table_snoop[i-1]-2];
        Y[i-1]=Y[pair_table_snoop[i-1]-2];
        X[i]=X[pair_table_snoop[i-1]-2];
        Y[i]=Y[pair_table_snoop[i-1]-2];
        X[i+1]=X[pair_table_snoop[i-1]-2];
        Y[i+1]=Y[pair_table_snoop[i-1]-2];
        i++;i++;
      }
    }
  }
  double xC;
  double yC;
  float X0=-1,Y0=-1,X1=-1,Y1=-1,X2=-1,Y2=-1;
/*   int c1,c2,c3; */
  for(i=1;i<cut_point; i++){
    if(pair_table_snoop[i]){
      X0=X[pair_table_snoop[i]-1];Y0=Y[pair_table_snoop[i]-1];
  /*     c1=pair_table_snoop[i]; */
      i++;
      break;
    }
  }
  for(;i<cut_point; i++){
    if(pair_table_snoop[i]){
      X1=X[pair_table_snoop[i]-1];Y1=Y[pair_table_snoop[i]-1];
    /*   c2=pair_table_snoop[i]; */
      i++;
      break;
    }
  }
  for(;i<cut_point; i++){
    if(pair_table_snoop[i]){
      X2=X[pair_table_snoop[i]-1];Y2=Y[pair_table_snoop[i]-1];
    /*   c3=pair_table_snoop[i]; */
      i++;
      break;
    }
  }
/*   for(i=cut_point-2;i>pair_table_snoop[c1]; i--){ */
/*     if(pair_table_snoop[i]){ */
/*       X1=X[pair_table_snoop[i]-1];Y1=Y[pair_table_snoop[i]-1]; */
/*       c2=pair_table_snoop[i]; */
/*       i++; */
/*       break; */
/*     } */
/*   } */
/*   for(i=pair_table_snoop[c1]+1;i<pair_table_snoop[c2]; i++){ */
/*     if(pair_table_snoop[i]){ */
/*       X2=X[pair_table_snoop[i]-1];Y2=Y[pair_table_snoop[i]-1]; */
/*       c3=pair_table_snoop[i]; */
/*       i++; */
/*       break; */
/*     } */
/*   } */ 
 if(X0 < 0 || X1 < 0 || X2 < 0){
   printf("Could not get the center of the binding bucket. No ps file will be produced!\n");
   fclose(xyplot);
   free(pair_table);
   free(pair_table_snoop);
   free(X);free(Y);
   pair_table=NULL;pair_table_snoop=NULL;X=NULL;Y=NULL;
   return 0;
 }
  double alpha   =   (X0 -X1)/(Y1-Y0);
  double alpha_p =   (X1 -X2)/(Y2-Y1);
  double b =         (Y0+Y1 -alpha*(X0+X1))*0.5;
  double b_p =       (Y1+Y2 -alpha_p*(X1+X2))*0.5;
  /*    if(abs(alpha -alpha_p) > 0.0000001){ */
  xC  =  (b_p - b) / (alpha - alpha_p);
  yC  =  alpha * xC + b;
  for (i = 1; i < cut_point; i++) {  
     X[i-1] = X[i-1] + 0.25*(xC-X[i-1]);  
     Y[i-1] = Y[i-1] + 0.25*(yC-Y[i-1]);  
  }  

  fprintf(xyplot,
          "%%!PS-Adobe-3.0 EPSF-3.0\n"
          "%%%%Creator: ViennaRNA-%s\n"
          "%%%%CreationDate: %s"
          "%%%%Title: RNA Secondary Structure Plot\n"
          "%%%%BoundingBox: 66 210 518 662\n"
          "%%%%DocumentFonts: Helvetica\n"
          "%%%%Pages: 1\n"
          "%%%%EndComments\n\n"
          "%%Options: %s\n", "2.2.10", vrna_time_stamp(), option_string());
  fprintf(xyplot, "%% to switch off outline pairs of sequence comment or\n"
          "%% delete the appropriate line near the end of the file\n\n");
  fprintf(xyplot, "%s", RNAss_head);
  char **A;
  fprintf(xyplot, "%s", anote_macros);
  if(seqs){
    fprintf(xyplot, "%s", anote_macros);
    A = annote(structure, (const char**) seqs);
  }
  fprintf(xyplot, "%%%%EndProlog\n");
  
  fprintf(xyplot, "RNAplot begin\n"
          "%% data start here\n");
  /* cut_point */
  if (cut_point > 0 && cut_point <= strlen(string))
    fprintf(xyplot, "/cutpoint %d def\n", cut_point-1);
  /* sequence */
  fprintf(xyplot,"/sequence (\\\n");
  i=0;
  while (i<length) {
    fprintf(xyplot, "%.255s\\\n", string+i);  /* no lines longer than 255 */
    i+=255;
  }
  fprintf(xyplot,") def\n");
  /* coordinates */
  fprintf(xyplot, "/coor [\n");
  for (i = 0; i < length; i++)
    fprintf(xyplot, "[%3.3f %3.3f]\n", X[i], Y[i]);
  fprintf(xyplot, "] def\n");
  /* base pairs */
  fprintf(xyplot, "/pairs [\n");
  for (i = 1; i <= length; i++)
    if (pair_table[i]>i)
      fprintf(xyplot, "[%d %d]\n", i, pair_table[i]);
  for (i = 1; i <= length; i++)
    if (pair_table_snoop[i]>i)
      fprintf(xyplot, "[%d %d]\n", i, pair_table_snoop[i]);
  fprintf(xyplot, "] def\n\n");
  if(relative_access){
    fprintf(xyplot,"/S [\n");
    for(i=0;i<cut_point-1; i++){
      fprintf(xyplot, " %f\n", (float)relative_access[i]/100);
    }
    fprintf(xyplot,"]\n bind def\n");
    fprintf(xyplot,"/invert false def\n");
    fprintf(xyplot,"/range 0.8 def\n");
    fprintf(xyplot,"/drawreliability {\n"                      
                   "/Smax 2.6 def\n"                         
                   "  0        \n"                              
                   "  coor 0 cutpoint getinterval {\n"
                   "    aload pop\n"
                   "    S 3 index get\n"
                   "    Smax div range mul\n"     
                   "    invert {range exch sub} if\n"  
                   "    1 1 sethsbcolor\n"
                   "    newpath\n"
                   "    fsize 2.5 div 0 360 arc\n"
                   "    fill\n"
                   "    1 add\n"
                   "  } forall\n"
                   "\n"
                   "} bind def\n"); 
  }
  fprintf(xyplot, "init\n\n");
  /*raw the data */
  if (seqs) { 
     fprintf(xyplot, "%% Start Annotations\n"); 
     fprintf(xyplot, "%s\n", A[0]); 
     fprintf(xyplot, "%% End Annotations\n"); 
   } 


  fprintf(xyplot,"%%switch off outline pairs or bases by removing these lines\n");
  if(relative_access){
    fprintf(xyplot,"drawreliability\n");
  }
  fprintf(xyplot,
          "drawoutline\n"
          "drawpairs\n"
          "drawbases\n");
  /* fprintf(xyplot, "%d cmark\n",c1); */
  /* fprintf(xyplot, "%d cmark\n",c2); */
  /* fprintf(xyplot, "%d cmark\n",c3); */
  if (seqs) { 
     fprintf(xyplot, "%% Start Annotations\n"); 
     fprintf(xyplot, "%s\n", A[1]); 
     fprintf(xyplot, "%% End Annotations\n"); 
   } 
  fprintf(xyplot, "%% show it\nshowpage\n");
  fprintf(xyplot, "end\n");
  fprintf(xyplot, "%%%%EOF\n");

  fclose(xyplot);
  if(seqs){free(A[0]);free(A[1]);free(A);}
  free(pair_table);free(pair_table_snoop);
  free(X); free(Y);
  return 1; /* success */
}


PRIVATE char **annote(const char *structure, const char *AS[]) {
  char *ps, *colorps, **A;
  int i, n, s, pairings, maxl;
  short *ptable;
  char * colorMatrix[6][3] = {
    {"0.0 1", "0.0 0.6",  "0.0 0.2"},  /* red    */
    {"0.16 1","0.16 0.6", "0.16 0.2"}, /* ochre  */
    {"0.32 1","0.32 0.6", "0.32 0.2"}, /* turquoise */
    {"0.48 1","0.48 0.6", "0.48 0.2"}, /* green  */
    {"0.65 1","0.65 0.6", "0.65 0.2"}, /* blue   */
    {"0.81 1","0.81 0.6", "0.81 0.2"} /* violet */
  };

  vrna_md_t   md;
  set_model_details(&md);

  n = strlen(AS[0]);
  maxl = 1024;

  A = (char **) vrna_alloc(sizeof(char *)*2);
  ps = (char *) vrna_alloc(maxl);
  colorps = (char *) vrna_alloc(maxl);
  ptable = vrna_pt_ali_get(structure);
  for (i=1; i<=n; i++) {
    char pps[64], ci='\0', cj='\0';
    int j, type, pfreq[8] = {0,0,0,0,0,0,0,0}, vi=0, vj=0;
    if ((j=ptable[i])<i) continue;
    for (s=0; AS[s]!=NULL; s++) {
      type = md.pair[vrna_nucleotide_encode(AS[s][i-1], &md)][vrna_nucleotide_encode(AS[s][j-1], &md)];
      pfreq[type]++;
      if (type) {
        if (AS[s][i-1] != ci) { ci = AS[s][i-1]; vi++;}
        if (AS[s][j-1] != cj) { cj = AS[s][j-1]; vj++;}
      }
    }
    for (pairings=0,s=1; s<=7; s++) {
      if (pfreq[s]) pairings++;
    }

    if ((maxl - strlen(ps) < 192) || ((maxl - strlen(colorps)) < 64)) {
      maxl *= 2;
      ps = realloc(ps, maxl);
      colorps = realloc(colorps, maxl);
      if ((ps==NULL) || (colorps == NULL))
          vrna_message_error("out of memory in realloc");
    }

    if (pfreq[0]<=2) {
      snprintf(pps, 64, "%d %d %s colorpair\n",
               i,j, colorMatrix[pairings-1][pfreq[0]]);
      strcat(colorps, pps);
    }

    if (pfreq[0]>0) {
      snprintf(pps, 64, "%d %d %d gmark\n", i, j, pfreq[0]);
      strcat(ps, pps);
    }
    if (vi>1) {
      snprintf(pps, 64, "%d cmark\n", i);
      strcat(ps, pps);
    }
    if (vj>1) {
      snprintf(pps, 64, "%d cmark\n", j);
      strcat(ps, pps);
    }
  }
  free(ptable);
  A[0]=colorps;
  A[1]=ps;
  return A;
}

/*--------------------------------------------------------------------------*/


int svg_rna_plot(char *string, char *structure, char *ssfile)
{
  float  xmin, xmax, ymin, ymax, size;
  int    i, length;
  float *X, *Y, *R = NULL, *CX = NULL, *CY = NULL;
  FILE  *xyplot;
  short *pair_table;

  length = strlen(string);

  xyplot = fopen(ssfile, "w");
  if (xyplot == NULL) {
    fprintf(stderr, "can't open file %s - not doing xy_plot\n", ssfile);
    return 0;
  }

  pair_table = vrna_ptable(structure);

  X = (float *) vrna_alloc((length+1)*sizeof(float));
  Y = (float *) vrna_alloc((length+1)*sizeof(float));

  switch(rna_plot_type){
    case VRNA_PLOT_TYPE_SIMPLE:   i = simple_xy_coordinates(pair_table, X, Y);
                                  break;
    case VRNA_PLOT_TYPE_CIRCULAR: {
                                    int radius = 3*length;
                                    int dr = 0;
                                    R = (float *) vrna_alloc((length+1)*sizeof(float));
                                    CX = (float *) vrna_alloc((length+1)*sizeof(float));
                                    CY = (float *) vrna_alloc((length+1)*sizeof(float));
                                    i = simple_circplot_coordinates(pair_table, X, Y);
                                    for (i = 0; i < length; i++) {
                                      if(i+1 < pair_table[i+1]){
                                        dr = (pair_table[i+1]-i+1 <= (length/2 + 1)) ? pair_table[i+1]-i : i + length - pair_table[i+1];
                                        R[i] = 1. - (2.*dr/(float)length);
                                      }
                                      else if(pair_table[i+1]){
                                        R[i] = R[pair_table[i+1]-1];
                                      }
                                      else{
                                        R[i] = 1.0;
                                      }
                                      CX[i] = X[i] * radius * R[i] + radius;
                                      CY[i] = Y[i] * radius * R[i] + radius;
                                      X[i] *= radius;
                                      X[i] += radius;
                                      Y[i] *= radius;
                                      Y[i] += radius;
                                    }
                                  }
                                  break;
    default:                      i = naview_xy_coordinates(pair_table, X, Y);
                                  break;
  }

  if(i!=length) fprintf(stderr,"strange things happening in PS_rna_plot...\n");


  xmin = xmax = X[0];
  ymin = ymax = Y[0];
  for (i = 1; i < length; i++) {
     xmin = X[i] < xmin ? X[i] : xmin;
     xmax = X[i] > xmax ? X[i] : xmax;
     ymin = Y[i] < ymin ? Y[i] : ymin;
     ymax = Y[i] > ymax ? Y[i] : ymax;
  }
  for (i = 0; i < length; i++)
    Y[i] = ymin+ymax - Y[i]; /* mirror coordinates so they look as in PS */

  if(rna_plot_type == VRNA_PLOT_TYPE_CIRCULAR)
    for (i = 0; i < length; i++){
      CY[i] = ymin+ymax - CY[i]; /* mirror coordinates so they look as in PS */
    }
   
  size = MAX2((xmax-xmin),(ymax-ymin));
  size += 15; /* add some so the bounding box isn't too tight */

  fprintf(xyplot,
          "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n"
          "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"452\" width=\"452\">\n");
  fprintf(xyplot,
          "<script type=\"text/ecmascript\">\n"
          "      <![CDATA[\n"
          "        var shown = 1;\n"
          "        function click() {\n"
          "             var seq = document.getElementById(\"seq\");\n"
          "             if (shown==1) {\n"
          "               seq.setAttribute(\"style\", \"visibility: hidden\");\n"
          "               shown = 0;\n"
          "             } else {\n"
          "               seq.setAttribute(\"style\", \"visibility: visible\");\n"
          "               shown = 1;\n"
          "             }\n"
          "         }\n"
          "        ]]>\n"
          "</script>\n");
  fprintf(xyplot,
          "  <rect style=\"stroke: white; fill: white\" height=\"452\" x=\"0\" y=\"0\" width=\"452\" onclick=\"click(evt)\" />\n"
          "  <g transform=\"scale(%7f,%7f) translate(%7f,%7f)\">\n",
          SIZE/size, SIZE/size, (size-xmin-xmax)/2, (size-ymin-ymax)/2);

  fprintf(xyplot,
          "    <polyline style=\"stroke: black; fill: none; stroke-width: 1.5\" id=\"outline\" points=\"\n");
  for (i = 0; i < length; i++)
    fprintf(xyplot, "      %3.3f,%3.3f\n", X[i], Y[i]);
  fprintf(xyplot,"    \" />\n");

  fprintf(xyplot,"    <g style=\"stroke: black; stroke-width: 1; fill: none;\" id=\"pairs\">\n");
  for (i = 1; i <= length; i++) {
    int j;
    if ((j=pair_table[i])>i){
      if(rna_plot_type == VRNA_PLOT_TYPE_CIRCULAR)
        fprintf(xyplot,
                "      <path id=\"%d,%d\" d=\"M %6.15f %6.15f C %6.15f,%6.15f %6.15f,%6.15f %6.15f %6.15f\" />\n",
                i,j, X[i-1], Y[i-1], CX[i-1], CY[i-1], CX[j-1], CY[j-1], X[j-1], Y[j-1]);
      else
        fprintf(xyplot,
                "      <line id=\"%d,%d\" x1=\"%6.5f\" y1=\"%6.5f\" x2=\"%6.5f\" y2=\"%6.5f\" />\n",
                i,j, X[i-1], Y[i-1], X[j-1], Y[j-1]);
    }
  }
  fprintf(xyplot, "    </g>\n");
  fprintf(xyplot, "    <g style=\"font-family: SansSerif\" transform=\"translate(-4.6, 4)\" id=\"seq\">\n");
  for (i = 0; i < length; i++)
    fprintf(xyplot, "      <text x=\"%.3f\" y=\"%.3f\">%c</text>\n", X[i], Y[i], string[i]);
  fprintf(xyplot, "    </g>\n");
  fprintf(xyplot, "  </g>\n");
  fprintf(xyplot, "</svg>\n");

  fclose(xyplot);

  free(pair_table);
  free(X); free(Y);
  if(R) free(R);
  if(CX) free(CX);
  if(CY) free(CY);
  return 1; /* success */
}

/*--------------------------------------------------------------------------*/

PUBLIC int ssv_rna_plot(char *string, char *structure, char *ssfile)
{           /* produce input for the SStructView java applet */
  FILE *ssvfile;
  int i, bp;
  int length;
  short *pair_table;
  float *X, *Y;
  float xmin, xmax, ymin, ymax;

  ssvfile = fopen(ssfile, "w");
  if (ssvfile == NULL) {
     fprintf(stderr, "can't open file %s - not doing xy_plot\n", ssfile);
     return 0;
  }
  length = strlen(string);
  pair_table = vrna_ptable(structure);

  /* make coordinates */
  X = (float *) vrna_alloc((length+1)*sizeof(float));
  Y = (float *) vrna_alloc((length+1)*sizeof(float));

  if (rna_plot_type == 0)
    i = simple_xy_coordinates(pair_table, X, Y);
  else
    i = naview_xy_coordinates(pair_table, X, Y);
  if (i!=length)
    fprintf(stderr,"strange things happening in ssv_rna_plot...\n");

  /* make coords nonegative */
  xmin = xmax = X[0];
  ymin = ymax = Y[0];
  for (i = 1; i < length; i++) {
     xmin = X[i] < xmin ? X[i] : xmin;
     xmax = X[i] > xmax ? X[i] : xmax;
     ymin = Y[i] < ymin ? Y[i] : ymin;
     ymax = Y[i] > ymax ? Y[i] : ymax;
  }
  if (xmin<1) {
    for (i = 0; i <= length; i++)
      X[i] -= xmin-1;
    xmin = 1;
  }
  if (ymin<1) {
    for (i = 0; i <= length; i++)
      Y[i] -= ymin-1;
    ymin = 1;
  }
#if 0
  {
    float size, xoff, yoff;
    float JSIZE = 500; /* size of the java applet window */
    /* rescale coordinates, center on square of size HSIZE */
    size = MAX2((xmax-xmin),(ymax-ymin));
    xoff = (size - xmax + xmin)/2;
    yoff = (size - ymax + ymin)/2;
    for (i = 0; i <= length; i++) {
      X[i] = (X[i]-xmin+xoff)*(JSIZE-10)/size + 5;
      Y[i] = (Y[i]-ymin+yoff)*(JSIZE-10)/size + 5;
    }
  }
#endif
  /* */

  fprintf(ssvfile,
          "# Vienna RNA Package %s\n"
          "# SStructView Output\n"
          "# CreationDate: %s\n"
          "# Name: %s\n"
          "# Options: %s\n", "2.2.10", vrna_time_stamp(), ssfile, option_string());
  for (i=1; i<=length; i++)
    fprintf(ssvfile, "BASE\t%d\t%c\t%d\t%d\n",
            i, string[i-1], (int) (X[i-1]+0.5), (int) (Y[i-1]+0.5));
  for (bp=1, i=1; i<=length; i++)
    if (pair_table[i]>i)
      fprintf(ssvfile, "BASE-PAIR\tbp%d\t%d\t%d\n", bp++, i, pair_table[i]);
  fclose(ssvfile);

  free(pair_table);
  free(X); free(Y);
  return 1; /* success */
}

/*---------------------------------------------------------------------------*/
PUBLIC int xrna_plot(char *string, char *structure, char *ssfile)
{           /* produce input for XRNA RNA drawing program */
  FILE *ss_file;
  int i;
  int length;
  short *pair_table;
  float *X, *Y;

  ss_file = fopen(ssfile, "w");
  if (ss_file == NULL) {
    fprintf(stderr, "can't open file %s - not doing xy_plot\n", ssfile);
    return 0;
  }

  length = strlen(string);
  pair_table = vrna_ptable(structure);

  /* make coordinates */
  X = (float *) vrna_alloc((length+1)*sizeof(float));
  Y = (float *) vrna_alloc((length+1)*sizeof(float));

  if (rna_plot_type == 0)
    i = simple_xy_coordinates(pair_table, X, Y);
  else
    i = naview_xy_coordinates(pair_table, X, Y);
  if (i!=length)
    fprintf(stderr,"strange things happening in xrna_plot...\n");

  fprintf(ss_file,
          "# Vienna RNA Package %s, XRNA output\n"
          "# CreationDate: %s\n"
          "# Options: %s\n", "2.2.10", vrna_time_stamp(), option_string());
  for (i=1; i<=length; i++)
    /* XRNA likes to have coordinate mirrored, so we use (-X, Y) */
    fprintf(ss_file, "%d %c %6.2f %6.2f %d %d\n", i, string[i-1],
            -X[i-1], Y[i-1], (pair_table[i]?1:0), pair_table[i]);
  fclose(ss_file);

  free(pair_table);
  free(X); free(Y);
  return 1; /* success */
}

#ifdef VRNA_BACKWARD_COMPAT

/*###########################################*/
/*# deprecated functions below              #*/
/*###########################################*/

PUBLIC int
PS_rna_plot(char *string,
            char *structure,
            char *ssfile){

  return vrna_file_PS_rnaplot((const char*)string,
                              (const char*)structure,
                              (const char*) ssfile,
                              NULL);
}

PUBLIC int
PS_rna_plot_a(char *string,
              char *structure,
              char *ssfile,
              char *pre,
              char *post){

  return vrna_file_PS_rnaplot_a((const char*)string,
                                (const char*)structure,
                                (const char*)ssfile,
                                (const char*)pre,
                                (const char*)post,
                                NULL);
}

PUBLIC int
PS_rna_plot_a_gquad(char *string,
                    char *structure,
                    char *ssfile,
                    char *pre,
                    char *post){

  return vrna_file_PS_rnaplot_a((const char*)string,
                                (const char*)structure,
                                (const char*)ssfile,
                                (const char*)pre,
                                (const char*)post,
                                NULL);
}

#endif


plot_layouts.c/ 0           0     0     644     4627      `
/**
 * This file is a container for all plotting layout algorithms
 *
 *  c Ronny Lorenz
 *    The ViennaRNA Package
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "utils.h"
#include "plot_layouts.h"

#ifdef _OPENMP
#include <omp.h>
#endif

#define PUBLIC
#define PRIVATE static

PUBLIC  int     rna_plot_type = 1;  /* 0 = simple, 1 = naview, 2 = circular plot */

PRIVATE float   *angle;
PRIVATE int     *loop_size, *stack_size;
PRIVATE int     lp, stk;

PRIVATE void  loop(int i, int j, short *pair_table);

#ifdef _OPENMP
/* NOTE: all threadprivate variables are uninitialized when entering a thread! */
#pragma omp threadprivate(angle, loop_size, stack_size, lp, stk)
#endif

/*---------------------------------------------------------------------------*/

PUBLIC int simple_xy_coordinates(short *pair_table, float *x, float *y)
{
  float INIT_ANGLE=0.;     /* initial bending angle */
  float INIT_X = 100.;     /* coordinate of first digit */
  float INIT_Y = 100.;     /* see above */
  float RADIUS =  15.;

  int i, length;
  float  alpha;

  length = pair_table[0];
  angle =      (float*) vrna_alloc( (length+5)*sizeof(float) );
  loop_size  =   (int*) vrna_alloc( 16+(length/5)*sizeof(int) );
  stack_size =   (int*) vrna_alloc( 16+(length/5)*sizeof(int) );
  lp = stk = 0;
  loop(0, length+1, pair_table);
  loop_size[lp] -= 2;     /* correct for cheating with function loop */

  alpha = INIT_ANGLE;
  x[0]  = INIT_X;
  y[0]  = INIT_Y;

  for (i = 1; i <= length; i++) {
    x[i] = x[i-1]+RADIUS*cos(alpha);
    y[i] = y[i-1]+RADIUS*sin(alpha);
    alpha += PI-angle[i+1];
  }
  free(angle);
  free(loop_size);
  free(stack_size);

  return length;

}

/*---------------------------------------------------------------------------*/

PRIVATE void loop(int i, int j, short *pair_table)
             /* i, j are the positions AFTER the last pair of a stack; i.e
                i-1 and j+1 are paired. */
{
  int    count = 2;   /* counts the VERTICES of a loop polygon; that's
                           NOT necessarily the number of unpaired bases!
                           Upon entry the loop has already 2 vertices, namely
                           the pair i-1/j+1.  */

  int    r = 0, bubble = 0; /* bubble counts the unpaired digits in loops */

  int    i_old, partner, k, l, start_k, start_l, fill, ladder;
  int    begin, v, diff;
  float  polygon;

  short *remember;

  remember = (short *) vrna_alloc((3+(j-i)/5)*2*sizeof(short));

  i_old = i-1, j++;         /* j has now been set to the partner of the
                               previous pair for correct while-loop
                               termination.  */
  while (i != j) {
    partner = pair_table[i];
    if ((!partner) || (i==0))
      i++, count++, bubble++;
    else {
      count += 2;
      k = i, l = partner;    /* beginning of stack */
      remember[++r] = k;
      remember[++r] = l;
      i = partner+1;         /* next i for the current loop */

      start_k = k, start_l = l;
      ladder = 0;
      do {
        k++, l--, ladder++;        /* go along the stack region */
      }
      while ((pair_table[k] == l) && (pair_table[k] > k));

      fill = ladder-2;
      if (ladder >= 2) {
        angle[start_k+1+fill] += PIHALF;   /*  Loop entries and    */
        angle[start_l-1-fill] += PIHALF;   /*  exits get an        */
        angle[start_k]        += PIHALF;   /*  additional PI/2.    */
        angle[start_l]        += PIHALF;   /*  Why ? (exercise)    */
        if (ladder > 2) {
          for (; fill >= 1; fill--) {
            angle[start_k+fill] = PI;    /*  fill in the angles  */
            angle[start_l-fill] = PI;    /*  for the backbone    */
          }
        }
      }
      stack_size[++stk] = ladder;
      if(k <= l)
        loop(k, l, pair_table);
    }
  }
  polygon = PI*(count-2)/(float)count; /* bending angle in loop polygon */
  remember[++r] = j;
  begin = i_old < 0 ? 0 : i_old;
  for (v = 1; v <= r; v++) {
    diff  = remember[v]-begin;
    for (fill = 0; fill <= diff; fill++)
      angle[begin+fill] += polygon;
    if (v > r)
      break;
    begin = remember[++v];
  }
  loop_size[++lp] = bubble;
  free(remember);
}

/*---------------------------------------------------------------------------*/

PUBLIC int simple_circplot_coordinates(short *pair_table, float *x, float *y){
  unsigned int  length = (unsigned int) pair_table[0];
  unsigned int  i;
  float         d = 2*PI/length;
  for(i=0; i < length; i++){
    x[i] = cos(i * d - PI/2);
    y[i] = sin(i * d - PI/2);
  }
  return length;
}

